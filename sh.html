<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
	<title>@Chinhvtr Audio Books</title>

	<!-- https://www.svgrepo.com/svg/235301/lotus
	https://www.svgrepo.com/svg/483896/sherlock-holmes-1 -->

	<!-- Favicon generated by https://realfavicongenerator.net/ -->
	<link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96" />
	<link rel="icon" type="image/svg+xml" href="favicon/favicon.svg" />
	<link rel="shortcut icon" href="favicon/favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png" />
	<meta name="apple-mobile-web-app-title" content="Audio Books" />
	<!-- <link rel="manifest" href="favicon/site.webmanifest" /> -->

	<!-- Root, common elements  type="text/css" -->
	<style>
		@charset "UTF-8";

		* {
			/* "SFU AmericanType",  */
			font-family: "SFU AmericanType", monospace, "Courier New";
			font-size: 19px;
			box-sizing: border-box;
			text-rendering: optimizeLegibility;
			-webkit-font-smoothing: antialiased;
		}

		/* SETTING SOME VARIABLE TO CUSTOMIZE THE PAGE */
		body {
			/* overwrite default body margin - which might be 8px */
			/* margin: 5px; */

			/* Font size of Chapter title (span) in Playlist item (li) */
			--playlist-item-title-font-size: 21px;

			--button-border-style: 1px solid #bdbec0;
			/* some rules to control hover over button and select box */
			--button-hover-border-color: #8d28a5;
			--button-hover-bground-color: #e5e7eb;
			/* the filter that shift color of backgound svg image of select boxes from Black to --button-hover-bground-color */
			--select-hover-bground-filter: invert(19%) sepia(33%) saturate(6688%) hue-rotate(278deg) brightness(91%) contrast(89%);

			/* Fun corner: change color of selBookGroup and elmSelBookTitles by the selected value of selBookGroup */
			--select-book-group-color: darkblue;
			/* filter to change color from Black to darkblue */
			--select-book-group-filter: invert(14%) sepia(49%) saturate(4923%) hue-rotate(236deg) brightness(81%) contrast(147%);			

			&:has(#selBookGroup option:nth-of-type(2):checked) {
				--select-book-group-color: darkred;
				--select-book-group-filter: invert(6%) sepia(86%) saturate(6340%) hue-rotate(360deg) brightness(111%) contrast(108%);
			}

			&:has(#selBookGroup option:nth-of-type(3):checked) {
				--select-book-group-color: darkgreen;
				--select-book-group-filter: invert(22%) sepia(99%) saturate(1440%) hue-rotate(95deg) brightness(90%) contrast(105%);
			}					
		}

		audio {
			width: 100%;
			display: none;
		}

		div[name="divContainer"] {
			/* width: 100%;
			width: 1100px; */
			/* When screen is too wide, make the page only 1100px wide */
			width: min(100%, 1100px);			

			/* 100vw 1vw = 1% of viewport width. Default width of the page is all screen */
			text-align: center;
			margin: 5px auto;

			&>* {
				width: 100%;
				max-width: 100%;
			}

			&>div[name="divCtnTop"] {
				/* in column mode: to push big Playing time closer to audio buttons */
				margin-bottom: -5px;

				/* css variable --margin-hack (see the hack explain below) when element details[name='chapterInforDetails'] collapsed */
				--margin-hack: 5px;

				position: relative; /* so that ::before pseudo could take this div as offsetParent */
				&::before{
					content: "";
					display: block;
            		position: absolute;
					width: 100%;
					height: calc(100% - var(--margin-hack));
					background: url() center top / contain no-repeat;
            		filter: invert(94%) sepia(78%) saturate(4262%) hue-rotate(312deg) brightness(101%) contrast(80%);
					opacity: .3; 

					/* background: url(https://chuabavang.com/templates/themes/images/icon/gold-lotus.svg) center top/ contain no-repeat;
					opacity: .3; */
					z-index: -1;
				}
				/* customized background for different type of books */
				&.lotusBgrnd::before{
					background-image: url(https://www.svgrepo.com/download/231459/lotus.svg);
					height: calc(115% - var(--margin-hack));
           			top: -7%;
				}
				&.detectiveBgrnd::before{
					background-image: url(https://www.svgrepo.com/download/483893/sherlock-holmes-2.svg);
				}
				&.fantasticNovelBgrnd::before{
					background-image: url(https://www.svgrepo.com/download/224464/shield.svg);
				}
				&.classicNovelBgrnd::before{
					background-image: url(https://www.svgrepo.com/download/480092/castle-6.svg);
					height: calc(130% - var(--margin-hack));
           			top: -15%;
				}
				&.xianxianBgrnd::before{
					background-image: url(https://www.svgrepo.com/download/477194/sword-material.svg);
					/* https://www.svgrepo.com/download/224460/sword.svg */
					/* url(https://www.svgrepo.com/download/224446/axe.svg); */
				}

				/* Hack for chapter infor tooltip not to be clipped. Because #elmChapterInfor has class .detailContent (which contains max-height for detail/summary to expand/collapse animation), thus its has property display:block, so tooltip contained in ::before pseudo of its <code> descendant being clipped by boudingRect of #elmChapterInfor. Can change #elmChapterInfor display to 'inline' for tooltip to fully shows up, but #elmChapterInfor cannot be collapsed anymore. So, I do this hack using padding */
				&>div:has(> details[name='chapterInforDetails']){					

					/* compensate the room of its presibling .detailContent */
					margin-bottom: calc(0px - var(--margin-hack));						

					&>.detailContent {
						/* make room for bottom tooltip*/
						padding-bottom: var(--margin-hack);
					}

					/* --margin-hack when element details[name='chapterInforDetails'] expanded */
					/* &:has( > details[open]) {
						--margin-hack: 60px;
					} */
				}

				/* --margin-hack when element details[name='chapterInforDetails'] expanded */
				&:has( details[name='chapterInforDetails'][open]) {
					--margin-hack: 60px;
				}
				/* End of tooltip hack */
			}
		}

		/* iphone, iPad has big screen dpi. See https://hover-pointer-media-query.glitch.me/ for pointer value for different device
		Following are settings for Desktop screen. "pointer: coarse" is for iphone/iPad and android phone/tablet which defaultly is handled 
		*/
		@media (pointer: fine) {
			body {
				--playlist-item-title-font-size: 18px;
			}

			* {
				font-size: 17px;
			}
		}

		/* see https://www.w3schools.com/css/css_rwd_mediaqueries.asp for different kind of screen like phone, tablet,.. */


		/* Introduce about Book or Chapter */
		div.bookChapIntro {
			columns: 3 300px;
			column-rule: 1px solid lightblue;
			column-gap: 30px;
			/* text-indent: 1em; */
			margin-top: 10px;
			padding-top: 5px;			
			border-top: 1px solid lightblue;
			text-align: justify;

			& *{
				font-size: inherit !important;
			}

			&::first-letter{
				font-size: 3.5em;
				/* initial-letter: 3 5; */
				font-weight: bold;
				text-transform: uppercase;
				color: var(--select-book-group-color);
				/* float: left; */
				padding: 0px 3px;
				float: inline-start;
				line-height: 1;
				margin-inline-end: .25rem;
				margin-bottom: -.25em;
				margin-top: -.15em; 
			}

			&>.bookChapIntroImg {
				width: 100px;
				margin-right: 10px;
				float: left;
			}

			/* li bullet format for list inside book intro div */
			& ul{
				/* overwrite the padding-left of ul elements inside book intro, if there any */
				padding-left: 20px;
				/* list-style-type: "⯐ "; */
				& li::marker{
					content: "⯐ ";
					color: hotpink;
				}

				& li li::marker{
					content: "⯐ ";
					color: #d269ff;
				}
			}
		}

		/* Flex container for dispay div side by side */
		.flex-container {
			/* set default flex setting, which is for small device like iPhone */
			display: flex;
			flex-direction: column;
			gap: 5px 15px;
			/* Only show gap between flex items on row mode */
		}

		/* Big Audio control below book cover Img and history buttons */
		div[name="divCtnAudioControlExtraBig"] {
			display: none;
		}

		.flex-container>div,
		h2 {
			flex: auto;
			/*0 0 auto*/
		}

		/* flex item that has book cover will have flex-grow = 0, so that all extra space will go to Playlist element*/
		.flex-container>div:has(>div > #elmArtwork) {
			/* div that contain the artwork which can be book cover or chapter cover */
			flex: 0 0 auto;
			/*0 0 auto*/
			order: 2;
			/*so that in the column flex, the artwork will be after Playlist */
			max-width: 100%;
			/* In column mode, size of artwrok can reach to 100% */
		}

		/* This left side of playlist has multiple children, so set this to make nicer visibility */
		.flex-container>div:has(>div > #elmArtwork)>* {
			margin-bottom: 5px;
		}

		.flex-container #elmArtwork {
			/* In column mode, size of artwrok can reach to 100% */
			max-width: 100%;
			
			border: 1px solid bisque;
			border-radius: 30px 0px;
			box-shadow: #0007 2px 2px 10px;

			/* make the top-left and bottom-right round border */
			/* clip-path: xywh(0 0px 100% 100% round var(--workart-border-radius));
			margin-bottom: -3.5px; */
			
			/* selector for youtube SD poster, which for now identified by the file name 'hqdefault.jpg' */
			&[src*="i.ytimg.com"][src*="hqdefault.jpg"]{
				/* crop the top and bottom black stripes */
				clip-path: xywh(0 12.5% 100% 75% round var(--workart-border-radius));
				/* remove border on normal workart. Becaused of the 'clip-path', the border will be made by the background color of mother div */
				border: none;
				/* change the border-box of the image using margin */
				margin-top: -9.2%;
				margin-bottom: calc(-3px - 9.5%);
				transition: margin .5s;
			}
		}

		/* adding effect for #elmArtwork by styling the div that contains #elmArtwork */
		.flex-container div:has(> #elmArtwork[src*="i.ytimg.com"][src*="hqdefault.jpg"]){
			--workart-border-radius: 30px 0; /* border radius is the same with clip-path in #elmArtwork */
			border-radius: var(--workart-border-radius); 
			width: fit-content;

			/* padding and background-color to make the border for the inside #elmArtwork */
			padding: 1px;
			background-color: #f1b874; /* #0040f9; */
			/* background: radial-gradient(closest-corner, #0000 69%, bisque 69%); */
			/* add shadow for the inside #elmArtwork */
			filter: drop-shadow(2px 2px 10px #0007);
			
			/* center the div */
			margin: 0 auto;			
		}

		.flex-container .noInternetImg {
			width: min(100%, 400px);
			margin-bottom: 15px !important;
		}

		.flex-container>div:last-child {
			flex-grow: 1;
		}

		.flex-container> :first-child {
			margin-right: 0px;
		}

		@media only screen and (min-width: 850px) {
			
			.flex-container {
				/* If screen is bigger, make flex to be row */
				flex-direction: row;
			}

			div[name="divContainer"]>div[name="divCtnTop"] {
				margin-bottom: 5px; /* in row mode,  */				
			}

			/* Big Audio control below book cover Img and history buttons */
			div[name="divCtnAudioControlExtraBig"] {
				display: flex;
				/* This div has control-button-flex class, so set its display to flex */
			}

			/* In wide screen, Hide two little rewind, fastforwar button on audio control panel to make the panel looks more simple. Because there are already two bigger buttons (below workart img element) which handle to jump 20seconds */
			.ap-sub-panel > button.ap-controls:is(.ap-rewind-btn,.ap-fastforward-btn){
				display: none;
			}

			/* .flex-container > :first-child {
				margin-right: 20px;
			}*/
			.flex-container>div:has(> div > #elmArtwork) {
				/* div that contain the artwork which can be book cover or chapter cover */
				order: 0;
				/*in the row flex, the artwork will be right side of Playlist */
				max-width: 40%;
				/* In row mode, size of artwrok cannot wider than 50% */				
			}
		}

		@media only screen and (min-width: 1100px) {
			div[name="divContainer"] {
				/* text-align: center;
		margin: 5px auto; */
				width: 1100px;
				/* When screen is too wide, make the page only 1100px wide */
			}
		}

		.flex-button-container {
			display: flex;
			flex-flow: row wrap;
			justify-content: space-evenly;
		}

		/* DETAIL - SUMMARY css */

		details {
			max-width: 100%;
			margin: 3px 0 5px 0;
			/* margin-bottom: 10px; */
			overflow: hidden;
			/* Keep this line to prevent an odd blue outline around the element in Safari. */
		}

		summary {
			display: inline-block;
			padding-top: 5px;
		}

		summary::-webkit-details-marker {
			display: none;
		}

		summary>span {
			/* position: relative;
	display: flex;
	align-items: flex-start; */
			text-align: center;
			cursor: pointer;
			/* padding-left: 1rem;
	background: #444;
	color: #fff;
	height: 4rem; */
		}

		/* Only decorate for the book title when width large enough */
		@media screen and (min-width: 800px){
			summary:has( > span[id="elmBookTitle"]){
				background: conic-gradient(from 12deg at 84% 40%, #efd9bd 115deg, #c2965e 0% 50%, #b1ceec 0% 295deg, #f2c079 0%);
				transform: skew(-25deg, 0);
				border-radius: 11px;
				box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.34);
				margin: 10px auto 5px;
				padding: 10px 8px;
				max-width: calc(100% - 40px);
				min-width: 60%;

				& > span{
					display: inline-block;
					transform: skew(25deg, 0);
				}
			}
		}

		summary>span{
			/* small triangle */
			&::before {
				content: '';
				width: 0;
				height: 0;
				display: inline-block;
				border: 6px solid transparent;
				border-width: 6px 9px;
				border-left-color: red;
				/* these 7 css lines is to make ⏵triangle */
				margin-right: 5px;
				transform: translateY(-2px);
				transform-origin: 40% 50%;
				transition: rotate 300ms ease-out;
			}

			/* class to store subtitle such as book chapters in Xianxian books, which are very long */
			& > .chapterSubtitles{
				font-size:.85em !important;
				color: #e28515;

				/* animation adapt from https://css-tricks.com/almanac/rules/s/starting-style/  */
				opacity: 0;
				display: none;
				/* the allow-discrete value will make properties like display wait until the end of the transition to switch to none */
				transition: opacity .75s ease-in, display .75s allow-discrete;
			}
		}

		details[open]>summary>span{
			&::before {
				rotate: 90deg;
			}

			/* class to store subtitle such as book chapters in Xianxian books, which are very long */
			& > .chapterSubtitles{
				display: inline;
				opacity: 1;

				/* @starting-style is making entry transitions whenever an element display is set to something different to none. */
				@starting-style {
					opacity: 0;
				}
			}
		}

		div.detailContent {/* details+ */
			box-sizing: border-box;

			max-width: 100%;
			/* max-height: 0px; */
			overflow: hidden;
			
			/* to compensate the bottom-margin of previous sibling <detail> element */
			margin-top: -3px;
			
			/* animation adapt from https://css-tricks.com/almanac/rules/s/starting-style/ */
			opacity: 0;
			display: none;
			/* the allow-discrete value will make properties like display wait until the end of the transition to switch to none */
			transition: opacity .75s ease-in, display .75s allow-discrete;
		}

		details[open]+div.detailContent {
			/* Set a max-height value enough to show all the content */
			/* max-height: 5000px; */

			/* for a.srcPlaying item not to be cropped at bottom */
			padding: 3px 0px;

			/* animation */
			display: block;
			opacity: 1;
			/* @starting-style is making entry transitions whenever an element display is set to something different to none. */
			@starting-style {
				opacity: 0;
			}
		}

		/*format summary marker (the small triagle) for Book and Chapter titles*/

		#elmBookTitle::before {
			border-left-color: darkblue;
		}

		#elmChapterTitle {
			text-align: center;
			font-size: 25px;
			color: red;
			font-weight: bold;
			/*padding-top: 5px;*/
			& *{font-size: inherit;}
			
		}

		#elmChapterInfor {
			margin-bottom: 5px;
			/* padding-bottom: 3px; */
		}

		#elmBookTitle {
			text-align: center;
			font-size: 23px;
			color: darkblue;
			font-weight: bold;
			text-wrap: pretty; /* balance this balance length of lines if title+eTitle is rendered into two lines */

			&:hover{
				text-shadow: 1px 1px 2px #3336;
			}
		}
		@media (hover: hover) and (pointer: fine) {
			/* 'nowrap' and <wbr/> element at the title will auto break the english title down if title+eTitle is rendered into two lines. Unfortunately, it not work on iOS, so I have to use @media query to let it effeft for desktop only */
			#elmBookTitle {
				text-wrap: nowrap; 
			}
		}

		#elmBookInfo {
			text-align: justify;
			/* text-justify: inter-word; */
			/* padding-left: 5px; */
		}

		/* END OF DETAIL - SUMMARY css */
		#selBookGroup {
			background: transparent url(https://uxwing.com/wp-content/themes/uxwing/download/education-school/books-icon.svg) center / 28px no-repeat;
			height: 44px;
			width: 41px;
			/* padding-top: 25px !important;
			padding-bottom: 4px; */
			-moz-appearance: none;
			-webkit-appearance: none;
			appearance: none;
			font-size: 0px; /* to hide the text in select box when it is collapsed */
			text-align-last: center;
			border: 2px solid black;
			/* var(--button-border-style); */
			filter: var(--select-book-group-filter);
			border-radius: 8px;
			cursor: pointer;

			&:has(option:nth-of-type(1):checked) {
				background-size: 26px;
			}

			&:has(option:nth-of-type(2):checked) {
				background-image: url(https://uxwing.com/wp-content/themes/uxwing/download/business-professional-services/male-services-support-icon.svg);
			}

			&:has(option:nth-of-type(3):checked) {
				background-image: url(https://uxwing.com/wp-content/themes/uxwing/download/education-school/read-book-icon.svg);
			}			
		}

		#selBookGroup:hover {
			filter: var(--select-hover-bground-filter);
			/* color: var(--button-hover-border-color);
	background-color: var(--button-hover-bground-color) !important; 
	*/
			-webkit-transition: background .2s ease;
			transition: background .2s ease;
		}

		/* This element contains the playing time over full duration and its tooltip contains the audio timeRange for played, buffered and seekable */
		#elmPlayingTime {
			flex-shrink: 0;
			/* Prevent playing time to be forced into two lines */
			text-align: center;
			font-weight: bold;
			/* margin-top: -2px; */
			/* margin: auto 0px; */
			font-size: xx-large;

			/* this prevent this to absorb double-click on its parent div element, so double-click on it which fastforward/rewind audio would work */
			pointer-events: none;
			/* Prevent user select the timer text when double click on it */
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none;

			display: flex;
			flex: 1 0 9em;
			align-items: center;
			justify-content: center;
    		flex-flow: row nowrap;

			& > *{
				display: flex;
				align-items: center;
				font: inherit;
			}
			& > .plt-slash{
				/* padding: 0 5px; */
				width: .75em;
				justify-content: center;
				/* margin-top: -3px; */
				color: #000;

				/* draw the slash by css inside ::before pseudo, adapt from https://stackoverflow.com/questions/39244591/making-a-longer-and-slightly-more-diagonal-slash-in-css */
				&::before{
					content: "";
					height: 1em;
					width: 0;
					transform: skew(-30deg);/*  translateY(2px) */
					translate: 0 -1px;
					border-left: dotted 5px;
				}
			}
			& > .plt-time{
				color: green;
				text-shadow: 1px 1px 1px #3336;
				/* -webkit-text-fill-color: #0002;
        		-webkit-text-stroke: 1.5px green; */
			}
			& > .plt-duration{
				/* make engraved text */
				background-clip: text;
				-webkit-background-clip: text;
				color: transparent;
				background-color: darkslategrey;
				text-shadow: 1px 1px 1px #9194947a;
			}
			/* fix the size of timer so that the slash always at the center of #elmPlayingTime */
			/* & > :is(.plt-time, .plt-duration){
				width: calc(50% - .5em);
			}
			& > .plt-time{
				justify-content: end;
			} */
			/* class to blink #elmPlayingTime when audio is paused */
			&.paused {
				& > :is(.plt-time, .plt-duration){
					/* color: #888; */
					animation: timer-blink-kf 2s step-start .3s infinite;

					/* make engraved text */
					background-clip: text;
					-webkit-background-clip: text;
					color: transparent;
					background-color: #555;
					text-shadow: 1px 1px 1px #f5f5f5a0;
				}
				& > .plt-slash{
					color: inherit;
				}
			}
		}

		@media (hover:hover) and (pointer:fine){
			/* on desktop browser, move #elmPlayingTime up abit to make it vertically middle of its container */
			#elmPlayingTime{ 
				margin-top: -6px; 
				& > .plt-slash::before{
					translate: 0 3px;
				}
			}
		}

		@keyframes timer-blink-kf{
			0%, 50%, 100% {
				opacity: 1;
			}
			25% {
				opacity: 0;
			}
			/* 75% {
				opacity: 0.75;
			} */
		}

		@keyframes trembling-kf {
			0%,70%,100% {transform: rotate(0)}
			75%,85%,95% {transform: rotate(10deg)}
			80%,90%     {transform: rotate(-10deg)}
		}

		div:has(> #elmPlayingTime) {
			/* the div container which is direct father of #elmPlayingTime */
			padding: 0 5px;
			/* to prevent #elmPlayingTime being broken into two line when screen width shrink */
			font-size: xx-large;
			/* max-height: 1.6em; */
			/* so that in column mode, 9em below become the height */
			flex: 1 0 9em;
			/* flex-grow: 1; */
			/* fix the width so buttons on the right not have to be moved left/right when playinTime switch from Loading to current time */
			margin: 6px auto;

			/* display: flex;
			align-items: center;
			justify-content: space-between;
			& > :first-child{flex-grow: 0;}
			& > :not(:first-child){flex-grow: 1;} */

			/* I'm using grid instead of flex to better control */
			display: grid;
			grid-template-columns: auto 1fr auto;
			align-items: center;
			/* justify-items: stretch; */
			grid-template-rows: 1.5em;
			/* column-gap: 5px; */
			/* set cell for each of this element's child */
			& > :first-child{grid-area: 1/1/1/1;} /* the noInternet icon */
			/* push both elmPlayingTime and Loading into same - middle cell */
			& > :is(:nth-child(2), :nth-child(3)){grid-area: 1/2/1/2;} 
			& > :nth-child(4) {grid-area: 1/3/1/3;} /* show time ranges button */
		}

		@media only screen and (min-width: 850px) {
			div:has(> #elmPlayingTime){
				/* format the border for the div that is direct mother of #elmPlayingTime and HourglassSpining */
				/* border: 2px dashed var(--select-book-group-color);
				border-radius: 1em; */
				
				position: relative;

				/* draw the dashed border for the div */
				&::before {
					content:"";
					position: absolute;
					border-radius: 1em;
					pointer-events: none;

					--b: 2.2px;  /* // border thickness */
					--s: 22px; /* // size of the dashes */
					--c1: var(--select-book-group-color);
					--c2: #dddd;
					inset: 0;
					padding: var(--b);
					background: 
					repeating-conic-gradient(var(--c1) 0 25%,var(--c2) 0 50%) 
					0 0/var(--s) var(--s) round;
					-webkit-mask:
						linear-gradient(#000 0 0) content-box,
						linear-gradient(#000 0 0);
					-webkit-mask-composite: xor;
							mask-composite: exclude;
				}
			}
		}

		@media only screen and (max-width: 850px) {
			
			div:has(> #elmPlayingTime) {
				/* When in column mode, flex-basic (9em) become the height of the div, so revoke it and set new height */
				flex: 0;
				height: 1.5em;
				border: none;
				/* this make noInternet icon being pushed to left side */
				width: 100%;				
				/* margin: unset; */
			}
		}
		
		/* the icon showing that there is no internet connection. You need to differentiate this with .noInternetImg which is image below workart (even though both use the same svg sprite symbol) */
		div.noInternetSignal{
			--size: 1.9em;
			width: var(--size);
			height: var(--size);
			margin-right: 5px;
			display: flex;
			align-items: center;
			
			& > svg{
				width: var(--size);
    			height: var(--size);
				font-size: 2em;
				animation: trembling-kf 1s infinite;
				& > use{
					width: var(--size);
    				height: var(--size);
				}
			}
		}
		
		/* the svg icon having the tooltip which shows the audio played, buffered, seekable timeRange. See timeRangeCanvas() function */
		div.timeRangeInfoButton{
			/* grid-area: 1 / 3 / 1 / 3; */
			--size: 1.3em;
			width: var(--size);
			height: var(--size);
			/* margin-right: 5px; */
			display: flex;
			align-items: center;			
			
			/* make the tooltip lingers longer than default */
			--tooltip-timeout: 10s;
			/* format a bit different for the tooltip */
			&::before{
				color: #ffd97c;
				font-size: 16px;
			}

			& > svg{
				width: var(--size);
    			height: var(--size);
				font-size: 2em;
				color: var(--select-book-group-color);
				fill: currentColor;
				& > use{
					width: var(--size);
    				height: var(--size);
				}
			}
			&:hover > svg{
				animation: trembling-kf 1s infinite;
			}
		}

		div[name="HourglassSpining"] {
			color: darkgreen;
			position: relative;
			/* to vertically center the Loading span */
			transform: translateX(-80px);
			/* to make spinning clock with the span seems to be centered*/
		}

		div[name="HourglassSpining"]>span {
			font-weight: bold;
			font-size: 2em; /* xx-large */
			/* Center vertically */
			position: absolute;
			top: 50%;
			transform: translate(0, -50%);
			margin-left: 10px;
		}

		#elmBookTotalDuration {
			color: darkgreen;
			margin: 5px 0px 5px 0px;

			&>span {
				font-size: x-large;
				font-weight: bold;
			}

			&>svg:first-of-type {
				color: darkgreen;
				font-size: 1.45em;
				margin: auto -4px -.35em 5px;
			}

			&>svg:last-of-type {
				color: darkgreen;
				font-size: 1.1em;
				margin: auto 4px -4px 8px;
			}
		}

		#elmSelBookTitles {
			max-width: 100%;
			margin: 2px auto;
			border-color: var(--select-book-group-color);
			border-width: 2px;
		}

		/* class to replace default spinner (little triangle at right side) of dropdown list */
		.dropdown-book-spinner {
			/* Hide default spninner */
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			
			border-color: #0000;
			line-height: 1.8em;
			padding-left: 5px;
			padding-right: 1.8em;
			border-radius: .4em;
			/* SVG background image */
			background: transparent url(https://uxwing.com/wp-content/themes/uxwing/download/education-school/books-icon.svg) right 0.2em center / 1.4em no-repeat; /* var(--book-micro-svg-bground) */

			&:focus {
				border-width: 2.5px !important;
				outline: none;
				/* remove browser-added black outline when dropdown got focus */
			}

			/* Hide default spninner for IE */
			&::-ms-expand {
				display: none;
			}
		}

		#elmInnerMcFlexCtn>span{
			& > input[type="radio"]{
				display: none;
			}

			&>label {
				font-size: var(--playlist-item-title-font-size);
				font-weight: bold;
				margin-right: 15px;
				cursor: pointer;

				position: relative; /* because ::after position is absolute */
				display: flex;
        		align-items: center;

				&:hover{
					-webkit-text-fill-color: #fff; /* Will override color (regardless of order) */
					-webkit-text-stroke: .8px currentColor;
					text-shadow: unset !important;
				}
				
				
				&::before {
					/* content: "🎙: "; 🗣 */
					content: "";
					background: url(https://uxwing.com/wp-content/themes/uxwing/download/peoples-avatars/silhouette-male-icon.svg) bottom 0px center / 20px no-repeat;
					
					/* https://uxwing.com/wp-content/themes/uxwing/download/peoples-avatars/account-icon.svg */
					/* https://uxwing.com/wp-content/themes/uxwing/download/business-professional-services/male-services-support-icon.svg */
					/* https://uxwing.com/wp-content/themes/uxwing/download/peoples-avatars/speak-talk-voice-icon.svg */
					width: 26px;
					height: 26px;
					box-sizing: border-box; /* so that the width and height already includes padding, border, and margin */
					margin: 3px 5px 3px;
					border: 2px solid #000;
					border-radius: 50%;
					/* transform: rotateY(180deg);
					color: red; */
				}
			}	

			/* make different color for different radio label */
			&:first-of-type>label {
				color: darkred;
				/* filter the before pseudo to make the icon color matches the text color */
				&::before{
					filter: invert(11%) sepia(72%) saturate(4836%) hue-rotate(355deg) brightness(81%) contrast(113%);
				}
			}

			&:nth-of-type(2)>label {
				color: darkblue;
				/* filter the before pseudo to make the icon color matches the text color */
				&::before{
					filter: invert(11%) sepia(55%) saturate(4237%) hue-rotate(235deg) brightness(105%) contrast(143%);
				}
			}

			&:nth-of-type(3)>label {
				color: darkorchid;
				/* filter the before pseudo to make the icon color matches the text color */
				&::before{
					filter: invert(22%) sepia(36%) saturate(6471%) hue-rotate(272deg) brightness(93%) contrast(86%);
				}
			}

			/* decoration for label having referenced radio button checked */
			& > input[type="radio"]:checked + label{
				text-shadow: -1px 1px 1px #3336;

				/* remove the image, keep only circle border */
				&::before{
					background-image: none;
					border-color: currentColor;
					background-color: #fff;
					filter: none; /* to deactive default filter */
					animation: radio-tick--blink-kf 3s alternate infinite;
				}

				/* draw the circle */
				&::after {
					content: "";
					position: absolute;
					box-sizing: border-box;
					position: absolute;
					top: calc(50% - 8px);
					left: 10px;
					width: 16px;
					height: 16px;					
					border: 1px solid;
					border-radius: 50%;
					/* background-color: #fc2; */
					background: radial-gradient(circle at 20%, #0000 0, currentColor 70%);					

					animation: spin-keyframe 2s linear infinite/* ,radio-tick--blink-kf 3s alternate infinite */;
				}

				/* OR draw the tick */
				/* &::after {
					content: "";
					position: absolute;
					top: calc(50% - 9px);
					left: 13px;
					rotate: 30deg;
					--tick-size: 5.5px;
					--tick-decor: 3.5px solid;
					height: calc(2* var(--tick-size));
					width: var(--tick-size);
					border-bottom: var(--tick-decor);
					border-right: var(--tick-decor);
					animation: radio-tick--blink-kf 3s alternate infinite;
				} */
			}
		}
		@keyframes radio-tick--blink-kf{
			0%, 50%{
				filter: none; /* drop-shadow(0 0 0rem #000); */ /* blur(0); */
			}
			100%{
				filter: drop-shadow(0px 0px 4px #000a);/* blur(1px); */
			}
		}

		/* General Setting fro some element types */
		fieldset{
			background-color: #f4f4e52b;
			border: 1px solid #bdbec0;
			border-radius: .4em;
			padding: .3em;
			max-width: 100%;
			/* Header of fieldset */
			& > legend{
				font-size: .875em;
				font-weight: 600;
				color: var(--select-book-group-color);
				text-align: left;
				margin-left: .5em;
				white-space: nowrap; /* on stupid iOS, legend somehow be compressed into multiple (>3) lines */
			}
		}
		p {
			margin: 5px 2px;
		}

		select,
		button {
			outline: none;
			color: #000;
			/*font-size: 18px;
			font-weight: bold;*/
		}
		blockquote{
			margin: 5px 20px;
			position: relative;
			&::before{
				content: '❝';
				color: darkcyan;
				left: -27px;
				top: -12px;
				font-size: 2.4em;
				position: absolute;
			}
		}

		/* Commonly format for optGroup of a select element such as one for #selBookGroup or .ap-speed-option-select */
		select > optgroup{
			color: #888;
			font-weight: 400;				
			text-shadow:3px 3px 1px #999;
			& > option{
				color: #000;
				font-style: normal;
			}
			/* &::before{
				content: "📚";
			} */
		}			

		a {
			&:link {
				text-decoration: none;
				/* padding: 2px 10px 4px 3px; */
			}

			&:visited {
				text-decoration: none;
			}

			&:hover {
				/* color:darkred !important; */
				background-color: rgb(227, 232, 244);
				border: 1px solid #666;
				border-right-width: 5px;
				padding: 2px 5px 4px 3px;
				border-radius: 5px;
			}
		}

		/* dfn: used for book/book kit/book collection summary
		var element used for real listening time all over the page
		*/
		dfn, var {
			font-size: inherit;
			font-weight: inherit;
			font-style: normal;
			text-decoration: none;
		}

		input[type="radio"]:checked{
			accent-color: red;
		}

		.glowing-border {
        	animation: glow-keyframe 1s 1;
			/* animation-iteration-count: 1; infinite*/
        }
		@keyframes glow-keyframe {
            0% {
                box-shadow: 0 0 5px grey, 0 0 10px grey, 0 0 15px grey;
            }
            50% {
                box-shadow: 0 0 20px grey, 0 0 30px grey, 0 0 40px grey;
            }
            100% {
                box-shadow: 0 0 0px grey, 0 0 0px grey, 0 0 0px grey;
            }
        }
		/* style to format part of chapter title differently from others to emphasize it */
		.tit-hoi     { color: #c09618; }
		.tit-chuong  { color: #0e4cd0 /* #d04f0e; */ }
		.tit-phan    { color: green; }
		.tit-tap     { color: purple; }
		.tit-quyen   { color: darkorange; }
		.tit-pham    { color: teal; }
		.tit-bai     { color: brown; }
		.tit-cau     { color: darkcyan; }
		.tit-so-don  { color: #1566bf; font-size: .95em !important;}		
	</style>

	<!-- inlineList, inlineListInfor -->
	<style>
		/* Display inline list of information. inlineList for list of anchors, inlineListInfor for list of pieces of information */
		ul.inlineList,
		ul.inlineListInfor {
			display: inline;
			padding-inline-start: 2px;
		}

		ul.inlineList>li:not(:last-of-type)::after {
			content: ' ┋ ';
			/*∴ ┋*/
			color: darkred;
		}

		ul.inlineListInfor {
			padding-inline-start: 0px;
		}

		ul.inlineListInfor>li::before {
			content: '∴';
			padding-left: 10px;
			padding-right: 7px;
			color: red;
		}

		ul.inlineListInfor>li:first-of-type::before {
			padding-left: 0;
		}

		ul.inlineList>li,
		ul.inlineListInfor>li {
			display: inline;
			/* format the box for percentage of listened duration in compared with total duration */
			& > span#percentageListened{
				background: linear-gradient(90deg, rgba(139, 198, 236, 0.5) 0%, rgba(149, 153, 226, 0.5) 100%) 0px 0px / 50% 100% no-repeat;
				border: 1px solid #0fa8a8;
        		border-radius: 6px;
				padding: 0px 5px 2px 5px;
				font-size: .85em;
        		font-weight: 700;
				/* transition: background-size .3s; */

				display: inline-block;
				width: 4.2em;

				height: 20px;
				/* I use line-height to control the vertical position of this span */
        		line-height: 18px;
				
				/* make tooltip stays a little longer */
				--tooltip-timeout: 8s;
			}
		}

		ul.inlineList {
			counter-reset: anchor;
		}

		ul.inlineList>li>a[href].srcPlaying {
			border: 1px solid #730a50;
			border-left: 5px solid #730a50;
			color: darkblue;
			font-weight: 700;
			background-color: rgb(255 243 229);
			padding: 1px 5px 2px 0px;
			border-radius: 5px;

			&:hover {
				background-color: rgb(246 213 175);
			}
		}

		ul.inlineList>li>a[href].srcPlaying::before {
			/* content: counter(anchor) ". "; "⏵ "  ⧉ */
			background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 92.2 122.88' fill='%2300008b'%3E%3Cpath style='fill-rule:evenodd;clip-rule:evenodd' d='M92.2 60.97 0 122.88V0z'/%3E%3C/svg%3E");
			margin-left: 2px;
		}

		/* If there is only one link, no need for order number */
		ul.inlineList>li:only-of-type>a[href].srcPlaying::before {
			content: "";
			/* "⏵ "; */
		}

		ul.inlineList>li>a[href] {
			counter-increment: anchor;
			white-space: nowrap;
			/* &:hover::before{
		color: black;
		filter: invert(13%) sepia(47%) saturate(6568%) hue-rotate(7deg) brightness(81%) contrast(124%);
	} */
		}

		ul.inlineList>li>a[href]::before {
			content: "\2002" counter(anchor) ".";
			background: url("data:image/svg+xml;charset=utf-8,%3Csvg fill='%230000EE' viewBox='300 150 424 724' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m725.4 853.3h-469.4c-47.1 0-85.3-38.2-85.3-85.3v-469.3c0-47.2 38.2-85.4 85.3-85.4h170.7v85.4h-170.7v469.3h469.4v-170.7h85.3v170.7c0 47.1-38.2 85.3-85.3 85.3zm-226.2-268.5-60.1-60.3 268.5-268.5h-152.9v-85.3h298.7v298.6h-85.4v-152.9l-268.8 268.4z'%3E%3C/path%3E%3C/svg%3E") left center/ 13px 13px no-repeat;
			padding-left: 16px;
			padding-right: 6px;
		}
		
		ul.inlineList>li>a.outsideLink[href]::before {
			/* content: counter(anchor) ". ";  */
			background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg fill='%230000EE' viewBox='150 120 724 724' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath d='m301.8 418.7-87.8 87.8a192 192 0 1 0 271.5 271.5l117-117a192 192 0 0 0-53-309l-37.5 37.5a64.1 64.1 0 0 0-9.9 12.7 128 128 0 0 1 55.1 213.6l-116.9 117a128 128 0 1 1-181.1-181.1l50.8-50.7a257.2 257.2 0 0 1-8.2-82.4z'/%3E %3Cpath d='m421.5 299a192 192 0 0 0 53 309l49.6-49.7a128 128 0 0 1-57.3-214.1l116.9-117a128 128 0 1 1 181.1 181.1l-50.8 50.7c7.2 26.9 9.9 54.7 8.2 82.4l87.8-87.8a192 192 0 1 0-271.5-271.6l-117 117z'/%3E %3C/svg%3E");
			/* 🔗 */
		}

		ul.inlineList>li>a:is([href*="youtube.com"], [href*="GetAudioYoutube"])::before{
			/* display: inline-block; */
			width: 35px; /* long enough to contains the icon */
			background: url('https://www.svgrepo.com/download/475700/youtube-color.svg') 0px center / 20px no-repeat !important;
			/* background-position: 0px 65%;
			background-size: 15px; */
		}
		ul.inlineList>li>a[href$=".pdf"]::before{
			background: url('https://uxwing.com/wp-content/themes/uxwing/download/file-and-folder-type/pdf-icon.svg')  0px center / 18px no-repeat;
			/* background-position: 0px 60%;
			background-size: 15px; */
		}
		ul.inlineList>li>a[href*="archive.org"]:not(.srcPlaying)::before{
			/* https://archive.org/offshoot_assets/assets/ia-logo-2c2c2c.03bd7e88c8814d63d0fc..svg */
			background: url('https://www.svgrepo.com/download/173820/historic-theatre.svg')  0px center / 18px no-repeat;
			/* background-position: 0px 60%;
			background-size: 15px; */
		}

		/* If there is only one link, no need for order number */
		ul.inlineList>li:only-of-type>a[href]::before {
			content: "";
			/*⚓ 🔗*/
		}

		svg.svg-img-infor {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			width: 1.1em;
			max-height: 1.4em;
			display: inline-block;
			color: #0fa8a8;
			fill: currentColor;
			font-size: inherit;
			margin-bottom: -.3em;
			margin-right: 5px;

			&:hover {
				color: #0d8707 !important;
			}
		}

		/* setting for svg that height bigger than width. We need some modification so that these svg looks not too small in compared with other square svg. Following are some modification for some special svg icon to make them equally-sized and vertical-middle with other svg icon and text */
		svg.svg-img-infor:has(use:is([href="#icnSvgListenTime"])) {
			font-size: .9em;
			margin-bottom: -.25em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgRemainTime"])) {
			font-size: 1.1em;
			margin-bottom: -.35em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgDuration"], [href="#icnSvgMediaLinks"])) {
			font-size: 1.15em;
			margin-bottom: -.35em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgBooks"])) {
			font-size: 1.15em;
			margin-bottom: -.4em; /* so that the svg stick to base-line */
		}
	</style>

	<!-- STYLE FOR BUTTONS AND SELECT IN MAIN PAGE USING SVG -->
	<style>
		/* Audio control button using SVG */
		.control-button-flex {
			display: flex;
			flex-flow: row wrap;
			justify-content: center;
			align-items: center;
			gap: 8px;
			max-width: 100%;
			margin-bottom: 5px;
			background-color: transparent;
			/* #FBB040; */
		}

		.control-button-flex button,
		.svgButton {
			cursor: pointer;
			-webkit-appearance: button;
			appearance: button;
			background-color: transparent;
			background-image: none;
			text-transform: none;
			margin: 0px;
			padding: 4px 4px 1px 4px;
			border: var(--button-border-style);
			border-radius: 20%;
			color: inherit;
		}

		.control-button-flex button:hover,
		.svgButton:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color);

			/* Make the remainder circle and played circle of circle-progress button a bit darker */
			--audio-playing-current-progress-played-color: #0ee302;
			--audio-playing-current-progress-remained-color: #656565;

			-webkit-transition: background-color .2s ease;
			transition: background-color .2s ease;
		}

		svg.button-svg-img {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			/* Somehow make width a bit smaller than height can prevent svg from being cropped */
			width: 1.2em;
			height: 1.25em;
			display: inline-block;
			fill: currentColor;
			-webkit-flex-shrink: 0;
			-ms-flex-negative: 0;
			flex-shrink: 0;
			-webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
			transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
			font-size: inherit;
			margin: auto -2px;
		}

		.\!text-\[12px\] {
			font-size: 12px !important;
		}

		.\!text-\[15px\] {
			font-size: 16px !important;
		}

		.\!text-\[20px\] {
			font-size: 20px !important;
		}

		.\!text-\[25px\] {
			font-size: 25px !important;
		}

		.\!text-\[28px\] {
			font-size: 28px !important;
		}

		.\!text-\[30px\] {
			font-size: 30px !important;
		}

		.\!text-\[35px\] {
			font-size: 35px !important;
		}

		.\!text-\[40px\] {
			font-size: 40px !important;
		}

		.\!text-\[50px\] {
			font-size: 50px !important;
		}

		.\!text-\[55px\] {
			font-size: 55px !important;
		}

		.\!text-\[80px\] {
			font-size: 80px !important;
		}

		.rotate-90 {
			transform: rotate(90deg);
		}

		.rotate-180 {
			transform: rotate(180deg);
		}

		.elm-hidden {
			/* This css for hiding element only and being used alot. SHOULD NOT touch this css, if in need, create other one */
			display: none !important;
		}

		.elm-disabled {
			cursor: not-allowed !important;
			pointer-events: none;
			color: gray !important;
			background-color: #ddd8d8 !important;
		}

		.animate-spin {
			animation: spin-keyframe 1s linear infinite
		}

		@keyframes spin-keyframe {
			from {
				transform: rotate(0deg);
			}

			to {
				transform: rotate(360deg);
			}
		}
	</style>

	<!--------------------- Audio Player - AP ---------------->
	<style>
		/* Player and control panel */
		.ap-container {
			/* height of audio control panel (ACP), this is calculated by js when nail-bottom sticky mode is selected, because only that mode need to use this css var to calculte the css top property */
			--acp-height: 60px;
			/* distance from audio control panel (ACP) to the bottom side of viewport for apple device (which has a thick line at bottom of screen used for app fast-switching) */
			--apple--acp-bottom: 20px;			

			max-width: 100%;
			background-color: #eee;
			border: 1px solid darkcyan;
			border-radius: 8px;
			padding: 2px 4px;

			/* add transition for border-color changes when changing sticky/nail mode */
			transition: border-color 1s ease;

			/* This is to stick the .ap-container at the top of the page, sticky mode = 1 */
			&.ap-container-sticky-top{
				position: sticky;
				top: 1px;
				/* set z-index so .ap-container not be overlapped by other elements except SDD */
				z-index: 5;

				border-color: darkmagenta;

				/* &.apc--pinned{
					box-shadow: 0px 4px 2px 0px #1113;
				} */
			}

			/* This is to stick the .ap-container at the bottom of the page, sticky mode = 2 */
			&.ap-container-sticky-bottom{
				position: sticky;
				/* for sticky bottom to work, .ap-container must be at the end of its parent, we will archive this by js */
				bottom: 2px;
				/* set z-index so .ap-container not be overlapped by other elements except SDD */
				z-index: 5;

				border-color: darkslateblue;

				&.apc--pinned{
					/* to make audio control panel not too close to the text */
					margin-top: 5px;

					/* when .ap-container is pinned at bottom, we need to set padding for [name="divCtnBottom"] (which is element right before .ap-container only when .ap-container is pinned at bottom) so that control panel not too close to the text */
					div[name="divCtnBottom"]:has(+ &){
						padding-bottom: 3px;
					}
					
					/* Because apple device has a thick-line (for fast window switching) at the bottom of the screen, we need to push the .ap-container a bit higher so that that line does not overlap the audio control panel, and also the curved at corner of screen does not hide the audio control panel. This class will be added manually in stickyAudioPanelHandler() for apple devices */
					&.apc--apple{
						bottom: var(--apple--acp-bottom);
						/* for apple device and when .ap-container is pinned at bottom, because .ap-container is set bottom bigger (right above is 20px), so we need to set padding a bit bigger for [name="divCtnBottom"] (which is element right before .ap-container) so that control panel not too close to the text */
						div[name="divCtnBottom"]:has(+ &){
							padding-bottom: 10px;
						}
					}					
				}
			}

			/* This is to change appearance of .ap-container when it is pinned at bottom or top of the page (that is, when the page scroll so original .ap-container is out of user's view) */
			&.apc--pinned{
				background-color: #ddd;
				border-width: 2px;

				/* add shadow to make a visual that audio control panel ABOVE other elements. For (top, bottom) sticky mode, only show shadow when ACP is pinned */
				box-shadow: 0 0 4px 3px #1113;
			}

			/* This is to put the .ap-container (short is ACP - Audio Control Panel) stay at the bottom of the page (mode = 3) or nail at the bottom of the viewport (mode = 4) at all time. The behavior of this modes are somewhat similar to .ap-container-sticky-bottom in mode=2, except that it is always pinned at bottom */
			&.ap-container-nail-bottom{
				/* 'position:sticky' would keep ACP (.ap-container) at bottom of screen when height of parent ([name="divContainer"]) more than viewport height. But when ACP's parent ([name="divContainer"])'s height not fill the height of viewport, ACP would be at the bottom of parent, not bottom of viewport. We fix that by class .apc-nail-bottom--fix-top which dynamically toggled by ResizeObserver API (see mainDivHeightObserver) */
				position: sticky;
				/* for sticky bottom to work, .ap-container must be at the end of its parent, we will archive this by js. */
				bottom: 2px;
				/* set z-index so .ap-container not be overlapped by other elements except SDD */
				z-index: 5;

				background-color: #ddd;
				border: 2px solid darkorange;

				/* add shadow to make a visual that audio control panel ABOVE other elements */
				box-shadow: 0 0 4px 3px #1113;
				
				/* to make audio control panel not too close to the text */
				margin-top: 5px;

				/* class to control position of ACP depending on the height of its parent - div[name="divContainer"]. This class is dynamically toggled by using JS ResizeObserver to watch for the height of ACP's parent changes to see if the height is more than viewport height or not (this is archived by mainDivHeightObserver) */
				&.apc-nail-bottom--fix-top{
					border-color: red;
					/* The problem of 'position:sticky' is that when ACP's parent ([name="divContainer"])'s height not fill the height of viewport, ACP would be at the bottom of parent, not bottom of viewport. One way to fix for that case is: we change its position to absolute */
					/* position: absolute; */

					/* Since change the position would trigger the whole page flow re-rendered which is very expensive, other approach is set the top big enough so the ACP would be stuck at bottom of viewport */
					bottom: unset; /* unset the original bottom (might not really necessary) */
					/* should be calc(100dvh - 100%) but not work for now. So I use 100dvh which is more than the top we need, but the boundary of div[name="divContainer"] would keep it at bottom of viewport */
					top: calc(100dvh - var(--acp-height));

					/* Because apple device has a thick-line (for fast window switching) at the bottom of the screen, we need to push the .ap-container a bit higher so that that line does not overlap the audio control panel, and also the curved at corner of screen does not hide the audio control panel. This class will be added manually in stickyAudioPanelHandler() for apple devices */
					&.apc--apple{
						top: calc(100dvh - var(--acp-height) - var(--apple--acp-bottom));
						
						/* for apple device and when .ap-container is pinned at bottom, because .ap-container is set bottom bigger (right above is 20px), so we need to set padding a bit bigger for [name="divCtnBottom"] (which is element right before .ap-container when .ap-container is nailed down at bottom) so that control panel not too close to the text */
						/* div[name="divCtnBottom"]:has(+ &){
							padding-bottom: 15px;
						} */
					}
					
					/* body:has(&){
						overflow-y:hidden;
					} */
				}

				/* for nail-bottom mode, parent of .ap-container (APC) has to change position to relative so its 'position:absolute' take that parent as its 'positioned ancestor' (so APC can keep its dimension). And also, we need to set the height of parent at least height of viewport for ACP stay at bottom of viewport */
				div[name="divContainer"]:has(> &){
					/* position: relative; */
					min-height: calc(100dvh - 10px); /* 10px is its top+bottom margin. If set to 16px (because margin of body is 8px), we can avoid scroll-bar to be appeared */
				}

				/* when .ap-container is stayed at bottom, we need to set padding for [name="divCtnBottom"] (which is element right before .ap-container when .ap-container is nailed down at bottom) so that control panel not too close to the text */
				div[name="divCtnBottom"]:has(+ &){
					padding-bottom: 3px;
				}
				
				/* Because apple device has a thick-line (for fast window switching) at the bottom of the screen, we need to push the .ap-container a bit higher so that that line does not overlap the audio control panel, and also the curved at corner of screen does not hide the audio control panel. This class will be added manually in stickyAudioPanelHandler() for apple devices */
				&.apc--apple{
					bottom: var(--apple--acp-bottom);
					
					/* for apple device and when .ap-container is pinned at bottom, because .ap-container is set bottom bigger (right above is 20px), so we need to set padding a bit bigger for [name="divCtnBottom"] (which is element right before .ap-container when .ap-container is nailed down at bottom) so that control panel not too close to the text */
					div[name="divCtnBottom"]:has(+ &){
						padding-bottom: 10px;
					}
				}
			}
		}

		.ap-panel {
			display: -webkit-box;
			display: -webkit-flex;
			display: -ms-flexbox;
			display: flex;
			align-items: center;
		}

		.ap-sub-panel {
			display: -webkit-box;
			display: -webkit-flex;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-flex: 0;
			/* 1 */
			-webkit-flex: 0;
			/* 1 */
			-ms-flex: 0;
			/* 1 */
			flex: 0;
			/* 1 */
			-webkit-box-pack: center;
			-webkit-justify-content: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-webkit-align-items: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.ap--track {
			-webkit-box-flex: 1;
			/* set both flex-grow and flex-shrink to 1 so that when the viewport width changes,.ap--track changes accordingly, then in turn .ap-title-time, and then .ap-title changes. This way, we can avoid long HANDLING RESPONSIVE at the end of this style block. Note that all other .ap-sub-panel has both flex-grow and flex-shrink set to 0 */
			-webkit-flex: 1 1 auto;
			/* 1 40% */
			-ms-flex: 1 1 auto;
			/* 1 40% */
			flex: 1 1 auto;
			/* 1 40% */
			margin: 0 5px;
			align-self: stretch;
			position: relative;

			/* manually set  pointer-events for children and offsprings */
			/* so its children does not prevent the coordinate of .ap--track element on mousemove event handler of this .ap--track element to work */
			& > *{
				pointer-events: none;
			}
			/* have to set .ap-progress pointer-events to auto for mousemove event handler on .ap-progress so that the mouse seeking on progress-bar to work */
			& > div.ap-info > div.ap-progress-container > div.ap-progress{
				pointer-events: auto !important;
			}

			/* div that display audio offset time at the mouse' position as a tooltip */
			& > div.moving-audio-offset-time{
				transform: translate(-50%, -100%);
				display: none;
				/* display: block; */
				position: absolute;
				color: #b6ffba; /* #c3f4ff; */ /* #F0B015; */
				background-color: #000a;
				border: 1px solid; /* none; */
				border-radius: 6px;
				padding: 3px 8px 6px;
				z-index: 5;				
				width: fit-content;
				max-width: 200px;
				top: 0;
				left: 50%;
				text-align: center;

				/* the pointing-down triangle */
				&:after {
					content: "";
					--arrow-size: 5px;
					display: block;
					position: absolute;
					border-color: #0009 transparent transparent transparent;
					border-style: solid;
					border-width: var(--arrow-size) var(--arrow-size) 0;
					bottom: calc(0px - var(--arrow-size));
					left: 50%;
					transform: translate(-50%, 0);
					width: 0;
				}
			}

			&:hover > div.moving-audio-offset-time{
				display: block;
			}
		}

		.ap--playback,
		.ap--settings {
			-webkit-box-flex: 0;
			/* 1 */
			-webkit-flex: 0;
			/* 1 */
			-ms-flex: 0;
			/* 1 */
			flex: 0;
			/* 1 */
		}

		.ap--settings>.ap-controls,
		.ap--playback>.ap-controls {
			-webkit-box-flex: 0;
			-webkit-flex: 0;
			/* 25% */
			-ms-flex: 0;
			/* 25% */
			flex: 0;
			/* 25% */
		}
		/* sticky the 'audio control panel' select options box */
		.ap--playback .ap-sticky-select {
			background: transparent url(https://www.svgrepo.com/download/436850/pin-slash-fill.svg) center / 26px no-repeat; /* https://www.svgrepo.com/download/437145/pin-slash.svg */
			width: 23px;
			height: 100%;
			-moz-appearance: none;
			-webkit-appearance: none;
			appearance: none;
			font-size: 0px; /* to hide the text in select box when it is collapsed */
			text-align-last: center;
			border: none;
			/* filter: var(--select-book-group-filter); */
			cursor: pointer;

			/* no sticky at all */
			/* &:has(option:nth-of-type(1):checked) {
				background-size: 26px !important;
			} */

			/* sticky on top */
			&:has(option:nth-of-type(2):checked) {
				background-image: url(https://www.svgrepo.com/download/446293/pin.svg);
				/* background-image: url(https://www.svgrepo.com/download/451186/pin-tear.svg);
				rotate: 180deg; */
			}

			/* sticky at bottom */
			&:has(option:nth-of-type(3):checked) {
				background-image: url(https://www.svgrepo.com/download/437147/pin.svg);
				/* url(https://www.svgrepo.com/download/436849/pin-fill.svg); */
			}

			/* simple always nail at bottom */
			&:has(optgroup:nth-of-type(2) option:nth-of-type(1):checked) {
				background-image: url(https://www.svgrepo.com/download/411046/pin.svg);
			}
			
			/* complex always nail at bottom */
			&:has(optgroup:nth-of-type(2) option:nth-of-type(2):checked) {
				background-image: url(https://www.svgrepo.com/download/436849/pin-fill.svg);
			}

			&:hover {
				filter: var(--select-hover-bground-filter);
				
			}
		}

		.ap--settings button,
		.ap--playback button {
			padding-left: 6px;
			/* On Ios, default padding is very wide (19px), so we need to fix this to save space of buttons for progress bar */
			padding-right: 6px;
		}

		/* Info section */
		.ap-info {
			width: 100%;
			position: relative;
			-webkit-align-self: flex-start;
			-ms-flex-item-align: start;
			align-self: flex-start;
			padding: 0;
		}

		.ap-title-time{			
			display: grid;
			grid-template-columns: minmax(100px, 1fr) minmax(50px, auto);
			align-items: end;
			/* align-content: stretch; */

			&  * {
				font-size: .9em;
			}
			& > .ap-title {
				/* has to set padding-top to prevent vietnamese glyph (diacritical mark, diacritical point, diacritical sign, or accent) from being cut-off. My test on iPhone padding-top should at least be 3px */
				padding: 3px 10px 0 0;
				text-align: left;
				white-space: nowrap;
				text-overflow: ellipsis;
				overflow: hidden;
				/* width: 350px; 				
				min-width: 0px;*/
			}

			& > .ap-time {
				/* flex: 0 0 auto; */
				display: flex;
				align-items: center;
				justify-content: end;				

				/* This element contains the remaining time (full duration and real remaining listen time) */
				/* & > .ap-time--remains{					
					set the timeout for the tooltip to be automatically disappear longer
					--tooltip-timeout: 10s;
					--data-translateX: -60%;
				} */
			}
		}

		.ap-progress-container {
			/* --tooltip-timeout: 3600s; */
			padding: 3px 0 7px;
			cursor: pointer;
		}

		.ap-progress {
			position: relative;
			height: 5px;
			border-radius: 5px;
			background: #c4c4c4;
		}
		
		.ap-progress-preload-bar,
		.ap-progress-bar {
			position: absolute;
			left: 0;
			top: 0;
			bottom: 0;
			width: 0;
			border-radius: 5px 0 0 5px;
			transition: width .5s;
		}

		.ap-progress-preload-bar {
			background: #a6a6a6;
			z-index: 0;
		}

		.ap-progress-bar {
			background: #f50;
			/* #f50 steelblue*/
			
			z-index: 1;
		}

		.ap-progress-bar::after {
			position: absolute;
			top: 0;
			right: -5px;
			width: 12px;
			height: 12px;
			margin-top: -4px;
			content: '';
			border-radius: 6px;
			background: #f50;
			opacity: 0.3;
			-webkit-transition: opacity .3s ease;
			transition: opacity .3s ease;
		}

		.ap-progress-container:hover .ap-progress-bar::after {
			opacity: 1;
		}

		/* css to show the loading animation in .ap-progress-bar when audio is being loaded */
		/* .ap-progress-bar--loading {
			height: 4px;
			width: 100%;
			--c:repeating-linear-gradient(135deg,#6100ee 0 12px, #ffc260 0 20px) no-repeat;
			background: var(--c),var(--c),#d7b8fc;
			background-size: 20% 100%;
			animation: l16 4s infinite alternate;
			
			& > *{
				visibility: hidden;
			}
		}
		@keyframes l16 {
			0%   {background-position: -30% 0, -30% 0}
			66%  {background-position: 130% 0, -30% 0}
			100% {background-position: 130% 0, 130% 0}
		} */

		.ap-progress-bar--loading {
			--c: repeating-linear-gradient(135deg, var(--select-book-group-color, #6100ee) 0 12px, #bbb 0 20px) no-repeat;
			--w: 18%; /* width of moving shuttle */
			--b: .5px; /* border width */
			background: var(--c), #d7b8fc; /* #e1cbfc */
			background-size: var(--w) calc(100% - 2 * var(--b));
			/* background-position: 0px var(--b); */
			border: var(--b) solid #000;
			animation: l16 cubic-bezier(.5, 0, .5, 1) 2s infinite alternate;
			
			& > *{ /* temporarily hide all children */
				visibility: hidden;
			}
		}
		@keyframes l16 {
			0%   {background-position: calc(-5% - var(--w)) var(--b)}
			100% {background-position: calc(105% + var(--w)) var(--b)}
		}

		.ap-played-bar,
		.ap-buffer-bar {
			/* These two will be set by js with some other attributes so that the canvas would not be blurry */
			width: 100%;
			height: 4px;
			border-radius: 3px;
			display: block;
			&:has( + &) {
				margin-bottom: 3px;
			}
		}

		/* Buttons */
		.ap-controls {
			position: relative;
			z-index: 2;
			display: block;
			height: 50px;
			cursor: pointer;
			-webkit-transition: background .2s ease;
			transition: background .2s ease;
			text-align: center;
			color: #222;
			border: 0;
			outline: 0;
			background: none;

			&:hover {
				background-color: #ccc;
			}
		}

		.ap-controls {
			cursor: pointer;
			appearance: button;
			-webkit-appearance: button;
			background-color: transparent;
			background-image: none;
			text-transform: none;
			margin: 0px;
			/* padding: 4px 4px 1px 4px;
	border: var(--button-border-style); */
			border-radius: 20%;
			color: inherit;
		}

		.ap-controls:hover,
		.svgButton:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color);
		}

		/* .ap-controls svg {
		fill: #333;
		}
		.ap-controls:hover svg {
		fill: #222;
		} */
		.ap-controls:active {
			background: rgba(0, 0, 0, .1);
		}

		.ap-volume-container {
			z-index: 3;
		}

		.ap-volume {
			position: absolute;
			right: 0;
			bottom: 50px;
			overflow: hidden;
			width: min(100%, 35px);
			/* 100% */
			height: 0;
			visibility: hidden;
			-webkit-transition: height .2s cubic-bezier(0.17, 0.72, 0.26, 1.23);
			transition: height .2s cubic-bezier(0.17, 0.72, 0.26, 1.23);
			background: #f2f2f2;
			border: 1px solid #ccc;
			border-bottom: 0;
		}

		.ap-volume-btn {
			display: block;
			text-align: center;
			width: 100%;
			padding-right: 9px !important;
		}

		.ap-volume-btn>svg>.ap--volume-off,
		.muted>svg>.ap--volume-on {
			display: none;
		}

		.muted>svg>.ap--volume-off {
			display: inline;
		}

		.ap-volume-container:hover {
			background: #ddd;
		}

		.ap-volume-container:hover .ap-volume {
			height: 120px;
			visibility: visible;
		}

		.ap-volume-progress {
			display: block;
			width: 4px;
			height: 100px;
			margin: 10px auto;
			background: rgba(0, 0, 0, .2);
			position: relative;
			border-radius: 3px;
		}

		.ap-volume-bar {
			position: absolute;
			left: 0;
			right: 0;
			bottom: 0;
			background: #f50;
			height: 50%;
			border-radius: 3px;
		}

		.ap-speed-container {
			display: flex;
			align-items: center;
			gap: 1px;
		}

		.ap-change-speed-buttons {
			display: flex;
			flex-flow: column wrap;
			justify-content: center;
			align-items: stretch;
			gap: 0px;
			/* max-width: 100%;
	margin-bottom: 5px; */
			background-color: transparent;
			/* #FBB040; */
		}

		.ap-change-speed-buttons>button {
			/* plus/minus speed buttons */
			border: none;
			background-color: transparent;
			padding: 0px 2px;
		}

		.ap-speed-option-select {
			background: transparent url(https://uxwing.com/wp-content/themes/uxwing/download/transportation-automotive/speed-test-icon.svg) 57% 3px / 30px no-repeat;
			padding-top: 30px;
			padding-bottom: 4px;
			-moz-appearance: none;
			-webkit-appearance: none;
			appearance: none;
			font-size: 15px;
			text-align-last: center;
			color: #000;
			border: none;
			border-radius: 8px;
			/* border:var(--button-border-style);
    border-radius: 15%; */
			cursor: pointer;

			&:hover {
				filter: var(--select-hover-bground-filter);
			}
		}

		.ap-change-speed-buttons>button:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color) !important;
		}

		.ap-active {
			background: rgba(0, 0, 0, .15);
			opacity: 1;
		}

		/* ------------SPEED SLIDER POPUP--------------- */
		#spd_btn{
			padding: 0;
			display: flex;
			flex-flow: column;
			row-gap: 2px;
			align-items: center;
			justify-content: center;
			width: 38px;
			--data-translateX: -80%;
			
			& > img{
				width: 30px;
			}

			&:hover > img{
				filter: var(--select-hover-bground-filter);
			}

			& > .spd_btnValue{
				font-size: 13px;
			}
		}
		
		.spd_popup{
			--popup-bg:#eee;
			--border:#aaa;
			--track:#ccc;
			--active-color: var(--select-book-group-color); /* #007bff; */
			--track-active: var(--active-color);/* #3b3b3b; */
			--handle: var(--active-color);/* #111; */
			--tick:#bbb;
			--tick-one: var(--active-color); /* #007bff; */
			--tick-large:#444;
			--text:#111;
			--muted:#222;

			/* using fixed position to position popup relative to viewport, so that placePopup() will work. Using absolute position, popup is relative to its closest positioned ancestor */
			position: absolute; /* absolute; */
			width:480px !important; 
			max-width:calc(100vw - 16px) !important;
			background:var(--popup-bg); 
			border: 1px solid var(--active-color); 
			border-radius:12px;
			padding:12px; 
			box-shadow: 5px 6px 7px 1px #0006;
			z-index:20;

			/* property for showing transition */
			display:none;
			opacity: 0;
			transform: scale(0);
			top: 0; /* for transition on top property */

			/* Apply transition to both opacity and display. And a bonus transform to make zoom-in effect */
			transition: opacity .5s, transform .5s, display .5s, top .3s ease;
  			transition-behavior: allow-discrete; /* Crucial for discrete properties */

			/* remove transition on top property because when popup is moved to another position, we do not want to see the transition effect on top property which messes up the smoothness of the fade-in and zoom-in effect.
			This class will be added/removed by js in openPopup() */
			&.no-top-transition{
				transition: opacity .5s, transform .5s, display .5s; /* no transition on top property */
			}

			/* open popup */
			&[data-open="true"] {
				display: block;
				opacity: 1;
				transform: scale(1);

				@starting-style {
					transform: scale(0);
					opacity: 0; /* Define starting style for the transition */
				}
			}

			&::before {
				content: "";
				position: absolute;
				border: 6px solid transparent;
				left: var(--arrow-left);
				transform: translateX(-50%);
			}

			/* Popup dưới button */
			&.spd-popup-below::before {
				top: -10px;
				border-bottom-color: var(--active-color); /* #333; */
				border-width: 0px 6px 10px;
			}

			/* Popup trên button */
			&.spd-popup-above::before {
				bottom: -10px;
				border-width: 10px 6px 0;
				border-top-color: var(--active-color); /* #333; */
			}
		}

		.spd_header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: 8px;
			margin: 0px 6px 5px;
		}

		.spd_header_left {
			display: flex;
			align-items: center;
			gap: 8px;
			font-weight: 400;
			color: var(--muted);

			&>button:hover {
				color: var(--button-hover-border-color);
				background-color: var(--button-hover-bground-color);
			}
		}

		/* small +/- buttons */
		.spd_small_btn {
			display: inline-grid;
			place-items: center;
			width: 30px;
			height: 28px;
			border-radius: 6px;
			border: 1px solid var(--border);
			background: #fff;
			cursor: pointer;
			line-height: 1;

			&:active {
				transform: translateY(1px);
			}
		}

		.spd_currentSpdLabel {
			font-weight: 700;
			min-width: 48px;
			text-align: right;
			color: var(--text);
		}

		/* track */
		.spd_track-wrap {
			position: relative;
			padding: 10px 8px 6px;
		}

		.spd_track {
			position: relative;
			height: 6px;
			background: var(--track);
			border-radius: 999px;
			overflow: visible;
		}

		.spd_fill {
			position: absolute;
			left: 0;
			top: 0;
			bottom: 0;
			width: 0%;
			background: var(--track-active);
			border-radius: 999px;
			transition: width 220ms cubic-bezier(0.2, 0.9, 0.2, 1);
		}

		.spd_handle {
			position: absolute;
			top: 50%;
			transform: translate(-50%, -50%) scale(1);
			width: 18px;
			height: 18px;
			border-radius: 50%;
			border: 1.5px solid #fff; /* make 2nd outermost white circle */
			box-shadow: 0px 0px 0px 1px darkorange; /* make the outermost circle */
			background: var(--handle);
			cursor: grab;
			touch-action: none;
			transition: left 220ms cubic-bezier(0.2, 0.9, 0.2, 1), transform 120ms ease;

			/* click effect */
			&.shrink {
				transform: translate(-50%, -50%) scale(0.88);
			}
		}

		/* ticks & labels */
		.spd_ticks {
			position: relative;
			margin-top: 8px;
			height: 40px;

			
		}

		.spd_tick {
			position: absolute;
			width: 2px;
			top: 0;
			transform: translateX(-50%);
			background: var(--tick);
			transition: height 160ms, background-color 160ms;

			/* format the tick differently for active tick */
			&[data-active="true"]{
				background: darkorange;
				width: 2.5px;
				transform: translateX(-50%) translateY(-2px) scaleY(1.2);
			}
		}

		.spd_tick-small {
			height: 8px;
		}

		.spd_tick-medium {
			height: 18px;
		}

		.spd_tick-large {
			height: 22px;
			background: var(--tick-large);
		}

		.spd_tick-one {
			height: 22px;
			background: var(--tick-one);
			width: 2.5px;
		}

		.spd_tick-fav {
			height: 13px;
			background: #888;
		}

		/* mốc 1.0 */

		.spd_tick-label {
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial,
				sans-serif;
			position: absolute;
			top: 24px;
			transform: translateX(-50%);
			font-size: 0.9rem;
			color: var(--muted);
			padding: 0 4px;
			border-radius: 4px;
			cursor: pointer;
			transition: transform 180ms, color 180ms, background 180ms;
			user-select: none;

			&[data-active="true"] {
				font-weight: 700;
				color: var(--active-color); /* var(--text); */
				background: #f6f6f6;
				border: 1px solid var(--border);
				transform: translateX(-50%) translateY(-3px) scale(1.02);
			}
		}

		.spd_tick-maxSpeedSel{
			appearance: none;
			background: transparent;
			text-align: center;
			border: 1px solid #aaa;
		}

		/* responsive small screens */
		@media (max-width: 520px) {
			.spd_popup {
				width: calc(100vw - 16px);

				& .spd_tick-label{
					font-size: 0.8em;
				}
			}
		}

		/* ------------HANDLING RESPONSIVE--------------- */
		@media(max-width:680px) {
			.ap-container {
				/* min-width: 400px; */
				width: 100%;

				height: auto;
				/* background-color: transparent; */
				/* border: none; */
			}

			.ap-panel {
				-webkit-flex-wrap: wrap;
				-ms-flex-wrap: wrap;
				flex-wrap: wrap;
				justify-content: space-evenly;
				height: auto;
			}

			.ap--track {
				margin-bottom: 10px;
				/* padding-left and right would make the audio playback position tooltip not precisely show */
				padding: 8px 10px;
				margin: 0;
				/* background-color: #ddd; */
				/* #56AEFF #B1D4E0*/
				border-radius: 10px;
				-webkit-box-ordinal-group: 2;
				-webkit-order: 1;
				-ms-flex-order: 1;
				order: 1;
				-webkit-box-flex: 1;
				-webkit-flex: 1 1 100%;
				-ms-flex: 1 1 100%;
				flex: 1 1 100%;				
			}

			.ap--playback {
				/* Only .ap--playback take extra space, .ap--settings keeps flex-grow=0 so take no extra space */
				-webkit-box-flex: 1;
				-webkit-flex: 1 1 70%;
				-ms-flex: 1 1 70%;
				flex: 1 1 70%;
				-webkit-box-ordinal-group: 3;
				-webkit-order: 2;
				-ms-flex-order: 2;
				order: 2;
			}

			.ap--settings {
				-webkit-box-ordinal-group: 4;
				-webkit-order: 3;
				-ms-flex-order: 3;
				order: 3;
			}

			.ap--playback>.ap-controls {
				-webkit-box-flex: 1;
				-webkit-flex: 1;
				/* 25% */
				-ms-flex: 1;
				/* 25% */
				flex: 1;
				/* 25% */
			}

			/* .ap-title,
			.ap-time {
				display: none;
			} */
		}
		/* @media(max-width:450px) {
		.ap-panel {
			flex-direction: row;
			justify-content: space-evenly;
			height: auto;
		}
		} */

		/** class to control the appearance of play/pause buttons' svg sprite icon stored in symbol#icnSvgPlayPauseProgress sprite, which control two states: 
			audioState = paused/playing: which depends on audio is paused (default) or playing (controled by class .isPPP-play)
			borderType = progress/plain: which depends on showing (default) or hiding (controled by class .isPPP-noProgress) circle progress
		*/
		symbol#icnSvgPlayPauseProgress{
			/* Old version, this property would be put in 'stroke-dashoffset' attribute of #svgProgressCircleBar component of #icnSvgPlayPauseProgress sprite icon. Now, I update directly to 'stroke-dashoffset' attribute of that component, so this css var not need anymore */
			/* --current-progress: 383.3; */

			/* stroke-dashoffset to show effect of percentage of current playing */
			--progress-background-color: #8f8f8f;
			/* remained color: #abef83 rgb(135, 243, 102)*/
			--progress-bar-color: #21ff15;
			/* Even the name, this control the width of circle progress that circlely circumferences the play/pause button */
			--progress-bar-width: 13;

			/* default state is audio paused, then default icon is the triangle (play icon) */
			& > g[name="playpauseIcon"]{
				/* & > [name="svgPlayIcon"]{ 
					stroke: currentColor;
				} */
				/* hide the pause icon, show play icon */
				& > [name="svgPauseIcon"]{ 
					display: none;
					/* stroke: currentColor; */
				}
			}

			/* default borderType is border WITH circle progress */
			& > g[name="svgIsPPP-Border"]{
				/* default icon is the triangle */
				& > [name="svgProgressCircleBackground"]{ stroke: var(--progress-background-color);}
				& > #svgProgressCircleBar{
					/* stroke: var(--progress-bar-color); */
					transition: stroke-dashoffset .5s linear;
					/* display: unset; */
				}
			}

			/* if audio state is playing, then the icon switch to two parallel bars (which is pause icon) */
			&.isPPP-play > g[name="playpauseIcon"]{				
				& > [name="svgPlayIcon"]{ display: none;}
				/* show the pause icon */
				& > [name="svgPauseIcon"]{ display: unset;}
			}

			/* if borderType if no circle progress */
			&.isPPP-noProgress > g[name="svgIsPPP-Border"]{
				/* the background border */
				& > [name="svgProgressCircleBackground"]{
					stroke: currentColor;					
				}				
				/* hide circle progress bar */
				& > #svgProgressCircleBar{
					display: none;
				}
			}

			/* when audio is paused AND circle progress is shown, make the circle a bit thicker so it look similar when pause icon is shown */
			&:not(.isPPP-play){
				--progress-bar-width: 16;
				/* when no progress circle, make the border less thicker than when there is */
				&.isPPP-noProgress{
					--progress-bar-width: 14;
				}
			}

			/* is both audio state is playing AND border type is no circle progress, make the background border with different color */
			&.isPPP-play.isPPP-noProgress > g[name="svgIsPPP-Border"] > [name="svgProgressCircleBackground"]{
				stroke: var(--progress-background-color);
			}
		}
	</style>

	<!-- Format ol, li of Playlist and popup book group list-->
	<style>
		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) {
			max-height: 450px;
			list-style: none;
			overflow-y: auto;
			/*overlay*/
			overflow-x: hidden;
			/*list-style: decimal-leading-zero;*/
			padding-left: 40px;
			/* to reserve space for li::before which show chapter order UI */
			border: 1px solid #bdbec0;
			border-radius: 10px;
			margin: 0px; /* to prevent margin-block-start, margin-block-end default is 1em = 17px */
			/* format the size and color of the CSS background */
			/* --__s: 240px;
			--__c: #b5c7f520; */
		}

		/* for some stupid reason, without following 'content-visibility: auto' rule, on iPad/iPhone the SDD avatar for .sdd-wrapper-chapterList elements (which right above ol#elmPlaylist) color acting very weid. But with this 'content-visibility' rule, the 'counter(list-item)' which show the ordinal number (in ::before pseudo element) before each chapter in ol#elmPlaylist got reset every new section */
		@media (hover: none) and (pointer: coarse){
			ol#elmPlaylist{
				/* Using content-visibility to speed-up performance, adapt from https://css-tricks.com/almanac/properties/c/content-visibility/ */
				content-visibility: auto;
				contain-intrinsic-size: 5005px; 
			}
		}

		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li {
			text-align: left;
			/* font-size: 16px; */
			color: #4F4F4F;
			position: relative;
			line-height: 21px;

			padding: 10px 0px 5px 7px;
			border-bottom: 1px solid #730a50c4;
			cursor: pointer;
			transition: color 0.4s;

			&:hover {
				background: linear-gradient(to right, rgba(255, 138, 0, 0.2), #fff) !important;
				/* background-color: #d8e08457; */
				transform: translate(0.5%, 0px);
				/* scale(1.05) translate(3%, 0px) */
				box-shadow: 2px 2px 15px 4px rgba(51, 51, 51, 0.18);

				&::before {
					background-color: #f1a25a38 !important;
				}
			}

			&::before {
				/* counter-increment: list-item; */
				content: counter(list-item);
				/* counter(list-item, decimal-leading-zero) to have leading 0 */
				color: black;
				font-size: var(--playlist-item-title-font-size);
				font-weight: 700;
				display: flex;
				height: 32px;
				width: 32px;
				border-radius: 50%;
				border: 1.5px solid #454545;
				background: #afafaf54;
				justify-content: center;
				align-items: center;
				position: absolute;
				top: 2px;
				left: -36px;
			}

			/* When the li ordernal number is too big (more than 2 digits), we need to make its font-size smaller so it fit inside the circle */
			&.threeDigitOrdernalNo::before {
				font-size: .9em;
			}
			&.fourDigitOrdernalNo::before {
				font-size: .8em;
			}

			&.beingPlay {
				/* mark that a chapter being played or a book set/kit just being drag in setting */
				background: linear-gradient(to right, rgba(156, 39, 176, 0.2), #fff0) !important;
				box-shadow: 2px 2px 15px 7px rgb(241 180 180 / 27%);

				&::before {
					border-color: #d52323;
					background: rgba(156, 39, 176, 0.25);
				}
			}

			/* Format the chapter titles in the list */
			&>span {
				color: #4F4F4F;
				font-size: var(--playlist-item-title-font-size);
				line-height: .8em;
			}

			/* Format the duration wrap in <code> tag */
			&>code {
				font-size: 0.9em;
			}
			/* mark elements that will be right-align from item to item */
			& [data-rAlignGroup]{
				display: inline-block;
				text-align: right;
			}
		}

		/* customize for even li */
		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li:nth-of-type(even) {
			background: linear-gradient(to left, rgba(138, 138, 138, 0.2), #fff);

			&:before {
				border-color: #2378D5;
				background: #2378d547;
			}

			/* Format the chapter titles in the list */
			&>span {
				color: #2378D5;
			}
		}

		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li:first-of-type {
			border-top: 1px solid #730a50c4;
		}

		ol.lstBookTitlesSetting>li:has(> input[type="checkbox"]:not(:checked)) {

			/* li that has unchecked chkbox, paint it gray */
			&>span,
			&>code {
				color: #639858 !important;
			}

			&::before {
				color: #999 !important;
			}
		}

		/* set columns and show/hide transition for details (extra) information for each <li> (which can be a book set or book kit) of ol.lstBookTitlesSetting */
		ol#lstBookTitlesSetting.lstBookTitlesSetting > li div.detailBookNames{
			padding: 3px 0px;
            text-align: justify;
            -moz-columns: 2 330px;
            -webkit-columns: 2 330px;
            columns: 2 330px;
			column-rule: thin dotted blue;

			opacity: 1;
			display: block;
			transition: opacity .75s ease-in, display .75s allow-discrete;

			/* class to hide .detailBookNames */
			&.hide-details{
				opacity: 0;
				display: none;
			}

			/* @starting-style is making entry transitions whenever an element display is set to something different to none. */
			@starting-style {
				opacity: 0;
			}
		}

		/* Chapter group css */
		ol#elmPlaylist:has(section) {
			padding-left: 0px !important;
			/* default #elmPlaylist has no section, so its  padding-left: 40px to reserve space for li::before which show chapter order UI*/
		}

		ol#elmPlaylist>input[type=checkbox] {
			display: none;
		}

		ol#elmPlaylist>input[type=checkbox]+label+section {
			padding-left: 40px !important;
			/* to reserve space for li::before which show chapter order UI. Note that #elmPlaylist that has section set padding-left: 0px */
			max-height: 0;
			max-width: 0;
			/* transform: scaleY(1); */
			opacity: 0;
			overflow: hidden;
			/* white-space:nowrap; */
			-webkit-transition: all .5s ease;
			-moz-transition: all .5s ease;
			-o-transition: all .5s ease;
			transition: all .5s ease;

			/* the label show the summary of current chapters group */
			&>label.chapter-group-summary {
				display: flex;
				align-items: center;
				justify-content: space-evenly;
				padding: 5px 0px;
				margin-left: -40px;
				/* to compensate padding-left: 40px of section */
				color: #f85012;
				pointer-events: none;
				/* save click event bubbling up to elmPlaylist's click handler */
				& > span > code{
					color: #043268;
				}
			}
		}

		ol#elmPlaylist>input[type=checkbox]:checked+label+section {
			max-height: 100%;
			max-width: 100%;
			/* transform: scaleY(1); */
			opacity: 1;
		}

		/* label to define beginning of chapter group. This is for label when its previous sibling checkbox is CHECKED, meaning section expanded and is default style */
		ol#elmPlaylist>input[type=checkbox]+label {
			color: rgb(139, 0, 127);
			margin: 4px auto;
			margin-left: 2px;
			padding: 7px 0px 7px 5px;
			cursor: pointer;
			display: flex;
			/* to display label center horizontally and vertically */
			align-items: center;
			justify-content: center;

			&.is-sticky {
				/* This for sticky label */
				position: -webkit-sticky;
				/* for safari */
				position: sticky;
				z-index: 2;
				top: 0;
				/* the hack for label being partly (0.1px) hidden, so IntersectionObserver triggers action (adding .stickyPinned class) when label being pinned (stickied) at the top */
				background-image: linear-gradient(to right, #e9d8c788 0%, #FFFFFF99 51%, #e9d8c788 100%);
				border: 1.5px solid rgb(144 42 136);
				border-radius: 5px;

			}

			&.stickyPinned {
				/* This is for label when being pinned */

				color: red;
				background-image: linear-gradient(to right, #b7d1e6e9 0%, #eef2f3dd 51%, #b7d1e6cc 100%) !important;
				/* linear-gradient(to right, #9284add1 0%, #fdfdfd 51%, #9284add1 100%) !important
		*/
				border-right-width: 5px !important;

				&::before {
					border-top-color: red;
					/* change color for small triangle */
					rotate: -180deg !important;
					transform: translate(0px, 4px);
				}
			}

			/* format differently for label that its next sibling section contain li chapter that is playing */
			&:has(+ section > li.beingPlay) {
				color: rgb(116 25 196);
				background-image: linear-gradient(to top left, #abb1f3bd, #ffffff2e 80%);
				font-weight: bold;

				&::before {
					border-top-color: rgb(116 25 196);
					/* change color for small triangle */
				}
			}

			/* underline animation effect class */
			&>span>code.underlineAnim {
				/* prepare for label hover effect */
				--bg-h: 2px;
				text-decoration: none;
				/* display: inline; */
				background-image: linear-gradient(to right, slateblue, grey);
				background-position: 0px calc(1em + 4px + var(--bg-h));
				background-repeat: no-repeat;
				background-size: 0% var(--bg-h);
				transition: background-size 0.5s ease-in-out;
				padding-bottom: 3px;
			}

			&:hover {
				color: darkcyan !important;

				/* text-transform: capitalize; uppercase */
				/* font-weight: bold; */
				&::before {
					border-top-color: darkcyan !important;
					/* change color for small triangle */
				}

				/* parent on hover: underline animation effect class */
				&>span>code.underlineAnim {
					/* change background width=100% to make the animation */
					background-size: 100% var(--bg-h);
					background-position-x: left;
				}
			}

			&::before {
				content: '';
				display: inline-block;
				width: 0;
				height: 0;
				border: 5px solid transparent;
				border-width: 10px 5px;
				border-top-color: rgb(139, 0, 127);
				/* these 7 css lines is to make ⏵ */
				margin-left: 4px;

				-webkit-transition: all .5s ease;
				-moz-transition: all .5s ease;
				-o-transition: all .5s ease;
				transition: all .5s ease;
				transform-origin: 25% 50%;
				transform: translate(-5px, calc(50% - 2px));
			}
		}

		@media (pointer: coarse) {

			/* for smart device has (pointer: coarse), the font-size set to 19px, so we need to change background-position so it not go off of the element and user cann't see it */
			ol#elmPlaylist>input[type=checkbox]+label>span>code.underlineAnim {
				--bg-h: 1.5px;
				background-position: 0px calc(1em - 1px);
			}
		}

		/* Customize for section collapsed  */
		ol#elmPlaylist>input[type=checkbox]:not(:checked)+label {
			background-image: linear-gradient(to bottom right, #fdfcfb00, #e2d1c3b3);
			border: 1px solid rgb(139, 0, 127);
			border-left: 5px solid rgb(139, 0, 127);
			border-radius: 5px;
			justify-content: space-between;
			/* to force the triangle in ::before to align left (looks like float:left) and label content align right */
			padding-right: 5px;

			&:has(+ section > li.beingPlay) {
				/* format differently for label that its next sibling section contain li chapter that is playing */
				background-image: linear-gradient(to bottom right, #abb1f3bd, #ffffff2e 80%);
			}

			&::before {
				rotate: -90deg;
				transform: translate(-3px, 4px);
			}
		}

		/* adding playing icon for beingPlay item */
		ol#elmPlaylist li.beingPlay::after {
			/* content: url('data:image/svg+xml,<svg fill="red" viewBox="0 0 10.5 7" xmlns="http://www.w3.org/2000/svg"><rect transform="translate(.5 6) rotate(180) translate(-.5 -6)" x="-.5" y="5" width="1.5" height="2"><animate attributeName="height" dur="1.2s" keyTimes="0;0.5;1" repeatCount="indefinite" values="2;7;2"/> </rect> <rect transform="translate(3.5 4.5) rotate(180) translate(-3.5 -4.5)" x="2.5" y="2" width="1.5" height="5"> <animate attributeName="height" dur="2.8s" keyTimes="0;0.4;0.8;1" repeatCount="indefinite" values="5;1;7;5"/> </rect> <rect transform="translate(6.5 3.5) rotate(180) translate(-6.5 -3.5)" x="5.5" width="1.5" height="7"> <animate attributeName="height" dur="1s" keyTimes="0;0.5;1" repeatCount="indefinite" values="7;0;7"/> </rect> <rect transform="translate(9.5 5) rotate(180) translate(-9.5 -5)" x="8.5" y="3" width="1.5" height="4"> <animate attributeName="height" dur="4.7s" keyTimes="0;0.5;1" repeatCount="indefinite" values="2;7;2"/> </rect> </svg>'); 
			width: 18px;
			transform: scaleY(1.3);
			right: 4px;
			bottom: 4px;
			*/
			display: block;
			position: absolute;
			right: 0;
			bottom: 3px;
			/* vertically center the playing bars
			top: 50%;
			transform: translateY(-50%); */

			/* bar jumping css adapt from https://css-loaders.com/bars/ */
			content: "";
			height: 20px;
			aspect-ratio: 1.1; /* fix ratio width/height */
			--c: no-repeat linear-gradient(#f50 0 0, #f50 50% 50%, #800 100% 100%);
			background:
				var(--c) 0%   100%,
				var(--c) 28.6%  100%,
				var(--c) 57.2% 100%,
				var(--c) 85.8% 100%;
			animation: jumping-bars-kf 1.8s linear alternate infinite;
		}

		@keyframes jumping-bars-kf {
			/* 16% is the width of each bar, can put in css var such as va(--bw) (bar width) */
			0%  {background-size: 16% 60% ,16% 80% ,16% 10% ,16% 30% }
			20% {background-size: 16% 100%,16% 10% ,16% 50% ,16% 70% }
			40% {background-size: 16% 30% ,16% 60% ,16% 100%,16% 10% }
			60% {background-size: 16% 80% ,16% 100%,16% 60% ,16% 60% }
			80% {background-size: 16% 20% ,16% 80% ,16% 40% ,16% 100%}
			100%{background-size: 16% 100%,16% 30% ,16% 80% ,16% 50% }
		}

		ol#lstJsFileDataSetting {
			/* responsive on screen height */
			max-height: min(calc(80dvh - 160px), 600px) !important;			
		}
		ol#lstJsFileDataSetting > li {
			padding: 3px 5px 0px 0px;
			counter-reset: bookKitListCounter;
			/* div contains the file/variable name and checkbox to load/not load the data file */
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile]){
				display: flex;
				flex-flow: row nowrap;
				justify-content: stretch;
				/* margin-right: 5px; */
				padding: 5px;
				border: 1px solid #ae7676;
				border-radius: 5px;

				--illustrated-bgrnd-color: #f5c7c7aa;
				background-image: linear-gradient(to right, transparent 30%, var(--illustrated-bgrnd-color) 100%), 
				repeating-linear-gradient(-40deg,#fffc 0 25px,#f4f4f4cc 0 50px);

				& > :first-child{ /* details element */
					flex-grow: 1;
					font-weight: bold;
					color: darkblue;
					margin: 0px; /* overwrite default */
					& > summary {padding-top: 0px} /* overwrite default */
					& > summary > span::before {
						transform: translateX(2px); /* Vertically centered the small triangle */
						border-left-color: darkblue /* overwrite default color of details small triagle */
					}
				}
				& > :last-child{
					flex-grow: 0;
					text-align: right; /* so checkbox would be align right */
					align-self: center;
				} 

				& + div.detailContent{
					padding: 3px 0px;
					text-align: justify;
					-moz-columns	: 2 330px;
					-webkit-columns	: 2 330px;
					columns			: 2 330px;
					column-rule: thin dotted blue;
					/* -webkit-column-break-inside: avoid;
					page-break-inside: avoid;
					break-inside: avoid; */

					/* This using max-height, in stead of opacity and display, to do animation */
					max-height: 0;
					/* the following two to overide the setting for common div.detailContent (using in #elmChapterInfor and #elmBookInfo) set at the beggining of stylesheet */
					display: block; 
					opacity: 1;

					transition: max-height .75s ease; /* , display .75s allow-discrete */

					& > h2 {
						text-align: center;
						margin: 5px 0px;
						column-span: all;
					}
				}

				/* remove the column-rule when .detailContent collapsed to avoid part of the rule stays visible on iOS (even when .detailContent collapsed) */
				&:has(details:not([open]))+div.detailContent{
					column-rule: none;
				}

				&:has(details[open])+div.detailContent{
					max-height: 2000px; /* Expand the content */					

					/* ISSUE: If we add @starting-style here, the .detailContent will not expanded in iOS */
					/* @starting-style {
						max-height: 0;
					} */
				}
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="0"]){ /* state-val==0 */
				border-color: #363636;
				--illustrated-bgrnd-color: #909090aa;
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="1"]){ /* state-val==1 */
				border-color: #653302;
				--illustrated-bgrnd-color: #f49b43aa;
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="2"]){ /* state-val==2 */
				border-color: #093a56;
				--illustrated-bgrnd-color: #95ceefaa;
			}
		}

		/* format list of book sets and book names that display on ol#lstJsFileDataSetting and ol.lstBookTitlesSetting */
		:is(ol#lstJsFileDataSetting, ol.lstBookTitlesSetting) > li {
			& p.dbFileBookList{
				counter-reset: dbBookListCounter;
				counter-increment: bookKitListCounter;
				margin: 2px 0 0 0;
				/* for the psuedo ::after absolute position to take effect */
				position: relative;
				/* seperator lines between book sets */
				&:not(:last-of-type){
					border-image: linear-gradient(to right, #c9b7e6, #af90a4) 1 / 0 0 1px 0;
					padding-bottom: 5px;
				}
				/* ordinal number for book set */
				&:before {
					counter-increment: section;
					content: counter(bookKitListCounter, upper-roman) ". ";
					color: darkorchid;
					font-weight: bold;
				}
				/* add a rectangle to mark the end of list book names of a book set (like at the end of a scient theorem proof) */
				&::after {
					content: "▩";
					font-size: 0.8em;
					color: darkorchid;
					position: absolute;
					bottom: 0px;
					right: 2px;
				}
				&:only-of-type::before{content: "▣ "} /* ▲ ▧ ▩ */
				/* format for book names */
				& > code{
					counter-increment: dbBookListCounter;
					word-spacing: -0.15em;
					display: inline;
					font-size: .9em;
					/* ordinal number for book name */
					&::before{
						content: " ∵\2005" counter(dbBookListCounter) ". ";
						color: darkorchid;
						font-size: .9em;
					}
					/* format color for alternating book names */
					&:nth-of-type(odd){color: #9f5c28}
					&:nth-of-type(even){color: #272782}
					&:only-of-type::before{content: " ∴ "}
				}
			}

			& input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile] {
				&:checked + label::before {
					content: "Fresh Load";
				}

				&:not(:checked) + label::before {
					content: "No show";
				}

				/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
				&:indeterminate + label::before {
					content: "Cache Load";
				}
			}
		}

		/* fieldset in DBFile tab to show statistics for whole DBs and status of DB checking for update */
		fieldset:has( > div[name="DBStatistics"]){
			padding:1px;
			display: flex;
			flex-direction: column;
			justify-content: space-evenly;
			& > div[name="DBStatistics"] > dfn{
				font-size:.85em;
				font-weight:400;
			}
		}

		/*       ScrollBar         */
		.niceScrollBar{
			/* to prevent below document to scroll when content of setting scroll reach to top or bottom. See https://getcssscan.com/blog/prevent-page-scrolling-while-scrolling-div-element for more */
			&:not(ol#elmPlaylist){ /* not apply for elmPlaylist */
				overscroll-behavior: contain;
			}

			&::-webkit-scrollbar {
				width: 10px;
			}

			&::-webkit-scrollbar-track {
				border-radius: 8px;
				background-color: #e7e7e7;
				border: 1px solid #cacaca;
			}

			&::-webkit-scrollbar-thumb {
				border-radius: 8px;
				border: 3px solid transparent;
				background-clip: content-box;
				background-color: #a3b3bd; /* #d55959; */
			}
		}

		/* End of Playlist*/

		/* Container that contains checkboxes for book Kit that has more than 1 book sets, so that user can show/hide multiple book sets (that belong to the same book kit) at the same time */
		div[name="bookKitChkboxContainer"]{
			justify-content: space-evenly;
			max-height: 5em;
			overflow: hidden auto;
			/* format differently for 3-state checkbox */
			& input[type="checkbox"][role="switch"][attr-BookKit]{
				border-color: blueviolet;
				&:checked::before{
					background: #8d3adb;
				}
			}
		}

		/* Class for changing UI of Book Sets when their parent's Book Kit is hover. See bookSetList() function for more
		For now, maximum two Book Kits having more than one Book Sets (for all group way), if there are more than such two book kit, we can add style for .bookKitNo2-Childs, .bookKitNo3-Childs, ...
		*/
		div[name="bookKitChkboxContainer"] > div[class^="bookKitNo"]{
		/* :is(.bookKitNo0, .bookKitNo1, .bookKitNo2, .bookKitNo3, .bookKitNo4) { */

			/*only to disable context menu on long press*/
			-webkit-tap-highlight-color: #0000;
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none;
		}

		.bookKitNo0:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo0:hover)+ol>li.bookKitNo0-Childs {
			background: linear-gradient(to right, rgb(0 123 255 / 20%), #fff) !important
		}
		.bookKitNo1:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo1:hover)+ol>li.bookKitNo1-Childs {
			background: linear-gradient(to right, rgb(255 226 0 / 20%), #fff) !important
		}
		.bookKitNo2:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo2:hover)+ol>li.bookKitNo2-Childs {
			background: linear-gradient(to right, #d34af933, #fff) !important
		}
		.bookKitNo3:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo3:hover)+ol>li.bookKitNo3-Childs {
			background: linear-gradient(to right, #f9884a33, #fff) !important
		}
		.bookKitNo4:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo4:hover)+ol>li.bookKitNo4-Childs {
			background: linear-gradient(to right, #524af933, #fff) !important
		}

		/* show/hide the togglePlaylistExtraTitles button depending on whether #elmPlaylist li items having extra title div.item-2nd-main-div or not*/
		button[name="togglePlaylistExtraTitles"]{
			/* default none */
			display: none;
		}
		div[name="divContainer"]:has(ol#elmPlaylist li > div.item-2nd-main-div) button[name="togglePlaylistExtraTitles"]{
			/* display only when elmPlaylist extra titles exist */
			display: block;
		}
		/* set color of button to red when extra titles in playlist is hidden */
		div[name="divContainer"]:has(ol#elmPlaylist.hideOptionExtraTitle) button[name="togglePlaylistExtraTitles"]{
			color: red;
		}
	</style>

	<!-- TOAST NOTIFICATION  -->
	<style>
		div[name="toastContainer"] {
			--toastify-toast-offset: 20px;
			--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));
			--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));
			--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));
			--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));

			position: fixed;
			display: flex;

			z-index: 999999;
			pointer-events: none;

			/* TOAST LOCATION */
			/* &[location='manual-Bottom-Left']{} */

			&[location='Bottom-Right'] {
				flex-direction: column-reverse;
				align-items: flex-end;
				/* right align */
				bottom: var(--toastify-toast-bottom);
				right: var(--toastify-toast-right);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-bottom: calc(var(--toastify-toast-bottom)/2);
						;
					}
				}
			}

			&[location='Top-Right'] {
				flex-direction: column;
				align-items: flex-end;
				/* right align */
				top: var(--toastify-toast-top);
				right: var(--toastify-toast-right);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-top: calc(var(--toastify-toast-top)/2);
						;
					}
				}
			}

			&[location='Bottom-Left'] {
				flex-direction: column-reverse;
				align-items: flex-start;
				/* right align */
				bottom: var(--toastify-toast-bottom);
				left: var(--toastify-toast-left);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-bottom: calc(var(--toastify-toast-bottom)/2);
						;
					}
				}
			}

			&[location='Top-Left'] {
				flex-direction: column;
				align-items: flex-start;
				/* right align */
				top: var(--toastify-toast-top);
				left: var(--toastify-toast-left);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-top: calc(var(--toastify-toast-top)/2);
					}
				}
			}
		}

		.toast-element {
			--toast-color-light-bgrnd: #eeed;
			--toast-color-dark-bgrnd: #333b;
			--toast-color-dark-text: #fff;

			--toast-color-info: #3498db;
			--toast-color-info-lightest: #aae3f6;
			/* #2f86eb */
			--toast-color-success: #07bc0c;
			--toast-color-success-lightest: #80d280;
			/* 47d864 */
			--toast-color-warning: #ffc021;
			--toast-color-warning-lightest: #ffdd80;
			/* f1c40f #00b894cc #fdcb6ecc*/
			--toast-color-error: #e74c3c;
			--toast-color-error-lightest: #fd9c9f;
			/* ff623d #bd3d53 */
			--toast-color-promise: #9542fa;
			--toast-color-promise-lightest: #b378fb;

			--toast-border-width: 1.5px;
			--progress-bar-height: calc(var(--toast-border-width) * 2);
			/* --toastify-color-progress-light: linear-gradient(90deg,#4cd964,#5ac8fa,#007aff,#34aadc,#5856d6,#ff2d55);
    		--toastify-color-progress-dark: #bb86fc; */

			/* Set a default minimum and maximum width */
			min-width: 200px;
			max-width: min(calc(100vw - 30px), 750px); /* so that the toast should not be too long */
			display: flex;
			position: relative;
			align-items: center;
			padding: 5px 10px;
			background-color: var(--toast-color-light-bgrnd);
			border: var(--toast-border-width) solid #666;
			border-left: 5px solid;
			border-radius: 5px;
			box-shadow: #666a 5px 5px 25px 0px;
			z-index: 13;
			pointer-events: auto;
			cursor: pointer;
			
			&.toast-manual {
				position: fixed;
				bottom: 0px;
				/* to prepare for transition */
				left: var(--toastify-toast-left);
			}

			&>.toast__icon {
				flex-grow: 0;
				padding: 4px 8px 0px 0px;
				user-select: none;
				display: inline-block;

				&>svg {
					width: 1.25em;
					height: 1.25em;
					fill: currentColor;
				}
			}

			&>.toast__msg {
				flex-grow: 1;
				font-size: 1.15rem;
				color: #eee;
				line-height: 1.5;
			}

			&>.toast-progress {
				position: absolute;
				/* to cover the bottom border of toast */
				bottom: calc(0px - var(--toast-border-width));
				left: -2px;
				width: calc(100% + 2px);
				height: var(--progress-bar-height);
				background-color: #4070f4;
			}
		}

		/* THEME */
		.toast-element.toast-dark-theme {
			background-color: var(--toast-color-dark-bgrnd);
			border-bottom: var(--progress-bar-height) solid black;

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast-progress {
				/* to cover the bottom border of toast */
				bottom: calc(0px - var(--progress-bar-height)) !important;
			}
		}

		.toast-element.toast-color-theme {
			border-color: var(--toast-color-dark-bgrnd) !important;

			&>.toast__icon {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
			}
		}

		.toast-element.toast-mono-theme {
			background-color: var(--toast-color-dark-bgrnd);			

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
				/* vertical middle the message in case message has something taller than normal (like a svg picture). I don't use it because flex cause so much trouble when the message contains mix of text, svg and sometime <br> */
				/* display: flex;
				flex-wrap: wrap;
        		align-items: center; */
				/* to preserve whitespace  */
				white-space: pre-wrap;				

				/* instead of setting display: flex for the toast__msg, which can middle the svg with the text but cause so much issue. I just simply set margin-bottom for svg manually */
				& > svg{
					margin-bottom: -3px;
				}
			}

			&>.toast__icon {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast-progress {
				/* background: var(--toastify-color-progress-light) !important; */
				background-color: var(--toast-color-dark-text) !important;
			}
		}

		@media only screen and (max-width: 450px) {
			.toast-element {
				&>.toast__icon {
					padding: 2px 8px 0px 0px;

					&>svg {
						width: 1.15em;
						height: 1.15em;
					}
				}

				&>.toast__msg {
					font-size: 1rem;
					/* toast text a bit smaller on small screen */
				}
			}
		}

		/* TOAST TYPES */
		.toast-type--Promise {
			color: var(--toast-color-dark-bgrnd);
			border-color: var(--toast-color-promise);
			border-bottom: var(--toast-border-width) solid var(--toast-color-promise) !important;

			&>.toast__icon {
				color: var(--toast-color-dark-bgrnd);

				&>svg {
					width: 1.4em;
					height: 1.4em;
					animation: spin-keyframe 1s linear infinite;
					animation-timing-function: steps(12, jump-none);
				}
			}

			&>.toast__msg {
				color: var(--toast-color-dark-bgrnd);
			}

			&>.toast-progress {
				background-color: var(--toast-color-promise);
			}

			&.toast-dark-theme {
				color: var(--toast-color-dark-text);

				&>.toast__icon {
					color: var(--toast-color-dark-text);
				}
			}

			&.toast-color-theme {
				color: var(--toast-color-dark-text);
				background-color: color-mix(in srgb, var(--toast-color-promise), transparent 10%);

				&>.toast__icon {
					color: var(--toast-color-dark-text);
				}
			}
		}

		.toast-type--Infor {
			border-color: var(--toast-color-info);
			
			&>.toast__icon {
				color: var(--toast-color-info);
			}

			&>.toast__msg {
				color: #043268;
			}

			&>.toast-progress {
				background-color: var(--toast-color-info);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-info), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-info-lightest);
				}
			}
		}

		.toast-type--Success {
			/* background-color:#333c; */
			border-color: var(--toast-color-success);

			&>.toast__icon {
				color: var(--toast-color-success);
			}

			&>.toast__msg {
				color: #026516;
			}

			&>.toast-progress {
				background-color: var(--toast-color-success);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-success), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-success-lightest);
				}
			}
		}

		.toast-type--Warning {
			border-color: var(--toast-color-warning);

			&>.toast__icon {
				color: var(--toast-color-warning);
			}

			&>.toast__msg {
				color: #543d02;
			}

			&>.toast-progress {
				background-color: var(--toast-color-warning);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-warning), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-warning-lightest);
				}
			}
		}

		.toast-type--Error {
			border-color: var(--toast-color-error);

			&>.toast__icon {
				color: var(--toast-color-error);
			}

			&>.toast__msg {
				color: #8a1c04;
			}

			&>.toast-progress {
				background-color: var(--toast-color-error);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-error), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-error-lightest);
				}
			}
		}

		/* keyframe for progress-bar counting-down animation */
		@keyframes progress-keyframe {
			100% {
				width: 0%;
			}
		}

		/* Set for manual mode only */
		@keyframes Toastify__slideManualIn {
			from {
				transform: translateX(calc(-100% - 32px));
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes Toastify__slideManualOut {
			from {
				transform: translateY(0);
			}

			to {
				/* bottom: calc(-100% - 10px) ;  */
				transform: translateY(calc(100vh + 100%));
			}
		}
		/* End of Set for manual mode only */
		
		/* Bounce animation */
		/* Bounce from/to Right */
		@keyframes Toastify__bounceInRight {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			from {
				opacity: 0;
				transform: translate3d(calc(100vw + 100px), 0, 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(-25px, 0, 0);
			}

			75% {
				transform: translate3d(10px, 0, 0);
			}

			90% {
				transform: translate3d(-5px, 0, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutRight {
			20% {
				opacity: 1;
				transform: translate3d(-20px, 0, 0);
			}

			to {
				opacity: 0;
				transform: translate3d(calc(100vw + 100px), 0, 0);
			}
		}

		/* Bounce from/to Left */
		@keyframes Toastify__bounceInLeft {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			0% {
				opacity: 0;
				transform: translate3d(calc(-100vw - 100px), 0, 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(25px, 0, 0);
			}

			75% {
				transform: translate3d(-10px, 0, 0);
			}

			90% {
				transform: translate3d(5px, 0, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutLeft {
			20% {
				opacity: 1;
				transform: translate3d(20px, 0, 0);
			}

			to {
				opacity: 0;
				transform: translate3d(calc(-100vw - 100px), 0, 0);
			}
		}

		/* Bounce from/to bottom */
		@keyframes Toastify__bounceInBottom {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			from {
				opacity: 0;
				transform: translate3d(0, calc(100vh + 100px), 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(0, -20px, 0);
			}

			75% {
				transform: translate3d(0, 10px, 0);
			}

			90% {
				transform: translate3d(0, -5px, 0);
			}

			to {
				transform: translate3d(0, 0, 0);
			}
		}

		@keyframes Toastify__bounceOutBottom {
			20% {
				transform: translate3d(0, calc(0 - 10px), 0);
			}

			40%,
			45% {
				opacity: 1;
				transform: translate3d(0, calc(0 + 20px), 0);
			}

			to {
				opacity: 0;
				transform: translate3d(0, calc(100vh + 100px), 0);
			}
		}

		/* Bounce from/to top */
		@keyframes Toastify__bounceInTop {
			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			0% {
				opacity: 0;
				transform: translate3d(0, calc(-100vh - 100px), 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(0, 25px, 0);
			}

			75% {
				transform: translate3d(0, -10px, 0);
			}

			90% {
				transform: translate3d(0, 5px, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutTop {
			
			20% {
				transform: translate3d(0, calc(0 - 10px), 0);
			}
			40%, 45% {
				opacity: 1;
				transform: translate3d(0, calc(0 + 20px), 0);
			}
			to {
				opacity: 0;
				transform: translate3d(0, calc(-100vh - 100px), 0);
			}		
		}

		/* ——End of Bounce animation—— */

		/* Slide animation */
		/* Slide from/to Right */
		@keyframes Toastify__slideInRight {
			from {
				transform: translateX(calc(100% + 100px));
				opacity: 0;
			}

			to {
				transform: translateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutRight {
			0% {
				transform: translateX(0);
				opacity: 1;
			}
			100% {
				transform: translateX(calc(100% + 100px));
				opacity: 0;
			}
		}

		/* Slide from/to Left */
		@keyframes Toastify__slideInLeft {
			from {
				transform: translateX(-120vw);
				opacity: 0;
			}

			to {
				transform: translateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutLeft {
			0% {
				transform: translateX(0);
				opacity: 1;
			}
			100% {
				transform: translateX(-120vw);
				opacity: 0;
			}
		}

		/* Slide from/to Top */
		@keyframes Toastify__slideInTop {
			0% {
				transform: translateY(-50vh);
				opacity: 0;
			}
			100% {
				transform: translateY(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutTop {
			from {
				transform: translateY(0);
				opacity: 1;
			}

			to {
				transform: translateY(-100vh);
				opacity: 0;
			}
		}

		/* Slide from/to Bottom */
		@keyframes Toastify__slideInBottom {
			0% {
				transform: translateY( calc(100vh + 50px));
				opacity: 0;
			}
			100% {
				transform: translateY(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutBottom {
			from {
				transform: translateY(0);
			}

			to {
				opacity: 0;
				transform: translateY( calc(100vh + 50px));
			}
		}
		/* End of Slide animation */

		/* Elliptic Slide animation */
		/* Elliptic Slide from/to Right */
		@keyframes Toastify__ellipticInRight {
			0% {
				transform: translateX(800px) rotateY(-30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 0;
			}
			100% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: -1800px 50%;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutRight {
			0% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: -1800px 50%;
				opacity: 1;
			}
			100% {
				transform: translateX(1000px) rotateY(-30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Left */
		@keyframes Toastify__ellipticInLeft {
			0% {
			transform: translateX(-800px) rotateY(30deg) scale(0);
			transform-origin: -100% 50%;
			opacity: 0;
		}
		100% {
			transform: translateX(0) rotateY(0) scale(1);
			transform-origin: 1800px 50%;
			opacity: 1;
		}
		}
		@keyframes Toastify__ellipticOutLeft {
			0% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: 2000px 50%;
				opacity: 1;
			}
			100% {
				transform: translateX(-1000px) rotateY(30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Top */
		@keyframes Toastify__ellipticInTop {
			0% {
				transform: translateY(-600px) rotateX(-30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 0;
			}
			100% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% 1400px;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutTop {
			0% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% 1400px;
				opacity: 1;
			}
			100% {
				transform: translateY(-600px) rotateX(-30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Bottom */
		@keyframes Toastify__ellipticInBottom {
			0% {
				transform: translateY(600px) rotateX(30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 0;
			}
			100% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% -1400px;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutBottom {
			0% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% -1400px;
				opacity: 1;
			}
			100% {
				transform: translateY(600px) rotateX(30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 1;
			}
		}
		/* End of Elliptic Slide animation */

		/* FLIP animation */
		@keyframes Toastify__flipInHorz {
			0% {
				transform: rotateX(80deg);
				opacity: 0;
			}
			100% {
				transform: rotateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__flipOutHorz {
			0% {
				transform: rotateX(0);
				opacity: 1;
			}
			100% {
				transform: rotateX(70deg);
				opacity: 0;
			}
		}

		@keyframes Toastify__flipInVert {
			0% {
				transform: rotate3d(1, 1, 0, -80deg);
				opacity: 0;
			}
			100% {
				transform: rotate3d(1, 1, 0, 0deg);
				opacity: 1;
			}
		}
		@keyframes Toastify__flipOutVert {
			0% {
				transform: rotate3d(1, 1, 0, 0deg);
				opacity: 1;
			}
			100% {
				transform: rotate3d(1, 1, 0, -70deg);
				opacity: 0;
			}
		}
		/* END OF FLIP animation */

		/* SLIT animation */
		@keyframes Toastify__slitInHorz {
			0% {
				transform: translateZ(-800px) rotateX(90deg);
				opacity: 0;
			}
			54% {
				transform: translateZ(-160px) rotateX(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(0) rotateX(0);
			}
		}
		@keyframes Toastify__slitOutHorz {
			0% {
				transform: translateZ(0) rotateX(0);
				opacity: 1;
			}
			54% {
				transform: translateZ(-160px) rotateX(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(-800px) rotateX(90deg);
				opacity: 0;
			}
		}

		@keyframes Toastify__slitInVert {
			0% {
				transform: translateZ(-800px) rotateY(90deg);
				opacity: 0;
			}
			54% {
				transform: translateZ(-160px) rotateY(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(0) rotateY(0);
			}
		}
		@keyframes Toastify__slitOutVert {
			0% {
				transform: translateZ(0) rotateY(0);
				opacity: 1;
			}
			54% {
				transform: translateZ(-160px) rotateY(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(-800px) rotateY(90deg);
				opacity: 0;
			}
		}
		/* END OF SLIT animation */

		@keyframes Toastify__zoomIn {
			from {
				opacity: 0;
				transform: scale3d(0.3, 0.3, 0.3);
			}

			to {
				opacity: 1;
			}
		}
		@keyframes Toastify__zoomOut {
			from {
				opacity: 1;
			}

			to {
				opacity: 0;
				transform: scale3d(0.3, 0.3, 0.3);
			}
		}

		@keyframes Toastify__swirlIn {
			0% {
				transform: rotate(-540deg) scale(0);
				opacity: 0;
			}

			100% {
				transform: rotate(0) scale(1);
				opacity: 1;
			}
		}
		@keyframes Toastify__swirlOut {
			0% {
				transform: rotate(0) scale(1);
				opacity: 1;
			}

			100% {
				transform: rotate(-540deg) scale(0);
				opacity: 0;
			}
		}
	</style>

	<!-- small popup css -->
	<style>
		.havingShortPopup {
			display: inline-block;
			position: relative;
		}

		.havingShortPopup .shortPoup {
			
			/* to prevent jump2Chapter popup go outside of screen viewport */
			width: min(500px, calc(100vw - 40px));
			top: 100%;
			left: 50%;
			transform: translateX(var(--data-translateX, -50%));

			background-color: #656565;
			color: #fff;
			text-align: center;
			padding: 5px;
			border: 1px solid gray;
			border-radius: 6px;
			box-shadow: 6px 7px 12px 1px #0007;

			/* Position the tooltip text - see examples below! */
			position: absolute;
			z-index: 5;
			/* must higher than chapter-group-label's z-index */

			visibility: hidden;
			opacity: 0;
			transition: opacity .7s;

			&.shortPoupShow {
				visibility: visible !important;
				opacity: 1;
			}

			&::after {
				content: " ";
				position: absolute;
				bottom: 100%;
				/* At the top of the poup */
				left: var(--data-translateX-pseudo-after, calc(50% - 8px));
				/*  margin-left: -10px; */
				border-width: 8px;
				border-style: solid;
				border-color: transparent transparent #656565 transparent;
			}
	}

		/* .havingShortPopup:not(:hover) .shortPoupShow{
	visibility: hidden !important;
	opacity: 1;
} */
		.shortPoup input:not([type="button"]) {
			width: 10em;
		}

		/* Remove Arrows/Spinners */
		/* Chrome, Safari, Edge, Opera */
		input::-webkit-outer-spin-button,
		input::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		/* Firefox */
		input[type=number] {
			appearance: textfield;
			-moz-appearance: textfield;
		}

		.shortPoup input+span {
			padding-right: 30px;
		}

		.shortPoup>* {
			margin-bottom: 5px;
		}

		.shortPoup>label {
			display: inline-block; /* for margin to work */
			font-size: 0.9em;			
		}

		.shortPoup>label>b {
			font-weight: 400;
			color: #d0f399;
			font-size: 1.1em;
		}

		.shortPoup input:invalid+span.checkInputValidity::after {
			position: absolute;
			content: "✖";
			color: #ff7272;
			font-size: 1.2em;
			padding-left: 5px;
		}

		.shortPoup input:valid+span.checkInputValidity::after {
			position: absolute;
			content: "✓";
			color: #80f9f9;
			font-size: 1.15em;
			padding-left: 5px;
		}

		/* Sleep timer related elements */
		.havingShortPopup > button:has( + #sleepTimerDivPopup){
			&.sleepTimerActive{
				/* color: red !important; */
				animation: sleepTimerActive_colorChange 3s alternate infinite;
				& > svg {
					animation: trembling-kf 1s infinite;
				}
			}
			& + div > input#ipSleepTimer{
				caret-color: var(--select-book-group-color);
				&::placeholder {
					opacity: 0.7;
					color: var(--select-book-group-color); /* #520a7e88; */
				}
			}
		}
		@keyframes sleepTimerActive_colorChange{
			from, 40% {color: red}
			to {color: #c5a91e}
		}
		#elmSleepTimerCountDown{
			font-size: 1.3em;
			color: darkred; /* var(--select-book-group-color); */
			background: beige;
			border-radius: 5px;
    		padding: 0 5px;

			/* set animation for the countdown timer when time reach to under 30 second */
			&.almostReachingEnd{
				animation: timer-blink-kf 2s step-start .3s infinite;
				/* animation for the svg icon right before the countdown */
				svg:has(+ &){
					animation: trembling-kf 1s infinite;
				}
			}			

			/* format for svg right before input box */
			svg:has( + &){
				color: darkred;
			}
		}

		/* .shortPoup .popupCloseButton {
			float: right;
			padding: 2px 4px;
			border: 1px solid gray;
			border-radius: 5px;
			background-color: #ddd;
		}

		.shortPoup .popupCloseButton:hover {
			background-color: #d2f3f3;
		}

		.shortPoup .popupCloseButton::before {
			content: '✕';
		} */

		/* Drag and Drop */
		.activeDragItem {
			/* transform: scaleY(1.2) translateY(-20px); */
			background-color: #666;
			box-shadow: rgba(181, 14, 14, 0.16) 0px 1px 4px, rgb(124, 76, 76) 0px 0px 0px 3px;
		}

		.draggingGhostElem {
			background-color: orange;
			position: absolute;
			opacity: 1 !important;
			border: 2px solid darkblue;
			pointer-events: none;
			list-style-type: none;
			& *{
				opacity: 1 !important;
				color: #000 !important;
				font-weight: bold;
			}

			/* to make the checkbof float right exactly as original li */
			&>input[type="checkbox"] {
				float: right;
				margin-right: 7px;
				font-size: 20px;
				border: 1px solid darkred !important;
			}
		}

		.activeDropItem {
			transform: translateX(50px) scaleX(1.2);
			background-color: #21ff1577 !important;
			box-shadow: rgba(0, 0, 0, 0.16) 0px 1px 4px, rgb(51, 51, 51) 0px 0px 0px 3px;
		}
	</style>

	<!-- SETTING MODAL POPUP -->
	<style>
		/* CSS nền hiển thị Modal */
		.modalPopup .modalPopupOverlay {
			position: fixed;
			top: 0px;
			left: 0px;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.7);
			z-index: 9;
			display: none;
		}

		/* CSS bảng nội dung Modal */
		.modalPopup .modalPopupContentWrapper {
			/* position: absolute;
			display: block; */
			/* This line and next to fit wrapper height to the content */
			overflow: hidden;
			top: 0px; /* 50% */
			/* min(50%, 200px)Use 50% if you want the modal verically middle of screen */
			left: 50%;
			transform: translate(-50%, -50%) scale(0);
			background-color: #fff;
			/* DFDBE5 */
			width: min(90vw, 850px);
			z-index: 10;
			text-align: center;
			padding: 10px;
			box-sizing: border-box;
			border-radius: 20px;
			display: block;
			position: fixed;
			box-shadow: 0px 0px 10px #111;
			transition: all 300ms ease-in-out;
			
			/* format the color and the size for the CSS background set in .circus-background */
			--__s: 45px;
    		--__c: #a088b921;
		}

		@media (max-width: 700px) {
			.modalPopup .modalPopupContentWrapper {
				width: 95vw;
			}
		}

		/* CSS Header bao bọc title & nút tắt Modal */
		.modalPopup .modalHeader {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-top: -10px;
			/* margin-bottom: 10px; */
		}

		/* CSS tieu de của Modal */
		.modalPopupContent #elmHistoryWipeAll {
			display: flex;
			align-items: center;
			width: 34px;

			&+label::after {
				content: "Wipe out all saved data";
			}
		}

		.modalPopupContent #elmHistoryWipeAllButDataCfg+label::after {
			content: "Reset to new DBs cfg above";
		}

		.modalPopupContent #elmCheckDBFilesUpdate+label::after {
			content: "Check new DBs edition";
		}

		.modalPopupContent #chkShowHideAllHistChapDetails + label::after{
			content: "Show/Hide chapers infor";
		}
		.modalPopupContent #chkDisableCircleProgressButton {
			&:checked+label::before {
				content: "Show Play progress";
				color: var(--select-book-group-color);
			}

			&:not(:checked)+label::before {
				content: "Hide Play progress";
			}
		}

		.modalPopupContent #chkHideBufferBar {
			&:checked+label::before {
				content: "Show played, buffer bar";
				color: var(--select-book-group-color);
			}

			&:not(:checked)+label::before {
				content: "Hide played, buffer bar";
			}
		}

		@media (min-width: 800px) {
			.modalPopupContent #chkShowHideAllHistChapDetails + label::after{
				content: "Ẩn/Hiện chi tiết các chương sách";
			}
			.modalPopupContent #elmHistoryWipeAll+label::after {
				content: "Xóa toàn bộ thông tin đã lưu";
			}

			.modalPopupContent #elmHistoryWipeAllButDataCfg+label::after {
				content: "Nạp lại theo cấu hình CSDL mới";
			}

			.modalPopupContent #elmCheckDBFilesUpdate+label::after {
				content: "Kiểm tra phiên bản mới các CSDL";
			}

			.modalPopupContent #chkDisableCircleProgressButton {
				&:checked+label::before {
					content: "Hiện tiến trình trên nút Play";
				}

				&:not(:checked)+label::before {
					content: "Ẩn tiến trình trên nút Play";
				}
			}

			.modalPopupContent #chkHideBufferBar {
				&:checked+label::before {
					content: "Hiện thanh played, buffer";
				}

				&:not(:checked)+label::before {
					content: "Ẩn thanh played, buffer";
				}
			}
		}

		/* CSS nút tắt modal */
		.modalPopup .closeModal {
			position: absolute;
			right: 10px;
			top: 5px;
			width: 34px;
			height: 34px;
			text-align: center;
			padding: 2px;
			cursor: pointer;

			border-radius: 6px;
			background: #eee;
			border: 1px solid #aaa;

			&::before {
				content: ' ';
				background: transparent url("https://uxwing.com/wp-content/themes/uxwing/download/checkmark-cross/remove-icon.svg") 0px 0px / 30px 30px no-repeat !important;
				display: block;
				width: 30px;
				height: 30px;
				text-align: center;
			}

			&:hover {
				background: #ccc;

				&::before {
					filter: invert(14%) sepia(98%) saturate(7458%) hue-rotate(358deg) brightness(91%) contrast(122%);
					transition: filter 150ms ease-out;
				}
			}
		}

		.modalPopupContent .bounding-box {
			border: 1px solid gray;
			border-radius: 10px;
			background-color: #f0f8ff44;
			padding: 5px 0px 2px 0px;
			margin: 5px 0px;
		}

		/* This conflict with tooltip, so it has to be removed
	.modalPopupContent #chkShowBookKit + label{
		&:checked + label::after{
			content: "Book Kit view";
		}
		&:not(:checked) + label::after{
			content: "Book Set view";
		}
		
	}*/

		.modalPopup.activeModalPopup .modalPopupOverlay {
			display: block;
			backdrop-filter: blur(2px);
			-webkit-backdrop-filter: blur(2px);
		}

		/* CSS animation when Modal shown */
		.modalPopup.activeModalPopup .modalPopupContentWrapper {
			/* calc(50vh - 50%) Using dvh to better account for address-bar of iPhone */
			transform: translate(-50%, max(calc(25dvh - 25%), 1px) ) scale(1);
			/* remove the dark border added by browser when the div is forced to have focus in initSettingModal() */
			&:focus{outline: none;}
		}

		.modalPopupContent label[for="selPopupBookGroup"]{
			display: none;
		}
		.modalPopupContent #selPopupBookGroup {
			width: 90%;
			border-width: 2px;
			/* border-color: var(--select-book-group-color); */
			border-color: #000;
			filter: var(--select-book-group-filter);
		}

		@media (min-width: 500px) {
			@media (pointer: fine) {
				/* only show the label for desktop */
				.modalPopupContent label[for="selPopupBookGroup"]{
					display: block;
				}
			}
			.modalPopupContent #selPopupBookGroup {
				width: 20em;
			}
		}

		/* Format ol, li of popup book group list (mostly in setting modal). The others CSS are with ol#elmPlaylist */
		ol.lstBookTitlesSetting {
			/* to prevent margin-block-start, margin-block-end default is 1em = 17px */
			margin: 5px 0px !important;
			/* responsive on screen height */
			max-height: min(calc(80dvh - 100px), 600px) !important;			
		}

		/* Since there are multiple bookKit checkboxes, so make the height of #lstBookTitlesSetting (in Setting modal) shorter to prevent overflow */
		ol#lstBookTitlesSetting {
			/* responsive on screen height */
			max-height: min(calc(80dvh - 130px), 600px) !important;
		}

		ol.lstBookTitlesSetting>li>input[type="checkbox"] {
			float: right;
			margin-right: 7px;
			font-size: 20px;
			border-color: darkred;
			&:checked:before{
				background: #4a51b9; /* #4ab957; */
			}
		}

		/* Format fancy checkbox */
		input[type="checkbox"][role="switch"] {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			position: relative;
			color: inherit;
			font-size: inherit;
			width: 2em;
			height: 1em;
			box-sizing: content-box;
			border: 1px solid;
			border-radius: 1em;
			vertical-align: text-bottom;
			margin: auto;

			&:checked:hover {
				background: color-mix(in srgb, #8bb9ee 60%, CanvasText 10%);
			}

			&:not(:checked):hover {
				background: color-mix(in srgb, GrayText 30%, CanvasText 10%);
			}

			/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
			&:indeterminate:hover {
				background: color-mix(in srgb, GrayText 30%, white 70%);
			}

			&::before {
				content: "";
				position: absolute;
				top: 50%;
				left: 0;
				transform: translate(0, -50%);
				box-sizing: border-box;
				width: 0.7em;
				height: 0.7em;
				margin: 0 0.15em;
				border: 1px solid;
				border-radius: 50%;
				background: currentcolor;
			}

			&:checked::before {
				left: 1em;
				background: #0d8707;
			}

			/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
			&:indeterminate {
				background: transparent;

				&::before {
					border-radius: 20%;
					left: 0.5em;
					background: #b8b8b8;
					scale: 0.9;
					/* make it smaller so it looks same size as circle */
					transform: translate(0, calc(-50% - 0.05em));
				}
			}

			&:disabled {
				opacity: 0.4;
			}
		}

		[name="Toast-Setting"]{
			/* responsive on screen height */
			max-height: min(calc(90dvh - 130px), 600px) !important;
			overflow-y: auto;
		}

		/* Fancy radio buttons */
		.fancyRadioContainer {
			display: flex;
			-webkit-box-align: center;
			flex-wrap: wrap;
			align-items: center;
			justify-content: flex-start;
			/* space-evenly */
			gap: 5px;
			padding: 2px 4px 4px 10px;
			margin-bottom: 5px;

			&>input[type="radio"].fancyRadioHidden {
				margin-right: 8px;
				position: absolute;
				opacity: 0;
				z-index: -1;
			}
		}

		input[type="radio"].fancyRadioHidden+label.fancyRadioLabel {
			font-weight: 300;
			position: relative;
			z-index: 1;
			margin-right: 0.6em;
			padding-left: 1.6em;
			padding-right: 1em;
			line-height: 1.8;
			vertical-align: middle;
			cursor: pointer;
			color: #333;
			/* e91e63 */
			transition: all 0.25s ease 0s;

			&::before {
				content: " ";
				box-sizing: border-box;
				display: block;
				position: absolute;
				top: 0.3em;
				left: 0px;
				width: 1.2em;
				height: 1.2em;
				border: 2px solid rgb(233, 30, 99);
				border-radius: 1em;
				z-index: -1;
				transition: all 0.25s ease 0s;
			}

			&.fancyRadioLabelPurple::before {
				border-color: rgb(148, 30, 233);
			}

			&.fancyRadioLabelBlue::before {
				border-color: rgb(30, 30, 233);
			}

			&.fancyRadioLabelGold::before {
				border-color: rgb(212 122 17);
			}

			&.fancyRadioLabelRandomChoose{
				/* text-decoration: underline;
				border: 1px solid darkred;
        		border-radius: .5em; */

				&::after {
					content: "";
					box-sizing: border-box;
					display: block;
					position: absolute;
					top: 0.5em;
					left: .2em;
					width: 0.8em;
					height: 0.8em;
					/* border: 2px solid darkorange; */
					/* background-color: #938f8f; */
					background: radial-gradient(circle at 67%, #ccc6 0, #666 60%);
					border-radius: 50%;
					z-index: -1;
					animation: spin-keyframe 2s linear infinite;
				}
			}
		}

		input[type="radio"].fancyRadioHidden:checked+label.fancyRadioLabel {
			padding-left: 1em;
			color: rgb(255, 255, 255);

			&::before {
				top: 1px; /* 0.15em */
				width: 100%;
				height: 1.8em;
				background: rgb(233, 30, 99);
			}

			&.fancyRadioLabelPurple::before {
				background: rgb(148, 30, 233);
			}

			&.fancyRadioLabelBlue::before {
				background: rgb(30, 30, 233);
			}

			&.fancyRadioLabelGold::before {
				background: rgb(212 122 17);
			}
		}

		.setting-elm-disabled {
			cursor: not-allowed;
			pointer-events: none;
			background-color: #ddd8d866;
			border-image: linear-gradient(to right, #743ad5, #d53a9d) 1 / 1.5px 0;
		}

		/* Hotkeys user-help using Grid-layout */
		div[name="hotkeysSettingWrapper"]{
			width: 100%;
			max-height: min(calc(100dvh - 70px), 780px) !important;
			overflow: hidden auto;
			
			& > div{ /* without this inner-wrapper div, the scroll-y will not work */
				display: block; /* at default small size, just make it simple block */
			}

			& > div > fieldset{
				display: grid;
				justify-items: start;
				align-items: center;
				grid-template-columns: [hotKey] min-content [description] 1fr;
				grid-auto-flow: row;
				grid-gap: .2em .5em;
				
				@media screen  and (min-width: 800px){
					/* for fieldset that has enough width, make the column displaying keys bigger so it is shown in one line */
					&.lanscape-content{
						grid-template-columns: [hotKey] auto [description] 1fr;
					}
				}

				/* &:not(:last-child){
					margin-bottom: 8px;
				}
 */
				&  *{
					font-size: .9em;
				}
						
				/* common guide spread two columns */
				& > span.commonGuide{
					grid-column: span 2;
					text-align: justify;
					line-height: 1.3;

					border: 1px solid gray;
					border-radius: 10px;
					background-color: #f0f8ff44;
					padding: 2px 5px;
				}
				/* samp - an item of grid contains hotkey code */
				& > samp  {
					grid-column: hotKey;
					grid-row: auto;
					justify-self: end; /* align right */
					align-self: center; /* center to avoid the div stretch */
					text-align: right;
				}
				
				/* hotkey description */
				& > label {
					grid-column: description;
					grid-row: auto;
					padding: .4em;
					border: 0;
					text-align: left;
				}

				/* hotkey decoration */
				& kbd/* :not(:has(> kbd)) */  {
					/* font-family: monospace; */
					background-color: #eee;
					border-radius: 3px;
					border: 1px solid #b4b4b4;
					box-shadow:
						0 1px 1px rgba(0, 0, 0, 0.2),
						0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
					color: #333;
					display: inline-block;
					margin-bottom: 3px;
					
					font-size: 0.95em;
					font-weight: 700;
					line-height: 1.2;
					padding: 2px 4px;

					white-space: nowrap; /* to avoid text is broken into lines */
					
					/* using different color for keys that having ignoreModifier=true in its shortcut */
					&.ignoreModifierKeys{
						color: var(--select-book-group-color);
					}
				}

				& > div[name="coryright"]{
					grid-column: span 2;
					text-align:left;
					display: flex;
					flex-flow: row nowrap;
					align-items: center;
					/* margin: -17px 0 -6px 0; */
					font-size: 1.1rem;
					& > [name="authorName"]{
						display: inline-block;
						line-height: 1.3em;
						height:1em;
						overflow: hidden;
						&::after {
							content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁\A🅑🅈 🄲🄷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🄷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🆃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷ🅨 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ Ⓒ🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽ🅸🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾ🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃ🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽ🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋ🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋⓉ🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋⓉⓇ";
							font-size: 1rem;
							white-space: pre;
							display: inline-block;
							animation: l39-1 4.5s infinite steps(20) alternate, l39-2 3s infinite alternate;
						}
					}
				}
			}
		}
		@media (pointer: fine) {
			/* On desktop, change the height for the animation look right */
			div[name="authorName"]{
				line-height: 1.2em !important;
				height:1.2em !important;
			}
		}
		@keyframes l39-1 {
			100%{transform: translateY(-100%)}
		}
		@keyframes l39-2 {
			0% {
				color: #000;
			}
			20% {
				color: blue;
			}
			60% {
				color: red;
			}
			80%{
				color: green;
			} 
			100% {
				color: #000;
			}
		}
		/* @keyframes changeLetters {
			0% {
				color: #000;
				content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁" ;
			}
			20% {
				content: "🅑🅨 🅲🅷🅸🅽🅷🆅🆃🆁" ;
			}
			40% {
				color: red;
				content: "🄱🅈 🅲🅷🅸🅽🅷🆅🆃🆁" ;
			}
			60% {
				content: "🅑🅨 🄲🄷🄸🄽🄷🅅🅃🅁" ;
			}
			80%{
				color: green;
				content: "ⒷⓎ ⒸⒽⒾⓃⒽⓋⓉⓇ"
			} 
			100% {
				color: #000;
				content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁";
			}
		} */
		
		/* for wider screen, applying grid layout to inner-wrapper div to make the effect of two column */
		@media (min-width: 800px) {
			div[name="hotkeysSettingWrapper"] > div{
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    			/* grid-auto-flow: row dense; */
				column-gap: 8px;
				align-items: baseline;

				/* the first fieldset is keyboard of search-dropdown, which is the longest one */
				/* & > fieldset:first-of-type{
					grid-row: span 4; 
					margin-bottom: 0px;
				} */
			}
		}
	</style>

	<!-- Tabs - group -->
	<style>
		/* Adpat from https://codepen.io/hluebbering/pen/PoaWLrw and https://jsbin.com/rebini/3/edit?css,output */
		.tabs-group {
			display: flex;
			flex-wrap: wrap;
			margin: 0px auto;
			width: 100%;

			/* Setting for tab headers */
			&>label {
				--active-tab-header-text-color: #222;
				--active-tab-header-text-hover-color: #945396;
				--inactive-tab-header-text-color: #fff;
				--active-tab-header-bg-color: #93cef8; 
				--inactive-tab-header-bg-color: #699879;
				--svg-shadow-on-hover: #0008;
				/* --active-tab-header-bg-color: #ccc;
				--inactive-tab-header-bg-color: #666; */

				--tab-header-border-color: #fff; /* #ebffd4 */
				--tab-header-border-width: 1px;

				/* the width and the skew degreen of pseudo ::after, ::before of this label element to make the curved -overlapping at left+right of tab header */
				--padd-width: .7em; /* changing this width to modify total tab header width */
				--pad-skew: 13deg;

				background: var(--inactive-tab-header-bg-color);
				color: var(--inactive-tab-header-text-color);				
				cursor: pointer;
				display:inline-block;
				position:relative;
				order: initial;

				margin:0 .3rem 0 calc(-4px + var(--padd-width));
				/* padding-right must be large enough so the ::after pseudo not overlap the header content (which is svg icon) */
				padding: .5rem calc(2px + var(--padd-width)/2) .1rem;
				
				border-radius:0.5rem 0.5rem 0 0; /* just to smooth the top edges */
				/* border-top: var(--tab-header-border-width) solid var(--tab-header-border-color); */

				&:first-of-type{
					/* first tab header need to align with left side of tab content */
					margin-left: calc(-1px + var(--padd-width)); /* 1px is tab content border width */
				}

				/* ::before and ::after make left/right curver borders */
				&::before, &::after{
					content:" ";
					position: absolute;
					top:0;
					bottom: 0; /* use this instead of height: 100%; */
					width: var(--padd-width);					
					background-color: inherit; 
					/* border-top: var(--tab-header-border-width) solid var(--tab-header-border-color); */
					z-index: -1; /* so that the curved side is below the tab header's svg icon */
				}
				&::before{
					border-radius: calc(2px + var(--padd-width)/2) 0 0 0;
					transform: skew(calc(0deg - var(--pad-skew)));
					border-left: var(--tab-header-border-width) solid var(--tab-header-border-color);
					left: calc(-2px - var(--padd-width)/2); /* give the LI border ~2px extrusion */
				}
				&::after{
					border-radius: 0 calc(2px + var(--padd-width)/2) 0 0;
					transform: skew(var(--pad-skew));
					right: calc(-2px - var(--padd-width)/2); /* give the LI border ~2px extrusion */
					border-right: var(--tab-header-border-width) solid var(--tab-header-border-color);
					z-index: 1; /* overlap next tab header element. Remove this, the overlap will be at the ::before */
				}

				/* Content of the label */
				& > code {
					position:relative;
					z-index:2; /* to make the svg icon above the label's pseudo :before and :after */

					/* customized tooltip timeout for tab header because those tooltips show short introduce about the function of the tab, so they are usually quite long and need more time for user to read */
					--tooltip-timeout: 6s;

					& > svg{
						/* somehow, with the size of .8em or 1.1em, the svg is not cropped, but with the size of .9em or 1em, it is */
						font-size: 1.1em !important;
					}
				}

				&:hover > code > svg{
					/* filter: drop-shadow(-3px -3px 3px  var(--svg-shadow-on-hover)) drop-shadow(3px -3px 3px  var(--svg-shadow-on-hover)) drop-shadow(-3px 3px 3px  var(--svg-shadow-on-hover)) drop-shadow(3px 3px 3px  var(--svg-shadow-on-hover)); */
					color: var(--svg-shadow-on-hover);
					/* color: color-mix(in srgb, #000 80%, var(--inactive-tab-header-bg-color) 20%); */
				}
				/* speciffically customize to make the icnSvgKeyboard looks more vertically middle */
				&:has(use[href="#icnSvgKeyboard"]){
					padding-top: .35em;
				}
			}			

			&>.tab-content {
				max-height: calc(100dvh - 60px);
				background: var(--active-tab-header-bg-color);
				display: none;
				flex-flow: column nowrap;
				flex-grow: 1;
				padding: 5px;
				width: 100%;

				/* so that all tab content elements is after all tab headers */
				order: 99;

				border: 1px solid #666;
				border-radius: 0px 10px 10px;
			}

			&>input[type="radio"] {
				display: none;
			}
		}

		/* a bit of fun, change the background color of tab header based on the book group ways */
		body:has(#selBookGroup > optgroup > option:nth-of-type(2):checked) .tabs-group > label{
			--active-tab-header-bg-color: #c9c5f2; 
			--inactive-tab-header-bg-color: #945396;
		}		
		body:has(#selBookGroup > optgroup > option:nth-of-type(3):checked) .tabs-group > label{
			--active-tab-header-bg-color: #ccc;
			--inactive-tab-header-bg-color: #666;
		}

		/* Setting tab header for active tab */
		.tabs-group>input[type="radio"]:checked+label {
			background: var(--active-tab-header-bg-color);
			color: var(--active-tab-header-text-color);

			/* overlap prev tab header element */
			&::before{ z-index: 1; }
			/* overlap next tab header */
			/* &::after{ z-index: 1; } */

			/* &:hover > code > svg{
				--svg-shadow-on-hover: #0006;
			} */

			&+.tab-content {
				display: flex;
				flex-flow: column;
			}
		}

		/* @media (min-width: 10em) {
			.tabs-group>.tab-content {
				order: 99;
			}

			.tabs-group>label {
				order: 1;
				margin-right: 0.3rem;
				margin-top: 0;
				width: auto;
			}
		} */
	</style>
	
	<!-- CSS FOR LOADING PAGE -->
	<style>
		/* Adapt from https://css-loaders.com/, especially from 'The filling', 'The Continuous' category */
		#loadingPageWrapper {
			position: fixed;
			top: 0px;
			left: 0px;
			width: 100vw;
			height: 100vh;
			background: white;
			z-index: 15;
			opacity: 1;
			/* make fading-out effect when remove splash screen */
			transition: opacity .5s linear;

			&>div {
				/* height: 20px; */
				width: fit-content;
				position: absolute;
				top: 30%;
				/* top: 0;
				bottom: 0; */
				left: 0;
				right: 0;
				margin: 0px auto;
			}
		}

		/* The bar with a shuttle keep moving back&ford */
		.loader-bar-nonstop{
			width: 100%;
			height: 1.5rem;
			border-radius: 2rem;
			color: #514b82;
			border: .15rem solid;
			position: relative;
			overflow: hidden;
			
			&::before {
				content: "";
				position: absolute;
				margin: 2px;
				width: 14px;
				top: 0;
				bottom: 0;
				left: -20px;
				border-radius: inherit;
				background: currentColor;
				box-shadow: -10px 0 12px 3px currentColor;
				clip-path: polygon(0 5%, 100% 0,100% 100%,0 95%,-30px 50%);
				animation: l14 1s infinite linear;
			}
		}
		@keyframes l14 {
			0% {color: #514b82;}
			20% {color: #ef5d74;}
			40% {color: #f9a74b;}
			60% {color: #60beeb;}
			80% {color: #fbef5a;}
			100% {left: calc(100% + 20px);color: #514b82;}
		}

		/* The Loadin text with waves insides */
		.loading-text-loader {
			width: fit-content;
			font-size: 3em;
			line-height: 1.5;
			/* margin-top: -.3em; */
			/* font-family: system-ui,sans-serif; */
			font-weight: bold;
			/* text-transform: uppercase; */
			color: #0000;
			--wave-color: #008000aa;
			-webkit-text-stroke: 1px #000;
			-webkit-text-stroke-color: var(--select-book-group-color, #000);
			
			background:
				radial-gradient(1.13em at 50% 1.6em, var(--wave-color) 99%,#0000 101%) calc(50% - 1.6em) 0/3.2em 100% text,
				radial-gradient(1.13em at 50% -0.8em,#0000 99%, var(--wave-color) 101%) 50% .8em/3.2em 100% repeat-x  text;
			animation: l9 2s linear infinite;

			&::before {
				content: "Loading";
			}
		}		
		@keyframes l9 {
			to {background-position: calc(50% + 1.6em) 0,calc(50% + 3.2em) .8em}
		}
		
		.loading-text-splash-screen{
			font-size: 3.5em;
			/* text-transform: uppercase; */
			--wave-color: #000b;
			margin-top: -.25em;
			animation: l9 2s linear infinite, l10 2s linear alternate infinite;
		}
		@keyframes l10 {
			0% {-webkit-text-stroke-color: #514b82;}
			20% {-webkit-text-stroke-color: #ef5d74;}
			40% {-webkit-text-stroke-color: #f9a74b;}
			60% {-webkit-text-stroke-color: #60beeb;}
			80% {-webkit-text-stroke-color: #fbef5a;}
			100% {-webkit-text-strokecolor: #514b82;}
		}	

		.circus-background {
			/* Adapt from https://codepen.io/t_afif/pen/bGKKaPq https://freefrontend.com/css-background-patterns/*/
			--__s: 30px;
			--__c: #e2c9b921;
			--_l: #0000 46%, var(--__c) 47% 53%, #0000 54%;
			background: radial-gradient(100% 100% at 100% 100%, var(--_l)) var(--__s) var(--__s), radial-gradient(100% 100% at 0 0, var(--_l)) var(--__s) var(--__s), radial-gradient(100% 100%, #0000 22%, var(--__c) 23% 29%, #0000 30% 34%, var(--__c) 35% 41%, #0000 42%) transparent;
			background-size: calc(var(--__s)* 2) calc(var(--__s)* 2);
			/* background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 304 304' width='304' height='304'%3E%3Cpath fill='%239C92AC' fill-opacity='0.1' d='M44.1 224a5 5 0 1 1 0 2H0v-2h44.1zm160 48a5 5 0 1 1 0 2H82v-2h122.1zm57.8-46a5 5 0 1 1 0-2H304v2h-42.1zm0 16a5 5 0 1 1 0-2H304v2h-42.1zm6.2-114a5 5 0 1 1 0 2h-86.2a5 5 0 1 1 0-2h86.2zm-256-48a5 5 0 1 1 0 2H0v-2h12.1zm185.8 34a5 5 0 1 1 0-2h86.2a5 5 0 1 1 0 2h-86.2zM258 12.1a5 5 0 1 1-2 0V0h2v12.1zm-64 208a5 5 0 1 1-2 0v-54.2a5 5 0 1 1 2 0v54.2zm48-198.2V80h62v2h-64V21.9a5 5 0 1 1 2 0zm16 16V64h46v2h-48V37.9a5 5 0 1 1 2 0zm-128 96V208h16v12.1a5 5 0 1 1-2 0V210h-16v-76.1a5 5 0 1 1 2 0zm-5.9-21.9a5 5 0 1 1 0 2H114v48H85.9a5 5 0 1 1 0-2H112v-48h12.1zm-6.2 130a5 5 0 1 1 0-2H176v-74.1a5 5 0 1 1 2 0V242h-60.1zm-16-64a5 5 0 1 1 0-2H114v48h10.1a5 5 0 1 1 0 2H112v-48h-10.1zM66 284.1a5 5 0 1 1-2 0V274H50v30h-2v-32h18v12.1zM236.1 176a5 5 0 1 1 0 2H226v94h48v32h-2v-30h-48v-98h12.1zm25.8-30a5 5 0 1 1 0-2H274v44.1a5 5 0 1 1-2 0V146h-10.1zm-64 96a5 5 0 1 1 0-2H208v-80h16v-14h-42.1a5 5 0 1 1 0-2H226v18h-16v80h-12.1zm86.2-210a5 5 0 1 1 0 2H272V0h2v32h10.1zM98 101.9V146H53.9a5 5 0 1 1 0-2H96v-42.1a5 5 0 1 1 2 0zM53.9 34a5 5 0 1 1 0-2H80V0h2v34H53.9zm60.1 3.9V66H82v64H69.9a5 5 0 1 1 0-2H80V64h32V37.9a5 5 0 1 1 2 0zM101.9 82a5 5 0 1 1 0-2H128V37.9a5 5 0 1 1 2 0V82h-28.1zm16-64a5 5 0 1 1 0-2H146v44.1a5 5 0 1 1-2 0V18h-26.1zm102.2 270a5 5 0 1 1 0 2H98v14h-2v-16h124.1zM242 149.9V160h16v34h-16v62h48v48h-2v-46h-48v-66h16v-30h-16v-12.1a5 5 0 1 1 2 0zM53.9 18a5 5 0 1 1 0-2H64V2H48V0h18v18H53.9zm112 32a5 5 0 1 1 0-2H192V0h50v2h-48v48h-28.1zm-48-48a5 5 0 0 1-9.8-2h2.07a3 3 0 1 0 5.66 0H178v34h-18V21.9a5 5 0 1 1 2 0V32h14V2h-58.1zm0 96a5 5 0 1 1 0-2H137l32-32h39V21.9a5 5 0 1 1 2 0V66h-40.17l-32 32H117.9zm28.1 90.1a5 5 0 1 1-2 0v-76.51L175.59 80H224V21.9a5 5 0 1 1 2 0V82h-49.59L146 112.41v75.69zm16 32a5 5 0 1 1-2 0v-99.51L184.59 96H300.1a5 5 0 0 1 3.9-3.9v2.07a3 3 0 0 0 0 5.66v2.07a5 5 0 0 1-3.9-3.9H185.41L162 121.41v98.69zm-144-64a5 5 0 1 1-2 0v-3.51l48-48V48h32V0h2v50H66v55.41l-48 48v2.69zM50 53.9v43.51l-48 48V208h26.1a5 5 0 1 1 0 2H0v-65.41l48-48V53.9a5 5 0 1 1 2 0zm-16 16V89.41l-34 34v-2.82l32-32V69.9a5 5 0 1 1 2 0zM12.1 32a5 5 0 1 1 0 2H9.41L0 43.41V40.6L8.59 32h3.51zm265.8 18a5 5 0 1 1 0-2h18.69l7.41-7.41v2.82L297.41 50H277.9zm-16 160a5 5 0 1 1 0-2H288v-71.41l16-16v2.82l-14 14V210h-28.1zm-208 32a5 5 0 1 1 0-2H64v-22.59L40.59 194H21.9a5 5 0 1 1 0-2H41.41L66 216.59V242H53.9zm150.2 14a5 5 0 1 1 0 2H96v-56.6L56.6 162H37.9a5 5 0 1 1 0-2h19.5L98 200.6V256h106.1zm-150.2 2a5 5 0 1 1 0-2H80v-46.59L48.59 178H21.9a5 5 0 1 1 0-2H49.41L82 208.59V258H53.9zM34 39.8v1.61L9.41 66H0v-2h8.59L32 40.59V0h2v39.8zM2 300.1a5 5 0 0 1 3.9 3.9H3.83A3 3 0 0 0 0 302.17V256h18v48h-2v-46H2v42.1zM34 241v63h-2v-62H0v-2h34v1zM17 18H0v-2h16V0h2v18h-1zm273-2h14v2h-16V0h2v16zm-32 273v15h-2v-14h-14v14h-2v-16h18v1zM0 92.1A5.02 5.02 0 0 1 6 97a5 5 0 0 1-6 4.9v-2.07a3 3 0 1 0 0-5.66V92.1zM80 272h2v32h-2v-32zm37.9 32h-2.07a3 3 0 0 0-5.66 0h-2.07a5 5 0 0 1 9.8 0zM5.9 0A5.02 5.02 0 0 1 0 5.9V3.83A3 3 0 0 0 3.83 0H5.9zm294.2 0h2.07A3 3 0 0 0 304 3.83V5.9a5 5 0 0 1-3.9-5.9zm3.9 300.1v2.07a3 3 0 0 0-1.83 1.83h-2.07a5 5 0 0 1 3.9-3.9zM97 100a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-48 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 96a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-144a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM49 36a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM33 68a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 240a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm80-176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm112 176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 180a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 84a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6z'%3E%3C/path%3E%3C/svg%3E"); */
		}

		/* Adapt from https://css-pattern.com/ */
		.radial-background {
			/* https://codepen.io/t_afif/pen/YzaoqVV */
			/* --__s: 30px; 
			--__c: #cbb37d26;
			
			--_g: #0000 83%, var(--__c) 85% 99%,#0000 101%;
			background:
				radial-gradient(27% 29% at right ,var(--_g)) calc(var(--__s)/ 2) var(--__s),
				radial-gradient(27% 29% at left  ,var(--_g)) calc(var(--__s)/-2) var(--__s),
				radial-gradient(29% 27% at top   ,var(--_g)) 0 calc(var(--__s)/ 2),
				radial-gradient(29% 27% at bottom,var(--_g)) 0 calc(var(--__s)/-2)
				transparent;
			background-size: calc(2*var(--__s)) calc(2*var(--__s)); */

			/* --__s: 65px;
			--__c: #ecd0783d;
			--c2: #fff;
			
			--l1:#0000  48%,var(--__c) 0 52%,#0000 0;
			--l2:#0000 1.3%,var(--c2) 0 32%,#0000 0;
			background:
				linear-gradient(-45deg,var(--l2)),
				linear-gradient( 45deg,var(--l1)),
				linear-gradient( 45deg,var(--l2)) calc(var(--__s)/2) calc(var(--__s)/2),
				linear-gradient(-45deg,var(--l1)) var(--c2);
			background-size: calc(2*var(--__s)) var(--__s),var(--__s) var(--__s); */

			/* --__s: 50px;
			--__c: #b2cdd952;
			--c2: #fff;
			
			--_g: calc(2*var(--__s)) calc(2*var(--__s)) 
				radial-gradient(25% 25%,var(--__c) 99%,#0000 101%);
			background:
				0 var(--__s)/var(--_g),var(--__s) 0/var(--_g),
				radial-gradient(50% 50%,var(--c2) 97%,#0000)
				calc(var(--__s)/2) calc(var(--__s)/2)/var(--__s) var(--__s),
				linear-gradient(90deg,var(--__c) 50%,var(--c2) 0) 
				0 0/calc(2*var(--__s)); */

			--__s: 80px; /* control the size*/
			--c1: #fff;
			--__c: #f8994f20; /* #bfb35a33; */

			--_s: calc(2*var(--__s)) calc(2*var(--__s));
			--_g: 35.36% 35.36% at;
			--_c: #0000 66%,var(--__c) 68% 70%,#0000 72%;
			background:
				radial-gradient(var(--_g) 100% 25%,var(--_c)) var(--__s) var(--__s)/var(--_s),
				radial-gradient(var(--_g) 0    75%,var(--_c)) var(--__s) var(--__s)/var(--_s),
				radial-gradient(var(--_g) 100% 25%,var(--_c)) 0 0/var(--_s),
				radial-gradient(var(--_g) 0    75%,var(--_c)) 0 0/var(--_s),
				repeating-conic-gradient(var(--c1) 0 25%,#0000 0 50%) 0 0/var(--_s),
				radial-gradient(var(--_c)) 0 calc(var(--__s)/2)/var(--__s) var(--__s)
				var(--c1);
		}

		/* targeting smart device, the background color need to be a little darker, so its alpha channel value need to be a little bit higher */
		@media (pointer: coarse) and (hover: none){
			.circus-background{ --__c: #e2c9b938; }
			.radial-background {--__c: #f2a06040;}
			.sdd-chapterList-background {--__c: #a7677820;}
		}
	</style>

	<!-- CSS FOR TOOL TIP -->
	<style>
		/* Default tooltip setting (also ) */
		[data-tooltip] {
			--arrow-size: 5px;
			/* the timeout for the tooltip to be automatically disappear after being shown on element::hover. By using a css variable, I can customize timeout for some element that has very long tooltip such as Setting tab headers (which show short introduction about the function of the tab) */
			--tooltip-timeout: 5s;
			position: relative;
			/* z-index: 10; */

			/* Disable context menu on long press on touch screen */
			-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none;
		

			/* Positioning and visibility settings of the tooltip */
			&::before, &::after {
				position: absolute;
				visibility: hidden;
				opacity: 0;
				left: 50%;
				bottom: calc(100% - 5px + var(--arrow-size));
				pointer-events: none;
				transition: 0.2s;
				/* will-change: transform; */
				z-index: 12;
			}

			/* The actual tooltip with a dynamic width */
			&:before {
				content: attr(data-tooltip);
				padding: 10px 18px;
				box-sizing: border-box;
				min-width: 60px;
				max-width: min(500px, calc(100vw - 30px));
				width: max-content;
				width: -moz-max-content;
				border-radius: 6px;
				font-size: 14px;
				/* background-color: #3b4850e6; */
				background: #3b4850e6 linear-gradient(30deg, #3b485070, #3b444b70, #3c525870);
				box-shadow: 0px 0px 10px #0009; /* old: 0px 0px 14px #0009 */
				color: #fff;
				text-align: center;
				white-space: pre-wrap;
				font-weight: 400;
				transform: translate(var(--data-translateX, -50%), calc(0px - var(--arrow-size))) scale(0.5);
			}

			/* Tooltip arrow */
			&:after {
				content: '';
				border-style: solid;
				border-width: var(--arrow-size) var(--arrow-size) 0px var(--arrow-size);
				/* CSS triangle */
				border-color: rgba(55, 64, 70, 0.9) transparent transparent transparent;
				transition-duration: 0s;
				/* If the mouse leaves the element, 
									the transition effects for the 
									tooltip arrow are "turned off" */
				transform-origin: top;
				/* Orientation setting for the
									slide-down effect */
				transform: translateX(-50%) scaleY(0);
			}

			/* Tooltip becomes visible at hover */
			&:hover:before, &:hover:after {
				visibility: visible;
				opacity: 1;
			
				/* my own smart way to do the tooltip-timeout for tooltips to be disapeared after some specific of duration. Here I set 'animation-iteration-count:1' (animation run only 1 time) and most importantly, set 'animation-fill-mode:forward' so that when animation end, it keeps the state of that point of time. The timeout is set in property 'animation-delay' (just right next to 'animation-timing-function') */
				animation: .3s ease-out var(--tooltip-timeout) 1 forwards keyframe-auto-hide-tooltip-timeout;
				/* note that here we have to sacrifice controling the transform because transform for ::before and ::after are differents, so some tooltip animation on hover-again element might not as beautiful as without tooltp-timeout, but this is subtle and hardly see */
			}

			/* element that has attribute [no-auto-hide] would NOT have tootip auto disapear after var(--tooltip-timeout) seconds, its tooltip stay visible until mouse/pointing device moves out of the element */
			&[no-auto-hide]:hover:before, &[no-auto-hide]:hover:after {
				animation: none;
			}

			/* Scales from 0.5 to 1 -> grow effect */
			&:hover:before {
				transition-delay: 0.3s;
				/* transform: translate(-50%, calc(0px - var(--arrow-size))) scale(1); */
				transform: translate(var(--data-translateX, -50%), calc(0px - var(--arrow-size))) scale(1);
			}

			/* Arrow slide down effect only on mouseenter (NOT on mouseleave) */
			&:hover:after {
				transition-delay: 0.5s;
				/* Starting after the grow effect */
				transition-duration: 0.2s;
				transform: translateX(-50%) scaleY(1);
			}
		}

		/* customize tooltip timeout for touch devices */
		@media (pointer: coarse) and (hover:none){
			[data-tooltip]{
				/* for touch device I make the timeout a little bit smaller, so user does not have to click on somewhere else to hide the tooltip */
				--tooltip-timeout: 4s;
			}
		}

		/* tooltip timeout keyframe, which at the end of animation force the tooltip to be hidden out */
		@keyframes keyframe-auto-hide-tooltip-timeout {			
			to{
				visibility: hidden;
				opacity: 0;
				/* display: none; */
			}
		}

		/* That's it for the basic tooltip, which set for TOP tooltip. Below are customization for left, right, bottom tooltips */

		/* LEFT */		
		[data-tooltip-location="left"]{
			/* Tooltip + arrow */
			&:before, &:after {
				left: auto;
				right: calc(100% - 5px + var(--arrow-size));
				bottom: 50%;
			}

			/* Tooltip */
			&:before {
				transform: translate(calc(0px - var(--arrow-size)), 50%) scale(0.5);
			}

			&:hover:before {
				transform: translate(calc(0px - var(--arrow-size)), var(--data-translateY, 50%)) scale(1);
			}

			/* Arrow */
			&:after {
				border-width: var(--arrow-size) 0px var(--arrow-size) var(--arrow-size);
				border-color: transparent transparent transparent rgba(55, 64, 70, 0.9);
				transform-origin: left;
				transform: translateY(50%) scaleX(0);
			}

			&:hover:after {
				transform: translateY(50%) scaleX(1);
			}
		}

		/* RIGHT */
		[data-tooltip-location="right"]{
			&:before, &:after {
				left: calc(100% - 5px + var(--arrow-size));
				bottom: 50%;
			}

			&:before {
				transform: translate(var(--arrow-size), 50%) scale(0.5);
			}

			&:hover:before {
				transform: translate(var(--arrow-size), var(--data-translateY, 50%)) scale(1);
			}

			&:after {
				border-width: var(--arrow-size) var(--arrow-size) var(--arrow-size) 0px;
				border-color: transparent rgba(55, 64, 70, 0.9) transparent transparent;
				transform-origin: right;
				transform: translateY(50%) scaleX(0);
			}

			&:hover:after {
				transform: translateY(50%) scaleX(1);
			}
		}
		
		/* BOTTOM */
		[data-tooltip-location="bottom"]{
			&:before, &:after {
				top: calc(100% - 5px + var(--arrow-size));
				bottom: auto;
			}

			&:before {
				transform: translate(var(--data-translateX, -50%), var(--arrow-size)) scale(0.5);
			}

			&:hover:before {
				/* If there is no --data-translateX, then it will be translate -50% */
				transform: translate(var(--data-translateX, -50%), var(--arrow-size)) scale(1);
			}

			&:after {
				border-width: 0px var(--arrow-size) var(--arrow-size) var(--arrow-size);
				border-color: transparent transparent rgba(55, 64, 70, 0.9) transparent;
				transform-origin: bottom;
			}
		}
	</style>

	<!-- CSS FOR TREE VIEW -->
	<style>
		/* original idea https://codepen.io/axelaredz/pen/WNzPxb */
		div#ListeningHistoryWrapper{
			width: 100%;
			padding-top: 0px;
			max-height: min(calc(100dvh - 70px), 780px) !important;
			overflow: hidden auto;
			text-align: left;
		}
		.treeview {
			/* set the padding-left of all nested ul. This in turn define the location of li content and position of tree lines */
			--ul-padding-left: 20px;
			/* the distance from tree vertical line (which drawed by li::before) to the label content */
			--vertical-lines-indent: calc(var(--ul-padding-left) / 2); /* 20px;  */
			/* the top of tree horizontal line (which drawed by li::after) connecting the vertical line to the border of label content. Note that in li.chapter_li, I set '--horizon-lines-top:50%' for chapter_li only */
			--horizon-lines-top: 25px;
			/* the padding left and right of the li, this need to be used to calculate the horizontal line's width so it match the border of label content. Note: if you change this value, the small triagle of book li (li.parent_li) might not be centered with tree-lines */
			--li-padd-left: 5px;
			/* the padding top of the li */
			--li-padd-top: 5px;
						
			min-height:20px;
			padding:3px;
			margin-bottom: 0px !important;
			border-radius:4px;
			/* box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.5); */
			
			& ul{
				/* set the padding-left of all nested ul (except the outermost ul), so the vertical tree lines would match everything else */
				padding-left: var(--ul-padding-left);
			}
			/* set different padding, margin for outer-most ul */
			& > ul{
				/* The following 2 properties is used to overwrite the default padding (which usually is 1em 1em 1em 2.5em) and margin of ul, which is very wide */
				padding: 0 5px 0px 0;
				margin: 0px;

				/* set color for the label of outer-most li */
				&>li>label {color: #000 !important}
				/*remove the tree lines (both vertical and horizontal) of outer-most li*/
				&>li::before, &>li::after {
					border:0
				}
			}
		}
		
		@media screen and (max-width: 500px) {
			.treeview {
				/* make tree lines shorter on small screen such as iPhone */
				--ul-padding-left: 14px;
			}
		}

		/* common setting for all tree li, mostly for drawing tree lines */
		.treeview li {
			list-style-type:none;
			margin:0;
			padding:var(--li-padd-top) 0 0 var(--li-padd-left);
			position:relative;

			&::before, &::after {
				content:'';
				left:calc(0px - var(--vertical-lines-indent));
				position:absolute;
				right:auto
			}
			/* vertical tree line */
			&::before {
				border-left:1px solid #999;
				height:100%;
				top:0;
				width:1px
			}
			/* has to fix the height of vertical tree line of last li so it make a L corner, not be crossed as + */
			&:last-child::before {
				height: var(--horizon-lines-top)
			}

			/* horizontal tree line which connect vertical tree line to the label content */
			&::after {
				border-top:1px solid #999;
				height:var(--vertical-lines-indent);
				top: var(--horizon-lines-top);
				width: calc(var(--li-padd-left) + var(--vertical-lines-indent))
			}

			/* because li might contain sub-folder ul (which in turn contain li), so we don't put text directly into li, instead, we put in label element */
			& > label {
				border:1px solid #666;
				border-radius:5px;
				display:inline-block;
				padding:3px 8px;
				text-decoration:none;
				font-size: .9em;

				/* these setting NOT for outer-most li>label (the label has attribute [for="outer_listening_history"]) */
				&:not(.treeview  > ul > li > label) > *{
					font-size: inherit;
					/* so that no children of label would take mouse event */
					pointer-events: none;
				}
				& [data-rAlignGroup]{
					display: inline-block;

					&[data-rAlignGroup='listenedTime']{
						/* right-align the dropoff time to make a better-readable visual */
						text-align: right;
					}
				}
			}
			
			/* set different color for title and svg icon */
			&:nth-of-type(odd) > label > :is(span.histTitle, svg.svg-img-infor) {
                color: #272782;
            }
			&:nth-of-type(even) > label > :is(span.histTitle, svg.svg-img-infor) {
                color: #9f5c28;
            }
			/* &:nth-of-type(odd) > label{
				&, & * {
					color: #272782;
				}
			}
			&:nth-of-type(even) > label{
				&, & * {
                color: #9f5c28;
				}
            } */
		}
		

		/* li that contains the uncompleted-listening chapters for a book */
		li.chapter_li{
			/* This line can be removed. Its purpose is to make tree horizontal line for chapter li to be at the middle of the li element (this works because children of .chapter_li does not increase the height of .chapter_li element). This can't be applied to .parent_li because middle of .parent_li is middle of itselft AND its content (which is ul with a bunch of .chapter_li elements) */
			--horizon-lines-top: 50%;

			cursor: pointer;
			/* so the width of li does not 100% even the content is much narrower */
			width: fit-content;

			/* header of li that contains the last listening chapters for a book */
			&.last-playing-chapter > label{
				border:1.5px solid var(--select-book-group-color) !important;
				background: linear-gradient(to left, #ddd, #fff0);
				/* border-right-width: 3px !important; */ /* make a mark on right-side to highlight this chapter is last-playing-chapter. The left-side already has a dot drawed by ::before pseudo element */
			}

			&:hover > label{
				background:#ddd;
				border:1px solid #94a0b4;
				color:#000;			
			}
		}

		/* The little red dot (with little rectangle) marking the last-listening-chapter and little dot on last-listening-book */
		li.chapter_li.last-playing-chapter > label::before, li.parent_li.last-playing-book > label::after {
			/* note that this dot-size affect the function Setting.addListeningHistory() on how identify clicking on li.parent_li>label ::before pseudo to remove a book out of history */
			--dot-size: 6px; /* size of the dot */
			content: "";
			display: block;
			position: absolute;
			top: calc(var(--horizon-lines-top) - var(--dot-size)/2);
			left: calc(6px - var(--dot-size)/2); /* I got 6px by experiment, I still not sure where it come from, but it works perfectly. It might be [label padding-right (8px) + label border width (2px)]/2 */
			width: var(--dot-size);
			height: var(--dot-size);
			border-radius: 50%; /* make the small dot */
			background-color: #f00;
			z-index: 1;
		}
		/* little rectangle at the tail of chapter li. Need to add {li.chapter_li.last-playing-chapter > label::after} to right above CSS  */
		/* li.chapter_li.last-playing-chapter > label::after{
			left: unset;
			right: calc(0.5px - var(--dot-size)/2);
			border-radius: 0;
			top: var(--horizon-lines-top);
		} */
		/* different color for the dot of book li */
		li.parent_li.last-playing-book > label::after{
			background-color: #80f;
		}

		/* li that contain information for a book, this li should contains ul>li for chapters */
		.treeview li.parent_li{
			/* this is used to seperate book to book a bit wilder than chapter to chapter */
			&:has(> ul):not(.treeview > ul > li.parent_li){
				padding-top: calc(1.5*var(--li-padd-top));
				padding-bottom: calc(1.5*var(--li-padd-top));
			}

			&.last-playing-book{
				& > label{
					border:2px solid var(--select-book-group-color) !important;
					background: linear-gradient(to right, #ff8a0033, #fff0);					
				}

				/* li that contain the last listening chapters of current played book */
				& li.last-playing-chapter > label{
					background: linear-gradient(to right, #9c27b033, #fff0) !important;
				}
			}

			& >input[type=checkbox] {
				display: none;		
			}
			& >input[type=checkbox] + label {
				cursor:pointer;

				/* when hover on parent li (one that has ul>li), change UI of all of its children li */
				&:hover, &:hover+ul li > label  {
					background-color:#eee9;
					border:1px solid #333; /* #94a0b4 */
					color:#333;
					/* & * {color:#000;} */
				}

				/* change the color and the width of tree-lines belong to this group */
				&:hover +ul li::before, &:hover +ul li::after{
						border-width: 1.5px;
						border-color: var(--select-book-group-color);
					}

				/* make small-turnable triangle for the label, but not for the outer-most li label */
				&:not([for="outer_listening_history"])::before {
					--triangle-height: 8px;
					--triangle-width: 5px;
					content: '';
					display: inline-block;
					width: 0;
					height: 0;
					border: 5px solid transparent;
					border-width:var(--triangle-height) var(--triangle-width);
					border-top-color: #00588b;
					/* these 7 css lines is to make ⏵ */
					/* margin-left: 4px; */

					/* The next 4 lines is to position the small triangle at the intersection of vertical&horizontal tree lines */
					position: absolute;
					left: calc(var(--triangle-width)/2 + 0.5px - var(--li-padd-left)/2 - var(--vertical-lines-indent)); /* 0.5px is half of tree-line width */
					top: calc(var(--horizon-lines-top) - var(--triangle-height));
					z-index: 1; /* so that the triangle above horizontal line drawed by li::after */

					transition: all .5s ease;
					transform-origin: 25% 50%;
					transform: translate(-5px, calc(50% - 2px));
				}
				/* an square at the intersection connecting the vertical tree-line and the outer-most li's label */
				/* &[for="outer_listening_history"]::after {
					--dot-size: 6px;
					content: "";
					display: block;
					position: absolute;
					/* bottom: calc(0px - var(--dot-size)/2); * /
					left: calc(1px + var(--vertical-lines-indent) + var(--li-padd-left) - var(--dot-size)/2);
					width: var(--dot-size);
					height: var(--dot-size);
					background-color: #a96004;
					z-index: 1;
				} */
				&:hover::before{
					border-top-color: #8d1db9 !important;
				}
			}
			
			/* transition for li>label, li>ul when collapsing/expanding */
			& >input[type=checkbox]:not(:checked) + label{
				/* border: 1.5px solid #ba2ef5; */
				border-left-width: 4px !important; /* make the mark so that user know that this book is collapsed */
				&::before {
					border-top-color: red;
					rotate: -90deg;
					transform: translate(-3px, 3px);
				}
			}
			/* :not(:checked) */
			& >input[type=checkbox] + label + ul{
					/* use max-height to animated the collapse effect. "height: 0" not work with css transitions */
					max-height: 0;
					/* hide the scroll-bar so that the content is hidden when set max-height to 0 */
					overflow: hidden;
					/* max-width: 0; */
					/* opacity: 0; */
					transition: max-height 1s ease;
				}
			& >input[type=checkbox]:checked + label + ul {
				max-height: 5000px; /* 100%; */
				/* max-width: 100%; */
				/* opacity: 1; */
				
			}			
		}
	</style>

	<!-- CSS FOR SEARCH DROPDOWN -->
	<style>
	div[name="sdd-BookTitlesDropdown-container"] { /* Books list container */
	   position: relative;
	   width: min(800px, 95vw);
	   margin: 5px auto;
	}

	div[name="sdd-ChaptersListDropdown-container"] { /* Chapters list container */
	   margin-bottom: 5px;
	}

	/* the root div of the sdd  */
	.sdd-wrapper {
	   --color-black: hsl(0, 0%, 10%);
	   --color-darks: hsl(0, 0%, 20%);
	   --color-darkgreys: hsl(0, 0%, 50%);
	   --color-greys: hsl(0, 0%, 80%);
	   --color-light: hsl(0, 0%, 96%);
	   --color-white: hsl(0, 0%, 100%);
	   --color-blues: hsl(217, 91%, 60%);
	   --color-dark-blues: hsl(217, 91%, 40%); /* #4679cd; */
	   --color-dark-light_yellow: rgba(255, 138, 0, 0.2);
	   --shadow-small: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
		  0 1px 2px 0 rgba(0, 0, 0, 0.06);
	   --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
		  0 2px 4px -1px rgba(0, 0, 0, 0.06);
	   --shadow-large: 7px 8px 15px -3px rgba(0, 0, 0, 0.4), 2px 7px 6px -2px rgba(0, 0, 0, 0.2);
	   --shadow-bottom: 0px 3px 3px 0px #1115;
	   /* -20px 18px 10px -15px #1113, 20px 18px 10px -15px #1113; */
	   
	   position: relative;
	   width: 100%;
	   max-width: min(800px, 100%, 95vw);
	   margin: 0px auto;

	   & * {
		  padding: 0;
		  margin: 0;
		  box-sizing: border-box;
		  text-align: left;
	   }

	   /* this em contain the order of the option and opt-group */
		& em.item-order{
			display: inline-block;
			text-align: right;
			font-style: normal;
			color: darkgoldenrod;
			font-size: .9em;
			margin-right: 3px;
			/* background-color: gainsboro;
			padding: 1px 2px;
			border-radius: .25em; */
		}

		/* This class store item de-emphasize infor */
		& .item-slight-details{
			font-size:.875rem;
			color: var(--select-book-group-color);
		}
	}

	/* the control that always display, even when dropdown closed */
	.sdd-wrapper .sdd-controls {
	   position: relative;
	   /* font-family: inherit;
	   font-size: 1rem;
	   font-weight: 400; */
	   line-height: 1.2;
	   cursor: pointer;
	   user-select: none;
	   width: 100%;
	   height: auto;
	   padding: 0.4rem .5rem;
	   padding-right: 1.7em; /* so the text not overlap the background sized 1.5em */
	   border: 2px solid var(--select-book-group-color);
	   outline: none;
	   border-radius: 0.4rem;
	   color: var(--color-black);
	   background-clip: padding-box;
	   /* background-color: var(--color-white); */
	   box-shadow: var(--shadow-medium);
	   transition: all 0.3s ease-in-out;

	   /* following svg background is actually #icnSvgBooks sprite icon, see svg block at the very end of the page */
	   --sdd-avatar-icon: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='102.4 153.6 870.4 819.2'%3E%3Cpath d='M512 819.2c-23.3 31.1-60.5 51.2-102.4 51.2H179.2a76.8 76.8 0 0 1-76.8-76.8V230.4a76.8 76.8 0 0 1 76.8-76.8h230.4c41.9 0 79.1 20.1 102.4 51.2 23.3-31.1 60.5-51.2 102.4-51.2h230.4a76.8 76.8 0 0 1 76.8 76.8v358.4c0-41.9-20.1-79.1-51.2-102.4v-256a25.6 25.6 0 0 0-25.6-25.6H614.4a76.8 76.8 0 0 0-76.8 76.8v460.8c0 26.8 13.8 50.5 34.7 64.2 6.6 22.7 16.5 43.9 29.2 63.2a127.8 127.8 0 0 1-89.5-50.6M153.6 230.4v563.2a25.6 25.6 0 0 0 25.6 25.6h230.4a76.8 76.8 0 0 0 76.8-76.8V281.6a76.8 76.8 0 0 0-76.8-76.8H179.2a25.6 25.6 0 0 0-25.6 25.6M892.2 824a127.5 127.5 0 0 0 29.4-81.6 25.6 25.6 0 0 1 51.2 0 179.3 179.3 0 0 1-153.6 177.4v27.4a25.6 25.6 0 0 1-51.2 0v-27.4a179.8 179.8 0 0 1-136.3-100.6 178.5 178.5 0 0 1-17.3-76.8 25.6 25.6 0 0 1 51.2 0A127.5 127.5 0 0 0 695 824c23.4 28.3 58.9 46.4 98.5 46.4h.2c39.7 0 75.1-18.1 98.5-46.4M716.8 588.8a76.8 76.8 0 0 1 153.6 0v153.6a76.8 76.8 0 0 1-153.6 0z'/%3E%3C/svg%3E"); /* https://uxwing.com/wp-content/themes/uxwing/download/web-app-development/stack-icon.svg */ /* https://brandeps.com/icon-download/B/Book-open-microphone-icon-vector-01.svg */

	   /* set SDD icon as direct background of .sdd-controls */
	   /* background: var(--sdd-avatar-icon) right 0.25em center / 1.5em no-repeat; */

	   /* set SDD icon as the background of the pseudo ::after so it is to control the icon, such as applying filter to just change the color of icon without effecting other part of SDD */
	   &::after {
		--bg-size: 1.5em;
		content: "";
		background: var(--sdd-avatar-icon) right 0em center / var(--bg-size) no-repeat;
		width: var(--bg-size);
		height: var(--bg-size);
		position: absolute;
		right: .25em;
		top: 50%;
		translate: 0 -50%;        
		filter: var(--select-book-group-filter);		
	  }
	  &:hover::after{
		filter: var(--select-hover-bground-filter);
	  }
	  

	   /* make this Div just one line, its content may be truncated */
	   &.single-line{
		  white-space: nowrap;
		  /* Prevents line breaks */
		  overflow: hidden;
		  /* Hides overflow content */
		  text-overflow: ellipsis;
		  /* Adds ellipsis (...) for overflow text */
	   }
	}

	.sdd-wrapper .sdd-dropdown-wrapper {
	   position: absolute;
	   /* max-height: 0px; */
	   /* opacity: 0; */
	   top: 100%;
	   left: 0;
	   width: 100%;
	   z-index: 20;
	   /* padding-bottom: 2px; */
	   border-radius: 0.25rem;
	   border: 2px solid var(--color-greys);
	   background-color: var(--color-white);
	   box-shadow: var(--shadow-large);
	   /* transition: opacity .6s ease-in-out; */
	}

	/* This div has single role to be the bottom border of SDD, with the purpose to separate SDD with other background elements. Especialy, for SDD chapter list to be seperated from backgroung ol#elmPlaylist */
	
	.sdd-wrapper .sdd-dropdown-border-bottom-stripes {
		height: 5px;
		--__c: var(--select-book-group-color);
		background: linear-gradient(-45deg, var(--__c) 60%, transparent 60%, transparent 75%, var(--__c) 75%) 0px 0px /40px 20px;
		animation: sdd-dbb-stripes 2s linear infinite;
	}
	@keyframes sdd-dbb-stripes {
		from {
			background-position: 40px 0;
		}
		to {
			background-position: 0 0;
		}
	}

	/* Customized class for chapter-list SDD. This class will apply for SDD outermost container .sdd-wrapper. If we need to change the css for any component inside .sdd-wrapper, we specify the query-selector path for that component and put css for that component inside that path */
	.sdd-wrapper.sdd-wrapper-chapterList{

		& .sdd-controls::after{
			background-image: url(https://www.svgrepo.com/download/501591/immersive-reader.svg);
			/* https://www.svgrepo.com/download/501225/immersive-reader.svg */
			/* url('https://uxwing.com/wp-content/themes/uxwing/download/web-app-development/stack-icon.svg'); */
			background-size: 1.3em;
		}
		& .input-wrapper input.sdd-search-box{
			caret-color: var(--select-book-group-color);
			&::placeholder {
				opacity: 0.7;
				color: var(--select-book-group-color); /* #520a7e88; */
			}
		}
		/* customize the sdd-dropdown-content background */
		& .sdd-dropdown-wrapper .sdd-dropdown-content {
			--__s: 240px;
			--__c: #a7677816; /* #f5b5f029 */
			--__c2: transparent;

			--_g: #0000 54%,var(--__c) 54% 57%,#0000 57%; 
			background: 
				radial-gradient(farthest-side at -33.33% 50%,var(--_g)) 0 calc(var(--__s)/2),
				radial-gradient(farthest-side at 50% 133.33%,var(--_g)) calc(var(--__s)/2) 0,
				radial-gradient(farthest-side at 133.33% 50%,var(--_g)),
				radial-gradient(farthest-side at 50% -33.33%,var(--_g)),
				var(--__c2);
			background-size: calc(var(--__s)/4.667) var(--__s),var(--__s) calc(var(--__s)/4.667);

			& .sdd-dropdown-item:nth-of-type(odd){
				color: #7d1f21;
			}
		}		

		/* & .sdd-dropdown-wrapper .sdd-dropdown-item.is-selected::before{
			border-color: #797979;
		} */

		/* & .sdd-dropdown-wrapper .sdd-dropdown-item.is-active.is-selected{
			background: linear-gradient(25deg, var(--sdd-dropdown-item-color-light) 0%, #ccca 70%, var(--color-dark-light_yellow) -10%);
		} */

		/* customize the animation for .sdd-dropdown-border-bottom */

		/* adapt from #4 of https://css-loaders.com/infinity/ */
		/* .sdd-wrapper .sdd-dropdown-border-bottom-arrows {
			height: 5px;
			--__c: var(--select-book-group-color) 0 15px, #0000 0 20px;
			background: repeating-linear-gradient(135deg, var(--__c)) left top, repeating-linear-gradient(45deg, var(--__c)) left bottom;
			background-size: 200% 50%;
			background-repeat: no-repeat;
			animation: sdd-dbb-arrows 35s infinite linear;
		}
		@keyframes sdd-dbb-arrows {
			100% {background-position:top right,bottom right}
		} */

		/* Adapt from #2 of https://css-loaders.com/factory/ */
		& .sdd-dropdown-wrapper .sdd-dropdown-border-bottom {
			--__c: var(--select-book-group-color); /* main color of the dots */
			--__h: 8px; /* height of the div and the dots */
			--__s: 25px; /* the size of the block that each contains one dot */
			--__cw: 65%; /* clip-width: which set the width of the left side which contains square dots */
			
			animation: none; /* reset animation in case other class having animation */
			height: var(--__h);
			box-shadow: 0 2px 0 var(--__c); /* draw the bottom/top border, change to negative to draw top border, change to 0px to remove the border */
			background: linear-gradient(#0fa8a8 0 0) var(--__cw) 100%/3px 100% no-repeat, var(--color-light); /* draw the cross-bar */
			display: grid;
			&::before,
			&::after{
				content: "";
				grid-area: 1/1;
				background: repeating-linear-gradient(90deg, var(--__c) 0 calc(1.5*var(--__h)),#0000 0 100%) 0 0/var(--__s) 100%;
				clip-path: inset(0 calc(100% - var(--__cw)) 0 0);
				animation: sdd-dbb-sc .8s infinite linear;
			}
			&::before{
				background: radial-gradient(circle calc(var(--__h)/2) at calc(var(--__h)/2) 50%, color-mix(in hsl, var(--__c) 40%, #d3cf00) 99%,#0000) 0 0/var(--__s) 100%;
				clip-path: inset(0 0 0 var(--__cw));
			}
		}
	}
	@keyframes sdd-dbb-sc {
		100% {background-position: var(--__s) 0}
	}
	
	@media (pointer:fine) and (hover:hover) {
		/* on desktop screen, make the dots size a bit smaller */
		.sdd-wrapper .sdd-dropdown-border-bottom-factory {
			--__h: 6px;
			--__s: 20px;
		}
	}

	/* wrapper for searchbox and functional buttons */
	.sdd-wrapper .input-wrapper {
		position: relative;
		display: block grid;
		/* 1st column set to minmax(0px, 1fr) instead of 1fr to avoid 2nd column to be blowed out of container. Learn from https://css-tricks.com/preventing-a-grid-blowout/ */
		grid-template-columns: minmax(0px, 1fr) minmax(1rem, max-content);
		background-color: var(--color-light);
		border: 1px solid grey;
		border-radius: 5px;

		/* bottom box shadow */
		box-shadow: var(--shadow-bottom);
		
		div.sdd-control-buttons{
			display: block grid;
			grid-auto-flow: column dense;
			place-items: center end;
			/* display: flex;
			align-items: center;
			justify-content: flex-end; */
			margin: auto 5px;
			
			& > button {
				width: 1.4em;
				height: 1.4em;
				margin-left: 3px;
				appearance: none;
				border: none;
				background-color: transparent;
				
				cursor: pointer;
				color: var(--select-book-group-color);

				&:hover {
					/* color: var(--color-blues) !important;
					background-color: var(--color-greys); */
					border-color: var(--color-blues) !important;
				}
				&:active, &:focus{
					color: var(--color-dark-blues) /* !important */;
					border: 1px solid var(--color-greys);
					outline: none !important;
					box-shadow: none;
				}
				& > svg {
					color: inherit;
					fill: currentColor;
				}

				&.toggle-extra-title-button[attr-extra-title-hidden]{
					color: red;
				}
			}

			& > button.clear-input-button {
				display: none; /* only show when sdd-search-box is valid */
			}
			& > button.close-open-groups-button{
				display: none; /* only show when sdd has optGroup */
			}
			/* only show when sdd option has extra title which is contained in div.item-2nd-main-div element */
			/* & > button.toggle-extra-title-button{
				display: none; 
			} */

			/* button to choose the option between exact search and search with removed diacritics*/
			& > button.search-diacritics-option-button{
		
				display: block grid; /* to center the svg icon insides */
				place-items: center;
				
				padding: .15em;
				border: 2px solid var(--select-book-group-color);
				border-radius: .2em;
				color: darkmagenta;
				background-color: bisque;
				&.search-diacritics-exactSearch{ /* Exact search mode */
					/* border-width: 1px;
					border-color: #999; */
					color: #333;/* var(--select-book-group-color); */
					border-color: #666;
					background-color: unset;
					& > svg{
						filter: blur(.7px) drop-shadow(-1px -1px 4px var(--select-book-group-color)); /* grayscale(1) */
					}
				}
				/* class to mark that SDD search mode is heavySearchMode, which may highlight only first match instead of all matches */
				&.heavySearchMode{
					color: crimson;
				}
			}
		}
	}

	/* close/open groups button only show it dropdown having optgroup */
	.sdd-wrapper:has(div.sdd-dropdown-wrapper > div.sdd-dropdown-content > div.optgroup) .close-open-groups-button{
		display: block;
	}

	/* SERIOUS WARNING: If we show the button this way, it will very very drastically slow down search-performance (when type in the search-input-box) to the point that it might take 20 seconds for each key pressed in.
	show toggle extra titlte button when any SDD option having extra title stored in div.item-2nd-main-div element */
	/* .sdd-wrapper:has(div.sdd-dropdown-wrapper > div.sdd-dropdown-content div.sdd-dropdown-item > div.item-2nd-main-div) .toggle-extra-title-button{
		display: block;
	} */	

	/* Search box */
	.sdd-wrapper .input-wrapper .sdd-search-box {
	   display: block;
	   /* flex: 1 1 auto; */
	   /* width: 100%; */
	   height: auto;
	   line-height: 1.8;
	   font-family: inherit;
	   font-size: 1.1rem !important; /* avoid page zooming when textbox got focus in iOs */
	   font-weight: 400;
	   
	   padding: .2rem 0 .1rem .8rem;
	   /* border-radius: 5px; */
	   caret-color: #d53498; /* var(--select-book-group-color) */
	   border: none;
	   outline: none;
	   color: var(--color-black);
	   background-clip: padding-box;
	   background-color: transparent; /*  var(--color-white); */

	   &:invalid {
		  &+div.sdd-control-buttons > button.clear-input-button {
			display: none;
		  }
	   }

	   &:valid {
		  /* border: 1px solid grey; */
		  &+div.sdd-control-buttons > button.clear-input-button{
			display: block grid;
			align-items: center;
		  }

		  /* Can use following complex css so that button only appear when textbox got focus
		  :is(&:focus, &:hover)+div.sdd-control-buttons > button.clear-input-button,
		  &+div.sdd-control-buttons > button.clear-input-button:is(:hover,:focus) {
			display: inline-block;
			color: darkgreen;
		  } */
	   }
	   
	}

	/* dropdown menu */
	.sdd-wrapper .sdd-dropdown-content {
		max-height: 0rem;
		overflow: hidden scroll;
		transition: max-height .5s ease-in-out;
		/* transition-property: height,max-height; */
		/* position: relative; */ /* so that .sdd-dropdown-status-bar would take this as its offsetParent and being positioned relative to this */
		counter-reset: dropdownItemCounter;

		--sdd-dropdown-item-color-light: color-mix(in srgb, var(--select-book-group-color) , transparent 70%);
		--sdd-dropdown-item-color-extra-light: color-mix(in srgb, var(--select-book-group-color) , transparent 82%);
		/* --sdd-dropdown-item-color-dark: color-mix(in srgb, var(--select-book-group-color) 60%, #181818 40%);
		--sdd-dropdown-item-color-selected: color-mix(in srgb, var(--color-blues) , transparent 40%); */

		&::-webkit-scrollbar {
			width: 5px;
			height: auto;
		}

		&::-webkit-scrollbar-thumb {
			border-radius: 0.25rem;
			background-color: var(--color-blues);
			box-shadow: var(--shadow-small);
		}

		& > .sdd-dropdown-status-bar{
			position: absolute;
			z-index: 5;
			/* display: block; */
			visibility: visible;
			opacity: 1;
			top: 2.65rem;
			right: .1em;
			text-align: center;
			
			background-color: #000a;
			color: white;
			padding: .5em .8em;
			border: 1.5px solid #000;
			border-radius: .5em;
			transition: all .5s ease-in-out;
			&.statusbar-hidden{
				opacity: 0;
				/* display: none; */
				visibility: hidden;
			}
			& > mark{ /* the number of result found */
				color: var(--select-book-group-color);
				font-weight: bold;
				padding: 0px 4px 2px;
			 }
		}
	}

	/* if add .hideOptionExtraTitle to .sdd-wrapper element, all .item-2nd-main-div element inside each dropdown option will be hidden */
	.sdd-wrapper.hideOptionExtraTitle .sdd-dropdown-item > .item-2nd-main-div,
	#elmPlaylist.hideOptionExtraTitle li > .item-2nd-main-div{
		display: none;
	}
	/* dropdown option */
	.sdd-dropdown-content .sdd-dropdown-item {
		position: relative;
		font-family: inherit;
		font-size: 1rem;
		font-weight: normal;
		line-height: inherit;
		cursor: pointer;
		user-select: none;
		padding: .4rem .25rem .4rem 1.25rem;
		color: #5b0a72; /* var(--color-blues) */
		background-color: transparent; /* var(--color-white); */
		/*transition: all 0.2s ease-in-out;*/
		
		&:nth-of-type(even) {
			color: var(--color-black);
			background: linear-gradient(to left, rgba(138, 138, 138, 0.2), transparent);
		}
		counter-increment: dropdownItemCounter;
		
		/* div element that contain extra information such as Author, MC */
		& > .item-2nd-main-div{
			margin-top: 2px;
			font-size: .85em;
			color: #555;

			& span{
				font-size: inherit;
			}

			/* class to force statistics text to be left-aligned even they mostly has data-rAlignGroup attributes which defaultly align right */
			& span.forceTextLeft{
				& > var{
					text-align: left !important;
				}
			}
		}

		/* class to set style for chapter's foreign title, if it has one */
		& > .englishTitle{
			text-align:right;
			padding-right:0.7em;
		}

		&::after{ /* small number at right end of the option */
			content: counter(dropdownItemCounter);
			font-size: .7em;
			position: absolute;
			top: calc(50% - .5em);
        	right: 3px;			
		}
		&:only-of-type:after{
			content: "";
		}

		&.disabled {
			pointer-events: none;
			cursor: default !important;
			background: unset;
			color: var(--color-darkgreys);
			& *{
				color: inherit;
			}
		}

		&:not(:last-child) {
			border-bottom: 1px solid #8080805e;
		}

		& span.highlight {
			background: rgba(255, 237, 40, .4);
			border-radius: 1px;
			text-decoration: underline;
		}

		&.is-active,
		&.is-active:hover {
			/* color: var(--color-white); */
			/* --s: 15px;
			clip-path: polygon(0 0, 100% 0,100% 100%, 0 100% ,var(--s) 50% ); */

			background: linear-gradient(-165deg, transparent,  transparent 30%, var(--color-dark-light_yellow)); /* var(--color-dark-blues); */
			/* &  *{
				color: inherit;
			} */
			/* &::after{
				color: initial;
			} */
		}

		&.is-selected,
		&.is-selected:hover {
			/* color: initial; var(--color-black); */
			--s: 15px; /* control the shape */
			clip-path: polygon(0 0,calc(100% - var(--s)) 0,100% 50%, calc(100% - var(--s)) 100%,0 100%); /* ,var(--s) 50% */
			padding-right: calc(var(--s) );
  
			background: linear-gradient(25deg, transparent 0%, #ccca 70%, var(--sdd-dropdown-item-color-light) -10%); /* var(--color-blues); */
			&::before{
				/* using tick character */
				/* content: "✔";
				color: var(--sdd-dropdown-item-color-light);
				position: absolute;
				top: calc(50% - .75em);
				left: .25em; */

				/* drawed by css */
				content: "";
				position: absolute;
				top: calc(50% - 9px);
				left: .35em;
				transform: rotate(30deg);
				--tick-size: 6.5px;
				--tick-decor: 3.5px solid var(--sdd-dropdown-item-color-light);
				height: calc(2*var(--tick-size));
				width: var(--tick-size);				
				border-bottom: var(--tick-decor);
				border-right: var(--tick-decor);        
			}
			/* &  *{
				color: inherit !important;
			} */
		}

		/* option that both selected and active would have a bit different decoration */
		&.is-active.is-selected{
			background: linear-gradient(25deg, var(--color-dark-light_yellow) 0%, #ccca 70%, var(--sdd-dropdown-item-color-light) -10%);
			/* linear-gradient(to right, var(--color-blues), transparent); */
		}

		/* [data-rAlignGroup] to mark that elements need to right-align from option to option */
		& [data-rAlignGroup]{
			display: inline-block; /* so width property could take effect */
			text-align: right;
		}

		/* Thesse two svg class is to color the svg */
		& svg{
			color:var(--select-book-group-color);
			/* &.MaleAuthor{
				color:#4520ad;
			}

			&.Microphone{
				color:#272782;
			} */
		}		
	}

	/* class for subTitle to be applied to chapter subtitle, which can be found in SDD items, SDD representative control (the one remains when SDD collapsed) and in elmPlaylist items */
	.subTitle{
		font-size: .85em !important;
		& > i{
			color: #008333;
			font-size: inherit;
		}
		/* & *{
			font-size: inherit;
		} */
	}

	/* for SDD items, make the subTitle balance so that it has small chance to overlap with the ordinal number (which on the far right) of the item */
	.sdd-dropdown-content .subTitle{
		display: inline-block;
    	text-wrap: balance;
	}

	.sdd-controls .subTitle{
		/* font-size: .8em !important; */
		color: var(--select-book-group-color);		
	}	

	/* sdd item hover only when container has .allow-hover-on-item class */
	.sdd-dropdown-content.allow-hover-on-item .sdd-dropdown-item:hover {
		color: var(--color-black);
		background: linear-gradient(45deg, var(--color-greys) 60%, transparent);
		transition: all 0.2s ease-in-out;
	}

	/* dropdown option group */
	.sdd-dropdown-content .optgroup {
		border: 1.5px solid #cfcdcf;
		border-radius: 5px 5px 0 0 ;
		margin-top: 5px;
		/* padding-bottom: 2px; */
		counter-reset: dropdownItemCounter;
				
		&>input[type=checkbox] {
			display: none;
		}

		& input[type=checkbox]+.optgroup-header {
			max-width: 100%;
			display: block;
			/* display: flex;
			flex-flow: row wrap;
			align-items: center; */
			font-size: 1rem;
			font-weight: bold;
			/*.875rem;*/
			line-height: 1.5;
			background: white;
			color: #595b5d;
			border-bottom: 2px solid #c1c1c1;
			border-top: 1.5px solid #837d7dc9;
			cursor: pointer;
			padding: 3px .75rem;
			border-radius: 4px 4px 0 0;
			background-image: repeating-linear-gradient(45deg, var(--sdd-dropdown-item-color-extra-light)  0 15px, #d9dbe999 0 30px); /* #cbcfe999 */
			/* linear-gradient(to right, #d2ceca88 0%, #FFFFFF99 51%, #d2ceca88 100%); */
			box-shadow: var(--shadow-bottom);

			&.disabled {
				pointer-events: none;
				cursor: default !important;
				/* background-image: unset; */
				color: var(--color-darkgreys);

				& *{
					color: inherit !important;
				}
			}

			&::before {
				content: '';
				display: inline-block;
				width: 0;
				height: 0;
				border: 5px solid transparent;
				border-width: 10px 5px;
				border-top-color: rgb(17, 4, 112);
				/* these 7 css lines is to make ? */
				margin-left: 4px;

				-webkit-transition: all .5s ease;
				-moz-transition: all .5s ease;
				-o-transition: all .5s ease;
				transition: all .5s ease;
				transform-origin: 25% 50%;
				transform: translate(-5px, 50%);
			}

			& .item-slight-details{
				font-size:.875rem;
				color: var(--select-book-group-color);
			}
		}

		&:has(:is(.is-active, .is-selected)) input[type=checkbox]+.optgroup-header{
			background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, transparent 90%), 
			repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
			/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
		}
		/* If on desktop, make the optGroup header look a litte more colorful */
		@media (hover: hover) and (pointer: fine) {
			&:has(.is-active) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, transparent 90%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}

			&:has(.is-selected) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--sdd-dropdown-item-color-light) 51%, transparent 90%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}
			&:has(.is-active.is-selected) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, var(--sdd-dropdown-item-color-light) 80%, transparent 100%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}
		}

		& input[type=checkbox]:not(:checked)+.optgroup-header {
			&::before {
				rotate: -90deg;
				transform: translate(-60%, 4px);               
			}
			
		}

		& input[type=checkbox]+.optgroup-header+section {
			/* hide the scroll-bar so that the content is hidden when set max-height to 0 */
			overflow: hidden;

			/* max-width: 0;
			max-height: 0;
			opacity: 0;
			transition: all .5s ease; */
			max-width: 100%;
			/* use max-height to animated the collapse effect. "height: 0" not work with css transitions */
			/* max-height: 0;
			transition: max-height .5s ease; */

			/* animation adapt from https://css-tricks.com/almanac/rules/s/starting-style/ */
			display: none;
			opacity: 0;			
			transition: opacity .75s ease-in, display .75s allow-discrete;
			/* the allow-discrete value will make properties like display wait until the end of the transition to switch to none */
			
		}

		& input[type=checkbox]:checked+.optgroup-header+section {
			/* max-height: 5000px; --> Should not change like this, for section that is too long (like group chapter of Pham Nhan Tu Tien), 5000px is not enough, this would cause some item of the SDD cannot be reached to be shown in the view, even their markup still in the DOM. However, when set max-height to 100%, the transition on 'max-height' will not work. So, we have to do the trade-off: set max-height 100% OR some large number like 30000px */
			/* max-height: 100%; */ /* 30000px; */ /* max-content; */
			
			/* animation */
			display: block;
			opacity: 1;
			/* @starting-style is making entry transitions whenever an element display is set to something different to none. */
			@starting-style {
				opacity: 0;
			}
		}

	}

	/* no result notification */
	.sdd-dropdown-content .no_results{
		padding: .5em 0px;
		color: var(--select-book-group-color); /* --color-dark-blues */
		text-align: center;
	}
 	</style>
</head>

<body onload="loadPage();" class="niceScrollBar">
	<!-- PAGES WAITS FOR MAIN PAGE TO BE FULLY LOADED-->
	<div id="loadingPageWrapper">
		<div>
			<div class='loader-bar-nonstop'></div>
			<div class='loading-text-loader loading-text-splash-screen'></div>			
		</div>
	</div>
	<!-- HTML MODAL POPUP -->
	<div class="modalPopup" id="modalSettingPopup">
		<div class="modalPopupOverlay" onclick="ssData.setting.closeSettingModal()"></div>
		<div class="modalPopupContentWrapper circus-background" tabindex="0">
			<!-- <div class="modalHeader"> </div> -->

			<div class="modalPopupContent">
				<div class="closeModal" onclick="ssData.setting.closeSettingModal()"></div>
				<div class="tabs-group">
					<!-- Tabs group Book Kit/Set setting -->
					<input type="radio" name="tabs-component" id="radioTabBookSetting" checked="checked">
					<label for="radioTabBookSetting"><code data-tooltip="Thiết đặt Book Kits / Book Sets. Có thể:&#xa;– Ẩn/Hiện sách trong danh sách các tựa sách ở trang chủ.&#xa;– Kéo thả để đảo thứ tự các sách.&#xa;– Có thể thực hiện độc lập cho từng 'Kiểu phân nhóm'.&#xa;– Một số thông tin về Book Set (bộ sách), Book Kit (kho sách) xem trong tooltip của checkbox 'Book Set/Kit View'" data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgBookSets"/></svg></code></label>
					<div class="tab-content">
						<div class="flex-button-container bounding-box">
							<div class="control-button-flex" style="padding-top: 2px;"><label
									for="selPopupBookGroup">Kiểu nhóm: </label><select id="selPopupBookGroup"
									class="dropdown-book-spinner" title="Những cách nhóm thứ tự các truyện"></select>
							</div>

							<span class="control-button-flex">
								<input id="chkShowBookKit" type="checkbox" class="!text-[25px]" role="switch"
									title="Danh sách hiển thị phía dưới là Book Kit hay Book Set">
								<label for="chkShowBookKit" data-tooltip="set in addBookSettingTab()"
									data-tooltip-location="bottom"
									style="color: var(--select-book-group-color); --data-translateX: -75%">Book Set
									view</label>
							</span>

							<span class="control-button-flex">
								<input id="chkShowHideBooksDetails" type="checkbox" class="!text-[20px]" role="switch">
								<label for="chkShowHideBooksDetails" data-tooltip="Ẩn/Hiện chi tiết các tên sách cho mỗi Book Set hoặc Book Kit"
									style="color: var(--select-book-group-color); --data-translateX: -75%">Chi tiết</label>
							</span>
						</div>

						<div name="bookTitlesSettingWrapper">
							<div name="bookKitChkboxContainer" class="control-button-flex"></div>
							<ol id="lstBookTitlesSetting" class="lstBookTitlesSetting niceScrollBar"></ol>
						</div>
					</div>

					<!-- Tabs group for Listening History -->
					<input type="radio" name="tabs-component" id="radioTabListenHistory">
					<label for="radioTabListenHistory"><code data-tooltip="Lịch sử các cuốn sách đã nghe.&#xa;– Thông tin về các cuốn sách đã nghe (gần nhất ở trên), các chương đang nghe dở cũng thời gian.&#xa;– Bấm vào tam giác nhỏ ở điểm giao các dòng kẻ, bên trái mục thông tin sách để xóa cuốn sách đó khỏi lịch sử nghe sách.&#xa;– Có thể dùng nút lệnh để xóa toàn bộ thông tin lịch sử nghe sách." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgHistory"/></svg></code></label>
					<div class="tab-content">
						<div id="ListeningHistoryWrapper" class="treeview niceScrollBar bounding-box"></div>
						
						<div class="flex-button-container bounding-box">
							<span class="control-button-flex">
								<input id="chkShowHideAllHistChapDetails" type="checkbox" class="!text-[25px]"
									checked="" role="switch">
								<label for="chkShowHideAllHistChapDetails"></label>
							</span>

							<span class="control-button-flex">
								<button id="elmHistoryClear" 
									data-tooltip="Xóa toàn bộ Lịch sử nghe sách" data-tooltip-location="top">
									<svg class="!text-[20px] button-svg-img">
										<use href="#icnSvgClearHistory" />
									</svg>
								</button>
								<label for="elmHistoryClear">Xóa lịch sử nghe sách</label>
							</span>
						</div>
					</div>

					<!-- Tabs group for buttons and UI setting -->
					<input type="radio" name="tabs-component" id="radioTabUIOthers">
					<label for="radioTabUIOthers"><code data-tooltip="Thiết đặt giao diện (GUI).&#xa;– Chủ yếu thiết đặt cho Toast.&#xa;– Thiết đặt cho thanh tiến trình (Circle Progress) trên nút Play, thanh Buffer Bar.&#xa;– Một số nút lệnh xóa dữ liệu trang Web lưu nhằm nâng cao trải nghiệm người dùng." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgGUI"/></svg></code></label>
					<div class="tab-content">
						<div class="flex-button-container bounding-box">
							<span class="control-button-flex">
								<input id="chkDisableCircleProgressButton" type="checkbox" class="!text-[30px]"
									checked="" role="switch"
									title="Ẩn/Hiện tiến trình phát hình tròn bao quanh nút Play/Pause">
								<label for="chkDisableCircleProgressButton"></label>
							</span>
							<span class="control-button-flex">
								<input id="chkHideBufferBar" type="checkbox" class="!text-[30px]" checked=""
									role="switch"
									title="Ẩn/Hiện thanh tiến trình dữ liệu audio đã được tải về máy (buffer)">
								<label for="chkHideBufferBar"></label>
							</span>
						</div>

						<div name="Toast-Setting" class="niceScrollBar bounding-box"></div>

						<div class="flex-button-container bounding-box">
							<!-- <span class="control-button-flex">
								<button id="elmHistoryClear"
									data-tooltip="Xóa toàn bộ Lịch sử nghe sách" data-tooltip-location="top">
									<svg class="!text-[25px] button-svg-img">
										<use href="#icnSvgClearHistory" />
									</svg>
								</button>
								<label for="elmHistoryClear">Xóa lịch sử nghe sách</label>
							</span> -->

							<span class="control-button-flex">
								<button onclick="historyCls.wipeAll(0);"
								data-tooltip="Xóa toàn bộ lịch sử thông tin trang Web đã ghi nhận. Nạp lại trang Web" id="elmHistoryWipeAll">
									<svg class="!text-[25px] button-svg-img">
										<use href="#icnSvgFullTrashBin" />
									</svg>
								</button>
								<label for="elmHistoryWipeAll"></label>
							</span>
						</div>
					</div>

					<!-- Tabs group Database files & variables setting -->
					<input type="radio" name="tabs-component" id="radioTabJsFileDataSetting">
					<label for="radioTabJsFileDataSetting"><code data-tooltip="Thiết đặt Database file.&#xa;– Xem thông tin về các Book Kit, các sách của mỗi Book Kit trong từng file Database.&#xa;– Lựa chọn Database file để hiện các sách trong phiên làm việc tới.&#xa;– Kéo thả để đảo thứ tự nạp các Database (do đó thứ tự sách bị đảo theo, dù các thứ tự này có thể thay đổi lại trong tab Book Setting)" data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgDatabaseConfig"/></svg></code></label>
					<div class="tab-content">
						<div name="jsFileDataSettingWrapper" style="flex-grow: 1;">
							<ol id="lstJsFileDataSetting" class="lstBookTitlesSetting niceScrollBar"></ol>
						</div>
						<fieldset>
							<legend>Thống kê</legend>
							<div name="DBStatistics"></div>
						
							<div class="flex-button-container">
								<span class="control-button-flex">
									<button onclick="ssData.setting.handyCheckDBsEdition(true);"
									data-tooltip="Kiểm tra để tìm xem có phiên bản (edition) mới các file dữ liệu (Database- DB). Nếu có phiên bản mới của một file dữ liệu, bạn có thể cần phải khởi động lại app để cập nhật dữ liệu mới nhật." id="elmCheckDBFilesUpdate">
										<svg class="!text-[20px] button-svg-img">
											<use href="#icnSvgCheckDBsUpdate" />
										</svg>
									</button>
									<label for="elmCheckDBFilesUpdate"></label>
								</span>
								<span class="control-button-flex">
									<button onclick="historyCls.wipeAll(1);"
									data-tooltip="Xóa toàn bộ lịch sử thông tin trang Web đã ghi nhận ngoài cấu hình file database chọn ở bảng phía trên. Nạp lại trang Web" id="elmHistoryWipeAllButDataCfg">
										<svg class="!text-[20px] button-svg-img">
											<use href="#icnSvgTrashBin" />
										</svg>
									</button>
									<label for="elmHistoryWipeAllButDataCfg"></label>
								</span>
							</div>
						</fieldset>
					</div>

					<!-- Tabs group HotKeys setting -->
					<input type="radio" name="tabs-component" id="radioTabHotKeysSetting">
					<label for="radioTabHotKeysSetting"><code data-tooltip="Xem thông tin phím tắt điều khiển trang Web, bao gồm:&#xa;– Phím tắt cho Danh mục sách/chương (Search-Dropdown)&#xa;– Phím tắt điều khiển player (Audio–Player).&#xa;– Phím tắt chung của trang chủ.&#xa;– Phím tắt trong cửa số cấu hình này." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgKeyboard"/></svg></code></label>
					<div class="tab-content">
						<div name="hotkeysSettingWrapper" class="niceScrollBar"></div>
					</div>

				</div>
			</div>
		</div>
	</div>
	<!-- end of html modal popup -->

	<!-- MAIN PAGE -->
	<div name="divContainer">
		<!-- Top part of the page, containing book select element and chapter title, audio element -->
		<div name="divCtnTop">
			<audio id="elmMyAudio" autoplay controls src=""></audio>

			<div>
				<!-- Searched Dropdown list of Book titles (Book kits, Book sets, Books)  -->
				<div name="sdd-BookTitlesDropdown-container"></div>

				<div id="elmDivMcRadioCtn">
					<p id="elmInnerMcFlexCtn" class="flex-button-container"></p>
				</div>
			</div>

			<div>
				<details open name="chapterInforDetails">
					<summary><span id="elmChapterTitle"></span></summary>
				</details>
				<div id="elmChapterInfor" class="detailContent"></div>
			</div>
		</div>

		<!-- Audio controls panel -->
		<div class="ap-container">
			<div class="ap-panel">
				<div class="ap-sub-panel ap--playback" name="divCtnAudioControlBottom"> <!-- control-button-flex -->
					<div class="ap-controls" data-tooltip="Chọn chế độ bám dính Bảng điều khiển audio khi cuộn trang" style="--data-translateX:-20px">
						<select class="ap-sticky-select" title="Chọn dính Bảng điều khiển audio khi cuộn trang"></select>
					</div>

					<button class="ap-controls ap-reload-btn"
						data-tooltip="Nạp lại link truyện" data-tooltip-location="top"
						style="--data-translateX:-40px">
						<svg class="!text-[20px] button-svg-img">
							<use href="#icnSvgReload" />
						</svg>
					</button>

					<button class="ap-controls ap-prev-btn" title="Nghe chương trước">
						<svg class="!text-[30px] rotate-180 button-svg-img">
							<use href="#icnSvgSkipNext" />
						</svg>
					</button>
					<button class="ap-controls ap-rewind-btn" onclick="xAudio.currentTime -= 10;"
						title="Lùi lại 10 giây">
						<svg class="!text-[20px] rotate-180 button-svg-img">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>
					<button class="ap-controls ap-play-pause-btn" title="Phát/Dừng truyện">
						<svg class="!text-[40px] button-svg-img">
							<use href="#icnSvgPlay" svg-icon-name="PlayPauseIcon" />
						</svg>
					</button>

					<button class="ap-controls ap-fastforward-btn" onclick="xAudio.currentTime += 10;"
						title="Tiến lên 10 giây">
						<svg class="!text-[20px] button-svg-img">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>
					<button class="ap-controls ap-next-btn" title="Nghe chương sau">
						<svg class="!text-[30px] button-svg-img">
							<use href="#icnSvgSkipNext" />
						</svg>
					</button>
				</div>

				<div class="ap-sub-panel ap--track">
					<!-- the div that contain the tooltip displaying audio playback time at current mouse position -->
					<div class="moving-audio-offset-time">-/--</div>
					<!-- the main part containing media title, progress bar, buffered and played canvases -->
					<div class="ap-info">							
						<div class="ap-title-time">
							<div class="ap-title"></div>
							<div class="ap-time">
								<span class="ap-time--remains">0:00 / 0:00</span>
							</div>
						</div>
						<div class="ap-progress-container">
							<div class="ap-progress">
								<div class="ap-progress-bar" style="width: 10%;"></div>
								<div class="ap-progress-preload-bar" style="width: 100%;"></div>
							</div>
						</div>
						<!-- buffered bar -->
						<canvas class="ap-played-bar"></canvas>
						<!-- buffered bar -->
						<canvas class="ap-buffer-bar"></canvas>
					</div>
				</div>
				<div class="ap-sub-panel ap--settings">
					<!-- Speed select box with increase/decrease buttons -->
					<div class="ap-controls ap-volume-container">
						<button class="ap-controls ap-volume-btn">
							<svg class="!text-[15px] button-svg-img">
								<use href="#icnSvgVolumeOn" class="ap--volume-on" />
								<use href="#icnSvgVolumeOff" class="ap--volume-off" />
							</svg>
						</button>
						<div class="ap-volume">
							<div class="ap-volume-progress">
								<div class="ap-volume-bar" style="height: 70px;"></div>
							</div>
						</div>
					</div>

					<!-- Speed select box with increase/decrease buttons -->
					<button class="ap-controls" data-tooltip="Chọn tốc độ phát" id="spd_btn" data-tooltip-location="left">
						<img class="button-svg-img" src="https://uxwing.com/wp-content/themes/uxwing/download/transportation-automotive/speed-test-icon.svg" />
						
						<span class="spd_btnValue">1x</span>
					</button>
					<!-- Speed Slider Popup old position. If we put it here, its closest positioned ancestor should be .ap-container (audio controls panel - ACP), so it is very hard to control the popup position especially when  ACP stick at the bottom of screen (see function placePopup())-->
					
				</div>
			</div>
		</div>		

		<!-- Speed Slider Popup - We have to put it here so its closest positioned ancestor is the BODY itself -->
		<div id="spd_popup" class="spd_popup" role="dialog" data-open="false">
			<div class="spd_header">
				<div class="spd_header_left">
					<div style="margin-right:10px;">Chọn tốc độ audio</div>
					<!-- small - and + buttons -->
					<button id="spd_dec" class="spd_small_btn" data-tooltip="Giảm 0.05 &#10; Bấm mũi tên ↓ hoặc ← &#10; Bấm cùng phím Shift ⇧ để giảm 0.1">
						<svg class="!text-[12px] button-svg-img">
							<use href="#icnSvgMinusSign" />
						</svg>
					</button>
					<button id="spd_inc" class="spd_small_btn" data-tooltip="Tăng 0.05 &#10; Bấm mũi tên ↑ hoặc → &#10; Bấm cùng phím Shift ⇧ để tăng 0.1">
						<svg class="!text-[12px] button-svg-img">
							<use href="#icnSvgPlusSign" />
						</svg>
					</button>
				</div>

				<div class="spd_currentSpdLabel">1.0x</div>
			</div>

			<div class="spd_track-wrap">
				<div id="spd_track" class="spd_track">
				<div id="spd_fill" class="spd_fill"></div>
				<div id="spd_handle" class="spd_handle" role="slider" tabindex="0"></div>
				</div>
				<div id="spd_ticks" class="spd_ticks"></div>
			</div>
		</div>

		<!-- DIV contains playing time and functional buttons -->
		<div class="flex-container">
			<!-- playing time -->
			<div>
				<!-- <svg class="noInternetSignal elm-hidden"><use href="#svgIconNoInternetConnection"/></svg> -->
				<div class="noInternetSignal elm-hidden" data-tooltip="Mất kết nối Internet" style="--data-translateX: -20px;">
					<svg><use href="#svgIconNoInternetConnection"/></svg>
				</div> 
				<div id="elmPlayingTime"><div class="plt-time"></div><div class="plt-slash"></div><div class="plt-duration"></div></div>
				<div name='HourglassSpining' class='elm-hidden'>
					<svg class="!text-[30px] button-svg-img animate-spin">
						<use href="#icnSvgHourGlass" />
					</svg>
					<span class="loading-text-loader"></span>
				</div>
				<div class="timeRangeInfoButton">
					<svg><use href="#icnSvgDuration"/></svg>
				</div>
			</div>

			<!-- functional buttons -->
			<div name="divCtnAudioControl" class="flex-button-container">
				<div class="control-button-flex" name="divOtherControlTop">
					<!-- <button class="ap-reload-btn" title="Nạp lại link truyện" data-tooltip="Nạp lại link truyện" style="height:41px; --data-translateX: -15%">
						<svg class="!text-[20px] button-svg-img">
							<use href="#icnSvgReload"/>
						</svg>
					</button> -->
					
					<button name="togglePlaylistExtraTitles"
						data-tooltip="Ẩn/hiện tiêu đề phụ cho danh mục chương sách.">
						<svg class="!text-[20px] button-svg-img">
							<use href="#icnSvgToggleExtraTitlesBtn" />
						</svg>
					</button>

					<!-- button to scroll to current playing chapter in #elmPlaylist -->
					<button name="gotoPlayingChapter"
						data-tooltip="Đến chương đang phát">
						<svg class="!text-[20px] button-svg-img">
							<use href="#icnSvgJump2Selected" />
						</svg>
					</button>

					<!-- Seeking/Jumping to a specific time button -->
					<div class="havingShortPopup">
						<button id="seekDurationButton"
							data-tooltip="Chọn thời gian nghe">
							<svg class="!text-[28px] button-svg-img">
								<use href="#icnSvgRunJumping" />
							</svg>
						</button>
						<!-- popup to type in duration to jump to -->
						<div id="seekDurationDivPopup" class="shortPoup">
							<label for="ipAudioDuration"></label>
							<input id="ipAudioDuration" type="text" inputmode="text" maxlength="10" pattern=""
								placeholder="Nhập thời gian">
							<span class="checkInputValidity"></span>
						</div>
					</div>
				</div>

				<!-- Page functional buttons -->
				<div class="control-button-flex" name="divHistoryControlTop">
					<!-- Sleep Timer button -->
					<div class="havingShortPopup">
						<button id="sleepTimerButton"
							data-tooltip="Hẹn giờ tắt Audio (nút sẽ chuyển sang màu đỏ).&#xa– Nhập 0 hoặc để trắng: Tắt hẹn giờ (nút hẹn giờ chuyển về màu đen).&#xa– Nhập -1 để audio tự tắt khi phát hết chương sách hiện tại.">
							<svg class="!text-[28px] button-svg-img">
								<use href="#icnSvgSleepTimer" />
							</svg>
						</button>
						<!-- popup to type in time to stop playing -->
						<div id="sleepTimerDivPopup" class="shortPoup SleepTimer">
							<label for="ipSleepTimer"></label>
							<datalist id="sleepTimersDatalist"></datalist>
							<input id="ipSleepTimer" placeholder="⏲ Hẹn giờ tắt" maxlength="10" list="sleepTimersDatalist" />
							<span class="checkInputValidity"></span>

						</div>
					</div>
					
					<!-- book group way -->
					<select id="selBookGroup" title="Đổi cách nhóm thứ tự các truyện"></select>

					<!-- open setting button. Here I do a small-hack by setting z-index:0 to make the button on its own stacking context, so it is not being covered by #elmChapterInfor, so it is clickable when audio control panel is pinned at bottom of the page -->
					<button onclick="ssData.setting.openSettingModal();" style="z-index:0">
						<svg class="!text-[30px] button-svg-img">
							<use href="#icnSvgSetting" />
						</svg>
					</button>					
				</div>

				<!-- History buttons -->
				<div class="control-button-flex" name="divHistoryControlTop">
					<button id="elmHistoryGoBackward" onclick="historyCls.historyGo(-1);"
						title="Lịch sử nghe: Sách ngay trước" data-tooltip-location="bottom">
						<svg class="!text-[30px] rotate-180 button-svg-img">
							<use href="#icnSvgHistoryForward" />
						</svg>
					</button>
					<button id="elmHistoryGoForward" onclick="historyCls.historyGo(1);"
						title="Lịch sử nghe: Sách tiếp theo" data-tooltip-location="bottom">
						<svg class="!text-[30px] button-svg-img">
							<use href="#icnSvgHistoryForward" />
						</svg>
					</button>
				</div>

				<!-- Chapter group buttons -->
				<div class="control-button-flex" name="divChapterGroupControls">
					<span><input id="allChapGrpChkbox" type="checkbox" checked class="!text-[25px]" role="switch"
							title="Đóng/mở tất cả các chapter group">&emsp13;
						<label for="allChapGrpChkbox" data-tooltip="Đóng/mở tất cả các chapter group"
							data-tooltip-location="bottom">Nhóm chương</label>
					</span>
				</div>
			</div>

		</div>

		<div name="divCtnMiddle" class="flex-container">
			<div>
				<!-- chapter/book workart -->
				<div><img id="elmArtwork" /></div>

				<!-- No-Internet SVG image -->
				<svg class="noInternetImg elm-hidden">
					<use href="#svgIconNoInternetConnection" />
				</svg>
				
				<!-- Sleep-Timer count-down text -->
				<div class="control-button-flex elm-hidden">
					<svg class="!text-[25px] button-svg-img">
						<use href="#icnSvgSleepTimer" />
					</svg>
					<span id="elmSleepTimerCountDown">00:00</span>
				</div>

				<!-- Book Total duration -->
				<div id="elmBookTotalDuration" xrole="containing-tooltip">
					<svg class="svg-img-infor" style="margin-right:4px;">
						<use href="#icnSvgDuration" />
					</svg>
					<span data-tooltip="Tổng thời gian cả cuốn sách">00:00:00</span>
					<svg class="svg-img-infor">
						<use href="#icnSvgListenTime" />
					</svg>
					<span data-tooltip="Thời gian thực tế nghe cả cuốn sách với tốc độ phát hiện tại"
						role="listeningTime">00:00:00</span>
				</div>

				<!-- Big audio Play/Pause and other control button -->
				<div class="control-button-flex" style="color: #29689e;" name="divCtnAudioControlExtraBig">
					</button>
					<button onclick="xAudio.currentTime -= 20;" class="ap-rewind-btn" title="Lùi lại 20 giây">
						<svg class="!text-[50px] rotate-180 button-svg-img">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>

					<button title="Phát/Dừng truyện">
						<svg class="!text-[80px] button-svg-img">
							<use href="#icnSvgPlay" svg-icon-name="PlayPauseIcon" />
						</svg>
					</button> <!-- icnSvgPlayProgress -->

					<button onclick="xAudio.currentTime += 20;" class="ap-fastforward-btn" title="Tiến lên 20 giây">
						<svg class="!text-[50px] button-svg-img">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>

				</div>
			</div>

			<div name="elmPlaylistCtn">
				<!-- Searched Dropdown list of chapters list -->
				<div name="sdd-ChaptersListDropdown-container"></div>

				<ol id="elmPlaylist" class="radial-background niceScrollBar"></ol>
			</div>
		</div>
		<div name="divCtnBottom">
			<!-- ontoggle run only one time -->
			<details>
				<summary><span id="elmBookTitle"></span></summary>
			</details>
			<div id="elmBookInfo" class="detailContent"></div>
		</div>
	</div>

	<!-- <script src="config.js"></script>
	<script src="data.js?v=1.112"></script>
	 -->
	
	
	<!-- Script that deal with loading js script files that contains page configuration and database, then loadPage() -->
	<script>
		"use strict";
			/* Class deal with DB files being loaded as js script elements */
			class DBFiles{
	
				/** Enum to define the loadMode of script file, especially for DB file  */
				static LMODE = Object.freeze({
					/* @value 0: Database file would not be loaded */		
					noShow: 0,
					/* @value 1: Database file is freshly-loaded, meaning even the file has been loaded before and being stored in browser's cache, the cache will be ignore and the page will load file from server */
					freshLoad: 1,
					/* @value 2: Database file is cache-loaded. If the file has been cached by browser before, the page will use that cache version of file for better performance and save bandwidth */
					cacheLoad:2
					/* @value -1 : called from Setting.addJsDatabaseFileReport() to load information of a database that was not choosen for showing when page load (its loadMode in xDBFilesCfg == 0). This loadMode is treated as loadMode=2 */
					//,tempLoad: -1
					/* for some DB that currently has loadMode = noShow(0) but it has new edition, we temporarily change it loadMode to delayFresh(-2), so that when completing reload (fresh) new edition of that DB, we would know to change its loadMode back to noShow */
					//,delayFresh: -2
				});
	
				/** LoadJS: class to load multiple js libraries and return a promise or an array of promise
				* @adapt_from https://github.com/MiguelCastillo/load-js/tree/master. See that github for usage and options, although I has renamed some flag name to to descibe more correcly their functionality, also I added some new @atttributes to meet my needs for this app (see @CUSTOMIZED_PROPERTIES section below).
				See _DEFAULT_OPTIONS in exec() function for the default value for all flags
	
				* @ORIGINAL_PROPERTIES
					@property type: @defaults to 'text/javascript'.
					@property async: @defaults to false.
					@property charset: @defaults to utf-8.
					@property id: no default value. If id is not set, loadJs will hash the script url (without parameters - string after '?') and make it to be the script id
					@property url: Location of the script to load. Required if no text is provided.
					@property text: Script code to execute. Required if no url is provided.
	
					@flag cacheEnable {@defaults to true} (I rename from original name 'cache'): flag to determine if item with ID or URL is to be cached. if this flag set to false, its promise will not be update the the loadJs internal cache
					@flag allowExternal {@defaults to true}: flag to handle situations when the DOM already has a script element with the same ID or URL as what loadJS is being told to load. By default, loadJs will ignore the script with similar url (same without parameter) that not loaded by loadJs. If set to false, loadJS will use script elements that already exist in the DOM. To turn off this behavior, set allowExternal to false. 
					@flag debug {@defaults to false}: flag to show debug message.
	
				* @CUSTOMIZED_PROPERTIES 
					@flag allowReload {@defaults to false}: the flag to tell loadJs to overload the old js file (which also had been loaded by loadJs). I use for config.js to detect if there is new database version or on Setting.addJsDatabaseFileReport(). Let see a case when loadJS has loaded a js file, e.g 'data_0.js', now that file is loaded again (also by loadJS), if this flag is missing or false, we can't load again the same file. This is different from @property allowExternal is that  allowExternal compared with js script NOT loaded by loadJS (might be a markup that was hard-coded or dynamiclly loaded by other agency )
					@flag freshLoad {@defaults to false}: the flag to tell if the script should be fresh-load (=true) or got from cache (false or missing), if applicable. 
						@note that when freshLoad = true, @flag allowReload is also set to true. Also, there is a @property urlVersion is attached to script element which store the lastest version of script url, which can be used to update back in function which invoked loadJS
					@flag removeMarkup {@defaults to true}: the flag to tell if the script mark-up should be delete out of DOM or keep it in the DOM (false). Even of markup being removed out of DOM, its data still being kept in window variables, so we still being able to process script data
	
					@attribute extAttr {@defaults to empty json {} }. extAttr will keep all @properties that user want to attach to script element for later usage:
						@attribute fileNo: store the ordernal number of current database file, which act as an Id to identify a Database File
						@attribute jsDBName: name of database file, also the name of database variable inside that file (they must be the same). For now, each file should have only one data variable, such as data_0.js has only one const json-like object 'data_0'
						@attribute loadMode: the mode to load the Database file. See LMODE for detail information of each type of loadMode
							
						@note See createScript() for the handy, customized property that added to script element like id, jsDBName, loadMode, urlVersion, watermark, type, charset
				* @USAGE
						@way 1: loadJS("https://code.jquery.com/jquery-2.2.1.js")
						 .then(function() {});
						@way 2: loadJS(["https://code.jquery.com/jquery-2.2.1.js", "https://unpkg.com/react@15.3.1/dist/react.min.js"])
						 .then(function() {}); 
						@way 3: loadJS({
								url: "data_1.js?v=3333",
								freshLoad: true,
								extAttr: {
									fileNo: 1,
									jsDBName: 'data_1', 
									allowReload: true,
									loadMode: -1
								}
							})
							.then(_ => {})
							See Setting.addJsDatabaseFileReport() for one example of usage that customize for this App
						@way 4: loadJS([{
								 url: "data_1.js?v=3333",
								removeMarkup: false,
								extAttr: {
									fileNo: 1,
									jsDBName: 'data_1', 
									allowReload: true,
									loadMode: -1
								}
							}, {
								async: true,
								url: "https://unpkg.com/react@15.3.1/dist/react.min.js"
							}])
							.then(_ => {})
						@otherway : can use loadJS to load script code instead of url as above ways
				* @RETURN
					 * if @items is one item, it will return the script element directly
					 * if @items is array of items, it will return the array of result json which has one of following formats:
					 * 	- success: {status: 'fulfilled', value: ...the script element...}
					 * 	- failed:  {status: 'rejected', reason: ...the script element...}
				*/
				static loadJS = (function createLoadJS() {
					var _loadJsInternalCache = {}; //store scrips promise that being loaded by Loadjs
					var head = document.getElementsByTagName("head")[0] || document.documentElement;
					const _WATERMARK = "Chinhvtr";
	
					/* HELPER FUNCTIONS */
					/** get script THAT NOT LOADED by LoadJS */
					/* function getScriptById(id) {
						var script = id && document.getElementById(id);
	
						if (script && script.watermark !== _WATERMARK) {
							console.warn("load-js: duplicate script with id:", id);
							return script;
						}
					}
					
					function getScriptByUrl(url) {
						var script = url && document.querySelector("script[src='" + url + "']");
	
						if (script && script.watermark !== _WATERMARK) {
							console.warn("load-js: duplicate script with url:", url);
							return script;
						}
					} */
	
					/** get script that NOT loaded by LoadJS 
					 * @param url {string}: the url or the id of scipt
					 * @param byUrlOrId {boolean}:
					 * 		@value true (default): search script by url without param (string after '?')
					 * 		@value false: search by id
					 * @return
					 * 	- the first found script element if found
					 * 	- null if not found
					*/
					function getExternalScript(url, byUrlOrId = true) {
						if(!url) return null;
	
						if(byUrlOrId) url = url.split("?")[0];
						const _queryStr = byUrlOrId? "script[src^='" + url + "']" : "script[id='" + url + "']";
	
						const _scripts = document.querySelectorAll(_queryStr);
						let _foundScript = null;
	
						_scripts.forEach(_script => {
							if (!_foundScript && _script.watermark !== _WATERMARK) {
								console.warn("loadJS: found external script (one that not loaded by loadJs) with " + (byUrlOrId?"url":"id") + ":", url);
								_foundScript =_script;
							}
						});
	
						return _foundScript;					
					}
	
					/** simple hash function to hash any string to 7-chars string, this used to create an (nearly) unique id for the script. For now, I use String.prototype.hashCode */
					/* function simpleHash(str) {
						let hash = 0
						for (let i = 0; i < str.length; i++) {
							hash = ((hash << 5) - hash + str.charCodeAt(i)) | 0
						}
						return (hash >>> 0).toString(36)
					} */
	
					/** append script text (set in options.text) in the case that options.url is missing. Because options.text contain the js code already, so script should be loaded immediately without any delay, meaning no need to handle the async state of the script 
					 * @param head: the document.head element
					 * @param script: the script element that created by createScript() but not yet append to the DOM
					*/
					function appendScriptByText(head, script) {
						head.appendChild(script);
						return Promise.resolve(script);
					}
	
					/** append script by url (speified in options.url), so we use Promise to handle async state of script load 
					 * @param head: the document.head element
					 * @param script: the script element that created by createScript() but not yet append to the DOM
					*/
					function appendScriptByUrl(head, script) {
						return new Promise(function(resolve, reject) {
						// Handle Script loading
						var done = false;
	
						// Attach handlers for all browsers.
						//
						// References:
						// http://stackoverflow.com/questions/4845762/onload-handler-for-script-tag-in-internet-explorer
						// http://stevesouders.com/efws/script-onload.php
						// https://www.html5rocks.com/en/tutorials/speed/script-loading/
						//
						script.onload = script.onreadystatechange = function() {
							if (!done && (!script.readyState || script.readyState === "loaded" || script.readyState === "complete")) {
							done = true;
	
							// Handle memory leak in IE
							script.onload = script.onreadystatechange = null;
							resolve(script);
							}
						};
	
						script.onerror = reject;
	
						head.appendChild(script);
						});
					}
	
					/* IMPORTAN FUNCTIONS */
	
					/** function to create script and attached properties, attributes to script element for later processing when script file is loaded or failed-loading. Note that for now, the script has not been appended to the DOM
					 * @param option: json of all attributes that need to config the script element and some other atttribute added to elements for using later. See https://github.com/MiguelCastillo/load-js/tree/master for list of default attribute like type, async, charset, id, url, text, cache (I renamed to 'cacheEnable'), debug
					 * ADDED: jsDBName, loadMode, allowReload, urlVersion
					 * @return the script element
					 */
					function createScriptElem(options) {
						var script = document.createElement("script");
						/* some built-in attribute of a script element, see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script for the full list */
						script.charset = options.charset || "utf-8";
						script.type = options.type || "text/javascript";
						script.async = !!options.async; //default false
						//in exec() we already create an options.id if user not clearly specify it
						script.id = options.id; 
						//script.id = (options.id || options.url).split("?")[0]; //without param of url if there any
	
						/* customized attribute to meet user extra need */
						//attach all extra/extented attributes that user need to attach to script for later handy usage
						script.extAttr = options.extAttr || {};
						//attach a watermark to know that the script is loaded by loadJs or not
						script.watermark = _WATERMARK;
						//adding timestamp for ease of debugging when loadJS internal cache hit
						script.timestamp = (new Date()).toLocaleString();
	
						/* Using version paramet '?v={version_number}' to force the browser to re-load and script file (mostly through file url) */
						const _DEF_VERSION = Math.round(performance.now()); //101;
						let _dbUrl = options.url;
						const _versReg = _dbUrl.match(/v\=(\d+)/);
						if(_versReg){
							let _version = parseInt(_versReg[1]);
							if(isNaN(_version)) _version = _DEF_VERSION;
							// freshLoad = true, we need to re-load the script even there is old version in the cache. For the specific case of this page when loading DB stored in script file, we do fresh-load only when loadMode == 1 (and we need to specify freshLoad attribute when invoking loadJs). Other mode loadMode= -1 (called from addJsDatabaseFileReport()) or =2, using cache if applicable
							// We archive fresh-load by changing the version so the js file load will ignore browser's cache.
							if(options.freshLoad)  _dbUrl = _dbUrl.replace(_versReg[0], "v=" + (++_version));
						}
						else _dbUrl += (_dbUrl.indexOf("?")>-1? "": "?") + "v=" + _DEF_VERSION; //assign a initial version number
						
						//save new versionning into urlVersion of script element, so later in loadPage, we can update the new version into xDBFilesCfg.toLoad[index].dbUrl. Note that I don't want to use script.src since it is absolute address while script.urlVersion is relative address (shorter)
						script.urlVersion = options.url = _dbUrl;
	
						if (options.url) { script.src = options.url; }
						if (options.text) { script.text = options.text; }
						return script;
					}
	
					/** function to create script and append it to the DOM. Note that this function only support for one script only. This function also handle some situation like duplicate load by loadJs or duplicate with hard-coded markup.
					 * @param option: config for the single script to be load
					 * @return a promise wrapping the script
					 */
					function exec(options) {
						// if user only invokde loadJS with a string as parameter like loadJS('https://code.jquery.com/jquery-2.2.1.js'), consider as loading by url
	
						/* Create default value for options attributes when missing */
						if (typeof options === "string") {
							options = {
								url: options
							};
						}
	
						//default flags if not otherwise specify differently when invoking loadJS()
						const _DEFAULT_OPTIONS = {
							cacheEnable: true, //update script to the loadJs internal cache
							allowExternal: false, //ignore the external having same url script (after removing parameter if any), if any
							allowReload: false, //not allow reload if this script has been loaded before by loadJs
							freshLoad: false, //using the browser cache if any
							removeMarkup: true, //remove markkup out of DOM when done loading script
							debug: false
						}
						options = Object.assign({}, _DEFAULT_OPTIONS, options);
	
						// if freshload, meaning loading new version of the script without using browser caches or loadJS internal cache, so we must set allowReload = true
						if(options.freshLoad) options.allowReload = true;
	
						// if user not specify an id for script, we make one from its url without param
						let _scriptId = options.id || (options.url.split('?')[0]).hashCode(); // make an id from url if option.id is not explicitly specified
						options.id = _scriptId; //update back the maybe-new id to the option
	
						// cache here just to avoid same js files being loaded twice in the SAME session, with requirement both are loaded by loadJS
						let _cachedScriptEntry = _loadJsInternalCache[_scriptId]; //see if script already in loadJS cache
	
						if (_cachedScriptEntry) {
							if (!!options.debug) {
								console.warn("loadJS: Script hit - this script has been loaded by loadJS in current page session. id:", _scriptId, "; url:", options.url);
							}
							//if options.allowReload = true: return script Promise right away without reloading it
							if(!options.allowReload)
								return _cachedScriptEntry;
						}
						//check allowExternal only when no _cachedScriptEntry because when there is _cachedScriptEntry, allowExternal is checked when the first time this script is loaded by loadJS
						else if (options.allowExternal) {
							// not found script in the cache AND options.allowExternal = true or missing, we need to look in the DOM to see if there any script (of cource, not loaded by loadJS). In case found, use that script without having loadJs reloaded that script
	
							let el = getExternalScript(options.url) ;//getScriptById(options.id) || getScriptByUrl(options.url);
	
							// found an external script with similar url (but not loaded by loadJs)
							if (el) {
								// Promise.resolve(el) is the same with 'new Promise( (resolve, reject) => resolve(el) )'
								let promise = Promise.resolve(el);
								//store external script promise into cache
								if (_scriptId) { _loadJsInternalCache[_scriptId] = promise; }
								return promise;
							}
						}					
	
						if (!options.url && !options.text) {
							throw new Error("load-js: must provide a url or text to load");
						}
	
						// depding on the type of script (code or url), we need different function to append the script and handle async nature of the script to the DOM
						const _scriptElem = createScriptElem(options);
						var pendingPromise = (options.url ? appendScriptByUrl : appendScriptByText)(head, _scriptElem);
	
						//if options.removeMarkup is true of missing, remove the script markup in document.head, so if other inspect the code would not see the script had been loaded to the page which could cause confusing for them when inspecting the code.
						if(options.removeMarkup !== false)
							//finally is to do performing cleanup/finalizing after the previous operations are complete (doesn't matter successfull to failed).
							pendingPromise.finally(_ => {
								_scriptElem.remove();
							});
	
						//if cacheEnable is not explicitly set to false, save this script inside _loadJsInternalCache for later check of duplication
						if (_scriptId && options.cacheEnable !== false) { _loadJsInternalCache[_scriptId] = pendingPromise; }
	
						return pendingPromise;
					}
	
					/** load one script or array of script 
					 * @param items is one item or array of items. Each item can be a string which contains url of the script or a json. If item is an json, the json is actually the option which has attributes as described in wrapper loadJS comments above
					 * 
					 * @return
					 * if @items is one item, it will return the script element directly
					 * if @items is array of items, it will return the array of result json which has one of following formats:
					 * 		success: {status: 'fulfilled', value: ...the script element...}
					 * 		failed:  {status: 'rejected', reason: ...the script element...}
					 * See createScript() for the handy, customized property that added to script element like id, jsDBName, loadMode, urlVersion, watermark, type, charset
					*/
					return function load(items) {
						return items instanceof Array ? Promise.allSettled(items.map(exec)) : exec(items);
					}
				})();
	
				/** Function to deploy data inside DB js file into the page, that is to load the Book Kit variables inside each Database file named {_jsDBName} into a collection {ssData.jsDBFiles} along with database file _loadMode */
				static deployDB(_jsDBName, _loadMode) {
					const bookKitVars = []; //store the names of attributes (each actually is book Kit variable) of the current data variable (like data_0)
					this.name = _jsDBName; //store data variable names inside the variable content
					for (const key of Object.getOwnPropertyNames(this)) {
						//console.log(key);
						if (key.match(/\_Data$/) && (typeof this[key] == 'object')) {
							//console.log(key + ":" + (typeof this[key]));
							bookKitVars.push(key);
						}
					}
	
					// new item of ssData.jsDBFiles for _jsDBName
					const _newJsDBFile = { dbName: this.name, dbs : bookKitVars, loadMode: _loadMode};
					// find index of current item in ssData.jsDBFiles having dbName == _jsDBName
					const _jsDBFileIdx = ssData.jsDBFiles.findIndex(_dbFile => _dbFile.dbName == _jsDBName );
	
					if(_jsDBFileIdx == -1)
						// not found, just push it in
						ssData.jsDBFiles.push(_newJsDBFile);
					else
						//found, replace old item with new one
						ssData.jsDBFiles.splice(_jsDBFileIdx, 1, _newJsDBFile);
				}
	
				/** Compare {edt} attribute (edition) from xDBFilesCfg.toLoad[index].edt with _DEFAULT_CFG.cDBFilesEdt.edt[index] to see if there is later version of any of data_{index} DB files. If there is, UPDATE edt IMMEDIATELY.
				 * @param _ivkFrom: invoked from, mostly for controlling the message
				 * 		@value 0: invoked from loadPage()
				 * 		@value 1: invoked from Setting.handyCheckDBsEdition()
				 * 		@note: for now, this param is redundant and is not usable
				 * @return 
				 * 		@value null is there is no new update on any DB files
						@value an json: see the 'return' directive at the very end of function for detailed information
				*/
				static checkDBFilesEdition(_ivkFrom){
					const _DEF_DB_EDITION = 100; //initial edition of any DBFile
					
					//array store DB dbName (like 'data_0', 'data_1') that has new edition that is to be fresh load (load ignoring browser'cache).
					let _DBsHasNewEdition = [];
					
					//the counter to count the number of DBs that has NO edt attributes before. This only happen when there is no xDBFilesCfg in local storage (which only the case when the page is loaded very firs time OR local storage has been completely wiped-out)
					let _DBsLoadedVeryFirstTimeCounter = 0;
	
					xDBFilesCfg.toLoad.forEach((_dbItem, i) => {
						
						let _latestDbEdition = _DEF_DB_EDITION;
						//Check Edition of a DB files, if it is smaller than the lastest (in _DEFAULT_CFG.cDBFilesEdt.edt array)
						if(_DEFAULT_CFG?.cDBFilesEdt?.edt ?? false){
							_latestDbEdition = i < _DEFAULT_CFG.cDBFilesEdt.edt.length ? _DEFAULT_CFG.cDBFilesEdt.edt[i] :  _DEF_DB_EDITION;
						}
	
						//if current edition of inspected DBItem is not set yet (when page runs clean - meaning cache and localStore of last session is all wiped out) OR not the lastest (need update)
						if(!_dbItem.hasOwnProperty("edt") || _dbItem.edt <  _latestDbEdition) {
							//store DBs already cached but has later edition
							if(!_dbItem.hasOwnProperty("edt")) _DBsLoadedVeryFirstTimeCounter++;
	
							//Important: update the edition number IMMEDIATELY and DIRECTLY into xDBFilesCfg.toLoad[index].edt
							_dbItem.edt =  _latestDbEdition;
	
							//store dbName of DB having new edition
							_DBsHasNewEdition.push(_dbItem.dbName);
						}
					});				
	
					return _DBsHasNewEdition.length > 0 ? 
						{	// array contains dbName of all DB having new edition
							DBsHasNewEdition: _DBsHasNewEdition,
							// true if all DB having new edition is actually has no .edt before (meaning page is loaded very first time of just being fully wiped out all its localStorage)
							noDBsBefore: _DBsLoadedVeryFirstTimeCounter == _DBsHasNewEdition.length
						} : 
						//if there is no DBs having new edition, return null
						null;
				}
	
				/** Function to download and load-up all DB script file, update its version into xDBFilesCfg.toLoad[index].dbUrl. Doing some extra work by the callbacks _promiseCB, _allSettleCB
				 * @param _ivkFrom: invoked from, used for doing some extra work depending on where this function is invoked from, and for controlling the toast message
				 * 		@value 0: invoked from loadPage()
				 * 		@value 1: invoked from ssData.setting.handyCheckDBsEdition
				 * @param _promiseCB {function} the callback function when EACH script promise suceed
				 * @param _allSettleCB {function} the callback function when ALL scripts promise are settled (does not matter successfully or not)
				 * @return 
				 * 		@value array of dbName of all DBs having new edition
				*/
				static importDBfromFiles(_ivkFrom, _promiseCB, _allSettleCB){
					//make an alias for xDBFilesCfg.toLoad
					let toLoadArr = xDBFilesCfg.toLoad;
	
					//check if there is new DB files updated, mark those DBs has new edition or has no cache with loadMode = 1 (fresh Load) so that DBFiles.loadJS will do the rest to load latest version of those new DB files. Note that this function could override loadMode for some DB files on check failCount above
					// this array store list of DB files that has newer editions. If none has or fail to load 'config.js', it is null. See return in DBFiles.checkDBFilesEdition for the format of returned value
					let _newEditionDBs = DBFiles.checkDBFilesEdition(0);
	
					let _DBsHasNewEdition = [];
					//notify user about DBs having new edition
					if(_newEditionDBs){
						/** the function to create notification message to user of the detail of new DBs 
						 * @param _DBarray the array of DBs file_no that need to create message, such as [0, 1, 3]
						*/
						const _newDBNotifyMsg = (_DBarray) => {
							let _msg = '';
							if(_DBarray.length > 0)
								_msg = (_msg==''?'': '<br>') + `${_DBarray.length > 1?"Các ":""}CSDL ${ _DBarray.map(t => "<mark style='color:red;font-weight:bold'>"+t+"</mark>").join(", ") } có phiên bản mới`;
							return _msg;
						}
	
						let _msg = '';
	
						//empty function, this function is used as toast callback when user manually check new edition (when page is running), then it found a shown DB (loadMode = 1,2) having new edition, so when the toast is timed-out, this callback will be invoked to ask user to refesh the page to get new DB updated
						let _toastCallback = _ => {};
	
						//get the list of all DBs having new edition
						_DBsHasNewEdition = _newEditionDBs.DBsHasNewEdition;
	
						//_newEditionDBs.noDBsBefore = true when all DBs (in xDBFilesCfg.toLoad) load into page not yet has 'edt' attribute, meaning this might be the very first time page is loaded or xState was completely wiped-out
						if(_newEditionDBs.noDBsBefore){
							if(_ivkFrom==0 )
							_msg = 'Sử dụng app lần đầu tiên hoặc dữ liệu lưu của các phiên làm việc trước của app đã bị xóa sạch!';
						}
						else{
							//get all DBs has new edition but is set to be hidden
							const _DBloadHide = _DBsHasNewEdition.filter(_dbName => 
								toLoadArr.find(_dbItem => _dbItem.dbName == _dbName).loadMode == DBFiles.LMODE.noShow
							);
	
							//get all DBs has new edition and is set to be shown
							const _DBloadShow = _DBsHasNewEdition.filter(_dbName => !_DBloadHide.includes(_dbName)
							);
	
							// show toast for DBs having new edition and also set to be shown
							if(_DBloadShow.length > 0){
								let _localMsg = _newDBNotifyMsg(_DBloadShow);
								if(_localMsg != '')
									_msg += _localMsg + ', đã được App tự động ' + (_ivkFrom == 0? 'cập nhật.' : 'tải xuống (Dữ liệu mới chỉ cập nhật khi nạp lại trang Web.).');
							}
	
							// show toast for DBs having new edition but set to be hidden
							if(_DBloadHide.length > 0){
								let _localMsg = _newDBNotifyMsg(_DBloadHide);
								if(_localMsg != '')
									_msg += (_msg == ''? '': '<br>') + _localMsg + ', đã được App tự động cập nhật nhưng đang ở chế độ ẩn.';
							}
	
							//set toast callback when is invoked from Setting.handyCheckDBsEdition()
							if(_DBloadHide.length < _DBsHasNewEdition.length && _ivkFrom == 1)
							_toastCallback = _ => {
									if(confirm("CSDL có phiên bản mới. Cần nạp lại trang Web để cập nhật dữ liệu mới.\n\n Sẽ chỉ mất vài giây. Bạn có muốn nạp lại trang Web ngay bây giờ?"))
									//Force a hard reload to clear the cache if supported by the browser
										window.location.reload(true);
								}
						}
	
						if(toast && _ivkFrom == 1)
							toast.showToast(_msg, toast.ToastType.Infor, {duration: 1.5e4, cbEnd: _toastCallback}); 
						else
							//since Toast object has not been loaded, so we put it into delayedNotification
							ssData.delayedNotification.push({msg: _msg, option: {duration: 1.5e4}});
					}
					
					//function to check if a DB has new edition
					const _newDBcheck = _dbItem => {
						if(_DBsHasNewEdition.length == 0) return false;
						return Boolean( _DBsHasNewEdition.find(_dbName => _dbItem.dbName == _dbName) );
					}
					//function to filter all DBs that need to download
					const _filterFnc = _dbItem => {
						//const _newDBcheck = _dbName => 
						if(_ivkFrom == 0){
							/* call from loadPage(), we need to load all DB that match one of following condition:
							 a) cacheLoad (2) or freshLoad (1)
							 b) all DB (even in noShow(0) mode) but has new edition. Some DB of this condition might already be in condition a) */
							return _dbItem.loadMode != DBFiles.LMODE.noShow || _newDBcheck(_dbItem);
						}
						else {
							// call from Setting.handyCheckDBsEdition(), just load the DB has new edition
							return _newDBcheck(_dbItem);
						}
					}
					//store array of script url and its option to load into loadJs
					//loadMode: 0 - No Show. 1- Fresh load, No Cache. 2-load, using cache if applicable.
					let _jsDataFiles = toLoadArr.filter( _dbItem => _filterFnc(_dbItem) ) //filter item to be loaded (has loadMode 1 or 2)
					.map( _dbItem =>  ({
						url: _dbItem.dbUrl,
						//removeMarkup: since we don't set value for this flag, its default value would be true, meaning the script markup would be removed out of DOM after being loaded (sucess or fail), so other would not see any markup in the DOM for those config.js and data_*.js files
						//allowReload: true, //removed because when freshLoad = true, allowReload also set to true
						freshLoad: _dbItem.loadMode == DBFiles.LMODE.freshLoad || _newDBcheck(_dbItem), //script should ignore browser's cache if its loadMode is freshLoad or it has new edition (does not matter what its loadMode is)
						//see DBFiles.loadJS for explanation of some properties of extAttr
						extAttr: {
							//fileNo: _dbItem.fileNo, // this actually can derived from jsDBName below
							jsDBName: _dbItem.dbName, 
							loadMode: _dbItem.loadMode //this property actually not use
						} 
					})
					); //map into format of options for loadJS()
	
					DBFiles.loadJS(_jsDataFiles)
					.then((_res) => {
						_res.forEach(_prom => {
							// for success loaded db file: add data to data collected variable ssData.jsDBFiles
							if(_prom.status === "fulfilled"){
								// because of Promise.allSettled in loadJS, so _prom.value point to script elements created inside createLoadJS
								const _scriptElm = _prom.value;
								const _extAttr = _scriptElm.extAttr;
								const _jsDBName = _extAttr.jsDBName; //something like 'data_0'
	
								//xDBFilesCfg.toLoad corresponding with current script
								const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
								
								//this should never happen
								if(!_dbFileCfgItm) return console.log('importDBfromFiles(): somehow there is a database script element that not found in xDBFilesCfg.toLoad');
	
								//reset failCount
								_dbFileCfgItm.failCount = 0;
	
								// If flag freshLoad is set to true (when loadMode=1), loadJS.exec() will change version number in script url. So, we need to update dbUrl accordingly, so next time load the page, the page would use the right version from the browser's cache (because the browser's cache only keep the last version of script)
								_dbFileCfgItm.dbUrl = _scriptElm.urlVersion;
	
								//if DB file having loadMode == DBFiles.LMODE.noShow then clean its data since those data would not be shown in books list
								if( _dbFileCfgItm.loadMode == DBFiles.LMODE.noShow ){
	
									// for more control on clearing unneccessary data, I defer the clearing job to _promiseCB callback
									//delete the global variable for data that set hidden to save memory
									//window[_jsDBName] = undefined;
								}
								else{
									// if fresh-load, then change loadMode to cache-load for next session
									if(_dbFileCfgItm.loadMode == DBFiles.LMODE.freshLoad) {
										_dbFileCfgItm.loadMode = DBFiles.LMODE.cacheLoad;
										console.warn(`importDBfromFiles(): Database file ${_dbFileCfgItm.dbUrl} has change loadMode from 1 to 2 (Load from Browser's Cache on next session)`);
									}
								}
	
								if('function' == typeof _promiseCB){
									// load DB into ssData.jsDBFiles (so books inside that DB would be show in this session) if it is not in no-show mode (loadMode !=0)
									if (_ivkFrom == 0) _promiseCB(_scriptElm);
									//DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _extAttr.loadMode);
								
									// for now Setting.handyCheckDBsEdition has set no function for this callback
									if (_ivkFrom == 1) _promiseCB(_scriptElm);
								}
							}
							// for failed loaded db file: 
							else if(_prom.status === "rejected"){
								/* most likely the database file not exist */
	
								//_prom.reason.target point to script elements created inside createLoadJS
								const _scriptElm = _prom.reason.target;
								const _jsDBName = _scriptElm.extAttr.jsDBName;
	
								//mark loadMode of failly-loaded database file to be 'No Show' and increase failCount
								const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
								if(_dbFileCfgItm){
									_dbFileCfgItm.loadMode = DBFiles.LMODE.noShow;
									if(typeof _dbFileCfgItm.failCount == 'number')_dbFileCfgItm.failCount++; else _dbFileCfgItm.failCount = 1;
									console.log(`Database file ${_dbFileCfgItm.dbUrl} has change loadMode to 0 (No show on next session)`);
								}
							}
						});
	
						if('function' == typeof _allSettleCB) _allSettleCB();
	
						
					})
					return _DBsHasNewEdition;
				}			
			}
	
			/* Function is called at the very beginning when page is load. It does:
			- restore xState from localStorage, which along others page states from last sesson, it also contains which database files would be loaded, with which loadMode
			- load the Databases file with the loadMode stored in xState
			- call init() function
			 */
			function loadPage(){
				//note that since "config.js" has no suffix "?v=", so it is treated as loadMode = 1 because it will be added suffixe ?v={performance.noe()}
				//{url: "config.js", removeMarkup: false}
				DBFiles.loadJS( "config.js" ).then((_ret) => {
					/* STEP B: Lấy lại xState, xDBFilesCfg lưu trong Storage từ phiên trước; This have been moved to init() */
					function getFromStorage(_storageName){ //wrap function to restore json variable from localStorage
						let resState = localStorage.getItem(_storageName);
						if (resState != null) {
							try {
								resState = JSON.parse(resState);
							} catch (e) { resState = null }
						}
						return resState;
					}
	
					/* I. Initiate some important environment variables */
					xState = getFromStorage('xState') ?? structuredClone(_DEFAULT_CFG.xState); //restore xState from localStorage
					//this to add some attributes that add might just be added while xState has been initialized quite a go
					xState = Object.assign({},_DEFAULT_CFG.xState, xState);
	
					// initialize history object if somehow it is not yet existed
					if(!xState.hasOwnProperty("history")) xState.history = structuredClone(_DEFAULT_CFG.xState.history);
					//this line is used to update new property 'books' of xState.history. TODO: This is redundant if user wipeout all localStorage data, and cann be moved after someimt
					xState.history = Object.assign({},_DEFAULT_CFG.xState.history, xState.history);
	
					xDBFilesCfg = getFromStorage('xDBFilesCfg') ?? structuredClone(_DEFAULT_CFG.xDBFilesCfg); //restore xDBFilesCfg from localStorage
					
					//initiate empty xState.toastCfg 
					if(!xState.hasOwnProperty("toastCfg")) xState.toastCfg={theme:3, mode:4}; // if xState.toastCfg has not been set at all, set it to my favorite toast setting. Or just set to empty json {} for completely random setting
	
					//this to add some attributes that add might just be added while xState has been initialized quite a go
					xDBFilesCfg = Object.assign({},_DEFAULT_CFG.xDBFilesCfg, xDBFilesCfg);
	
					//initiate last checked time
					ssData.lastDBCheck = Date.now();
	
					//initiate delayedNotification storage for delayed (postponed) notification to user (especially when toast object has not created like when invoking from this loadPage() function)
					if(!ssData.hasOwnProperty("delayedNotification")) ssData.delayedNotification = [];
	
					//_DEFAULT_CFG.xDBFilesCfg looks like {"len":3,"toLoad":null};
					//in case new database just being added, the len in the cfg changes
					//for now, I fix number of databases on _DEFAULT_CFG.xDBFilesCfg.len
					xDBFilesCfg.len = _DEFAULT_CFG.xDBFilesCfg.len; //Math.max( (xDBFilesCfg.len ?? 3), _DEFAULT_CFG.xDBFilesCfg.len);
					
					/* II.A. Prepairing xDBFilesCfg.toLoad array before actually loading the DBs and book data inside them */
					//initiate xDBFilesCfg.toLoad array if it not yet exist (this only happen when page loaded for very first time or local storge was been completely wiped out)
					if(!(xDBFilesCfg.toLoad instanceof Array))  xDBFilesCfg.toLoad = [];
					let toLoadArr = xDBFilesCfg.toLoad; //don't swap this line and above
	
					/* II. load the DB files */
					const _DEF_LOADMODE = DBFiles.LMODE.cacheLoad;  //default loadMode is load, use cache
					// fill in items that localStorage's xDBFilesCfg does not have. This might happens when new database files being added to the page
					const _DB_MAX_FAILCOUNT = 10; //maximum fail count for an DB files before it is put into 'No Show' mode				
	
					const _DB_FILE_REFIX = "data_";
					//standard, initial database file information based on the len in config
					let _toLoadArrTemp = [...Array(xDBFilesCfg.len).keys()].map(i => {
						return {fileNo: i, //order number of Database file, act as an Id to identify a Database File
							dbName: `${_DB_FILE_REFIX}${i}`,  //name of Database variable inside file
							dbUrl: `${_DB_FILE_REFIX}${i}.js`, //Database file url
							loadMode: _DEF_LOADMODE, //default: database to be cache loaded
							failCount: 0} //count the number of fail when load this database
					});
	
					//if current cached has more number of databases than the config setting, remove them out of toLoadArr
					if(_toLoadArrTemp.length < toLoadArr.length){
						let _removedDBs = "";
						for(let i=_toLoadArrTemp.length; i<toLoadArr.length; i++)
						_removedDBs += "<mark>" + toLoadArr[i].dbName + "</mark>";
						ssData.delayedNotification.push({msg: "Database " + _removedDBs + " bị loại khỏi app.", option: {duration: 1e4}});
						//naive way to remove the database out of toLoadArr. Only work correctly if databases are in order like data_0, data_1, data_2, data_3,...
						toLoadArr.length = _toLoadArrTemp.length;
					}
					//add database to toLoadArr if there any new database in _toLoadArrTemp (which made from the config setting)
					const _pageLoadedFirstTime = toLoadArr.length == 0;
					for(let i=0; i<_toLoadArrTemp.length; i++) {
						const _toLoadItemTmp = _toLoadArrTemp[i];
						if( !toLoadArr.find(_item => _item.fileNo == _toLoadItemTmp.fileNo) ) {
							toLoadArr.push(_toLoadItemTmp);
							//only notify of new DBs if this it not the very first time the page is loaded (so there is no cache for DBs yet)
							if(!_pageLoadedFirstTime) ssData.delayedNotification.push({msg: "Có database <mark>" + _toLoadItemTmp.dbName + "</mark> mới được thêm vào app.", option: {duration: 1e4}});
						}
					}
					
					// if all data files having loadMode = 0 (no load) then mark the data_0 loadMode = 2 so there is at least one database to be loaded
					if(toLoadArr.every(_lm => _lm.loadMode == DBFiles.LMODE.noShow)){
						toLoadArr.find(_lm => _lm.fileNo == 0).loadMode = _DEF_LOADMODE; //load, use cache
					}
	
					//for item that has too many times fail when loading, just mark it to 'No show' so the page won't bother load it, except when its loadMode == 1 (forcing fresh load)
					toLoadArr.forEach((_dbItem, i) => {
						//mark no show if failCOunt > 10
						if(_dbItem.loadMode == DBFiles.LMODE.cacheLoad && _dbItem.failCount > _DB_MAX_FAILCOUNT) _dbItem.loadMode = DBFiles.LMODE.noShow;
					});
	
					ssData.jsDBFiles = []; //initialize jsFiles for deployDB() to put data into
	
					/* II.B downloading DBs from js script files and loading book data into the page */
	
					/** function to be invoked as a callback for importDBfromFiles() each time a script promise successfully loaded 
					 * @param _scriptElem {promise} the script promise that wrap script element
					*/
					const _promiseCB = _scriptElm => {
						const _extAttr = _scriptElm.extAttr;
						const _jsDBName = _extAttr.jsDBName; //something like 'data_0'
						//xDBFilesCfg.toLoad corresponding with current script
						const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
	
						//note that the case loadMode==noShow (0), importDBfromFiles() has taken care to delete the global variable for data that set hidden to save memory. Here, we only do the deploy data inside database that set to be shown: cacheLoad(2), freshLoad(1)
						if(_dbFileCfgItm.loadMode > 0)
							DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _extAttr.loadMode);
						else
							window[_jsDBName] = undefined;
					}
					//now, actually download the DB script file and deploy data inside (if DB is not in hidden mode), then run the init()
					DBFiles.importDBfromFiles(
						//mark that invoke from loadPage()
						0, 
						//callback function which will be invoked each time a DB script file is loaded succesfully
						_promiseCB,
						//callback function which is invoked when all DBs has been loaded (each might be sucessful or failed)
						init
					);
				})
				.catch(err => {
					console.error(err);
					alert("Không nạp được file config.js, trang Web không thể hoạt động.");
				});
			}
	</script>

	<!-- SMALL, HANDY NON-UI FUNCTIONS -beauty -->
	<script>
		"use strict";
		String.prototype.toProperCase = function () {
			return this.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
		};
		String.prototype.hashCode = function () {
			let hash = 0;
			if (this.length === 0) return hash;
			for (let i = 0; i < this.length; i++) {
				hash = ((hash << 5) - hash + this.charCodeAt(i)) | 0
			}
			return (hash >>> 0).toString(36)
		}
		/* Simple, small, useful functions */
		/* padding some char before a text 
			n: the number of text to be padded
			width: number of char to pad
			z: char to pad
		*/
		const pad = (n, width, z) => String(n+ '').padStart(width, z || '0'); // '0009'

		//make braket that enclose something store in let m
		const makeBrk = (m) => (m ? "[" + m + "]" : "" );
		//convert integer number to upper-roman form
		const int2Roman = (num) => {
			const romanValues = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
			let roman = '';
			for (let key in romanValues) {
				while (num >= romanValues[key]) {
					roman += key;
					num -= romanValues[key];
				}
			}
			return roman;
		}
		
		/* make inline svg from sprite embeded at the end of HTML
			_spriteName {string}: id of svg sprite stored in <symbol> element
			_options	{Json}, may have following attributes
				class	{string}: list of class	names
				style	{string}: inline style that customize UI of a paticular icon
				title	{string}: tooltip for current icon
		*/
		const makeSvgFromSprite = (_spriteName, _options) => {
			let _class = "", _inlineStyle = "", _title = "";
			if (_options) {
				if (_options.class) _class = `class="${_options.class}"`;
				if (_options.style) _inlineStyle = `style="${_options.style}"`;
				//if(_options.title) _title = `title="${_options.title}"`; //for now, svg not support title, so ignore this for now
			}
			return `<svg ${_class} ${_inlineStyle} ${_title}>
			<use href="#${_spriteName}"/>
		</svg>`;
		}
		//extract host name from an url
		/* const getHostName = (url) => {
			if (!url) return "";
			let regRet = url.match(/(\w+)\.\w{2,}(\/|\?|$)/); 
			return (Array.isArray(regRet) && regRet[1].toProperCase()) || "Link";
		}; */
		/* extract host name from an url using URL API which support by most of modern browser. This version work better than the above regEx version */
		const getHostName = (url) => {
			if (!url.trim()) return "";
			//using URL API to extract the hostname
			let domain = (new URL(url));
			//break hostname into parts
			let names = domain.hostname.split(".");
			names.splice(-1, 1); //remove the last part of hostname because it commonly is domain extension like net, com, gov, vn, us,..

			//for double extension like .com.vn, .net.au or .edu.uk, we need to get previous part of hostname
			if(names.length === 0) return 'Link'
			else{
				let hName = 'Link';
				if(['com','net','org','gov','edu','info'].includes(names.at(-1)) ) 
				hName = names.at(-2) ?? 'Link'
				else 
				hName = names.at(-1);
				//map the hostname with something shorter or more meaningful
				const _NamesMap = {
					'phatphapungdung' : 'PPƯD',
					'phapthihoi': 'PhápThíHội',
					'dieuphapam': 'DPA', //DiệuPhápÂm
					'tinhtong': 'PhápHành',
					'theravada': 'Theravāda',
					'thuvienanime': 'Tóm tắt',
					'audioaz': 'AudioAZ',

					'youtube': 'YT',
					'dropboxusercontent': 'Dropbox',
					'googleapis': 'Google'
				};

				return _NamesMap[hName] ?? hName.toProperCase();
			}
		};

		//format number with comma delimeter
		const commaNum = x => x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."); //x.toLocaleString(); 
		//convert duration string (such as '34:09', '01:05:28' to second in number
		const toSeconds = (str) => {
			if (!str) return 0;
			let t = str.split(':').map(n => { return isNaN(parseInt(n)) ? 0 : parseInt(n) });
			return t.reduce((r, elem) => r * 60 + elem, 0);
		}
		//convert total number of second to duration string format: HH:mm:ss, HH will be left out if HH=0
		/* const toHhMmSs = (sec) => {
			if (isNaN(sec)) return "00:00";
			
			sec = sec << 0; //make sec to be integer
			let h = (sec / 3600) << 0; sec = sec % 3600;
			let m = (sec / 60) << 0;
			let s = sec % 60;
			return (h ? commaNum(h) + ":" : "") + pad(m, 2) + ":" + pad(s, 2);
		} */

		/** convert second to a human-readable format
			* @param sec {number}: the amount of seconds to be formatted
			* @param _verbose (optional)
			* 		- missing or 0: format to HHHH:Mm:ss
			* 		- 1: format to DD Ngày, HH:Mm:ss
			* 		- 2: format to DD Ngày, HH Giờ, MM Phút, SS Giây
			*/
		const toHhMmSs = (sec, _verbose = 0) => {
			//check if sec is NaN or ±Infinity. In the case audio cannot be loaded, it seems that on window audio.duration return NaN, on iOs return Infinity (== Number.POSITIVE_INFINITY)
			if (!Number.isFinite(sec)) return "-:--";

			sec = Math.round(sec); //sec << 0; //make sec to be integer
			if (sec < 0) sec = -sec;
			if(_verbose < 2) {
				//convert second to Mm:Ss  no matter what
				const toMmSs = sec => pad(~~(sec / 60) % 60, 2) + ":" + pad(sec  % 60, 2);
				const mmss = sec % 3600;
				if(_verbose == 0) //HHHH:Mm:ss
					return (sec >= 3600? commaNum(~~(sec / 3_600)) +":" : "") + toMmSs(mmss);

				if(_verbose == 1){ //DD Ngày, HH:Mm:ss
					const d = ~~(sec / 86_400), h = ~~(sec / 3_600) % 24;

					return [d === 0? "" : commaNum(d) +  " ngày ⅋ ", // 🙵 ＆ ⅋ &
						h > 0? h +":" : "",
						toMmSs(mmss)].join("");
				}
			}

			if(_verbose == 2) //DD Ngày, HH Giờ, MM Phút, SS Giây
				return Object.entries({
					"ngày": ~~(sec / 86_400),
					"giờ":  ~~(sec / 3_600) % 24,
					"phút": ~~(sec / 60) % 60,
					"giây": sec  % 60
				})
					.filter(val => val[1] !== 0)
					.map(([key, val]) => `${val} ${key}`)
					.join(', ');			
		};

		/** A debounce function is a technique used to limit how often a function is executed, especially when it's called repeatedly in a short time (e.g., during user input, scrolling, or resizing). It waits for a pause in activity before calling the function.
		 * @param func {function} the function to be invoked only once after a certain delay has passed since the last time it was invoked.
		 * @param delay {number}: number of seconds to wait for once after a certain delay has passed since the last time it was invoked.
		 * @Usage debounce(func, 300)(...args) where ...args is arguments of func function
		 * @Usage
			const onScrollEnd = debounce(() => {
				// do expensive stuff once (e.g., analytics, lazy compute)
				console.log('scroll stopped');
			}, 200);
		 * @Usage with ResizeObserver: 
		 * 		const resizeObserver = new ResizeObserver( debounce(onResizeCallback, 200) ); (original is: new ResizeObserver(onResizeCallback) )
		 * 		
		 */
		function debounce(func, delay=100) {
			let timeoutId;
			return function (...args) {
				clearTimeout(timeoutId);
				timeoutId = setTimeout(() => { func.apply(this, args); }, delay);
			};
		}

		/** check if current OS is of a type
		 * @param type
		 * 		@value -1: check if is touchDevice
		 * 		@value 1: check if is Windows
		 * 		@value 2: check if is iOS or iPadOS
		 * 		@value 3: check if is MacOS
		 * 		@value 4: check if is Android
		 * 		@value 5: check if is Linux
		 * 
		*/
		function checkOS(type) {
			const userAgent = navigator.userAgent.toLowerCase();			

			//check if this is touch device
			if(type == -1) return (
					"ontouchstart" in window ||
					navigator.maxTouchPoints > 0 ||
					navigator.msMaxTouchPoints > 0
				);

			//check windows
			/* 
				Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
				Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
				Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 Edg/136.0.0.0
			 */
			if(type == 1) return userAgent.includes('windows nt');

			// /iphone|ipad|ipod/ is for safary. 'macintosh' for chrome, edge running on ios or ipadOS, note that on ios/ipados, chrome&edge also has userAgent.includes('mac os x') like in mac device
			/* 
				Safari on iPad:		Mozilla/5.0 (iPad; CPU OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1
				Edge on iPad: 		Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) EdgiOS/136 Version/16.0 Safari/605.1.15
				Chrome on iPad:	Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/136 Version/11.1.1 Safari/605.1.15
			 */
			if(type == 2) return /iphone|ipad|ipod|macintosh/.test(userAgent)  && !window.MSStream;

			//macos. Note that this also return true for chrome, edge running on ipadOS
			/* 
				macOS 10.15 (Catalina), Firefox 22.0
				Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/605.1.15 (KHTML, like Gecko) FxiOS/22.0 Safari/605.1.15

				macOS 10.15, Safari 13.0.5
				Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.5 Mobile/15E148 Safari/604.1
			 */
			//if(type == 3) return userAgent.includes('mac os x');

			//android
			/* 
				Samsung Galaxy Nexus, Chrome 18.0
				Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19

				Huawei VNS-L31, Chrome 75.0
				Mozilla/5.0 (Linux; Android 7.0; HUAWEI VNS-L31) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.101 Mobile Safari/537.36

				Android 7.0, Firefox Focus 8.0.15
				Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/8.0.15 Chrome/75.0.3770.101 Mobile Safari/537.36
			 */
			//if(type == 4) return userAgent.includes('android');

			//linux
			/* 
				Ubuntu, Firefox 34.0
				Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0

				Linux
				Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0

				OpenSUSE, Firefox 19.0.2
				Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 Firefox/19.0.2 
			*/
			//if(type == 5) return userAgent.includes('linux');

			/* work for now, but navigator.platform is depricated soon; navigator.userAgentData not yet widely supported (not supported in Safari, for now )
			function isWindowOS() {
				const 
					platform = window.navigator?.userAgentData?.platform || window.navigator.platform,
					//macosPlatforms = ['macOS', 'Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
					//iosPlatforms = ['iPhone', 'iPad', 'iPod'],
					windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
				return windowsPlatforms.includes(platform);
			} 
			*/
		}

		//get param from Url string
		/* function getUrlVars() {
			let vars = {};
			let parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi,
				function (m, key, value) {
					vars[key] = value;
				});
			return vars;
		} */

	</script>

	<!-- TOAST + PROTOTYPE FUNCTION THAT EFFECT UI -->
	<script>
		"use strict";
		/* Helper prototype for any HTML element that:
			- if attr is string - which is an element's attribute (e.g 'height'), it return Element.style[{that attribute}]
			- if attr is json (e.g {'height': 100px, 'font-size':17px} ), it will set the assigned value for an attribute
		*/
		Element.prototype.css = function (attr) {
			if (typeof attr === 'string') {
				return getComputedStyle(this, '')[attr];
			}
			else if (typeof attr === 'object') {
				for (let name in attr) {
					if (this.style[name] !== undefined) {
						this.style[name] = attr[name];
					}
				}
			}
		};

		/* Prototype for Audio element to get/set attribute */
		/* Element.prototype.attr = function (attrName, attrVal) {
			if (attrVal === undefined)
				return this.getAttribute("attr-" + attrName) || this.getAttribute(attrName);
			else {
				this.setAttribute("attr-" + attrName, attrVal);
			}
		} */

		/** Toast class to show multiple toasts at a time 
			@config toastConfig {JSON}: setting for toast, including:
				mode {integer}, location {string}: 		the Toast them mode, also define location of the toast
				theme {integer}, themeName {string}: 	define theme light(0) or dark(1)
				animMode {integer}, animName {string}:	define the type of animation, which is bounce(0), slide(1), flip(2), zoom(3)
				animDir{integer}, animDirName {string}:	For 'bounce' and 'slide' animation, this param define the animation direction, depend on the location of toast. E.g, location at "Bottom-Right", there will be two animMode which is in/out of Bottom and in/out of Right
			Example of one toastConfig
				{
					"mode": 3, "location": "Bottom-Left",
					"theme": 1, "themeName": "toast-dark-theme",
					"animMode": 0, "animName": "bounce",
					"animDir": 0, "animDirName": "Bottom"
				}
			
			This Toast object support callback when a toast about to vanish (because of timeout has reached to the end Or user click on the toast to vanish it). Example
				- toast.showToast("Tesst callback", toast.ToastType.Error, {duration: 1.5e4, cbEnd: _ => {console.log('Callback End')} } );
				- ssData.delayedNotification.push({msg: "Tesst callback", option: {duration: 1.5e4, cbEnd: _ => {console.log('Callback End')} }}); toast.showDelayedToast();
				TODO: need to add callback support for ChainToast and promise toast
		*/
		let Toast = function ToastObj() {
			/* For manual mode, we need to calculte location of new Toast so that it can be in-between shown Toasts if there is a gap which big enough */
			function locateToastManually(toastElem) {
				const BOTTOM_START = 20, TOAST_GAP = 10; //Toast bottom start and gap between Toasts
				//find the bottom, so new Toast not overlap old ones that has not been removed
				toastElem.setAttribute("newToastAdded", ""); //this attribute help to know this is newly added Toast
				let _toastElems = document.querySelectorAll(".toast-element:not([newToastAdded])"); //get all Toasts except the new added one
				toastElem.removeAttribute("newToastAdded"); //remove this attribute for the next added Toast (if any)

				// array store CSS bottom property and dimension of all currently displaying Toasts. The first item here is the fake element to shorten the code below. rect.top of this first element make the effect as css setting: 'bottom: {BOTTOM_START}px' from bottom of screen
				let _allToastSizes = [{ cssBottom: BOTTOM_START - TOAST_GAP, txt: "Dummy Marking Toast", rect: { top: window.innerHeight - BOTTOM_START + TOAST_GAP, height: 0 } }];
				_toastElems.forEach(_elm => {
					// cssBottom: =style.bottom property, measured from bottom of screen. 
					// rect: dimension of element, all measured from top-left of screen
					// txt: content of the Toast, for debugging only, can be removed
					_allToastSizes.push({ cssBottom: parseInt(_elm.style.bottom), txt: _elm.innerText, rect: _elm.getBoundingClientRect() });
				});

				//sort in ascending order of {cssBottom} buttom property, meaning the Toast element from bottom to up
				_allToastSizes = _allToastSizes.sort((a, b) => a.cssBottom - b.cssBottom);
				let _thisCSSBottom = BOTTOM_START; // the css bottom need to be calculated for new Toast
				let _currHeight = toastElem.getBoundingClientRect().height; //height of current Toast

				//func to calculate bottom property of Toast[i]'s next Toast should be
				let calNextBottom = i => {
					return _allToastSizes[i].cssBottom + _allToastSizes[i].rect.height + TOAST_GAP;
				}

				if (_allToastSizes.length > 1) { //beside fake element, this mean if there is at least one Toast still shown
					// go from screen's bottom up to find if there any space that can display the new Toast
					for (let i = 1; i < _allToastSizes.length; i++) {

						let _prevTop = _allToastSizes[i - 1].rect.top;
						let _nextBottom = _allToastSizes[i].rect.bottom;
						//console.log(`${_prevTop - _nextBottom} : ${_currHeight}`);

						if (_prevTop - _nextBottom > _currHeight + TOAST_GAP) {
							//found a gap which large enough to place new Toast, then this Toast would locate within this gap, right above of Toast[i-1]
							_thisCSSBottom = calNextBottom(i - 1);
							break;
						}

						//if reach to last Toast without found any larg-enough gap, make new Toast right above the last one
						if (i == _allToastSizes.length - 1) _thisCSSBottom = calNextBottom(i);
					}

				}
				// make bottom change to Toast element
				toastElem.style.bottom = _thisCSSBottom + "px";
			}

			// fun-purposed function utilizing internal variable to count the number of Toast
			function toastCounter() {
				return toastCounter.count++;
			};
			toastCounter.count = 0; //this simulate internal variable that keeps through multiple toast request

			let toastConfig = null;
			function getToastConfig(){return toastConfig};

			//Cannot use Object.freeze for toastChoices because animDirs attribute need to add to this object depending on modes and animation types
			const toastChoices = {
				modes: ["manual-Bottom-Left", "Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"],
				modes_weighted: [1, 2, 2, 2, 20], //weighted for modes when randomly choose
				themes: ["toast-light-theme", "toast-dark-theme", "toast-color-theme", "toast-mono-theme"],
				themes_weighted: [1, 1, 1, 8], //weighted for themes when randomly choose
				animations: ["bounce--m", "slide--m", "elliptic--m", "zoom", "flip--i", "swirl", "slit--i"],
				/** From name of animation (such as 'bounce--m' or 'slit-i') to generate possible animation direction. See inside function for more detail
					@param _animName {string}: the name of animation
						- animation with suffix '--m' (moving): the toast will move from outside of screen into viewport following x or y axis
						- animation with suffix '--i' (in-place): the toast will twisted in-place in vertical or horizontal
					@param _location {string}: the name of location of Toast container, which define possible direction for animation with --m
				@return: { anim: (name of animation), dir: (array of possible directions or null), animTimeFnc: animation time function }
				*/
				posssibleAnimDirs : function(_animName, _location){
					let _regEx = _animName.match(/\-\-([mi]+)/);
					let _animTimeFnc = ["ease-out", "ease-in"];
					if( _animName.match(/^(bounce|zoom|flip)/) ) _animTimeFnc = ["cubic-bezier(.68,-0.55,.4,1.6)", "cubic-bezier(.68,-0.55,.26,1.35)"];

					//note that _animName must be lower-case
					if(!_regEx) return {anim: _animName, dir: null, animTimeFnc: _animTimeFnc};

					_animName = _animName.replace(_regEx[0],""); //remove the --mi trailing
					
					
					if(_regEx[1] == 'm'){
						let _sides = _location?_location.split("-").slice(-2) : [];
						_sides = _sides.map(_side => _side.toProperCase()); //change direction to proper-case
						//if(_sides.length == 2){ toastChoices["animDirs"] = _sides; }
						return {anim: _animName, dir: _sides.length == 2? _sides: null, animTimeFnc: _animTimeFnc};
					}

					if(_regEx[1] == 'i'){
						return {anim: _animName, dir: ["Horz","Vert"], animTimeFnc: _animTimeFnc};
					}
				}
			};

			/** Adapt from https://trekhleb.medium.com/weighted-random-in-javascript-4748ab3a1500
				* Picks the random item based on its weight.
				* The items with higher weight will be picked more often (with a higher probability).
				*
				* For example:
				* - items = ['banana', 'orange', 'apple']
				* - weights = [0, 0.2, 0.8]
				* - weightedRandom(items, weights) in 80% of cases will return 'apple', in 20% of cases will return
				* 'orange' and it will never return 'banana' (because probability of picking the banana is 0%)
				*
				* @param {any[]} items
				* @param {number[]} weights
				* @returns {{item: any, index: number}}
				*/
			/* eslint-disable consistent-return */
			function weightedRandom(items, weights) {
			if (items.length !== weights.length) {
				throw new Error('Items and weights must be of the same size');
			}

			if (!items.length) {
				throw new Error('Items must not be empty');
			}

			// Preparing the cumulative weights array.
			// For example:
			// - weights = [1, 4, 3]
			// - cumulativeWeights = [1, 5, 8]
			const cumulativeWeights = [];
			for (let i = 0; i < weights.length; i += 1) {
				cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0);
			}

			// Getting the random number in a range of [0...sum(weights)]
			// For example:
			// - weights = [1, 4, 3]
			// - maxCumulativeWeight = 8
			// - range for the random number is [0...8]
			const maxCumulativeWeight = cumulativeWeights[cumulativeWeights.length - 1];
			const randomNumber = maxCumulativeWeight * Math.random();

			// Picking the random item based on its weight.
			// The items with higher weight will be picked more often.
			for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
				if (cumulativeWeights[itemIndex] >= randomNumber) {
				return {
					item: items[itemIndex],
					index: itemIndex,
				};
				}
			}
			}
			/* Function to make random configuration for Toast */
			function setToastMode() {
				function getChoice(_choiceName, _testChoice){
					let _choiceArrayName = _choiceName + "s";
					let _choiceIdx = _testChoice ?? xState.toastCfg?.[_choiceName] ?? -1;
					//if no specific choice, choose randomly
					if(_choiceIdx == -1)
						//if current choice has weight, choose randomly based on weight
						if(toastChoices.hasOwnProperty(_choiceArrayName + "_weighted"))
							_choiceIdx = weightedRandom(toastChoices[_choiceArrayName], toastChoices[_choiceArrayName + "_weighted"]).index;
						else
							//otherwise, just choose pure-randomly
							_choiceIdx = Math.floor(Math.random() * toastChoices[_choiceArrayName].length);
					return [_choiceIdx, toastChoices[_choiceArrayName][_choiceIdx]];
				}				

				/* Choose theme light or dark for this session 
				toastTheme  = 0: light theme "toast-light-theme"
							= 1: dark theme	"toast-dark-theme"
				*/
				const [_theme, _themeName] = getChoice("theme");

				/* get random value between 0 and 1 to decide Toast mode for current page session.
				toastMode   = 0:   manual mode, on left side. "manual-Bottom-Left"
							= 1-4: auto mode on Bottom/Top-Right/Left side: "Bottom-Right", "Top-Right", "Bottom-Left", "Top-Left"
					For 4 Auto-mode, the name of the mode IS the location of toast Container
				*/
				const [_mode, _containerLocation] = getChoice("mode");

				/* Animation mode, one of "bounce", "slide", "flip", "zoom", "swirl", "diagFlip" */
				let [_animMode, _animName] = getChoice("animation");

				//update toast
				toastConfig = { 'mode': _mode, 'location': _containerLocation, 'theme': _theme, 'themeName': _themeName, 'animMode': _animMode };

				let _toastContainer = document.querySelector(`[name="toastContainer"][location="${_containerLocation}"]`);
				if(!_toastContainer){ //create if it is not existed yet
					_toastContainer = document.createElement("DIV");
					_toastContainer.setAttribute("name", "toastContainer");
					document.body.appendChild(_toastContainer);
				}
				_toastContainer.setAttribute("location", _containerLocation);
				
				// Default dir value for animation having no direction such as zoom, flip, swirl, ... 
				let [_animDir, _animDirName] = [-1, ""];
				let _possAnimDirs = toastChoices.posssibleAnimDirs(_animName, _containerLocation);
				_animName = _possAnimDirs.anim;
				let _animTimeFnc = _possAnimDirs.animTimeFnc;

				/* for bounce and slide only: direction of animation, depend on location of the toast elements */				
				// if there are animation possible directions
				if(_possAnimDirs.dir !== null){
					toastChoices["animDirs"] = _possAnimDirs.dir;
					[_animDir, _animDirName] = getChoice("animDir");
				}
				
				// unique animation for Toast manual mode, because other mode messes the toast bottom, hence the locateToastManually() does not work correctly
				if (_mode == 0) {
					[_animName, _animDir, _animDirName] = ["slideManual", -1, ""];
					_animTimeFnc[1] = "cubic-bezier(.68,-0.55,.26,1.35)";
				}
				
				toastConfig['animName'] = _animName;
				toastConfig['animDir'] = _animDir;
				toastConfig['animDirName'] = _animDirName;
				toastConfig['animTimeFnc'] = _animTimeFnc;
				
				//return toastConfig;
				//console.log(toastConfig);
			}
			setToastMode();

			// a local variable, if is set to TRUE, the next Toast request will be depressed the Toast from showing
			let depressToastFlag = false;
			/* get/set depressToastFlag. When user call depressToast(true), the next toast will be depressed */
			function depressToast(flag){
				if(flag == undefined) return depressToastFlag
				else depressToastFlag = flag;
			}

			// enum of Types of Toast allowed. Using Object.freeze to prevent this being changed, which make toastChoices to be an enum
			const ToastType = Object.freeze({
				Infor: "Infor",
				Success: "Success",
				Warning: "Warning",
				Error: "Error",
				Promise: "Promise"
			});

			/* Check if current Toast is one of 4 basic types "Infor", "Success", "Warning", "Error" */
			function isBasicType(_toastType) {
				return !(_toastType == ToastType.Promise);
			}

			/* set default duration before being removed for each Toast type */
			function defaultDuration(_toastType) {
				let _defaulDur = 2000;
				switch (_toastType) {
					case ToastType.Success:
						_defaulDur = 2000;
						break;
					case ToastType.Infor:
						_defaulDur = 3000;
						break;
					case ToastType.Warning:
						_defaulDur = 4000;
						break;
					case ToastType.Error:
					case ToastType.Promise:
						_defaulDur = 5000;
						break;
					default:
						_defaulDur = 2000;
				}
				return _defaulDur;
			}

			const DEBUG = false; //set true to debug, the toast not disapeared

			/**	Create new toast element or (for toast created in Promise type only) update its content
				@param _msg {string, required}: message to show
				@param _toastType (optional): value of Toast.ToastType enum. Default Toast.ToastType.Infor
				@param _showDuration {integer, optional}: duration (in ms) the toast appear. See defaultDuration() above for default duration for each ToastType
				@param options {json}
					@property oldToastElem {HTMLElement}: the toast has created at last phase. If this is undefined, this is in-phase where we need to create toast element and add to DOM
					@property duration {integer}: duration to show the toast before it disappear, duration only have effect on out-phase to wait the time before removing Toast out of DOM
					@property persistance {boolean}: true then this Toast would not be wiped out by basic dismissAll() function (see that function for more)
					@property out {boolean}: specify this is at out-phase
					@property cbEnd {function}: callback function that if is spedified, will be invoked when the toast end and about to vanish
				*/
			function makeToast(_msg, _toastType, options) {
				
				_toastType = _toastType ?? ToastType.Infor;
				//console.log("Toast No: " + toastCounter() );
				let _duration = Math.max(options?.duration ?? 0, defaultDuration(_toastType)); //at least Default duration for each Toast type
				_duration += 2000;
				const _PERSISTANCE = options?.persistance ?? false;

				//constant to mark if current is in/out phase, maybe none or both of it
				const _inPhase = options?.in ?? (options?.oldToastElem ? false : true);
				const _outPhase = options?.out ?? isBasicType(_toastType); //if not specify, this is out phase if toast type is one of first 4 basic type 

				//make phase: create the new Toast element.  update phase: use the toastElem has create before to update content
				let toastElem = _inPhase ? document.createElement('div') : options?.oldToastElem;
				/* if(!toastElem) {
						console.log("Toast is null because both options.in = false and options.oldToastElem = undefined");
						return;
				} */

				if (_inPhase) { //make phase
					toastElem.setAttribute("toast-no", toastCounter()); //just for fun
					if(_PERSISTANCE) toastElem.setAttribute("isPersistance", true);
					toastElem.classList.add(toastConfig.themeName);
				}
				else { //update or out phase
					//search and remove old toast-type
					toastElem.classList.forEach(_cls => {
						if (_cls.indexOf("toast-type--") > -1) toastElem.classList.remove(_cls)
					});
					//in case toastElem has been removed by click on the toast
					if (!document.contains(toastElem)) {
						console.log("Toast has been removed");
						return;
					}
				}

				//add class to define toast basic css, type customized css and theme light/dark
				toastElem.classList.add("toast-element", `toast-type--${_toastType}`);
				toastElem.innerHTML = `
				<div class="toast__icon">${makeSvgFromSprite("svgIconToast" + _toastType)}</div>
				<div class="toast__msg">${_msg}</div>
				<div class="toast-progress"></div>
				`;

				//set in & out animation for toast 
				const ANIM_IN_DUR = 500, ANIM_OUT_DUR = 500;
				let _delay = _duration - ANIM_IN_DUR - ANIM_OUT_DUR;
				//console.log(`Toastify__${toastConfig.animName}In${toastConfig.animDirName}`);
				const _IN_ANIMATE = `Toastify__${toastConfig.animName}In${toastConfig.animDirName} ${ANIM_IN_DUR}ms ${toastConfig.animTimeFnc[0]}`,
				_OUT_ANIMATE_CLICK = `Toastify__${toastConfig.animName}Out${toastConfig.animDirName} ${ANIM_OUT_DUR}ms ${toastConfig.animTimeFnc[1]} forwards`,
				_OUT_ANIMATE = _OUT_ANIMATE_CLICK.replace(' forwards', ` ${_delay}ms forwards`); //in and out animation 
				//linear ease-in
				//console.log(_OUT_ANIMATE_CLICK);

				if (toastConfig.mode == 0) { //manual mode, locate on left-bottom
					toastElem.classList.add("toast-manual");
					_inPhase && document.body.appendChild(toastElem);
					if (_inPhase) locateToastManually(toastElem);
				}
				else { //auto mode, locate at right-bottom
					toastElem.classList.add("toast-auto");
					_inPhase && document.querySelector(`[name="toastContainer"][location="${toastConfig.location}"]`).appendChild(toastElem);
				}

				let _animationStr = "";
				if (_inPhase) { //making in-animation for in-phase
					_animationStr = _IN_ANIMATE; //in make phase, always show in-animation
				}
				if (_outPhase) { //making in-animation for out-phase
					//make phase with one of first 4 ToastType, meaning this is just normal notification toast, then both animations are shown
					if (!DEBUG) _animationStr += (_animationStr == "" ? "" : ", ") + _OUT_ANIMATE;
				}
				if (_animationStr) toastElem.style.animation = _animationStr;

				//handle on click to Toast to remove it, add right when toast element is created and add to DOM at in-phase
				if (_inPhase)
					toastElem.addEventListener("click", (evt) => {
						// add out-effect animation
						toastElem.getAnimations().forEach(_anim => { _anim.finish(); }); //finish old animations if any
						toastElem.style.animation = _OUT_ANIMATE_CLICK;
						let _newAnmations = toastElem.getAnimations();
						if (Array.isArray(_newAnmations) && _newAnmations.length > 0) _newAnmations[0].play(); // run animation right-away

						//wait animation to finish then remove the toastElem
						setTimeout(function () {
							//invoke the 'end' callback if there is any
							options.cbEnd && options.cbEnd();

							//remove toastElem out of DOM and out of memory
							if(toastElem) toastElem.remove(); 
							toastElem = null; 
						}, ANIM_OUT_DUR + 50);

						//this is important. This is to avoid the click event bubbling up, some place above in DOM might catch it and works improperly (such as closeIfClickedOutside in Search-Dropdown class)
						evt.stopPropagation();
					});

				let _progressBar = toastElem.querySelector(".toast-progress");
				_progressBar.classList.toggle('elm-hidden', !_outPhase);
				if (_outPhase && !DEBUG) { //remove toast Element out of DOM at out-phase
					// start couting-down progress-bar (at starting of and) only when at out-phase
					_progressBar.style.animation = `progress-keyframe ${_delay}ms linear forwards`;

					// set duration to remove Toast
					const autoRemoveTO = setTimeout(function () {
						//remove toast element out of DOM 
						toastElem.remove(); 
						//clean the toastElem variable (I don't know if this is right way to do that)
						toastElem = null; 
						//invoke the 'end' callback if there is any
						options.cbEnd && options.cbEnd();
					}, _duration);
					toastElem.addEventListener("click", () => {
						// stop and clear the timeOut above
						clearTimeout(autoRemoveTO);
					});
				}

				//return toastElem for ChainToasts, promise function
				if (_inPhase && !_outPhase) return toastElem;
			}

			/* Function to remove all living toast 
				@param isExtensiveWipe {boolean}: 
					- false or missing: only wipe out basic toasts which wasn't created with option.persistance = true (those toast do not have attribute {isPersistance})
					-true: wipe all toasts, no matter its {isPersistance} attribute
			*/
			function dismissAll(isExtensiveWipe) {
				document.querySelectorAll(`.toast-element${isExtensiveWipe?"":":not([isPersistance])"}`).forEach(_toastElem => _toastElem.click());
			}
			/** Showing Basic Toast message, which has only single message
				@param msg {string}: the message to show
				@param toastType {enumerate}: define the background color of the toast. Has to be a value of enum Toast.ToastType. Default is Toast.ToastType.Infor
				@param options {json}. See the makeToast() function for full list of options attribute
					@property {duration} {integer}: number of millisecond the toast appear before being removed. Default: depend on ToastType, set in makeToast()
					@property {persistance} {boolean}: true if this toast not be wiped out by basic dismissAll()

			*/
			function showBasicToast(msg, toastType, options) {

				if (depressToastFlag) { //if the Toast not allow to show
					depressToastFlag = false; //turn back the flag
					return;
				}

				// There is no Toast when pages is hidden
				if (document.hidden) return;
				
				// make and show the Toast
				makeToast(msg, toastType, { duration: options?.duration ?? 2000, persistance: options?.persistance ?? false, out: true, cbEnd: options?.cbEnd });
			}
			/** Showing Delayed Toast message, which has only single message. Show the delayed message which usually from loadPage() when toast object has not been initialized. See the makeToast() function for full list of options attribute
			*/
			function showDelayedToast() {

				//delayed message stored in ssData.delayedNotification
				if (!ssData.delayedNotification || ssData.delayedNotification.length === 0) { //if there is no delayed message
					return;
				}
				ssData.delayedNotification.forEach(_msg => {
					showBasicToast(_msg.msg, ToastType.Infor, { duration: _msg.option.duration, persistance: true, cbEnd: _msg.option.cbEnd })
				});
				//clear all delayed Notification
				ssData.delayedNotification.length = 0;
			}

			/* Chained toast class which handle multiple message on the same toast element. The incoming messages can be shown on-the-fly (using showNextToast) until the last one is called using checkoutToast()
			Different from promise() method wich also support to show multiple messages
			*/
			class ChainToasts {
				_localToastElem = null;
				/* constructor and show the initial message, remember the Toast element
					@param options {json}
						- persistance: true if this toast not be wiped out by basic dismissAll()
					*/
				constructor(msg, toastType, options) {
					if (depressToastFlag) { //if the Toast not allow to show
						depressToastFlag = false; //turn back the flag
						this._localToastElem = null;
						return ;
					}

					// There is no Toast when pages is hidden
					if (document.hidden) {
						this._localToastElem = null;
						return ;
					}

					this._localToastElem = makeToast(msg, toastType ?? ToastType.Promise, {persistance: options?.persistance ?? false});
				}

				// show the next Toast message, but this should not be the last one			
				showNextToast(msg, toastType) {
					// if somehow this chain has been checkouted before by the call chainToasts.checkoutToast()
					if (!this._localToastElem || !document.contains(this._localToastElem)) return;

					makeToast(msg, toastType ?? ToastType.Promise, { oldToastElem: this._localToastElem, in: false, out: false });
				}

				// show the last Toast message and counting down to remove Toast element out of DOM
				checkoutToast(msg, toastType) {
					// if somehow this chain has been checkouted before
					if (!this._localToastElem || !document.contains(this._localToastElem)) return;

					makeToast(msg, toastType ?? ToastType.Success, { oldToastElem: this._localToastElem, in: false, out: true });
					//console.log(this);
					this._localToastElem = null; //delete variable
				}
			}

			/* toast.promise let pre-define messages for each state of promise. And this will show pre-defined message corresonding with .then or .catch of the promise
			Usage see: 
				toast.promise( fetchPromise,
				{
					pending: 'Đang lấy dữ liệu dung lượng file',
					success: 'Đã lấy được dữ liệu dung lượng file 👌',
					error: 'Không lấy được dữ liệu dung lượng file 🤯'
					persistance: false
						Set true if this toast not be wiped out by basic dismissAll()
				})
			*/
			function promise(_promise, options) {
				let toastElem = makeToast(options.pending, ToastType.Promise, { persistance: options?.persistance ?? false, out: false });
				_promise.then(_ => {
					document.contains(toastElem) && makeToast(options.success, ToastType.Success, { oldToastElem: toastElem, in: false, out: true })
				}
				)
					.catch(_err => {
						document.contains(toastElem) && makeToast(makeBrk(_err.message) + " " + options.error, ToastType.Error, { oldToastElem: toastElem, in: false, out: true })
					}
					);
			}

			/* Public enum, class and method */
			return {
				depressToast: depressToast,
				ToastType: ToastType, //enum of all toast type
				toastChoices: toastChoices, //json
				getToastConfig: getToastConfig, //this for debug only, can be removed
				setToastMode : setToastMode,
				showToast: showBasicToast,
				showDelayedToast: showDelayedToast,
				ChainToasts: ChainToasts, //class
				promise: promise,
				dismissAll: dismissAll
			}
		}

		/* This function for debug Toast only. Can be removed */
		/* function testToast() {
			const functionThatReturnPromise = new Promise((resolve, reject) => {
				setTimeout(resolve, 2000);
			});

			//create ChainToasts object
			let chainToast = new toast.ChainToasts("Promise is pending");
			functionThatReturnPromise.then(_ => {
				chainToast.showNextToast("Done with 2s wait, now wait 1s more"); //, toast.ToastType.Infor
				return new Promise((resolve, reject) => { // (*)
					setTimeout(resolve, 1000);
					//throw new Error("Test error");
				});
			})
				.then(_ => {
					chainToast.checkoutToast("Promise resolved 👌", toast.ToastType.Success);
					chainToast = null;
				})
				.catch(err => {
					chainToast.checkoutToast("Promise rejected 🤯" + err, toast.ToastType.Error);
				})

			return;
			toast.promise(
				functionThatReturnPromise,
				{
					pending: 'Promise is pending',
					success: 'Promise resolved 👌',
					error: 'Promise rejected 🤯'
				}
			)
		} */
		
	</script>

	<!-- ***** BIG FUNCTIONS THAT DEAL WITH BOOK DATA, GROUP/CATEGORY ***** -->
	<script>
		"use strict";
		
		/* IMPORTANT FUNCTION to prepare books/chapters data (and related data such as bookKitInfor, xBookGrp, xData) for the page to be built-on. It also create, populate and handle event for ssData.sddBooks, ssData.sddChaps and selBookGrp */
		function BookData() {
			const xBookGrp = ssData.xBookGrp; //abbreviate for xBookGrp
			//ssData.xData = [];
			let xData = ssData.xData; //abbreviate for xData

			/** 
				*  Useful function using outside
				*/
			/* Function to find the book from xData by bookId */
			const findBookFromId = (bookId) => {
				const _bIdx = ssData.bIds.indexOf(bookId);
				return bookId == -1? null : ssData.xData[_bIdx];
			};

			const statisticsHTML = (_statsData, _forceTextLeft = false) => {
				const _class = _forceTextLeft ? "class='forceTextLeft'" : "";
				return `<span ${_class}>${makeSvgFromSprite("icnSvgChapters",{class:"svg-img-infor"})}<var data-rAlignGroup="chapsCount">${_statsData.chaptersCount}</var>
					${makeSvgFromSprite("icnSvgDuration",{class:"svg-img-infor"})}<var data-rAlignGroup="bDuration">${toHhMmSs(_statsData.totalDur)}</var>
					${makeSvgFromSprite("icnSvgListenTime",{class:"svg-img-infor"})}<var data-rAlignGroup="bListenTime" style="font-size:inherit" attr-duration="${_statsData.totalDur}">${toHhMmSs(_statsData.totalDur / xState.audio.speed)}</var></span>`;
			}
			/* Based on the order of each book set, calculate the rank for each book kit (which actually the rank of avarage order of all book sets belong to a book kit) and save these information in ssData.bookKitInfor. This information will be used to sort bookKits in Setting modal in 'Book Kit view' mode */
			function calculateBookKitRank(_grpLine) {
				let _bookGrps = xBookGrp[_grpLine].grp;
				//grpRanks store rank (order) of each book kit for each group line that user re-arrange
				const bookKitInfor = ssData.bookKitInfor;
				for (let i = 0; i < bookKitInfor.length; i++) {
					let bkInforItemRank = bookKitInfor[i].grpRanks;
					if (!bkInforItemRank || !Array.isArray(bkInforItemRank))
						bookKitInfor[i].grpRanks = new Array(xBookGrp.length).fill(-1); //if not yet created, create new one with all -1
				}

				let _tempRank = bookKitInfor.map(_it => { return { bkId: _it.bkIdx, count: 0, rank: 0 } });
				for (let i = 0; i < _bookGrps.length; i++) {
					let _bkFather = _bookGrps[i].bookKit;
					/* if(_bkFather == undefined){
						// This is the case meta.bookGrp has group config but no book belong to
						toast.showToast(`The group named '${_bookGrps[i].label}', gId='${_bookGrps[i].gId}' in meta.bookGrp has no book belong to. FIXED IT NOWW`, toast.ToastType.Error, {duration:6e4, persistance: true});
						//create some dummy data for the other part of page could work
						_bookGrps[i].bookKit = -1;
						_bookGrps[i].books = [];
						continue;
					} */
					_tempRank[_bkFather].count++;
					_tempRank[_bkFather].rank += i;
				}
				// get the avarage rank of all book sets for each book kit
				_tempRank.forEach( _it => _it.rank = (_it.rank / _it.count).toFixed(2) );
				_tempRank.sort((a, b) => a.rank - b.rank); //sort ranks

				//update rank for the book kit
				for (let i = 0; i < _tempRank.length; i++) {
					let _tempItem = _tempRank[i];
					bookKitInfor[_tempItem.bkId].grpRanks[_grpLine] = { bsCount: _tempItem.count, rank: i, bsHidden: 0 }; //bsCount = book-set count, count number of book sets. bsHidden: book set hidden, count the number of hidden book set(s)
				}
				/* III. Update something more...? */
			}

			/** 
				*  Main functions of BOOKDATA
				*/

			/* Prepare, collect, update all data (see each step for more detail) for page to work.
			Because of storage and performance reason, some data is store separatedly (such as book group/category is stored in xBookGrp variable, but its configuration like visible/hidden, their display order is stored in xState.grpCfg) and need to gather back to some app variable for the app to work correctly
			This is called one time on init() */
			function prepareData() {
				/* STEP A: unite (shallow copy - of course) all book information (which seperated for the easy of code management) into single variable and update some purposedly missing properties*/
				
				//Merge all single database (each of them is one item in ssData.dbRawData) into big one (xData, xBookGrp) and get the start index of each of after being merged.
				let _idx = 0, _xData = [];
				//Variable {dataSize} is used to built ssData.bookKitInfor and get bookKit father id for each bookSet in xBookGrp 
				let dataSize = [{ idx: 0, name: "", eName: "" }];
				//iterate through each DB file having loadMode cacheLoad(2) or freshLoad(1)
				ssData.jsDBFiles.filter(_dbFile => _dbFile.loadMode > 0).forEach(_dbFile => {
					const _dbFileName = _dbFile.dbName; //the name of DB file also the name of DB variable that file contain, such as data_0 (without '.js' extension)

					//iterate through each bookKit inside DB variable (each DB file has only one DB variable with the same name, such as data_0)
					_dbFile.dbs.forEach(_db => {
						const _CnstData = window[_dbFileName][_db]; //the bookKit data, such as lotr_Data
						if(!_CnstData) return;
						// merge all definition for group book of each book kit into xBookGrp variable
						for (let i = 0; i < xBookGrp.length; i++) {
							xBookGrp[i].grp = xBookGrp[i].grp.concat(_CnstData.meta.bookGrp[i]);
						}

						//add information for the bookKit and the DB variable that contain each book
						_CnstData.books.forEach((_book, i) => _book.dbPath = {file: _dbFileName, bookKit: _db, idx: i});

						// merge all the books information to xData variable
						_xData = _xData.concat(_CnstData.books);
						// return the start index and the name of current book kit in xData
						_idx += _CnstData.books.length;
						dataSize.push( {idx: _idx, name: _CnstData.meta.name, eName: _CnstData.meta.eName} );
					})
				});
				ssData.xData = _xData; //store in session data for extensive use later
				//put books Ids into an array for quick search later 
				ssData.bIds = ssData.xData.map(_book => _book.bookId);
				// appoint the minimum size of a chapter group (which in Vietnamese is Tập) 
				ssData._MIN_TAP_SIZE = 5;

				/* STEP B: restore xSate from localStorage of last session. This has been moved to loadPage() */
				
				/* STEP C: This step to find id of each book and put it in the correspoding group and sub-group for each of the group way defined in const xBookGrp. 
				By the same time, create ssData.bookKitInfor variable
				*/

				/* STEP C1: Group 0 is so much different from the other two group ways, so it need to treat differently 
				By the same time, create ssData.bookKitInfor variable
				*/
				let bookGrpWay = 0; //this special categorization always at index 0
				//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
				let _bookGrpItems = xBookGrp[bookGrpWay].grp;

				let bkInfor = []; //based on xBooGrp[0] to create array of book Kit information
				for (let i = 0; i < _xData.length; i++) {
					let _grpIds = _xData[i].grp[bookGrpWay].split("$"); //in the form "SH.A1$1" or "HP.TAP7$4"
					let _bookGrpItm = _bookGrpItems.find(m => m.gId == "$" + _grpIds[1]); //find the item of _bookGrpItems that has gId is something like $1, $4
					if(!_bookGrpItm){ //if not found because of database error
						toast.showToast(`Book '${_xData[i].title}' has wrong group config at line '${bookGrpWay}'. Group '${_grpIds[1]}' in '${_xData[i].grp[bookGrpWay]}' not found on meta.bookGrp`, toast.ToastType.Error, {duration: 6e4, persistance: true});
						continue;
						//this handle the case that Books has a 'grp' config that meta.bookGrp does not have. The case meta.bookGrp has group config but no book belong to is handled in setting.calculateBookKitRank
					}

					if (!_bookGrpItm.books) _bookGrpItm.books = []; //create array that will store books of this categories, e.g, $1 will store 4 novel (Tieu thuyet) A1->A4 of Sherlock Holmes

					let _bkIdx = dataSize.findIndex((_currVar, _idx) => { return _idx == dataSize.length - 1 ? _currVar.idx >= i : _currVar.idx <= i && dataSize[_idx + 1].idx > i }); //find index of book kit
					//create information for each Book Kit
					if (_bkIdx > -1 && !bkInfor[_bkIdx]) bkInfor[_bkIdx] = { bkIdx: _bkIdx, startIdx: dataSize[_bkIdx].idx, endIdx: dataSize[_bkIdx + 1].idx - 1, label: dataSize[_bkIdx + 1].name };

					if (!_bookGrpItm.hasOwnProperty("bookKit")) _bookGrpItm.bookKit = _bkIdx; //update Book Kit for current Book set. 

					let _bookItem = _bookGrpItm.books.find(m => m.gbId == _grpIds[0]);
					if (_bookItem == undefined) { //if there is no data for this book yet?
						_bookItem = {};
						_bookGrpItm.books.push(_bookItem); //create new item for xBookGrp[0].grp
						_bookItem.gbId = _grpIds[0]; //group book id, part of grp[0]. E.g, grp[0]="SH.A1$1", then gbId="SH.A1"
						//_bookItem.bookId = _xData[i].bookId; //hard-coded 8 chars Book Id
						_bookItem.bName = _xData[i].title; //eTitle
						_bookItem.mc = _xData[i].mc; //mc and year are extra infor to quickly build book item for elmSelBookTitles
						_bookItem.year = _xData[i].year;
						_bookItem.bList = [_xData[i].bookId]; //list of bookId of xData items that is the same book but different MC
					}
					else {
						_bookItem.bList.push(_xData[i].bookId); //just add bookId of this item to book List
					}
				}
				ssData["bookKitInfor"] = bkInfor; //done building ssData.bookKitInfor

				/* STEP C2: Collect group information for grpWay 1,2,.. (other than 0) */
				for (bookGrpWay = 1; bookGrpWay < xBookGrp.length; bookGrpWay++) {
					//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
					let _bookGrpItems = xBookGrp[bookGrpWay].grp;

					for (let i = 0; i < _xData.length; i++) {
						let _grpIds = _xData[i].grp[bookGrpWay]; //in the form "SH.VTC-TT" or "SH.A1"
						let _bookGrpItm = _bookGrpItems.find(m => m.gId == _grpIds); //find the item of _bookGrpItems that has gId is something like "SH.VTC-TT" or "SH.A1"
						if(!_bookGrpItm){ //if not found because of database error
							toast.showToast(`Book '${_xData[i].title}' has wrong group config at line '${bookGrpWay}'. Group '${_xData[i].grp[bookGrpWay]}' not found on meta.bookGrp`, toast.ToastType.Error, {duration: 6e4, persistance: true});
							continue;
						}
					
						if (!_bookGrpItm.books) _bookGrpItm.books = []; //create array that will store books of this categories, e.g, $1 will store 4 novel (Tieu thuyet) A1->A4 of Sherlock Holmes

						let _bkIdx = dataSize.findIndex((_currVar, _idx) => { return _idx == dataSize.length - 1 ? _currVar.idx >= i : _currVar.idx <= i && dataSize[_idx + 1].idx > i }); //find index of book kit
						if (!_bookGrpItm.hasOwnProperty("bookKit")) _bookGrpItm.bookKit = _bkIdx; //update Book Kit for current Book set.		

						let _bookID = _xData[i].bookId;
						let _bookItem = _bookGrpItm.books.find(m => m.bookId == _bookID);
						if (_bookItem == undefined) { //if there is no data for this book yet?
							_bookItem = {};
							_bookGrpItm.books.push(_bookItem); //create new item for xBookGrp[bookGrpWay].grp
							_bookItem.gbId = _bookID; //group book id, currently is stt
							_bookItem.bookId = _xData[i].bookId; //hard-coded 8 chars Book Id
							_bookItem.bName = _xData[i].title; //eTitle;
							_bookItem.mc = _xData[i].mc;
							_bookItem.year = _xData[i].year;
							_bookItem.bList = [_bookID]; //list of bookId of xData items that is the same book but different MC
						}
						else
							_bookItem.bList.push(_xData[i].bookId); //just bookId stt of this item to book List
					}
				}

				/* STEP D: collect all configuration like visible/hidden, their display order is stored in xState.grpCfg to xBookGrp variable */
				if (!xState.grpCfg) xState.grpCfg = {};
				for (let i = 0; i < xBookGrp.length; i++) {
					/* D1. create xState.grpCfg if it has not yet created*/
					if (xState.grpCfg[i] == undefined) {
						xState.grpCfg[i] = { grpLine: i, grpWay: xBookGrp[i].grpWay, grp: [] };
						let _bookGrpItems = xBookGrp[i].grp;
						for (let j = 0; j < _bookGrpItems.length; j++) {
							xState.grpCfg[i].grp.push({ gId: _bookGrpItems[j].gId, label: _bookGrpItems[j].label, bHidden: false });
						}
					}
					/* D2. Update the a) order and b) hidden state of each book set 
					xState.grpCfg (store the order and shown/hidden states for each book set by each group way) has been updated immediately when user click a checkbox or drag&drop an item in Setting.
					Important: Guarantee the integrity between xBookGrp and xState.grpCfg; xBookGrp and the real book in xData
					*/
					else{
						let _bookGrpItems = xBookGrp[i].grp;
						let _xStateCfgs = xState.grpCfg[i].grp;
						if (!Array.isArray(_xStateCfgs) || _xStateCfgs.length == 0) return; //there is no setting for this group line yet

						//temp array store user-setting order for each xBookGrp gId, which will be used for sorting xBookGrp. Also it contains bHidden infor from xState
						let _tmpArrSorted = {}; 
						_xStateCfgs.forEach((_itm, _idx) => _tmpArrSorted[_itm.gId] = [_idx, !!_itm.bHidden, false]); 
						// item of _tmpArrSorted array: array having 3 items: 0--the order of the book, 1--hidden state of the book, 2---flag to mark if this _tmpArrSorted is updated in step D2.1, one that still false after step D2.1 is the redundant item in xState (item in _xStateCfgs but _bookGrpItems does not have)

						/* D2.1 update the xBookGrp's hidden state from xState and add information of newly-added book in xBookGrp that xState not yet had */
						_bookGrpItems.forEach(_itm => {
							if(_tmpArrSorted[_itm.gId]){
								_itm.bHidden = _tmpArrSorted[_itm.gId][1];
								_tmpArrSorted[_itm.gId][2] = true; //mark that this item already updated to xBookGrp
							}
							else{
								// This is the case that xBookGrp has some just-added books that xState does not have in last session. Use MAX_SAFE_INTEGER as fallback value for the order of newly-added book set
								_tmpArrSorted[_itm.gId] = [Number.MAX_SAFE_INTEGER, false];
								//add the newly-added book infor into xState
								_xStateCfgs.push({ gId: _itm.gId, label: _itm.label, bHidden: false });
							}
						});

						/* D2.2: This is the case meta.bookGrp has group config but no book belong to. So we need to remove any orphan item of _bookGrpItems that don't have any book (because that group item might have a typo in gId or other reasons) */
						for(let i= _bookGrpItems.length-1; i>=0; i--)  {
							let _itm = _bookGrpItems[i];
							// grp that don't have any book would have no chance to add the bookKit at step C, so bookKit==undefined
							if(_itm.bookKit == undefined){
								const _errMsg = `The group named '${_itm.label}', gId='${_itm.gId}' in meta.bookGrp has no book belong to. FIXED IT NOWW`;
								_bookGrpItems.splice(i, 1); //remove it out of xBookGrp
								console.error(_errMsg);
								toast.showToast(_errMsg, toast.ToastType.Error, {duration: 6e4, persistance: true});
								
							}
						};

						/* D2.3: remove any item in _xStateCfgs that _bookGrpItems don't have (because that item's book just been removed out of xData) */
						const _removedItems = []; //temp array to store index of _xStateCfgs that to be removed
						for(const  _key in _tmpArrSorted){
							let _tmp = _tmpArrSorted[_key];
							if(!_tmp[2]) _removedItems.push(_tmp[0]); //_xStateCfgs.splice(_tmp[0], 1); //remove
						};
						_removedItems.sort((a,b) => b-a); //sort the index decreasingly
						_removedItems.forEach(_idx => _xStateCfgs.splice(_idx, 1))  //remove

						/* D2.4 sort _bookGrpItems to update the xBookGrp's book ORDER from xState */
						_bookGrpItems.sort((_a, _b) => {
							return _tmpArrSorted[_a.gId][0] - _tmpArrSorted[_b.gId][0];
						});
						
					}
				}
				
				/* E. Calculate Book Kit rank to update to ssData.bookKitInfor */
				for (let i = 0; i < xBookGrp.length; i++) {
					calculateBookKitRank(i);
				}
			
				/* F. calculate book statistics for all books */
				//ssData.allBooksSummary = BookData.prototype.booksStatistics( ssData.xData );
			}

			/*** THIS FUNCTION  FOR grpLine==0 (which in fact 2 level grouping "Book Set > Book > MC" ) 
				* Adding and grouping books titles to sddBooks dropdown list for special case (case 0) where books are group in categories, each book may have different MC (e.g, Tay Du Ky, Sherlock Holmes) or different Authors (Buddha sermon) who will be listed into radio buttons.
			Each item of book select box is just represent for real book items in xData array, the real books lies in radios buttons of elmDivMcRadioCtn element
				@hiddenparam bookGrpWay: the order to put the title. For now, this function and next function only serves for bookGrpWay===0  (see xBookGrp, xSate.grpLine, xData.grp), so this parameter is missed
				@param _currBookId: bookId of the current playing book. There is a case that book is playing belong to group that is hidden by user (in setting class). In that case, This parameter is used to show the group and only current book (which is a bit different from user-setting) so that user has smooth experience when listning
				@param _repopulateSDD: true if need to re-populate sddBooks and then populate radio buttons with popuBooks2RadioButtons(), then finally load the book having bookId = {_currBookId}
					-false: just do the last two work without re-populating sddBooks
			*/
			function popuGrpBookTitles(_currBookId, _repopulateSDD = false) {
				/** function to generate setting for loading book sets and group of book sets (book kits) into SDD 
					* @return the full setting for populating sddBooks SDD. This full setting includes commonn setting, render, callback function and most importantly including data
				*/
				function genGrpBookSddSetting(){
					const bookGrpWay = 0; //this special categorization always at index 0

					//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
					let _bookGrpItems = xBookGrp[bookGrpWay].grp;

					let gStt = 1, kStt = 1; //stt of group and Book Kit
					let sddOptionData=[], sddOptGroup = [];
					for (let j = 0; j < _bookGrpItems.length; j++) {
						let bookGrpItem = _bookGrpItems[j];

						let hideThisGrp = bookGrpItem.bHidden;
						if (hideThisGrp) { //if user wants to hide this group 
							let _idx = -1;
							// search to find if this group contains the current playing book
							bookGrpItem.books.forEach(_bItem => {
								_idx = Math.max(_idx, _bItem.bList.indexOf(_currBookId))
							});
							if (_idx === -1) continue; //stop with this group, go with next one
						}

						//count number of books of this book kit. Note that bookGrpItem.books.length is number of book sets
						const _booksCount = bookGrpItem.books.reduce((bCount, _book) => bCount += _book.bList.length, 0);
						
						sddOptGroup.push( {stt: kStt, gId: bookGrpItem.gId, 
							label: `${int2Roman(kStt++)}. ${bookGrpItem.label}`,
							//disabled: bookGrpItem.gId == "$11", 
							subLabel: `${makeSvgFromSprite("icnSvgBookSets",{class:"svg-img-infor", style:"color:inherit"})}${bookGrpItem.books.length}${_booksCount > bookGrpItem.books.length?" " + makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor", style:"color:inherit"}) + _booksCount : ""}`, attr: {
								"attr-gId": bookGrpItem.gId
							}
						});

						for (let i = 0; i < bookGrpItem.books.length; i++) {
							let _book = bookGrpItem.books[i];

							//if user hides this group, and this book in this group not the current playing book
							if (hideThisGrp && _book.bList.indexOf(_currBookId) === -1) continue;

							//collect Author and MC name from each of book having {stt} stored in _book.bList, into a object looks like: { "author": [ "J. R. R. Tolkien" ], "mc": [ "Mạnh Tuấn", "Rin Mabuko" ] }
							const _propCollect = _book.bList.reduce((_tmpArr, _bookId) => {
								const _aBook = findBookFromId(_bookId);
								const _addProp = propName => {
									if(_tmpArr[propName].indexOf(_aBook[propName])==-1) _tmpArr[propName].push(_aBook[propName])
								}
								_addProp("author"); _addProp("mc");
								return _tmpArr
							}, {author:[], mc: []} );
							
							const _bookKitStatistics = BookData.prototype.booksStatistics(
								_book.bList.map( _bookId => ssData.bookData.findBookFromId(_bookId) )
							);

							//create option
							sddOptionData.push({stt: gStt++, gId: bookGrpItem.gId,
								value: _book.gbId, 
								label: _book.bName,//`${hideThisGrp ? "⚡ " : ""}${addSpace(makeBrk(_book.year))}${_book.bName}`,
								bookSetCount: _book.bList.length,
								year: _book.year,
								author: _propCollect.author,
								mc: _propCollect.mc,
								disabled: hideThisGrp,
								bkStatistics: _bookKitStatistics, //book Kit statistics
								attr: {
									"attr-book-array": JSON.stringify(_book.bList),
									"attr-gId": bookGrpItem.gId
								}
							});
						}
					}

					const addSpace = (str) => { //function to add " " to end of non-empty string
						if(str.trim()) return str.trim() + "&emsp13;"
						else return "";
					}
					//short function to generate svg icon for each author/mc of the author/mc array
					const listProp2Html = (propArray, _iconName) => {
						return propArray.map(prop => `${makeSvgFromSprite("icnSvg" + _iconName,{class:"svg-img-infor " + _iconName})}${prop}`).join("; "); //use ; as sperator to avoid the miss-match when searching in sddBooks
					}

					//create and return setting for sddBooks
					return {
						name: "bookTitles",
						displayOneLine: false,
						maxHeight: 500,
						//diacriticsFilterMode: false,
						//makeSelectKey: "Shift",
						//avatarIcon: "icnSvgBooks", //set avatar using svg sprite #icnSvgBooks
						searchBoxPlaceholder: "Tìm trong {_items_length} bộ sách ...",
						options: sddOptionData,
						optgroups: sddOptGroup,
						render: {
							//function to render the option. Below, data-rAlignGroup attribute to mark that element would be right-align vertically across all options (from book to book)
							option: function (data, escape) {
								return `<div class="item-main-div">${data.disabled?"⚡&emsp13;" : ""}<span class="item-slight-details">${addSpace(makeBrk(data.year))}</span><span>${escape(data.label)}</span>${data.bookSetCount > 1 ? " " + makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor"}) + data.bookSetCount: ""}</div>
								<div class="item-2nd-main-div">
									${statisticsHTML(data.bkStatistics, true)}

									<span>${listProp2Html(data.author, "MaleAuthor")}</span>.
									<span>${listProp2Html(data.mc, "Microphone")}</span>
								</div>`;
							},
							select_option: function (option, escape) {
								return option.firstChild.innerHTML; //textContent;
							},
							//function to render the group option label
							optgroup_header: function (data, escape) {
								return `${escape(data.label)}&emsp13;<span class="item-slight-details">${data.subLabel}</span>`;
							},
							'no_results': () => {
								return 'Không tìm thấy bộ sách nào';
							}
						},
						callbacks: {
							//callback function to be invoked when onChange event fire (a new item is selected)
							onChange: function (selectedItem) {
								//console.log(`onChange event: ${selectedItem.value}`);
								popuBooks2RadioButtons(selectedItem.value);
							}
							//callback function to update state of SDD search mode (removed diacritics or exact search)
							/* ,diacriticsFilterModeOnChanged: function(newDiacriticsSearchVal){
								xState.bookTitlesDiacriticsSearch = newDiacriticsSearchVal;
							} */
						}
					};
				}

				/** popuBooks2RadioButtons: Making radio buttons for each MC voicing a specific book for special case where xState.grpLine =0
					@param _groupId: Id of current group, which look like "SH.A1" 
					@param _bookId: the bookID value used to mark radio button that present current book (something like "ebebb619"). This param is included only on popuGrpBookTitles() function to pinpoint the current book. The onchange event of sddBooks will based on the bookLine to know which radio button should be checked when change the book category.
				*/
				function popuBooks2RadioButtons(_groupId, _bookId) {
					let elmInnerMcFlexCtn = document.getElementById("elmInnerMcFlexCtn");
					//console.log("popuBooks2RadioButtons: " + _bookId);

					elmInnerMcFlexCtn.innerHTML = ""; //clear radios button list

					//find item having value == catValue
					const _foundItem = ssData.sddBooks.items.find(item => item.value == _groupId);
					if(!_foundItem) return console.warn("popuBooks2RadioButtons: not found the item");

					//extract the book list of this book group
					let _bookIdsLst = JSON.parse(_foundItem.getAttribute("attr-book-array"));
					
					if (!_bookId) {
						if (xState.bookLine == undefined) xState.bookLine = 0; //default bookLine is 0
						_bookId = _bookIdsLst[ xState.bookLine >= _bookIdsLst.length ? 0 : xState.bookLine ]; //update to use bookLine
					}

					//Choose the attribute to show as the label of radio box. For most of the book, the same book should have different MC. Except for Budda Sutra, the same Sutra may be sermonized by different preachers
					const _booksLst = _bookIdsLst.map(_book_Id => findBookFromId(_book_Id));
					
					const _uniqueAuthArray = [...new Set(_booksLst.map(_book => _book.author))]; //trim the duplicate
					const _fieldName = _uniqueAuthArray.length === _booksLst.length? "author" : "mc";
					const _inputIdPrefix = "SpeakerMC_book_";
					let _innerH = [];
					for (let i = 0; i < _bookIdsLst.length; i++) {
						const _book_Id = _bookIdsLst[i];
						_innerH.push(`<span><input type="radio" name="SpeakerMC" id="${_inputIdPrefix}${_book_Id}" bookId="${_book_Id}" data-bookLine="${i}"><label for="${_inputIdPrefix}${_book_Id}">${_booksLst[i][_fieldName]}</label></span>`); //${_stt==bStt?"checked":""} 
					}
					elmInnerMcFlexCtn.innerHTML = _innerH.join("");

					//show the radio container if there are more than 1 radio buttons, otherwise hide it
					document.getElementById("elmDivMcRadioCtn").style.display = _bookIdsLst.length > 1 ? "block" : "none";

					//set click event handler for just-added radio buttons using event delegation.
					if(!elmInnerMcFlexCtn.hasAttribute("eventDelegation")){
						elmInnerMcFlexCtn.setAttribute("eventDelegation", true); //mark that event delegation handler already been set
						elmInnerMcFlexCtn.addEventListener("click", function(evt){
							const _target = evt.target;
							//if click on SpeakerMC radio butotn
							//if(_target.tagName == "INPUT" && _target.type == "radio" && _target.getAttribute("name") == "SpeakerMC"){
							if(_target.matches(`input[type="radio"][name="SpeakerMC"]`) ){
								const _book_id = _target.getAttribute("bookId"); //.match(/\d+/)[0]; //this is book Id value
								
								const _currBook = xAudio.getAttribute("attr-book");
								if (_currBook && _currBook == _book_id) return; //if current radio button is selected, do nothing
								
								changeBook(_book_id);
								//only update book line if there are more than one lines
								if(this.querySelectorAll('input[type="radio"][name="SpeakerMC"]').length > 1) 
									xState.bookLine = parseInt(_target.dataset.bookline);
							}
							evt.stopPropagation(); //stop bublling up the click event, so higher level element (such as Document) of DOM might catch and work improperly
						});
					}

					let _radioButton2Select = elmInnerMcFlexCtn.querySelector(`input[id='${_inputIdPrefix}${_bookId}']`);
					if (!_radioButton2Select) _radioButton2Select = elmInnerMcFlexCtn.querySelector(`input[id='${_inputIdPrefix}${_bookIdsLst[0]}']`);
					_radioButton2Select.click();
				};
			
				/** Function to find groupId which contains the book having _bookId
					* @param _bookId {8-chars-long string}: the id of the book need to find
					* @return the group id of the book {_bookId} if found
					* 	if not found, retuen group id of the very first book in the book list
					*/
				function findGroupIdForBook(_bookId) {
					/* find the groupId from bookId */
					const _findGroupId = (_bookId) => {
						let _foundGrpId = null; //store group ID if found
						//has to use Array.prototype.some() so we can jump all the way out of the nested loops by 'return true' immediately when found groupId
						xBookGrp[0].grp.some(_bookKitItem => { //each _bookKitItem is a bookKit. e.g: LOTR
							return _bookKitItem.books.some(_bookSetItem => { //each _bookSetItem is a bookSet which can be a singgle book or a book group (e.g, LOTR1 has two books read by two MC)
								//for each group, looking in the bList to see if it contains the _bookId
								if(_bookSetItem.bList.includes(_bookId)) {
									//found bookSet containing _bookId
									_foundGrpId = _bookSetItem.gbId; 
									return true; //must return TRUE to stop searching
								}
							});
						});
						//return groupId; null if not found
						return _foundGrpId; 
					}
					let _groupId = _findGroupId(_bookId);

					//if somehow _bookId not belong to any group, choose the first book
					if(!_groupId) {
						_bookId = ssData.xData[0].bookId; //select the first book to be new _bookId
						_groupId = _findGroupId(_bookId);
					}
					return _groupId;
				}

				/* MAIN: Starting populate SDD or Just change the book set */
				//get groupId (book set Id) for the book set that contains _currBookId book.
				const _groupId = findGroupIdForBook(_currBookId);

				if(_repopulateSDD){
					// get the setting including both setting and data
					const _bookListSetting = genGrpBookSddSetting();
					//load the sddBooks. By the same time select the book set that contains current _bookId, this in-turn will invoke ssData.sddBooks.callbacks.onChange() function, which invoke popuBooks2RadioButtons(_groupId)
					ssData.sddBooks.loadDropdown(_bookListSetting, ssData.sddChaps.LOAD_MODE_ENUM.All, _groupId);
				}
				else{
					// change to the new book set which contains the book having bookId = _bookId
					ssData.sddBooks.value = _groupId;
					// Even above assignment does not invoked onChange() callback, but we should not call ssData.sddBooks.onchange() since this just invoke popuBooks2RadioButtons one more redundant time.
				}

				//populate radio buttons if there are more than one books in this book set
				//NOTE that in ssData.sddBooks.loadDropdown few line above, function popuBooks2RadioButtons(_groupId) is invoked one time with one parameter, this invoke again with two parameters
				popuBooks2RadioButtons(_groupId, _currBookId);
			}			

			/*** THIS FUNCTION FOR grpLine > 0 (=1 or 2) which is just one level grouping "MC > Book" or "Book > MC". 
				adding and grouping books titles to dropdown list 
				@param _bookId {8-chars-string}: the book Id
				@param _bookGrpWay {1 or 2}: the order to put the title. For now, there are two type of order, see xBookGrp, xSate.grpLine, xData.grp
			***/
			function popuBookTitles(_bookId, _bookGrpWay) {
				if (_bookGrpWay == 0) { return; } //this should never happen, it have been taken care of at init() and selBookGroup.onchange() function, so that this function only work with bookGrpWay =1 or larger

				//hide the radio-buttons container which display the options for different Author or MC of the same book title
				document.getElementById("elmDivMcRadioCtn").style.display = "none";

				let xGrpLbl = xBookGrp[_bookGrpWay].grp, gStt = 1, kStt = 1;
				let sddOptionData=[], sddOptGroup = [];

				for (let j = 0; j < xGrpLbl.length; j++) {
					let bookGrpItem = xGrpLbl[j].books;

					let hideThisGrp = xGrpLbl[j].bHidden;
					let _idx = -1;
					if (hideThisGrp) { //if user wants to hide this group 
						// search to find if this group contains the current playing book (having stt = _currBook)
						bookGrpItem.forEach((_bItem, _idex) => {
							if (_bItem.gbId == _bookId) _idx = _idex
						});
						if (_idx === -1) continue; //stop with this group, go with next one
					}

					// add information for optGroup to setting
					sddOptGroup.push( {stt: kStt, gId: xGrpLbl[j].gId, 
						label: `${int2Roman(kStt++)}. ${xGrpLbl[j].label}`, 
						subLabel: `${bookGrpItem.length}`
					});

					for (let i = 0; i < bookGrpItem.length; i++) {
						if (hideThisGrp && _idx != i) continue; //if user want to hide the group, and book in index i is not current book

						/* let bIndex = bookGrpItem[i].gbId - 1; //book Index in xData is book Stt - 1
						let _xData = ssData.xData;
							*/
						//create option
						const _book = findBookFromId(bookGrpItem[i].bookId); // _xData[bIndex];
						//calculate book statistics if it not yet generated
						if(!_book.hasOwnProperty("statistics"))
							BookData.prototype.bookStatistics(_book);
						//add options setting data for sddBooks
						sddOptionData.push({stt: gStt++, 
							gId: xGrpLbl[j].gId,
							value: _book.bookId, 
							label: _book.title,
							year: _book.year,
							author: _book.author,
							mc: _book.mc,
							bStatistics: _book.statistics,
							disabled: hideThisGrp
						});
					}
				}

				const addSpace = (str) => { //function to add " " to end of non-empty string
					if(str.trim()) return str.trim() + "&emsp13;"
					else return "";
				}

				//create setting for sddBooks
				const _bookListSetting = {
					name: "bookTitles",
					displayOneLine: false,
					//diacriticsFilterMode: xState?.bookTitlesDiacriticsSearch ?? true,
					//makeSelectKey: "Ctrl",
					//avatarIcon: "icnSvgBooks", //set avatar using svg sprite #icnSvgBooks
					searchBoxPlaceholder: "Tìm trong {_items_length} quyển sách ...",
					options: sddOptionData,
					optgroups: sddOptGroup,
					render: {
						//function to render the option
						option: function (data, escape) {
							return `<div class="item-main-div">${data.disabled?"⚡&emsp13;" : ""}<span class="item-slight-details">${addSpace(makeBrk(data.year))}</span><span>${escape(data.label)}${data.bStatistics.chapGroupsCount? " " + makeSvgFromSprite("icnSvgChapGroupIcon",{class:"svg-img-infor"}) + data.bStatistics.chapGroupsCount:""}</span></div>
							<div class="item-2nd-main-div">
								${statisticsHTML(data.bStatistics, true)}
								
								<span>${makeSvgFromSprite("icnSvgMaleAuthor",{class:"svg-img-infor MaleAuthor"})}${data.author}</span>
								<span>${makeSvgFromSprite("icnSvgMicrophone",{class:"svg-img-infor Microphone"})}${data.mc}</span>
							</div>`;
							//return `<span>${escape(data.label)}</span>`;
						},
						//function to render the selected option to representative DIV
						select_option: function (option, escape) {
							return option.firstChild.innerHTML; // textContent;
						},
						//function to render the optGroup
						optgroup_header: function (data, escape) {
							return `<span>${escape(data.label)}</span>&emsp13;<span class="item-slight-details">${makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor", style:"color:inherit"})}${escape(data.subLabel)}</span>`;
						},
						'no_results': () => {
							return 'Không tìm thấy quyển sách nào';
						}
					},
					callbacks: {
						//callback function to be invoked when onChange event fire (a new item is selected)
						onChange: function (selectedItem) {
							//console.log(`onChange event: ${selectedItem.value}`);
							changeBook(selectedItem.value);
						}
						//callback function to update state of SDD search mode (removed diacritics or exact search)
						/* , diacriticsFilterModeOnChanged: function(newDiacriticsSearchVal){
							xState.bookTitlesDiacriticsSearch = newDiacriticsSearchVal;
						} */
					}
				};

				//load the sddBooks
				ssData.sddBooks.loadDropdown(_bookListSetting, ssData.sddBooks.LOAD_MODE_ENUM.All, _bookId);

				//ssData.sddBooks.value = _bookId; //restore the last book to be selected
				//ssData.sddBooks.onchange(); //make change. Note that onchange() is an alias of onChange(), but require no param
			}

			/** Short function to select the current book (WITHOUT re-populating Book list) for different case of Group Way (grpLine) 
				* @param _bookId {8-chars-string}: the book Id
				* @param _bookGrpWay {0 or 1 or 2}: the groupWay to group or sort books, which is 0 1 2
			*/
			function goGetBook(_bookId, _bookGrpWay) {
				if (_bookGrpWay == undefined) _bookGrpWay = xState.grpLine;
				if (_bookGrpWay == 0) {
					// WITHOUT re-populating the sddBooks for grpWay = 0, it just populates the radio-buttons (if they are more than one) and load the current book
					popuGrpBookTitles(_bookId, false);
				}
				else {
					//popuBookTitles(_bookId, _catLine);
					ssData.sddBooks.value = _bookId; //restore the last book to be selected
					ssData.sddBooks.onchange(); //make change. Note that onchange() is an alias of onChange()
				}
			}

			//populate the list which show the name of three way (3 _bookGrpWay) to group books, the select element look like a button having icon being a shelf of standing books
			let selBookGroup = document.getElementById("selBookGroup");
			(function populate_selBookGroup() {
				let _defGrpLabels = xBookGrp.map(_ => { return _.grpWay }); //get list of group name
				selBookGroup.innerHTML = "";// .options.length = 0; //clear the combobox
				//create optGroup to play as label for the select element
				const optGroup  = document.createElement('OPTGROUP');
				optGroup.label = "Kiểu phân nhóm/sắp xếp sách";
				_defGrpLabels.forEach( (_grpName,i) => {
					let opt = document.createElement('option');
					opt.value = i;
					opt.innerHTML = makeBrk(pad(i + 1, 2)) + " " + _grpName; //"&nbsp;" + 
					optGroup.appendChild(opt);
				});
				selBookGroup.appendChild(optGroup);
			})();

			//selBookGroup.addEventListener('change', selBookGroup_onchange, true);
			/* function to handle change the way to group book titles. Note that this function just change appearance of book list box, it does NOT touch to chapter and what is currently playing
				*/
			selBookGroup.onchange = () => {
				//I. save new grpLine to xState
				const newGrpIdx = xState.grpLine = parseInt(selBookGroup.value);

				/* II. Main job: Make the changing-chains */
				let _currBookId = xAudio.getAttribute("attr-Book"); //get the current book

				//_currBook can be null or undefined when page first loaded, which is called from bookDataInitial -> selBookGroup.onchange()
				if(!_currBookId) _currBookId = xState["lb"]; //xState["lb"] has been checked valid and (re)set in bookDataInitial

				{//this block added 6/5/2025 to avoid the case a book (which is NOT current book) is in history list, but user set the book set (where it belong to) to be hidden. So when user choose that book in book history setting tab, ssData.sddBooks does not have that book so it cannot load that book. So we create a ssData.bIdsHidden which keep all hidden books, then purge the history list if there is any book in history list that is currently set to be hidden
					//collect all book Ids that belong in hidden book set
					ssData.bIdsHidden = ssData.xBookGrp[newGrpIdx].grp
						//filter book set that is set Hidden
						.filter(_bSet => _bSet.bHidden)
						//get all books id belong to that book set
						.reduce( (bIds, _bSet) => {
								//concat with bList array of each of books item
								_bSet.books.forEach(_book => bIds = bIds.concat(_book.bList)); 
								return bIds; //accumulator
							}, 
						[]);
					// if _currBookId is also in hidden list, remove it out of the list since current book still shown in ssData.sddBooks
					const _currHiddenIdx = ssData.bIdsHidden.indexOf(_currBookId);
					if(_currHiddenIdx > -1)	ssData.bIdsHidden.splice(_currHiddenIdx, 1);
					//clean history if neccessary
					if(ssData.bIdsHidden.length > 0) historyCls.cleanHist();
				}

				//show/hide corresponding radio-buttons container element
				if (newGrpIdx == 0) { //for grpLine 0
					//populate the sddBooks for grpWay = 0, populate the radio-buttons (if they are more than one) and load the current book
					popuGrpBookTitles(_currBookId, true);					
				}
				else { //for grpLine 1 & 2
					//populate the sddBooks and load the current book for grpWay = 1 or 2
					popuBookTitles(_currBookId, newGrpIdx);
				}

				// Notify user
				toast.showToast(xBookGrp[newGrpIdx].grpWay, null, {persistance: true});

				/* III. Resize selBookGroup width with the content of selected item */
				/* let _sel = document.createElement('select');
				_sel.css({ "font-size": selBookGroup.css("font-size") }); //make font size the same as the main select
				_sel.innerHTML = "<option>" + pad(newGrpIdx + 1, 2) + "</option>"; //&nbsp;
				document.body.appendChild(_sel);
				selBookGroup.style.width = (_sel.offsetWidth - 2) + "px";
				_sel.remove(); */

				/* IV. Update spinner svg icon (which is a book with small micro) of sddBooks to match the new color */
				/* let oldBgrndImg = window.getComputedStyle(document.body).getPropertyValue('--book-micro-svg-bground');
				let oldBgrndColor = oldBgrndImg.match(/fill=\'([^\']+)\'/); //.match(/fill\%3D\%22([^\%]+)\%22/); //search for fill property in background image
				if (!oldBgrndColor) return; //not found, out
				oldBgrndColor = oldBgrndColor[1]; //svg icon old color
				let bdrColor = window.getComputedStyle(document.body).getPropertyValue('--select-book-group-color').replace("#", "%23"); //get border color of sddBooks
				document.body.style.setProperty('--book-micro-svg-bground', oldBgrndImg.replace(oldBgrndColor, bdrColor)); //make svg icon has same color with border */

				/* V. Glowing the BooksList element so user know the changes */
				//if(ssData.sddBooks) SddDropdown.prototype.glowingElem(ssData.sddBooks.displayElement)
				if(ssData.sddBooks) ssData.sddBooks.glowing();
			}

			//Initialize book Data, populate and assign	event handler for following listbox: sddBookTitles, sddChapters and selBookGroup. This is invoked one time in init when creating bookData obj
			prepareData(); //collect all data to xData and xBookGrp

			/** 
				*  BookData prototype functions
				*/

			/* Create real media links, cover image, original (outside) url,... for parts that have wildcart. For now, there are two kinds of wildcart:
			- book wildcart: the setting is set in "wc" attribute of the books. See data-beautify.js for the format of this setting
			- chapter wildcart: the setting is set in a chapter and effect consecutive chapters untils there is other setting in a sub-sequent chapter or a terminate-setting with wc.url=[], wc.img="". You need to check the code below for more.
			Note: These information is not created from beginning for all books, it is only being created each time a book is open inside changeBook() function.
			In future, if there is anything else can be wild-cart, this function need to be update to handle those wildcart things
			*/
			BookData.prototype.generateWCLinks = function(_bookId){
				/* function to check if a str is a full url */
				const isUrl = str => {
					if(!str) return false;
					return str.match(/^https?\:\/\//)
				};

				/* Function to generate data from wild-cart for wild-cart that set in chapter. Note that this function is invoked ONLY when in book metadata does not have attribute "wc" 
				FORMAT INFORMATION: Format of CHAPTER "wc" setting in database
					"wc": {
						"url": [
							{
								"urlLine": 0, //urlLine, there may be multiple urlLine 1,2,3,..
								"startNum": 0, //the number which is the start for auto-increasing-number replacement into the position of wildCartStr <*~~*>
								"nd": -1, //number of digits: define the length of auto-number, 0 will be padding to auto-number. E.g, nd=2, startNum = 1, so <*~~*> will be replaced with "01"
								"wcSrc": "...<*~~*>.mp3" //wild-cart source, the source must contain wildCartStr <*~~*> for replacement
							},
							{
								Other urlLine. Must have "urlLine" property. If "wcSrc" of any urlLine is set to "", null, or undefined. It will terminate that url line
							}
						],
						"img": "...", //src for workart img replacement. "img" may not contain wildCartStr <*~~*>, in that cases, all subsequent chapters would have the same workart img until a chapter has new setting for this "img" attribute
						
						"oUrl": "...<*~~*>" //outside link. Similar to "img", but this must contain wildCartStr <*~~*>. Extra infor: If a chapter (not this wc.img, wc.oUrl setting) has "img" attribute () but doesn't have "oUrl", when doing replacement, app will use value of "img" of that chapter
					}
				NOTE: wild-cart for title is NOT set in "wc" setting, it is rather set in chapter.tit attribute itself (because title changes much more frequently than url, img or oUrl)
				*/
				const chapterWildCart = function(bData){
					//if (!bData.wc || bData.wcDone) return; //if not wildcart specified, or already creating real links from wildcart, then do nothing
					let bParts = bData.parts;
					
					const wildCartStr = ssData.wildCartStr;

					/* Generate tittle from Wildcart */
					let _subsetWC = null, _subsetCounter = 0;
					let _wcLen = 1;
					for (let i = 0; i < bParts.length; i++) {
						if(bParts[i].tit == undefined) {
							//if _subsetWC was set by previous chapter, use the wild-cart
							if(_subsetWC && _subsetCounter)
							bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
						}
						// first chapter of the group that contains wild-cart
						else if(bParts[i].tit.includes(wildCartStr)){
							_subsetWC = bParts[i].tit; //set the wild-cart string for continuously subsequent chapters
							if(bParts[i].hasOwnProperty('titStartNum'))_subsetCounter = Number(bParts[i].titStartNum);
							else _subsetCounter = 1; //title always start with 1
							bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
						}
						else{
							/* // normal chapter, clear all the wild-cart identifier
							_subsetWC = null;
							_subsetCounter = 0; */

							// for normal chapter, keep the old _subsetWC and keep increasing _subsetCounter in case after some chapters that specify titles, there are bunch of undefined titles behind. So we don't need to re-defind wildcart titles for those undefined-title chapter
							_subsetCounter++;
						}
						
					}

					//create real audio links from wildcart
					let _wcLinks = []; //contains setting for current urlLine
					//_wcLen = _wc.length;
					let _wcImg = "", _wc_oUrl = "";
					for (let i = 0; i < bParts.length; i++) {
						const chapData = bParts[i];

						/* 1. make urls from wild-cart */

						//1a. if this chapter contains url setting for some adjacent chapters, update the setting
						if(chapData.wc && chapData.wc.hasOwnProperty("url")){ 
							const _wcUrls = chapData.wc.url;

							// a setting wc.url=[] in a chapter mark that chapter is the end of the last wc.url setting
							if(_wcUrls.length == 0) _wcLinks=[]
							else
							//update new setting for each urlLine. Note that the urlLine in old setting that new setting does not have will be kept for using
							_wcUrls.forEach(_jUrl => {
								//find the old setting for current urlLine from old _wcLinks
								const _oldIdx = _wcLinks.findIndex(_w => _w.urlLine === _jUrl.urlLine);
								//remove the old setting
								if(_oldIdx > -1) _wcLinks.splice(_oldIdx, 1);

								// wcUrl that has no wcSrc or wcSrc is set to "" or null is the one that mark the terminate of that urlLine.
								// Note that if this {urlLine} is not the last line, if we don't push this null wild-cart to _wcLinks array and 'chapData.url === undefined' (see few line of code below), when initiate 'chapData.url = Array(_wcLinks.length).fill("")', the _wcLinks[j].urlLine (in the wild-cart) and the index of item in chapData.url array would be miss-matched
								if(!_jUrl.wcSrc) _jUrl.wcSrc = null;

								//add new setting (or replace the old one which was spliced out)
								_wcLinks.push(_jUrl); 
								// startNum store the number that add to wild-cart in auto-wilcard links
								if(!_jUrl.hasOwnProperty("startNum")) _jUrl.startNum = 1; //default start from 1								
							});
						}

						//1b. generate url for each chapter from wild-cart
						//if there is _wcLinks empty, there nothing to wild-cart
						if(Object.keys(_wcLinks).length > 0) {

							// if url is missing, meaning its is array of empty string
							if(chapData.url === undefined) chapData.url = Array(_wcLinks.length).fill("");
							//first of all, convert url to array it is not
							if (!Array.isArray(bParts[i].url)) chapData.url = [chapData.url];
							let _chapUrls = chapData.url;

							for (let j = 0; j < _wcLinks.length; j++) {
								let urlLine = _wcLinks[j].urlLine;
								_wcLinks[j].startNum++; //increase startNum for each chapter, no matter how its url would be wild-carted

								// of the line {urlLine} if wild-cart link is null and chapter url for that line is not full url, we have no way to construct full url for this line, so make it null, so that at the end of this code block, we removed it out of url array
								if(!_wcLinks[j].wcSrc && !isUrl(_chapUrls[urlLine])) {
									_chapUrls[urlLine] = null;
									continue;
								}

								// Case 1: if link is null, there is no link, just remove it out of url array
								if (_chapUrls[urlLine] == null) {
									//because sometime null url is at index 0, so we need to  remove them from this later to avoid messing the array
									continue;
								}

								//Case 2: if the link is empty string, using stt (chapter index + 1) to fill in wild-cart
								if (_chapUrls[urlLine] == "") {
									_chapUrls[urlLine] = _wcLinks[j].wcSrc.replaceAll(wildCartStr, pad(_wcLinks[j].startNum - 1, _wcLinks[j].nd)); //note that chaper link most of the time start from 1 (not 0)
									continue;
								}

								//Case 3: if url is not empty, but not the full url link
								if (!isUrl(_chapUrls[urlLine])) {
									// use current url to fill in the wild-cart to get full link
									_chapUrls[urlLine] = _wcLinks[j].wcSrc.replaceAll(wildCartStr, _chapUrls[urlLine]);
									//console.log(_chapUrls[urlLine]);
								}

								//Case 4: if url is full url link, do nothing
							}

							//remove null link. Because splice() function change the index of array, so we go from back to beginning
							for (let j = _wcLinks.length - 1; j >= 0; j--) {
								let urlLine = _wcLinks[j].urlLine;
								if (_chapUrls[urlLine] == null) {
									//if null, meaning this chapter of this line does not have real link
									_chapUrls.splice(urlLine, 1); //remove this from array since there's no link for this line
								}
							}
						}
						
						/* 2. update the outside URl */
						//if this chapter has setting for oUrl, update it
						if(chapData.wc && chapData.wc.hasOwnProperty("oUrl"))
							_wc_oUrl = chapData.wc.oUrl;
						//only making wild-cart generator when _wc_oUrl is actual url
						if(_wc_oUrl && isUrl(_wc_oUrl)) {
							let _rplcUrl = chapData.oUrl || chapData.img; //take img if there is no oUrl for replacement
							if(_rplcUrl) chapData.oUrl = _wc_oUrl.replace(wildCartStr, _rplcUrl);
						}

						/* 3. update the cover image */
						//if this chapter has setting for img, update it
						if(chapData.wc && chapData.wc.hasOwnProperty("img"))
							_wcImg = chapData.wc.img;

						//a setting wc.img ="" or not full url mark this chapter is the end of last setting of old wc.img wildcart
						if(_wcImg && isUrl(_wcImg)) {

							//img wild-cart does not has any wild-cart
							if(_wcImg.indexOf(wildCartStr) === -1 ){
								if(!isUrl(chapData.img)) chapData.img = _wcImg;
							}
							else {
								//no img link at all (chapData.img == undefined, null, "") then there nothing todo. OR if img is full link, keep it that way.
								if (chapData.img && !isUrl(chapData.img)) {
									let _tmpSrc = _wcImg.replace(wildCartStr, chapData.img);
									//if it is youtube image, use high res, 16:9 thumbnail but might not always exist, so we need the error handler on cover image element which is on elmArtwork.onload()
									if(_tmpSrc.match(/ytimg\.com\/vi/)){
										//if there is youtubeId in img property, use this YoutubeId to make a mp3 link
										if(!chapData.hasOwnProperty("url")) chapData.url = []
										else if(!Array.isArray(chapData.url)) chapData.url = [chapData.url];

										const _convertedLink = `https://ph.tinhtong.vn/Home/GetAudioYoutube/${chapData.img}`;
										if(!chapData.url.includes(_convertedLink)) chapData.url.push(_convertedLink);

										//update img property to full url
										chapData.img = _tmpSrc.replace(/([^\/])+$/, "hq720.jpg");
									}
									else chapData.img = _tmpSrc;
								}
							}
						}
					}
				}

				/* Function to generate data from wild-cart set in Book Metadata 
				FORMAT INFORMATION: Format of BOOK "wc" in database is very much similar to CHAPTER "wc" setting (see comments of chapterWildCart function above) except that for now urlLine doesn't have startNum attribute
				*/
				const bookWildCart = function(bData){
					
					const wildCartStr = ssData.wildCartStr;
					let bParts = bData.parts;

					//create titles from wildcart set for all chapters of this book
					if (bData.wc.tit) {
						let _wc = bData.wc.tit;
						let _wcLen = 1; //(bParts.length + "").length;
						for (let i = 0; i < bParts.length; i++) {
							if(bParts[i].tit == undefined) bParts[i].tit = _wc.replaceAll(wildCartStr, pad(i + 1, _wcLen)) + (i == bParts.length-1? " (Hết)" :"");
						}
					}
					else {
						// Some book (especially buddha sutra), there are some group of continuous chapter having same name (because they are belong to same part of the book), we can wild-cart this sub-group of chapter
						let _subsetWC = null, _subsetCounter = 0;
						let _wcLen = 1;
						for (let i = 0; i < bParts.length; i++) {
							if(bParts[i].tit == undefined) {
								//if _subsetWC was set by previous chapter, use the wild-cart
								if(_subsetWC && _subsetCounter)
								bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
							}
							// first chapter of the group that contains wild-cart
							else if(bParts[i].tit.includes(wildCartStr)){
								_subsetWC = bParts[i].tit; //set the wild-cart string for continuously subsequent chapters
								_subsetCounter = 1; //title always start with 1
								bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
							}
							else{
								// normal chapter, clear all the wild-cart identifier
								_subsetWC = null;
								_subsetCounter = 0;
							}
							
						}
					}

					//create real audio links from wildcart
					if (bData.wc.url) {
						let _wc = bData.wc.url;
						let _wcLen = _wc.length;
						for (let i = 0; i < bParts.length; i++) {
							// if url is missing, meaning its is array of empty string
							if(bParts[i].url === undefined) bParts[i].url = Array(_wcLen).fill("");
							//first of all, convert url to array it is not
							if (!Array.isArray(bParts[i].url)) bParts[i].url = [bParts[i].url];
							let _chapUrls = bParts[i].url;

							for (let j = 0; j < _wc.length; j++) {
								let urlLine = _wc[j].urlLine;

								// Case 1: if link is null, there is no link, just remove it out of url array
								if (_chapUrls[urlLine] == null) {
									//because sometime null url is at index 0, so we need to  remove them from this later to avoid messing the array
									continue;
								}

								//Case 2: if the link is empty string, using stt (chapter index + 1) to fill in wild-cart
								if (_chapUrls[urlLine] == "") {
									_chapUrls[urlLine] = _wc[j].wcSrc.replaceAll(wildCartStr, pad(i + 1, _wc[j].nd)); //note that chaper link most of the time start from 1 (not 0)
									continue;
								}

								//Case 3: if url is not empty, but not the full url link
								if (!isUrl(_chapUrls[urlLine])) {
									// use current url to fill in the wild-cart to get full link
									_chapUrls[urlLine] = _wc[j].wcSrc.replaceAll(wildCartStr, _chapUrls[urlLine]);
									//console.log(_chapUrls[urlLine]);
								}

								//Case 4: if url is full url link, do nothing
							}

							//remove null link. Because splice() function change the index of array, so we go from back to beginning
							for (let j = _wc.length - 1; j >= 0; j--) {
								let urlLine = _wc[j].urlLine;
								if (_chapUrls[urlLine] == null) {
									//if null, meaning this chapter of this line does not have real link
									_chapUrls.splice(urlLine, 1); //remove this from array since there's no link for this line
								}
							}
						}
					}

					//create real outer original links (usually youtube) from wildcart. For youtube link, the yt ID mostly got from bParts[i].img (because most of the case, img and oUrl has the same YT Id). So, this snippet has to be put before the snipet that update the img property (right below)
					if (bData.wc.oUrl) {
						let _wc2 = bData.wc.oUrl;
						for (let i = 0; i < bParts.length; i++) {
							let _rplcUrl = bParts[i].oUrl || bParts[i].img; //take img if there is no oUrl for replacement

							if (_rplcUrl == undefined) continue;

							//if oUrl not the full url and not empty
							if (_rplcUrl !== "" && !isUrl(_rplcUrl))
								bParts[i].oUrl = _wc2.replace(wildCartStr, _rplcUrl);
						}
					}

					//create real chapter cover from wildcart
					if (bData.wc.img) {
						let _wc1 = bData.wc.img;
						for (let i = 0; i < bParts.length; i++) {
							if (bParts[i].img == undefined) continue; //no img link at all
							// if img is full link, keep it that way
							if (isUrl(bParts[i].img)) continue;

							if (bParts[i].img != "") {
								let _tmpSrc = _wc1.replace(wildCartStr, bParts[i].img);
								//if it is youtube image, use high res, 16:9 thumbnail but might not always exist, so we need the error handler on cover image element which is on elmArtwork.onload()
								if(_tmpSrc.match(/ytimg\.com\/vi/)){
									//if there is youtubeId in img property, use this YoutubeId to make a mp3 link
									if(!bParts[i].hasOwnProperty("url")) bParts[i].url = []
										else if(!Array.isArray(bParts[i].url)) bParts[i].url = [bParts[i].url];
										const _convertedLink = `https://ph.tinhtong.vn/Home/GetAudioYoutube/${bParts[i].img}`;
										if(!bParts[i].url.includes(_convertedLink)) bParts[i].url.push(_convertedLink);

									//update img property to full url
									bParts[i].img = _tmpSrc.replace(/([^\/])+$/, "hq720.jpg");
								}
								else bParts[i].img = _tmpSrc;
							}
						}
					}
				}

				let bData = findBookFromId(_bookId); //bData contains all information for current book
				if (bData.wcDone) return; //if not wildcart specified, or already creating real links from wildcart, then do nothing
				bData.wcDone = true; //mark that Wildcart already done

				//create tap attribute for book that has "autoTap"
				if(bData.hasOwnProperty("autoTap") && !bData.hasOwnProperty("tap")){
					const _TapSize = parseInt(bData["autoTap"]);
					//const _MIN_TAP_SIZE = 5; //this has been moved to ssData
					if(isNaN(_TapSize) || _TapSize < ssData._MIN_TAP_SIZE) _TapSize = ssData._MIN_TAP_SIZE;
					let _tapArray = [], _datLen = bData.parts.length, _from = 1, _grp = 1;
					while(_from < _datLen){
						let _to = Math.min( _from + _TapSize - 1, _datLen);
						//if very last group has too little books, merges it to previous one
						if(_datLen-_to > 0 && _datLen-_to < Math.floor(_TapSize/2)) _to = _datLen;
						_tapArray.push({"label": `Nhóm ${int2Roman(_grp++)}: Chương ${_from} đến chương ${_to}`, "f": _from, "t": _to});
						_from = _to + 1;
					}
					bData.tap = _tapArray;
				}								

				//only invoke chapterWildCart if book has no attribute "wc"
				if (!bData.wc) return chapterWildCart(bData)
				else bookWildCart(bData);
			}
			
			/** Handy function to calculate the total duration for a book from a chapter number to the end of the book. If calculate for the whole book, result will be saved into statistics attribute book data. Next time calculate for whole book again, the result will get from book data without re-calculating.
				* @param bData {jSon, string}: if bData type is string, it is bookId. Otherwise, it is json data of the whole book
				* @param fromChap: the chapter number, which is its index in the chapter list PLUS 1, that the summation start to the end of the book
				* @return {totalDur: total duration, chaptersCount: number of chapters being counted} 
				* also, add statistics attribute into book data with the same format.
				*/
			BookData.prototype.bookStatistics = (bData, fromChap) => {
				
				if(typeof bData == "string") bData = findBookFromId(bData);
				if(!bData) return {totalDur: 0,chaptersCount: 0} ;
				fromChap = fromChap ?? 1; //if fromChap not specified, start from very first chapter

				let totalDuration = 0, chapterGroupCount = 0;
				//if calculate for whole book and it is calulated before whose result saved in bData.totalDur, use that saved result without re-calculating
				if(fromChap === 1 && bData.hasOwnProperty("statistics")){
					totalDuration = bData.statistics.totalDur;
				}
				else
					//calculte total Duration
					for (let i = fromChap; i <= bData.parts.length; i++) {
						totalDuration += toSeconds(bData.parts[i-1].dur); 
					}

				//if calculate for whole book, save the result in book metadata for next use
				if(fromChap === 1 && !bData.hasOwnProperty("statistics")){
					const _chapsCount = bData.parts.length;
					bData.statistics = {totalDur: totalDuration, chaptersCount: _chapsCount};
					if(bData.hasOwnProperty("tap") && Array.isArray(bData.tap)) bData.statistics.chapGroupsCount = bData.tap.length
					else if(bData.hasOwnProperty("autoTap")){
						//this calculation has to match the heuristic to generate chapters groups in BookData.prototype.generateWCLinks()
						const _TapSize = parseInt(bData["autoTap"]);
						if(isNaN(_TapSize) || _TapSize < ssData._MIN_TAP_SIZE) _TapSize = ssData._MIN_TAP_SIZE;
						bData.statistics.chapGroupsCount = Math.floor(_chapsCount/_TapSize) + (_chapsCount % _TapSize >= ssData._MIN_TAP_SIZE? 1 : 0);
					}
				}

				return {totalDur: totalDuration, chaptersCount: bData.statistics.chaptersCount - fromChap + 1};
			}

			/** Handy function to get statistics for a collection of books. By the same time, it will calculate the total duration for each book at add that value to "totalDur" attribute of its data
				* @param books {array}: array of book data (which should be subset of ssData.xData)
				* @return {totalDur: total duration, booksCount: number of books, chaptersCount: number of chapters insides} 
				*/
			BookData.prototype.booksStatistics = (books) => {
				return books.reduce((_accumulator, _book) => {
					_accumulator.booksCount++;

					//Calculate book statistics for _book and stored it in statistics attribute. Note that if statistics calculated before, it will not be calculated again
					const _bSummary = BookData.prototype.bookStatistics(_book);

					//update chapter counts
					_accumulator.chapGroupsCount += _book.statistics.chapGroupsCount ?? 0; //some books do not have chapter group, don't have chapGroupsCount property
					//update chapter counts
					_accumulator.chaptersCount += _book.statistics.chaptersCount;
					//update totalDur to _book data if it not yet existed
					_accumulator.totalDur += _book.statistics.totalDur;

					return _accumulator;
				}, {totalDur: 0, booksCount: 0, chaptersCount: 0, chapGroupsCount: 0} );
			}

			/* Handy function to create unique book Id, which I personally use when making database */
			BookData.prototype.makeUniqueId = _ => {
				const rand = Math.random().toString(16).substr(2, 8);
				//check if it is really unique
				if(ssData.bIds.indexOf(rand) ==-1 ) return rand;

				//return Math.round(Date.now()).toString(36);
			}

			/* Function to check if there is any duplicate in bookId */
			BookData.prototype.checkDuplicateBookId = _ => {
				const duplicates = ssData.bIds.filter((item, index) => ssData.bIds.indexOf(item) !== index);
				if(duplicates.length == 0) toast.showToast("Không có bookId bị trùng")
				else{
					toast.showToast("Có bookId bị trùng. Xem trong cửa số Console về các mã bị trùng.", toast.ToastType.Error);
					console.log(duplicates);
				}
			}
			
			/** 
				*  Public methods
				*/
			return {
				goGetBook: goGetBook, //function to show a book by specified its stt.
				findBookFromId: findBookFromId, //function to find a book by its bookId
				//generateWCLinks: generateWCLinks //function to generate full information from wildcart
				calculateBookKitRank : calculateBookKitRank
			};
		} //END OF BookDATA CLASS
	</script>

	<!-- MAIN SCRIPT HANDLING THE PAGE -->
	<script>
		"use strict";
		// declare two state variables that would be saved in local-Storage for next session
		let xState = null, xDBFilesCfg = null;

		//session variables that extensively uses, so I don't put them into ssData as other variables and data (see ssData). Instead I make them global variables for shorter code
		let xAudio = document.getElementById("elmMyAudio"); //audio element		
		let toast = null; //instance of Toast class that notifies all kinds of toast
		
		function init() {
			/* Initiate obserers (IntersectionObserver, MutationObserver, ResizeObserver) to watch for UI changes, see each observer for more detail */
			function webAPIinit() {
				// MutationObserver object to detect when a new element having tooltip added to page, so js can locate them properly to make it inside the page
				//initiate Tooltip MutationObserver for adjsuting tooltip location
				ssData.ttMutationObserver = new MutationObserver((mutationList, observer) => {
					for (const mutation of mutationList) {
						if (mutation.type === "childList") {
							//console.log(mutation);
							for (const addedNode of mutation.addedNodes) {
								//console.log(addedNode);
								if (addedNode instanceof HTMLElement && addedNode.getAttribute("xrole") === "containing-tooltip") {
									//console.log(addedNode);
									guiUtils.reposTooltips(addedNode);
									observer.disconnect(); //job done, unhook the watching element
								}
							}
						}
						else if (mutation.type === "attributes") {
							//console.log(`The ${mutation.attributeName} attribute was modified.`);
							// console.log(mutation);
							const target = mutation.target;
							// div[name="divOtherControlTop"] which contains checkbox to expand/collapse all chapter-group and check if it is shown (its class .elm-hidden has been removed)
							if (target.getAttribute("name") == "divChapterGroupControls" && !target.classList.contains("elm-hidden"))
							guiUtils.reposTooltips(target);

							// for label[for="allChapGrpChkbox"], #elmHistoryGoBackward, #elmHistoryGoForward buttons when thier tooltip content changes
							if (target.hasAttribute("data-tooltip")) {
								//console.log(target);
								guiUtils.reposTooltips(null, { selfElem: target });
							}
							observer.disconnect(); //job done, unhook the watching element
						}
					}
				});

				/* because of DOM rendering, updating, so div[name="divContainer"] has got changed its sizes maybe up tp 2 or 3 rounds until page completely rendered, comprises of:
					- 1st round: temp width, temp height. This round is missed in some cases.
					- 2nd round: stable width, temp height
					- 3nd round: stable width, stable height
				So, we utilize ResizeObserver to watch for the last time size-changed to update tooltip location. We manually, asymtoptically achieve that by using an timeout*/
				//timeout ID of timeout object that control when last resize done
				let _TOid;
				const _mainContentContainer = document.querySelector('[name="divContainer"]');
				const resizeObserver = new ResizeObserver((entries, observer) => {
					//for (let entry of entries) { console.log(entry); }
					//console.log(performance.now(), entries[0].target.offsetHeight);
					if(_TOid) clearTimeout(_TOid);

					// debounce technique by using an timeout, we has tooltip repos-ed after 100ms when no other resize event occurs in that interval
					_TOid = setTimeout(_ => {
						guiUtils.reposAllTooltips(); //do the job

						// clean objects
						observer.unobserve(_mainContentContainer); //unhook
						observer = null; //remove ResizeObserver object
						clearTimeout(_TOid);

						//console.log('debounce', entries[0].target.offsetHeight);
					}, 100);
				});
				resizeObserver.observe(_mainContentContainer);
			}
			webAPIinit(); //init observers to watch for UI changes

			function pageEventHandlers(){
				/* Handle event when page is navigated away, the browser window is minimized, a browser tab is currently in the background, or a system element such as a task switcher obscures the page, task-switching on mobile platforms,... */
				document.addEventListener("visibilitychange", () => {
					if (document.hidden) { //or document.visibilityState=="hidden"
						saveState2Disk();
					} else {
						// Do something when the page got into user's view again
						//saveState();
						//if audio is playing, timeUpdate event will be invoked, so no need to raise it
						ssData.audioPlayer && ssData.audioPlayer.updateTime(true); //update with repaint heavy UI update immediately
					}
				});

				// extra event listeners for better behaviour
				window.addEventListener('focus', (event) => {
					saveState2Disk();
					
					//check for DB files update
					if(!ssData.hasOwnProperty("lastDBCheck") || (Date.now() - ssData.lastDBCheck > 1000 * _DEFAULT_CFG.cDBFilesEdt.checkEdtDelay)){
						//check if there is any DB files having new edition, download them. Among them, if there is a DB file that its loadMode currently set to cacheLoad or freshLoad, ask user to reload the page to update the new data inside those DB
						ssData.setting.handyCheckDBsEdition(false);					
					}
				}, false);
				window.addEventListener('blur', (event) => {
					saveState2Disk();
				}, false);

				/* window.addEventListener('beforeunload', (event) => {
					saveState2Disk();
					event.preventDefault();
				}, false); */

				/* keydown event provide short-cut keys for some frequently used functions 
				NOTE: audio hotkeys function created in AudioPlayer class also handles the document's keydown event
				*/
				const pageKeyDown = (evt) => {
					//evt && console.log(evt.code);
					/** hotkey format (see SddDropdown.prototype.runHotkey for more details) */
					//full list of hotkeys with callback functions
					const hotkeyOptions = [

						// Z, ControlRight: open Books List dropdown
						{task: "global_openBooksList", kCode: ["KeyZ", "ControlRight"], desc: "Mở danh sách các tựa sách.", callback: () => {
							ssData.sddBooks.toggle();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},

						// A, ShiftRight: open Chapters List dropdown
						{task: "global_openChaptersList", kCode: ["KeyA", "ShiftRight"], desc: "Mở danh sách các chương sách.", callback: () => {
							ssData.sddChaps.toggle();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},

						// S, Tab: switch mp3 audio sources for current chapter
						{task: "global_switchAudioSource", kCode: ["Tab", "KeyL"], desc: "Đổi phát chương bằng link dự phòng.", callback: () => {
							const _switchSrcBtn = document.querySelector(".switchChapterAudioSrc");
							if(_switchSrcBtn) _switchSrcBtn.click();
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Home: scroll to current playing chapter
						{task: "global_scrollToPlayingChapter", kCode: ["Home"], desc: "Cuộn tới chương đang được phát.", callback: () => {
							document.querySelector('[name="gotoPlayingChapter"]').click();
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// J: seeking to an audio time to play
						{task: "global_openSeeking2Time", kCode: ["KeyJ"], desc: "Chọn thời gian phát (Seeking).", callback: _ => document.getElementById("seekDurationButton").click()},

						// S: set sleep timer
						{task: "global_openSleepTimer", kCode: ["KeyS"], desc: "Hẹn giờ tắt.", callback: _ => document.getElementById("sleepTimerButton").click()},

						// N: expand or collapse all group chapters
						{task: "global_OpenCloseAllGroupChapters", kCode: ["KeyN"], desc: "Đóng/mở tất cả các nhóm chương.", callback: _ => {
							document.getElementById("allChapGrpChkbox").click()
						}},

						// G: change book Group way
						{task: "global_switchBookGrpWay", kCode: ["KeyG"], desc: "Đổi cách nhóm thứ tự sách.", callback: () => {
							const _selBookGroup = document.querySelector("#selBookGroup");
							if(_selBookGroup) {
								_selBookGroup.selectedIndex = (_selBookGroup.selectedIndex + 1) % _selBookGroup.length;
								_selBookGroup.onchange();
							}
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// D: change audio control panel sticky mode
						{task: "global_switchACPStickyMode", kCode: ["KeyD"], desc: "Đổi cách bám dính Bảng điều khiển audio.", callback: () => {
							const _apcStickySelEl = document.querySelector(".ap-sticky-select");
							if(_apcStickySelEl) {
								_apcStickySelEl.selectedIndex = (_apcStickySelEl.selectedIndex + 1 ) % _apcStickySelEl.length;
								//_apcStickySelEl.onchange();

								// Trigger the change event, so that both ACP.stickyMode attribute get updated (see stickyAudioPanelHandler()) and the audio speed popup position get updated (see bSpeed)
								_apcStickySelEl.dispatchEvent(new Event('change'));
							}
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// T: open Setting modal
						{task: "global_openSettingModal", kCode: ["KeyT"], desc: "Mở/Đóng hộp thoại chọn tốc độ phát audio.", callback: () => {
							document.getElementById("spd_btn").click();
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Q: open Setting modal
						{task: "global_openSettingModal", kCode: ["KeyC", "KeyQ"], desc: "Mở hộp thoại cấu hình.", callback: () => {
							ssData.setting.openSettingModal();
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Ctrl + Insert: toggle #elmPlaylist's extra titles
						{task: "global_togglePlaylistExtraTitles", kCode: ["Ctrl + Insert"], desc: "Ẩn/hiện tiêu đề phụ cho danh mục chương sách.", callback: () => {
							const _button = document.querySelector('button[name="togglePlaylistExtraTitles"]');
							//_button.offsetParent
							if(_button.checkVisibility()) _button.click();
							}
						},

						// Shift + PageDown: next book in History List
						{task: "global_historyGoForward", kCode: ["Shift+PageDown"], desc: "Phát quyển sách tiếp theo trong lịch sử nghe.", callback: () => {
							const _elmHistoryGoBtn = document.getElementById("elmHistoryGoForward");
							if(evt.shiftKey && !_elmHistoryGoBtn.classList.contains("elm-disabled"))
								_elmHistoryGoBtn.click()
							}
						}, //PgDown for next chapter  of current book
						// Shift + PageUp: previous book in History List
						{task: "global_historyGoBackward", kCode: ["Shift+PageUp"], desc: "Phát quyển sách ngay trước trong lịch sử nghe.", callback: () => {
							const _elmHistoryGoBtn = document.getElementById("elmHistoryGoBackward");
							if(evt.shiftKey && !_elmHistoryGoBtn.classList.contains("elm-disabled"))
								_elmHistoryGoBtn.click()
							}
						},  //PgUp for previous chapter of current book

						// Alt + PageDown: next book in History List
						{task: "global_bookListNext", kCode: ["Alt+PageDown"], desc: "Phát quyển sách tiếp theo trong danh mục.", callback: () => {
								if(evt.altKey){
									const _nextBook = ssData.sddBooks.nextItem();
									if(_nextBook)
										// if next book exist, make the change
										ssData.sddBooks.onchange()
									else
										//not, notify user
										toast.showToast("Đã là quyển sách cuối cùng rồi!", toast.ToastType.Warning);	
								}
							}
						}, //PgDown for next chapter  of current book
						// Alt + PageUp: previous book in History List
						{task: "global_bookListPrev", kCode: ["Alt+PageUp"], desc: "Phát quyển sách ngay trước trong danh mục.", callback: () => {
								if(evt.altKey){
									const _prevBook = ssData.sddBooks.prevItem();
									if(_prevBook)
										// if previous book exist, make the change
										ssData.sddBooks.onchange()
									else
										//not, notify user
										toast.showToast("Đã là quyển sách đầu tiên rồi!", toast.ToastType.Warning);
								}
							}
						},  //PgUp for previous chapter of current book
					];

					// if this function run without {evt} parameter, it just save the hotkeys List into ssData.hotKeys.mainPage to notify to user
					if(!evt && !ssData?.hotKeys?.mainPage){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.mainPage){
							ssData.hotKeys.mainPage = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return;
					}

					/* //find if the key just press in the list of supported shortcuts
					const hotkeyOpts = hotkeyOptions.filter(keyItem => keyItem.kCode.indexOf(evt.code)>-1);
					//if found, do the corresponding job
					hotkeyOpts.forEach(hotkeyOpt => hotkeyOpt.callback()); */

					//search if a key just press matched any key specify above, then take the corresponding action (stopPropagation and preventDefault)
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions);
					
				};
				pageKeyDown(); //to get the list of hotKey and saved in ssData.hotKeys.mainPage
				document.addEventListener("keydown", pageKeyDown); 

				/* Loading page:waiting for main page to be fully loaded */
				/* document.onreadystatechange = function () {
					if (document.readyState === "complete") document.querySelector("#loadingPageWrapper").remove();
					return;

					if (document.readyState !== "complete") {
						document.querySelector("body").style.visibility = "hidden";
						document.querySelector("#loadingPageWrapper").style.visibility = "visible";
					} else {
						document.querySelector("#loadingPageWrapper").style.display = "none";
						document.querySelector("body").style.visibility = "visible";
					}
				}; */

				window.addEventListener('resize', function (event) {
					//re-position for pre-hard-coded elements
					guiUtils.reposAllTooltips();

					/*	TODO: reload the book so the chapter-group-label got its height recalculted */
				}, true);

			}
			pageEventHandlers(); //add event handler for the main page

			/* function to initialize state/ui of some buttons, elements that having state stored in xState from last page session */
			(function pagePrepare(){
				// if xState does not have "flags" property yet, initiate a new empty json. xState.flags keep some flags such as disableCircleProgressButton, hideBufferBar, hideExtraTitles, expandBookInfo
				if(!xState.hasOwnProperty("flags")) xState.flags = {expandChapInfo:1}; //expandBookInfo:1, hideExtraTitles:1, disableCircleProgressButton: 1, hideBufferBar: 1, bookKitSetView:1

				//set the initial state for #icnSvgPlayPauseProgress svg sprite icon which control Play/Pause buttons having circle progress or not
				document.getElementById("icnSvgPlayPauseProgress").classList.toggle("isPPP-noProgress", !!xState.flags.disableCircleProgressButton);

				// create playlist object and initialize elmPlaylist handler and playlist-related buttons such as togglePlaylistExtraTitles, gotoPlayingChapter
				ssData.playlist = Playlist();

				/** function to handle the initial 'open' states of the details elemnt which in charge of expanding/collapsing #elmBookInfo (book infor) and #elmChapterInfor (chap infor). This function is gonna need to be bound to each of the aforementioned details elements (to bind it with 'this' in the code).
				 * @param xStatePropName {string}: the name of property in 'xState.flags' which keep the open/close state of the details element. Optional: We migh put this string as property of details element.
				*/
				function detailsElmHandle(xStatePropName){
					// ontoggle in charge of repos the tooltip if it has not been repos-ed before.
					this.ontoggle = function(){
						// this.tooltipFixed is a property added to details elemnt to know if the toolti[p in book/chapter infor has previously repos-ed

						// if details element toggle from 'open' to 'close', meaning the tooltips has already been repos-ed by ssData.ttMutationObserver, so mark it as fixed so if user expand the infor again, reposTooltips() don't have to run again
						//if(!this.open) this.tooltipFixed = true;

						if(!this.tooltipFixed && this.open) {
							// fix svg icon tooltips when book infor expanded for the very first time, because when it is collapsed, the dimemsion of those tooltip has not been initialized
							setTimeout(_ => guiUtils.reposTooltips(this.nextElementSibling), 500);
							this.tooltipFixed = true; //so next time expand the infor, reposTooltips() would not be invoked again
						}
						
						//this set or delete the property xState.flags.expandBookInfo, xState.flags.expandChapInfo
						if(this.open) xState.flags[xStatePropName] = 1 //set to 1 if expanded
						else delete xState.flags[xStatePropName]; //remove out of xState.flags if collapsed
						//this.removeAttribute('ontoggle'); //ontoggle only one time
						
						saveState2Disk();
					}
					this.toggleAttribute("open", !!xState.flags[xStatePropName]);
				}

				// set book and chapter infor expanded or collapsed
				[
					//elm store id of infor element. prop stores the property names in 'xState.flags'
					{elm: "elmBookInfo", prop: "expandBookInfo"},
					{elm: "elmChapterInfor", prop: "expandChapInfo"}
				].forEach(_which => {
					//the details element that is previousElementSibling and control the collapse/expands of book/chapter infor rendered inside #elmBookInfo or #elmChapterInfor
					const _detailElem = document.querySelector(`details:has(+ #${_which.elm})`);

					// _which.prop stores the property name in xState.flags (which can be xState.flags.expandBookInfo or xState.flags.expandChapInfo) which keep the 'open' state of of above _detailElem

					// set initial 'open' state of those details and handle toggle event for those details
					//detailsElmHandle.bind(bookInfoDetailsEl)(_which.prop);
					detailsElmHandle.call(_detailElem, _which.prop);
				});

				/* // set book general infor expanded or collapsed
				const bookInfoDetailsEl = document.querySelector("details:has(+ #elmBookInfo)"); //the details element that control the collapse/expands of book info #elmBookInfo
				detailsElmHandle.bind(bookInfoDetailsEl)("expandBookInfo");

				// set book general infor expanded or collapsed
				const chapInfoDetailsEl = document.querySelector("details:has(+ #elmChapterInfor)"); //the details element that control the collapse/expands of book info #elmBookInfo
				detailsElmHandle.bind(chapInfoDetailsEl)("expandChapInfo"); */
			})();

			//initialize toast object
			toast = Toast();
			toast.showDelayedToast(); //show any delayed message that loadPage might have but haven't got toast object yet to notify to user			

			//initial AudioPlayer object to take care of audio playing and corresponding UI

			//if xState does not have "audio" property yet, initiate a new one with default configuration. The "audio" property keep config for xAudio element such as speed, volume, muted
			if(!xState.hasOwnProperty("audio")) xState.audio = {"speed": 1.4, "volume": 1, "muted": false}; //this actually has been set in config.js file, I keep it here as a fail-safe
			let _spd = xState.audio.speed ?? 1.4; 
			_spd = !isNaN(parseFloat(_spd)) ? parseFloat(_spd) : 1.4; //my default speed
			let _volume = xState.audio.volume ?? 1;
			_volume = !isNaN(parseFloat(_volume)) ? parseFloat(_volume) : 1; //default audio volume
			_volume = Math.max( Math.min(_volume, 1), 0); //volume should be from 0 to 1

			ssData.audioPlayer = AudioPlayer({ speed: _spd, volume: _volume, muted: !!xState.audio.muted }); //init object for audio player

			//initialize Books List search-dropdown
			ssData.sddBooks = new SddDropdown('[name="sdd-BookTitlesDropdown-container"]');
			//initialize Chapters List search-dropdown
			ssData.sddChaps = new SddDropdown('[name="sdd-ChaptersListDropdown-container"]');
			
			//initialize book data, state data (xState) saved in localStorage and load most recently playing book + chapter of last session
			ssData.bookData = BookData(); // instance of BookData class which purely deal with  books and chapters Data
			(function bookDataInitial() { //populate select elements  and load the book
				
				
				/* const _bookdefault = Math.floor(Math.random() * ssData.bIds.length); //0 //the book that would be load when page is load in very first time in user's device
				let _lastBook = ssData.xData[_bookdefault].bookId; //default to load the first book
				if (typeof xState["lb"] != "undefined") {
					_lastBook = xState["lb"];

					//in case last book not exists
					if(!ssData.bookData.findBookFromId(_lastBook)) {
						//clean the history and get the most recent book that still exists
						let _last_existed_book = historyCls.prototype.getAdjHist(0);
						//if found, make that book to be the last-book, the one will be loaded when page initializes
						if(_last_existed_book) _lastBook = _last_existed_book.bookId;
					}
				}
				//set the last-book in xState if it is not yet exist or the last-book was removed (because the database file containing it was removed)
				xState["lb"] = _lastBook; */

				//clean xState.history in case there are some books are not existed anymore
				historyCls.cleanHist();

				//set grpLine if it is not yet exist
				if (xState.grpLine == undefined) xState.grpLine = 0;
				
				const selBookGroup = document.getElementById("selBookGroup");
				// show category/group/ books for current group line
				selBookGroup.value = xState.grpLine;

				/* Load the most recently read book */
				//selBookGroup.onchange() will do the rest. It invokes a stack of calls like this: [popuGrpBookTitles() or popuBookTitles()]--> ssData.sddBooks.onchange() --> changeBook() --> changeChap()
				selBookGroup.onchange();

			})(); //self-invoked function to load the last-book
		
			ssData.setting = Setting(); //instance of Setting class that handle the Setting modal diaglog			
		
			//remove splash screen
			const _loadingPageWrapper = document.querySelector("#loadingPageWrapper");
			//make the effect of splash-screen fading-out
			_loadingPageWrapper.style.opacity = 0;
			setTimeout(_ => _loadingPageWrapper.remove(), 500);

			/* handling double click on different sides of different elements to do the fastforward/rewind for different duration ranges */
			document.addEventListener("dblclick", evt => {
				let _target = evt.target;
				
				//seeking when user double click on workart
				if(_target.getAttribute("id")==='elmArtwork'){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 20;
					else xAudio.currentTime -= 20;
				}

				//seeking when user double click on the div that contain the playing time
				if (_target.tagName === "DIV" && _target.contains(elmPlayingTime) ){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 15;
					else xAudio.currentTime -= 15;
				}

				//seeking when double click on plain, empty (part that does not have any element) part of the body on the left and right
				if(_target === document.body){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 30;
					else xAudio.currentTime -= 30;
				}

				evt.stopPropagation();
			});
			
			const _elmPlaylist = document.getElementById("elmPlaylist"); //Chapter Playlist
			//const to tell if 'div.flex-container' and 'div[name="divCtnMiddle"]' flex-direction is in column mode or not
			const _COLUMN_MODE = document.querySelector("div.flex-container").css("flex-direction") == 'column'; //window.innerWidth < 850
			//setting the width for workart and the max-height for playlist in COLUMN MODE
			if(_COLUMN_MODE){
				//elmArtwork.style.width = "100%";
				_elmPlaylist.style["max-height"] = "550px";

				//move the sleep-timer countdown to be the last child of functional buttons container
				const _sleepTimerCouterContainer = document.querySelector("div:has(> #elmSleepTimerCountDown)");
				if(_sleepTimerCouterContainer){
					//the div that is container of all functional buttons (like sleeping timer, jumping/seeking, setting,...)
					const _functionalButtonsContainer = document.querySelector("div[name='divCtnAudioControl']");
					//insert at the end of the container
					_functionalButtonsContainer.insertBefore(_sleepTimerCouterContainer, null);
				}
			}

			/*  - fail-safe when high-res youtube image not available
				- align the height of elmPlaylist with the cover image on the left if it is too long
			*/
			const _elmArtwork = document.getElementById("elmArtwork");
			const _DEFAULT_POSTER_IMG = "default.jpg"; //"https://th.bing.com/th/id/OIG1.umQWEGl8_HY7m9Mm76ww";
			_elmArtwork.onload = async (_event) => {
				let elmArtwork = _event.target;
				// when a youtube thumbnail not exist, youtube will return a fallback image whose size is 120x90 so onerror event on elmArtwork will never be fired. This small trick is a way to know that an thumbnail not exist, so we replace another existed one.
				const low_resolution_ytImg = "hqdefault.jpg";  //can use mqdefault.jpg with lower resolution but it is 16:9 thumbnail. Both of this thumbnail is guranteed to be existed
				if (elmArtwork.naturalWidth === 120) {
					if( elmArtwork.src.includes(low_resolution_ytImg) ) {
						//still fail even if already default resolution image, might mean the YT video already been removed, so we use default image
						elmArtwork.src = _DEFAULT_POSTER_IMG;
						return;
					}

					elmArtwork.src = elmArtwork.src.replace(/([^\/])+$/, low_resolution_ytImg);

					//update new artwork to notification center
					guiUtils.updateNCWorkart();

					return;
				}

				//fix the width (which then fix the size) of elmArrtwork depending on  the ratio of width and height of source image
				const _nRatio = elmArtwork.naturalWidth / elmArtwork.naturalHeight;
				const _elmWidth = _nRatio > 1.3? 450 : ( _nRatio > 1 ? 400 : (_nRatio > .8 ? 350 : 300) );
				elmArtwork.style.width = _elmWidth + "px";

				//setting the width for workart and the max-height for playlist
				if(_COLUMN_MODE){
					//few lines of code above, we already set the width for workart and the max-height for playlist AND move the countdown sleep timer up					
					return; // so the rest of this block code for ROW MODE
				}
				
				//align the height of elmPlaylist with the cover image on the left if it is too long
				let _leftSideHeight = 0;
				for (let _elm of elmArtwork.closest('[name="divCtnMiddle"]').firstElementChild.children) {
					if (_elm.tagName === 'svg')
						//note that no-wifi svg does not have offsetHeight
						_leftSideHeight += _elm.getBoundingClientRect().height
					else
						_leftSideHeight += _elm.offsetHeight;
				}
				const chapterListHeight = ssData.sddChaps.displayElement.getBoundingClientRect().height;
				_elmPlaylist.style["max-height"] = Math.max(_leftSideHeight + 10 - chapterListHeight, 450) + "px";
			}
			_elmArtwork.onerror = evt => {
				//reload the image if it got error for the reason lost internet last time it got loaded
				let _retryCount = _elmArtwork.getAttribute("reload-Count");
				_retryCount = parseInt(_retryCount);
				if(isNaN(_retryCount)) _retryCount = 0;
				//update "reload-Count" with value increased by 1
				_elmArtwork.setAttribute("reload-Count", ++_retryCount);

				if (navigator.onLine){
					//allow trying reload 3 times
					if (_retryCount < 3)
						_elmArtwork.src = _elmArtwork.src + "?" + performance.now().toFixed(0);
					else if (_retryCount < 10) //in case _DEFAULT_POSTER_IMG not exists, which should never happen but still be able to
						_elmArtwork.src = _DEFAULT_POSTER_IMG;
					else 
					//in case _DEFAULT_POSTER_IMG not exists, which should never happen but still be able to. BUt I need to find a way for img element to stop keeping firing onerror event. Other way to do this is set _elmArtwork src to some inline svg image (which this page currently does not have)
					{
						// set src to empty or null actually does nothing
						_elmArtwork.setAttribute('src', "");
						// save onerror handler to savedErrorHandler property for next time to get it back
						_elmArtwork.savedErrorHandler = _elmArtwork.onerror;
						// set onerror to null to avoid infinite loop of reload when fallback image _DEFAULT_POSTER_IMG not found
						_elmArtwork.onerror  = null;
					}
				}
				else{
					//show cover img or sprite svg image of No Internet depending on state of internet connection
					guiUtils.showNoInternet();
				}
			}
			_elmArtwork.onclick = evt => {saveState2Disk()};
		}

		/* user changes to other books
			bookValue: value of selected item of elmSelBookTitles, not selected index in the elmSelBookTitles element, which in fact is stt of book in ssData.xData
			*/
		function changeBook(bookValue) {
			//bookValue = parseInt(bookValue);

			//if still the same book, then do nothing. This happens sometimes, for example when close the User-Setting windows, Page will updates all the setting changes, and finally re-load book+chapter
			if (xAudio.getAttribute("attr-Book") == bookValue) return;

			//div element which contains book information
			const elmBookInfo = document.getElementById("elmBookInfo");
			// the <details> element which control collapsing/expanding of #elmBookInfo
			const _detailElem = elmBookInfo.previousElementSibling;
			//set this so that if Book infor being collapsed this moment, but later user expand Book infor, the 'ontoggle' handler of details element would know to run reposTooltips() at that point of time to fix the tooltip position
			_detailElem.tooltipFixed = _detailElem.open;

			// observe the _elmChapterInfor element, so when its newly added children and desendant rendered, adjust tooltips position
			ssData.ttMutationObserver.observe(elmBookInfo, { childList: true, subtree: true });
			// obsever if div[name="divOtherControlTop"] which contains checkbox to expand/collapse all chapter-group be show-up or hidden
			ssData.ttMutationObserver.observe(document.querySelector('[name="divChapterGroupControls"]'), { attributes: true, attributeFilter: ["class"] });

			historyCls.addToHistory(bookValue); //add new book to History if it was not hostory back/forward

			//update state
			xState["lb"] = bookValue;
			//if not yet available, make a new JSON for this book
			if (typeof xState.history.books[bookValue] == "undefined") xState.history.books[bookValue] = { "urlLine": 0 }; //urlLine remember the url link index should be played for all chapter this book if each chapter has multiple mp3 links

			let bData = ssData.bookData.findBookFromId(bookValue); // [bookValue - 1]; //bData contains all information for current book

			//add the background based on its grp[0] value (which somewhat defines the type of the book)
			const _grp0 = bData.grp[0];
			//remove old background class if there any
			const _clsList = document.querySelector('div[name="divCtnTop"]').classList;
			_clsList.forEach(_cls => {if(_cls.endsWith('Bgrnd')) _clsList.remove(_cls)});
			// for book that is buddhist sutra or sermon or book, added the lotus background
			if(_grp0.match(/\$10[A-F]$/)) _clsList.add("lotusBgrnd");
			if(_grp0.match(/\$([1~3]|11|12)$/)) _clsList.add("detectiveBgrnd");
			if(_grp0.match(/\$([6-9]|4)$/)) _clsList.add("fantasticNovelBgrnd");
			if(_grp0.match(/\$(13[ACSR]|5A|5B)$/)) _clsList.add("classicNovelBgrnd");
			if(_grp0.match(/\$5X$/)) _clsList.add("xianxianBgrnd");

			// Create real media links, cover image, original (outside) url,..., generate chaps groups from autoTap attribute for parts that have wildcart
			BookData.prototype.generateWCLinks(bookValue);

			let strOrgLink = "<div>Nguồn: <ul class='inlineList'>";
			if (Array.isArray(bData.ssrc)) {
				let i = 1;
				bData.ssrc.forEach(s => { strOrgLink += "<li><a target='_blank' href='" + s + "'>" + (getHostName(s)) + "</a></li>" });
			}
			else
				strOrgLink += `<li><a target='_blank' href='${bData.ssrc}'>${getHostName(bData.ssrc)}</a></li>`; //
			strOrgLink += "</ul></div>";

			let totalDuration = BookData.prototype.bookStatistics(bData).totalDur;
			//for (let i = 1; i <= bData.parts.length; i++) { totalDuration += toSeconds(bData.parts[i - 1].dur); }

			//update the total duration of the Book
			const _elmBookTotalDuration = document.getElementById("elmBookTotalDuration");
			elmBookTotalDuration.querySelector("span:first-of-type").innerHTML = toHhMmSs(totalDuration);
			const _elmBookRealListening = elmBookTotalDuration.querySelector("span:last-of-type");
			_elmBookRealListening.setAttribute("attr-duration", totalDuration);
			_elmBookRealListening.innerHTML = toHhMmSs(totalDuration / xAudio.playbackRate);

			/* Update book infor to detail elem at the bottom of page */
			document.getElementById("elmBookTitle").innerHTML = bData.title + (bData.eTitle && bData.eTitle != bData.title ? " <wbr/>(" + bData.eTitle + ")" : ""); /* <wbr> and css style '#elmBookTitle{text-wrap: nowrap}' can auto-break the line after <wbr/> into new line if the whole title is more than 1 line. However, for now this seem not work in Safary */
			
			/** function to make general information of the books and put in bunch of li elements */
			function makeLiGeneralInfor() {
				/** function to generate svg icon along with tooltip and css style for each type of information
				* @param _type: inforType, see the code for details
				*/
				let makeSvgStr = _type => {
					let _iconTitle = ["Mã sách", "Số chương", "Tác giả", "Năm xuất bản", "Thể loại", "Người đọc", "Thời gian còn lại của sách", "Thời gian nghe còn lại thực tế của sách (theo tốc độ phát)", "Số nhóm chương"];
					let _iconNames = ["icnSvgId", "icnSvgChapters", "icnSvgMaleAuthor", "icnSvgCalendar", "icnSvgBookType", "icnSvgMicrophone", "icnSvgRemainTime", "icnSvgListenTime", "icnSvgChapGroupIcon"];
					let _inlineStyle = "", _class = "svg-img-infor";

					//real Listening time icon
					if (_type == 7) _inlineStyle = "width: 1.2em;";
					/* if (_type == 6 || _type == 7) //make these two time icons a bit bigger
						_class += " svg-img-infor-13"; */
					return `<code style="display: inline-block" data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom">${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}</code>`; //
				}

				return `<ul class='inlineListInfor' style='padding-inline-start: 0px;'>
					<li>${makeSvgStr(0)}<span style='user-select: auto;-webkit-user-select: auto;' data-tooltip="${bData.dbPath.file}.${bData.dbPath.bookKit}[${bData.dbPath.idx+1}]\n[${bData.grp}]" data-tooltip-location="bottom">${bData.bookId}</span>.</li>
					${bData.tap? "<li>" + makeSvgStr(8) + "<span>" + bData.tap.length + "</span></li>" : ""}
					<li>${makeSvgStr(1)}<span>${bData.parts.length} chương.</span></li>
					<li>${makeSvgStr(6)}<span>${toHhMmSs(totalDuration)}</span>&ensp;${makeSvgStr(7)}<span attr-duration="${totalDuration}" role="listeningTime">${toHhMmSs(totalDuration / xAudio.playbackRate)}</span></li>
					<li>${makeSvgStr(2)}<span>${bData.author}</span></li>`
							+ (bData.year ? `<li>${makeSvgStr(3)}<span>${bData.year}</span></li>` : "")
							+ `<li>${makeSvgStr(4)}<span>${bData.type}</span></li>
					<li>${makeSvgStr(5)}<span}>${bData.mc}</span></li>
				</ul>`;
			}

			document.getElementById("elmBookInfo").innerHTML = `${strOrgLink}
			<div xrole="containing-tooltip">${makeLiGeneralInfor()}
			<div id="elmBookGioithieu" class="bookChapIntro">${bData.intro}</div>
			</div>`;

			/** function to format the subtitle, for now, it italic the number (which usually be the chapter number of text book) 
				* @param subTit {string, undefined} the sub title
				* @param _for {boolean}
				* 		@value true: create html code for option of ssData.sddChaps
				* 		@value false: create html code for li element of ol#elmPlaylist
				* @example convert '80: Thái Dương thủ; 81: Ám giới; 82: Tần trong Tần Mục' into '<i>80</i>: Thái Dương thủ; <i>81</i>: Ám giới'
			*/
			const formatSubTit = (subTit, _for) => {
				if(!subTit) return "";
				subTit = subTit.replace(/(\d+)[\:\–\.\-]/g, "<i>$1</i>:");
				return "<div class='item-2nd-main-div subTitle'>" + subTit + "</div>";
				/* return _for ? 
					"<div class='item-2nd-main-div subTitle'>" + subTit + "</div>" :
					"<br/><span class='subTitle'>" + subTit + "</span>"; */
			}

			/* Create the Playlist which includes books' chapters */
			let _makeLiItem = (i) => {
				let _track = document.createElement('li');
				
				//set attribute data-rAlignGroup for right-align
				_track.innerHTML = `<code data-rAlignGroup='chapDuration'>${makeBrk(bData.parts[i - 1].dur)}</code> <span>${bData.parts[i - 1].tit}</span>${formatSubTit(bData.parts[i - 1].sTit, false)}`;

				//set class for li element in order to set font-size for chapter ordenal so the li::before pseudo can fit the whole number
				if( i >= 100) _track.classList.add(i > 999? "fourDigitOrdernalNo": "threeDigitOrdernalNo");
				_track.setAttribute("attr-stt", i);

				return _track;
			}
			
			const _elmPlaylist = document.getElementById("elmPlaylist"); //Chapter Playlist
			_elmPlaylist.innerHTML = ""; //clear the Playlist
			let sddOptionData=[], sddOptGroup = null;
			if (bData.tap) {	//Neu sach co nhieu tap
				let _divChapterGroupControls = document.querySelector('[name="divChapterGroupControls"]');
				_divChapterGroupControls.classList.remove("elm-hidden"); //show control buttons for chapter groups
				//reposTooltips(_divChapterGroupControls); // need to re-pos tooltip for elems that just show up

				let _bookxState = xState.history.books[bookValue];
				if (!_bookxState.chapGrpCollapse) _bookxState.chapGrpCollapse = []; //initialize chapGrpCollapse array for this book if it is not existed

				let j = 0, liGroup = null;
				let _groupTotalDur = 0;

				sddOptGroup = [];
				for (let i = 1; i <= bData.parts.length; i++) {
					if (bData.tap[j].f == i) {//start new group
						let _chapGrpChkbox = document.createElement('input');
						_groupTotalDur = 0;
						_chapGrpChkbox.type = "checkbox";
						_chapGrpChkbox.checked = !_bookxState.chapGrpCollapse.includes(j); //last time this group is collapsed or expanded
						_chapGrpChkbox.id = "chapGrpChkbox_" + j;
						_chapGrpChkbox.setAttribute("attr-grpNo", j);

						//Make label for group of chapters
						let _lbl = document.createElement('label');
						_lbl.htmlFor = "chapGrpChkbox_" + j;
						_lbl.style.fontWeight = "bold"; //make it bold to calculate maximum height of all labels
						_lbl.innerHTML = `<span style="display:block"><code class="underlineAnim">${bData.tap[j].label}</code></span>`;
						_lbl.classList.add("is-sticky");
						_elmPlaylist.appendChild(_chapGrpChkbox);
						_elmPlaylist.appendChild(_lbl);

						liGroup = document.createElement('section');
					}

					//add options setting data  for sddChaps
					sddOptionData.push({stt: i, gId: j,
						value: i, 
						label: bData.parts[i - 1].tit,
						dur: makeBrk(bData.parts[i - 1].dur),
						sTit: bData.parts[i - 1].sTit,
						eTit: bData.parts[i - 1].eTit,
						attr: {"attr-stt": i}
					});

					//Add li item to playlist
					liGroup.appendChild(_makeLiItem(i));
					_groupTotalDur += toSeconds(bData.parts[i - 1].dur);

					if (bData.tap[j].t == i || i == bData.parts.length) {//end of current option group
						if (j < bData.tap.length - 1 && bData.tap[j].t != bData.tap[j + 1].f - 1) {
							//Create dummy group for items that not belong to any group
							let _lbl = document.createElement('label');
							_lbl.innerHTML = "Orphan chapters";
							_elmPlaylist.appendChild(_lbl);
						}

						//adding label to display chapter group summary
						let grpSummary = document.createElement('label');
						grpSummary.classList.add("chapter-group-summary");
						let _chapCount = bData.tap[j].t - bData.tap[j].f + 1;
						grpSummary.innerHTML = `<span>Số chương: <code>${_chapCount}</code>.</span><span>Thời lượng: <code>${toHhMmSs(_groupTotalDur)}</code> / <code attr-duration="${_groupTotalDur}">${toHhMmSs(_groupTotalDur / xAudio.playbackRate )}</code></span>`;
						liGroup.prepend(grpSummary); //add to top

						_elmPlaylist.appendChild(liGroup);
						//right align duration of all chapter in this section
						SddDropdown.prototype.rightAlignElems(liGroup, "li");

						// add information for optGroup to setting
						sddOptGroup.push( {stt: j+1, gId: j, 
							label: `${int2Roman(j+1)}. ${bData.tap[j].label}`, 
							extraInfor: [_chapCount, toHhMmSs(_groupTotalDur)],
							attr: {"attr-grpNo": j}
						});

						j++; //prepare for new option group
					}
				}

				// update tooltip for label of allChapGrpChkbox checkbox
				ssData.ttMutationObserver.observe(document.querySelector('label[for="allChapGrpChkbox"]'), { attributes: true, attributeFilter: ["data-tooltip"] });
				//utilityHandles.updateAllChapGrpChkboxUI(); //update allChapGrpChkbox UI when all done
				ssData.playlist.updateAllChapGrpChkboxUI(); //update allChapGrpChkbox UI when all done

				/* make all group label same height so that when scroll up/down, the down sticky label would stay fit above the up group label*/
				let _chapGroupLabels = _elmPlaylist.querySelectorAll("input[type='checkbox'] + label");
				// wait for all labels to be rendered to find biggest height of all group labels
				setTimeout( () => {
					let _maxLabelHeight = 0;
					_chapGroupLabels.forEach(_lbl => {
						_maxLabelHeight = Math.max(_maxLabelHeight, _lbl.getBoundingClientRect().height);
						_lbl.style.fontWeight = null; //reset fontWeight that set before
					})

					_chapGroupLabels.forEach(_lbl => {
						_lbl.style.height = _maxLabelHeight + "px"; //make all label same height so when they are pinned to gether, they will fit above (and below) each other
					});
				}, 500);

				// stops watching all of old target elements, empty array of IntersectionObserverEntry (if any) for visibility changes.
				ssData.playlist.pinnedObserver.disconnect();
				// observe new chapter-group-labels
				_chapGroupLabels.forEach(_lbl => { ssData.playlist.pinnedObserver.observe(_lbl) });
			}
			else {// cho sach chi co 1 tap
				sddOptGroup = null;
				document.querySelector('[name="divChapterGroupControls"]').classList.add("elm-hidden"); //hide controls for chapter group
				for (let i = 1; i <= bData.parts.length; i++) {
					//add li to playlist
					_elmPlaylist.appendChild(_makeLiItem(i));

					//add options setting data  for sddChaps
					sddOptionData.push({stt: i, 
						value: i, 
						label: bData.parts[i - 1].tit,
						dur: makeBrk(bData.parts[i - 1].dur),
						sTit: bData.parts[i - 1].sTit,
						eTit: bData.parts[i - 1].eTit,
						attr: {"attr-stt": i}
					});
				}
				//right align duration of all chapters
				SddDropdown.prototype.rightAlignElems(_elmPlaylist, "li");
			}//.replace(/(\d+):/g, "<i>$1</i>:")

			//create setting for sddBooks
			const chapterListSetting = {
				name: "chapterTitles",				
				displayOneLine: false,
				//diacriticsFilterMode: xState?.chapterListDiacriticsSearch ?? true,
				//decorate background for SDDDropdownContent and SDD-dropdown-border-bottom, we specify customized class for whole .sdd-wrapper container
				customizedCssClass: "sdd-wrapper-chapterList",
				//avatarIcon: "icnSvgChapters", //set avatar using svg sprite #icnSvgChapters
				searchBoxPlaceholder: "Tìm trong {_items_length} chương sách ...",
				//rightAlignInEachOptGroup: false, //force right-align for items in whole SDD (not by optGroup as sddBooks)
				
				render: {
					//function to render the option
					option: function (data, escape) {
						return `<div class="item-main-div"><code class="item-slight-details" data-rAlignGroup="chapterDuration">${escape(data.dur)}</code>&emsp13;<span>${data.label}</span></div>
						${formatSubTit(data.sTit, true)}` +
						`${data.eTit? "<div class='item-2nd-main-div englishTitle'>" + data.eTit + "</div>" : ""}`;
					},
					//function to render the selected option to representative DIV
					select_option: function (option, escape) {
						return option.firstChild.innerHTML; // textContent;
					},
					//function to render the optGroup
					optgroup_header: function (data, escape) {
						return `<span>${escape(data.label)}</span>&emsp13;<span class="item-slight-details">[${escape(data.extraInfor[0])} chương / ${escape(data.extraInfor[1])}]</span>`;
					},
					'no_results': () => {
						return 'Không tìm thấy chương sách nào';
					}
				},
				callbacks: {
					//callback function to be invoked when onChange event fire (a new item is selected)
					onChange: function (selectedItem) {
						//console.log(`onChange event: ${selectedItem.value}`);
						changeChap(selectedItem.value);

						/* //open section if it is currently collapsed and scroll into playing chapter
						document.querySelector('[name="gotoPlayingChapter"]').click();  */
					}
				}
			};

			// Find out last playing chapter of current book. If this book has not been playing before, just start from chapter 1
			let lastChap = parseInt(xState.history.books[bookValue]["lc"] ?? 1);
			//we need attr-PrevBook to save playing time before changing to other book
			xAudio.setAttribute("attr-PrevBook", xAudio.getAttribute("attr-Book") ?? "");
			xAudio.setAttribute("attr-Book", bookValue); //save book id to xAudio attribute
			
			// make sure sddChaps load Setting only one time in one page session 
			if( !ssData.sddChaps.hasOwnProperty("settingLoaded") ){
				ssData.sddChaps.loadDropdown(chapterListSetting, ssData.sddChaps.LOAD_MODE_ENUM.SettingLoadOnly);

				ssData.sddChaps.settingLoaded = true;
			}

			// load/reload the sddChaps Data for the new book
			ssData.sddChaps.loadDropdown(
				{
					options: sddOptionData,
					optgroups: sddOptGroup
				}, 
				ssData.sddChaps.LOAD_MODE_ENUM.DataLoadOnly, 
				''+ lastChap //callbacks.onChange() take value to set selected item, so we have to convert to string if lastChap is integer
			);

			//changeChap(lastChap);
		}

		/* Function to take care of playing other chapter including preparing information for new chapter, load new source for audio,...
		newChap: stt of new chapter, can be text or number
		*/
		function changeChap(newChap) {
			//remember the last position that audio was played before new book/chapter attributes are updated to xAudio
			saveAudioCurrentTime();

			let bData = ssData.bookData.findBookFromId( xAudio.getAttribute("attr-Book") ) ; //bData contains all information for current book

			const _elmPlaylist = document.getElementById("elmPlaylist"); //Chapter Playlist

			//Check the validity of variable newChap
			if (newChap == undefined) return;
			newChap = parseInt(newChap);
			if (isNaN(newChap)) return;

			let chapLength = ssData.sddChaps.length;

			//if play the chapter that is currently playing, do nothing
			let _liNewChap = _elmPlaylist.querySelector(`li[attr-stt="${newChap}"]`);
			if (_liNewChap?.classList.contains("beingPlay")) { 
				//utilityHandles.updateNCWorkart(); //this does not seem to reload the Notification Center, but load the workart one more time
				//if item stt newChap having beingPlay class, meaning newChap is playing, then do nothing
				return; 
			} 

			if (newChap < 1 || newChap > chapLength) {
				toast.showToast("Không tìm thấy chương truyện có số thứ tự " + newChap, toast.ToastType.Warning);
				return;
			}

			//update sddChaps selected Item
			ssData.sddChaps.value = newChap;

			// dismiss all Toasts that might be belong to old chapter (if user switch chapter too fast)
			toast.dismissAll();

			//change selected appearance in Playlist
			let _lastTrack = _elmPlaylist.querySelector("li.beingPlay");
			_lastTrack && _lastTrack.classList.remove("beingPlay");
			_liNewChap.classList.add("beingPlay");
			//open section if it is currently collapsed and scroll into playing chapter
			document.querySelector('[name="gotoPlayingChapter"]').click();

			(function () { //to enable/disable the preivous/next chapter button depending on the location of chapter to be the first or the last one
				/* _elmSkipPrev = document.querySelector(".ap-prev-btn");
				if(newChap == 1) _elmSkipPrev.classList.add("elm-disabled")
				else _elmSkipPrev.classList.remove("elm-disabled"); */

				let _elmSkipNext = document.querySelector(".ap-next-btn");
				if (newChap == chapLength) _elmSkipNext.classList.add("elm-disabled")
				else _elmSkipNext.classList.remove("elm-disabled");
			})();

			//check done, remember the current Book and current Chapter for later use when needed
			xAudio.setAttribute("attr-chap", newChap);

			let elmChapterTitle = document.getElementById("elmChapterTitle");
			let chapData = bData.parts[newChap - 1]; //information for new selected chapter of current book

			/* add html code to format the title. Check Lỗ Ban and Tiên hiệp novel */
			/* const _formatTit1 = tit => {
				tit = tit.replace(/\s+/g," ");
				//adding break for some place marked with " - ", not " – " (long alt+151 em-dash; alt+150 en-dash)
				tit = tit.replaceAll(" - ", "<br/>");

				//Following separate char ('[\:\–\.\-]') can be replaced by '\b.'

				//format for text looks like '1-Thôn nhỏ bên núi' (without 'Hồi|Chương|Phần|Tập' preceding)
				// /((?<!Hồi|Chương|Phần|Tập)\s+\d+\s*[\:\-])/g
				tit = tit.replaceAll(/((?<!Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*[\:\–\.\-])/gi, "<b style='color:#1566bf'>$1</b>");

				//format for text looks like 'Hồi 1.1', 'Chương 2 -5' (two numbers)
				tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+(?:\s*[\:\–\.\-]\s*\d+))/gi, "<b style='color:#c09618'>$1</b>");

				//format for text looks like 'Chương 1: ', 'Tập 1 -' (single number) without matching a part of two numbers like 'Chương 19 – ' of 'Chương 19 – 23'
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\s*[\:\-\.\-]?\s*(?!\d+)))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:[\:\–\.\-\s]+(?!\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\s*[\:\–\.\-]+(?!\s*\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:[\s\:\–\.\-]\s*(?!\d)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+((?!\s*[\:\–\.\-]\s*\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+\s*(?:[\:\–\.\-](?!\s*\d+)|(?![\:\–\.\-])|$))/gi
				// /((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*(?:[\:\–\.\-\(](?!\s*\d+)|$))/gi
				tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*(?=[\:\–\.\-\(](?!\s*\d+)|$))/gi, "<b style='color:green'>$1</b>");

				//tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập)\s+\d+\s*[\:\-])/g, "<b style='color:darkred'>$1</b>"); //–
				//tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\.\d+)?[\:\s](?![\-\–]\s*\d+))/g, "<b style='color:green'>$1</b>");
				return tit;
			} */

			/* add html code to format the title. Check Lỗ Ban and Tiên hiệp novel, Buddish  */
			const _formatTit = tit => {
				tit = tit.replace(/\s+/g, " ");
				//adding break for some place marked with " - ", not " – " (long alt+151 em-dash; alt+150 en-dash)
				tit = tit.replaceAll(" - ", "<br/>");

				const separators = "[\\:\\–\\.\\-]";
				const roman = "[IVXLCDM]+";
				//name of class which will be used to format text
				const class_names = ["hoi", "chuong", "phan", "tap", "quyen", "pham", "bai", "cau"];
				// keywords
				const capTits = ["Hồi", "chương", "Phần", "Tập", "Quyển", "Phẩm", "Bài", "Câu"];

				capTits.forEach((key,i) => {
					key = key.charAt(0).toUpperCase() + key.slice(1);
					const cls = `tit-${class_names[i]}`;

					// Dạng x phân cách y (vd: Hồi 1.2, Phẩm IX-1)
					tit = tit.replace(
						new RegExp(`${key}\\s+(\\d+${separators}\\d+|${roman}${separators}\\d+)`, "gi"),
						`<span class="${cls}">${key} $1</span>`
					);

					// Dạng số đơn (vd: Hồi 3, Phẩm IX)
					tit = tit.replace(
						new RegExp(`${key}\\s+(${roman}|\\d+)`, "gi"),
						`<span class="${cls}">${key} $1</span>`
					);
				});

				// Số đứng một mình trước dấu phân cách
				tit = tit.replace(
					new RegExp(`(?:\\s|;)(\\d+)(?=\\s*${separators})`, "g"),
					'<span class="tit-so-don"> $1</span>'
				);

				return tit;
			};

			const _formatTit1 = tit => {
				tit = tit.replace(/\s+/g," ");
				//adding break for some place marked with " - ", not " – " (long alt+151 em-dash; alt+150 en-dash)
				tit = tit.replaceAll(" - ", "<br/>");
				return tit
					// Hồi x.y
					.replace(/Hồi\s+(\d+\.\d+)/g, '<span class="tit-hoi">Hồi $1</span>')
					// Hồi x
					.replace(/Hồi\s+(\d+)/g, '<span class="tit-hoi">Hồi $1</span>')
					// Chương x.y
					.replace(/Chương\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-chuong">Chương $1</span>')
					// Chương x
					.replace(/Chương\s+(\d+)/g, '<span class="tit-chuong">Chương $1</span>')
					// Phần x.y
					.replace(/Phần\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-phan">Phần $1</span>')
					// Phần x
					.replace(/Phần\s+(\d+)/g, '<span class="tit-phan">Phần $1</span>')
					// Tập x.y
					.replace(/Tập\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-tap">Tập $1</span>')
					// Tập x
					.replace(/Tập\s+(\d+)/g, '<span class="tit-tap">Tập $1</span>')
					// Quyển x.y
					.replace(/Quyển\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-quyen">Quyển $1</span>')
					// Quyển x
					.replace(/Quyển\s+(\d+)/g, '<span class="tit-quyen">Quyển $1</span>')
					// Phẩm x.y (gồm số thường và số La Mã)
					.replace(/Phẩm\s+(\d+[\:\–\.\-]\d+|[IVXLCDM]+(?:[\:\–\.\-]\d+)?)/g, '<span class="tit-pham">Phẩm $1</span>')
					// Phẩm x
					.replace(/Phẩm\s+(\d+|[IVXLCDM]+)/g, '<span class="tit-pham">Phẩm $1</span>')
					// Bài x.y
					.replace(/Bài\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-bai">Bài $1</span>')
					// Bài x
					.replace(/Bài\s+(\d+)/g, '<span class="tit-bai">Bài $1</span>')
					// Câu x.y
					.replace(/Câu\s+(\d+[\:\–\.\-]\d+)/g, '<span class="tit-cau">Câu $1</span>')
					// Câu x
					.replace(/Câu\s+(\d+)/g, '<span class="tit-cau">Câu $1</span>')
					// Số đứng một mình (trước dấu :)
					.replace(/(?:\s|;)(\d+)(?=\s*[\:\–\.\-])/g, '<span class="tit-so-don"> $1</span>');
			}

			document.querySelector(".ap-title").innerHTML = chapData.tit; //small track title right above progress bar
			elmChapterTitle.innerHTML = "<span style='color:darkblue;'>" + pad(newChap, 2) + "/" + pad(bData.parts.length, 2) + ".</span> " + _formatTit(chapData.tit) + (chapData.sTit? "<span class='chapterSubtitles'> ⸺ " + _formatTit(" " + chapData.sTit) + "<span>" : "" ) ; //〰︎〰︎ —	〰
			//https://perishablepress.com/all-the-hyphens-dashes/

			// calculate total remaining duration, note that this is displayed in book Infor and used to calculte percentage right below
			const remainDuration = BookData.prototype.bookStatistics(bData, newChap).totalDur;
			const _listenedDur = bData.statistics.totalDur - remainDuration;
			// calculte percentage of all chapters (from chapter 1 to chapter right before current chapter) has been listen in compared with the whole book
			const _listenedPercent = ( (1 - remainDuration / bData.statistics.totalDur)*100 ).toFixed(1);

			let tit = elmChapterTitle.innerText;
			/* inforType 0:🎧 1:🕓 2:📆 3:🎤 4: cId
				5: tooltip for Media 6: tooltip for switch mp3 links button
			*/
			let makeSvgStr = (_type, _tooltip) => {
				let _iconTitle = ["Thời lượng", "Thời gian nghe thực tế", "Năm xuất bản", "Người đọc", "Id của chương truyện", "Link trực tiếp chương truyện", "Đổi nghe link tiếp theo", "Skip-start: Thời gian bỏ qua đầu mỗi chương"];
				let _iconNames = ["icnSvgDuration", "icnSvgListenTime", "icnSvgCalendar", "icnSvgMicrophone", "icnSvgId", "icnSvgMediaLinks", "", "icnSkipStart"];
				let _inlineStyle = "", _class = "svg-img-infor";
				/* if (_type == 1) {
					_inlineStyle = "font-size:1.5em;margin-bottom: -.4em";
				}
				//for small icon, need to zoom it a bit so it looks equally to other icon
				if (_type == 1 || _type == 5) _class += " svg-img-infor-13"; */

				//icon for percentage of listened duration in compared with total duration				

				if (!_iconNames[_type]) return ` data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom"` // style="--data-translateX: -20%"
				else
					return `<code data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom">${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}</code>`;
			}
			//Adding infor for the chapter
			let strBookInfo = "";
			strBookInfo += `${chapData.eTit ? "Tên gốc: <i>" + chapData.eTit + "</i><br>" : ""}`;
			strBookInfo += `<span xrole='containing-tooltip'><ul class='inlineListInfor'>
				${chapData.dur ? "<li>" + makeSvgStr(0) + "<span>" + chapData.dur + "</span> " + makeSvgStr(1) + "<span attr-duration='" + toSeconds(chapData.dur) + "' role='listeningTime'>" + toHhMmSs(toSeconds(chapData.dur) / xAudio.playbackRate) + "</span></li>" : ""}
				${bData.skipStart ? "<li>" + makeSvgStr(7) + "<span>" + bData.skipStart + " giây</span></li>" : ""}
				<li><span id='percentageListened' style='background-size: ${_listenedPercent}% 100%;' data-listened-duration='${_listenedDur}' data-book-dur='${bData.statistics.totalDur}' data-listened-percent='${_listenedPercent}' data-tooltip='Phần trăm tổng thời lượng đã nghe [${ toHhMmSs(_listenedDur)}]&#xaso với cả cuốn sách [${ toHhMmSs(bData.statistics.totalDur)}]' data-tooltip-location='bottom'>${_listenedPercent}%</span></li> 
				${chapData.year ? "<li>" + makeSvgStr(2) + "<span>" + (chapData.year) + "</span></li>" : ""} 
				${bData.mc ? "<li>" + makeSvgStr(3) + "<span>" + bData.mc + "</span></li>" : ""} 
				${(chapData.cId) ? "<li>" + makeSvgStr(4) + "<span>" + chapData.cId + "</span></li>" : ""}`; //!bData.grp[2].split(".").pop().match(/[A-F]/) && 

			//set direct Link for audio
			let strLink = "<li><span  id='elmMp3Links'>" + makeSvgStr(5) + "Media: ";
			if (!Array.isArray(chapData.url)) {
				chapData.url = [chapData.url]; //if not array, convert to array for simpler code below
			}
			//if having multiple audio sources, list all of them and show Switch src button
			if (chapData.url.length > 1)
				strLink += `<button class='svgButton switchChapterAudioSrc' style='padding: 1px 5px 0px 5px;' onclick='ssData.audioPlayer.setSource(false)' ${makeSvgStr(6)}><svg class='button-svg-img' style='font-size:15px'><use href='#icnSvgSwitchChapterLinks'/></svg></button>&nbsp;`;

			//add audio url for playing
			strLink += "<ul class='inlineList'>";
			for (let i = 1; i <= chapData.url.length; i++)
				if (chapData.url[i - 1]) //in case url is empty or null or even undefined
					strLink += `<li role='audioSrc'><a target='_blank' href='${chapData.url[i - 1]}'>${getHostName(chapData.url[i - 1])}</a></li>`;

			//adding outside url (reference url, cannot be used as audio src)
			strLink += (chapData.oUrl ? `<li><a class='outsideLink' target='_blank' href='${chapData.oUrl}'>${getHostName(chapData.oUrl)}</a></li>` : "");
			strLink += "</ul><span></li>"; //closing tags

			let _chapInfor = "";
			if (chapData.infor)
				_chapInfor = ` ∴ <details ${window.chapInforDetailsOpen ? "open" : ""} ontoggle="window.chapInforDetailsOpen = this.open;" style="display: inline-block;margin-bottom: -5px;"><summary style="padding-top: 0px;cursor:pointer;">${makeSvgFromSprite("icnSvgChapterInfor", { class: "svg-img-infor", style: "" })}</summary></details><div class="detailContent"><div class="bookChapIntro" style="font-size: .8em;">${chapData.infor}</div></div>`;

			//div element which contains current chapter information
			let _elmChapterInfor = document.getElementById("elmChapterInfor");
			// the <details> element which control collapsing/expanding of #elmChapterInfor
			const _detailElem = _elmChapterInfor.previousElementSibling;
			//set this so that if Book infor being collapsed this moment, but later user expand Chapter infor, the 'ontoggle' handler of details element would know to run reposTooltips() at that point of time to fix the tooltip position
			_detailElem.tooltipFixed = _detailElem.open;

			// observe the _elmChapterInfor element, so when its newly added children and desendant rendered, adjust tooltips position
			ssData.ttMutationObserver.observe(_elmChapterInfor, { childList: true, subtree: true });
			//Show chapter information on the page	
			_elmChapterInfor.innerHTML = strBookInfo + strLink + "</ul></span>" + _chapInfor;

			//update chapter/book cover
			let elmArtwork = document.getElementById("elmArtwork");
			//elmArtwork.title = tit;
			//reset the number of time trying reload the image when error loading image
			elmArtwork.setAttribute("reload-Count", 0);
			//if somehow _DEFAULT_POSTER_IMG not exists (which should never happen) and last time failed to load workart and failed to load _DEFAULT_POSTER_IMG, onerror handler has to set to null to avoid infinite loop of reload broken img. Then the original onerror handler is saved in _elmArtwork.savedErrorHandler property, we have to get it back so onerror can handle picture failed load
			if(elmArtwork.onerror === null) elmArtwork.onerror = elmArtwork.savedErrorHandler;

			//size of image is now moved to elmArtwork.onload()
			if (chapData.img) { //if there is a chapter cover
				//update Chapter cover if there any
				elmArtwork.src = chapData.img;
				//elmArtwork.style.width = "450px";
			}
			else {
				elmArtwork.src = bData.cover;
				//elmArtwork.style.width = "300px";
			}

			//show cover img or sprite svg image of No Internet depending on state of internet connection
			guiUtils.showNoInternet();

			// update total remaining duration, note that this is displayed in book Infor
			let _elmRealRemainListening = document.getElementById("elmBookInfo").querySelector("[attr-duration]");
			
			_elmRealRemainListening.parentElement.querySelector("span:first-of-type").innerText = `${toHhMmSs(remainDuration)} (${bData.parts.length - newChap + 1} chương)`; //first span is total duration
			//const _elmRealRemainListening = _totalRemainDurElem.querySelector("span:last-of-type");
			_elmRealRemainListening.setAttribute("attr-duration", remainDuration);
			_elmRealRemainListening.innerText = toHhMmSs(remainDuration / xAudio.playbackRate); //last span is real listenning time

			document.title = xAudio.title = tit;

			// set infor shown on notification center
			if ('mediaSession' in navigator) {
				navigator.mediaSession.metadata = new MediaMetadata({
					title: makeBrk(chapData.dur) + " " + tit,
					artist: bData.author,
					album: bData.title,
					artwork: [
						{ src: elmArtwork.src, sizes: '512x512', type: 'image/png' }
					]
				});
				/* navigator.mediaSession.setActionHandler on "previoustrack", "nexttrack","play", "pause", "seekbackward", "seekforward" is set on Auio Player */
			}

			//trying load audio src with fail-safe to play other url line if current url line failed
			ssData.audioPlayer.setSource(false);

			// update audio source and playing new chapter
			let _bookValue = xAudio.getAttribute("attr-Book");
			// Lưu chương mở gần đây nhất của cuốn sách
			xState.history.books[_bookValue]["lc"] = newChap;

			//Jump to last audio played position
			(function gotoLastPosition() {
				let _bookValue = xAudio.getAttribute("attr-Book");
				let bSt = xState.history.books[_bookValue];
				if (!bSt) return;
				let cSt = parseFloat(bSt[parseInt(xAudio.getAttribute("attr-chap"))]);
				//if don't have that last-position, then we use skipStart set in chapter infor, If there is no skipStart in chap setting, use skipStart of book infor. If there is still no skipStart, then start from beginning
				cSt = !isNaN(cSt)? cSt: ( chapData?.skipStart ?? (bData?.skipStart ?? 0) );
				if (cSt) xAudio.currentTime = cSt;
			})();

			//Save xState into localStorage. This has to be put after gotoLastPosition() above, otherwise saveState2Disk() save 0 as currentTime for current chapter, then - as the result gotoLastPosition() goto time 0
			saveState2Disk();
		}

		//function to save position of current (of most recently, depend on cases) playing audio
		let saveAudioCurrentTime = () => {
			//get last book + chapter that is or was playing
			let _lB = xAudio.getAttribute("attr-Prevbook"); //_lB has to got from attr-Prevbook to handle the case changing book, the bookStt to save to xState belongs to previous book, not current book
			let _lC = xAudio.getAttribute("attr-chap");

			xAudio.setAttribute("attr-Prevbook", xAudio.getAttribute("attr-book")); //so if next chapter (of same book) play, _lB point to correct book
			if (_lB && _lC) { //note that, when the first chapter of first book playing, _lB="" and _lC should be null
				let currTime = xAudio.currentTime << 0; //get the integer
				if (currTime + 5 > xAudio.duration) {
					//if playing very close to end of video, then make it play from beginning next time
					delete xState.history.books[_lB][_lC];
				}
				else //save the position 
					xState.history.books[_lB][_lC] = currTime;
			}
		}

		/** Save and recorded page states to Local Disk
		 * @param xStateOnly {boolean}
		 * 	@value true (default): save only xState to disk
		 * 	@value false: save xState, xDBFilesCfg to disk
		 * @return a promise that outside code which invokes this function can use '.then()' to do something when localStorage saving is done (see closeSettingModal() function).
		*/
		function saveState2Disk(xStateOnly = true) {
			//using Promise so that the saving process does not block other work of the page, also its '.then()' could help on synchronous coding
			return new Promise( (resolve, reject) => {
				//using setTimeout so that the saving process does not block other work of the page
				setTimeout( _ => {
					//save current time into xState
					saveAudioCurrentTime();

					//Save xState into Local Storage
					localStorage.setItem('xState', JSON.stringify(xState));

					//save dbfile config
					if(!xStateOnly)
					localStorage.setItem('xDBFilesCfg', JSON.stringify(xDBFilesCfg));

					//only resolve when all savings done. Meaning if using .then(), the code inside then() work only after all savings have been finished
					resolve(1);
				}, 0);//delay 0 meaning this saving task will be carried out at next js call stack
			});
		}

	</script>

	<!-- SMALL CLASSES -->
	<script>
		"use strict";
		/* IIFE Function contains handler for buttons that utilize small popup */
		(function smallPopup(){
			/* Handle small popup for button functions Seek to a duration time for audio to play */
			function showSleepTimerPopup() {
				//the popup
				let _popupDiv = document.getElementById("sleepTimerDivPopup");
				//the button on main page that when click on it, the popup show-up
				let _btnShowPopup = _popupDiv.previousElementSibling; 
				//the textbox to type in the sleep timer
				let _ipSleepTimer = document.getElementById("ipSleepTimer");
				//datalist that _ipSleepTimer bind to
				const _sleepTimersDatalist = document.getElementById("sleepTimersDatalist");

				// the div that contains the span displaying count down sleep timer text (below workart)
				const _stCountdownCtn = document.querySelector('div:has( > #elmSleepTimerCountDown)');
				// the span that contains count down sleep timer text
				const _stCountdownSpan = document.getElementById("elmSleepTimerCountDown");

				//can take 'h', '-', ':' as the hour delimiter
				const _pattern = /^\d+(\s+phút|\s*[hHgG\.\-\:]\s*\d*)?$/;

				_ipSleepTimer.setAttribute("pattern", _pattern.source); //pattern to check valid
				_popupDiv.querySelector("label[for]").innerHTML = "Nhập thời gian dừng phát truyện theo định dạng, bấm Enter để đặt hẹn giờ:<br>— <b>HH[<i>delimiter</i>]mm</b>; ví dụ: <b>1h20</b> = 1 giờ 20 phút<br>— <b>mm</b>; ví dụ: <b>45</b> = 45 phút.<br/>Trong đó <b>HH</b> là số giờ, <b>mm</b> là số phút;  <b>[<i>delimiter</i>]</b> có thể là một trong các kí tự <b>H</b>, <b>h</b>, <b>G</b>, <b>g</b>, <b>.</b>, <b>-</b>, <b>:</b>";			
				
					//show the popup and put focus on the textbox
				_popupDiv.classList.add("shortPoupShow");
				SddDropdown.prototype.glowingElem(_popupDiv); //glow the popup to attract user attention
				_ipSleepTimer.focus({ focusVisible: true, preventScroll: false });

				if (!_ipSleepTimer.onkeyup) { //check this, so these event defined only one time

					/** function convert back and ford from time to time string
						* @time {string, number}
						* if number, it conver time to time string. E.g: 60 -> '1h', 75 -> '1h15'
						* if string, it conver time string to time (number). E.g: '1h' -> 60, '1h15' -> 75, '75' -> 75
					*/
					function convertSleepTime(time){
						if(typeof time == 'number'){
							let _timeStr = time;
							if(time >= 60){
								_timeStr = ( (time/60) << 0) + "h" + (time%60 || '');
							}
							return _timeStr;
						}

						if(typeof time == 'string'){
							if(!time.match(_pattern)) return null;

							//standard the hour delimiter
							time = time.replace(/[HGg\.\-\:]/g, 'h');

							let _times = time.split("h").map(_t => Number(_t) );
							let _timeMinutes = _times.pop();

							if(_times.length > 0){
								_timeMinutes += _times.pop() * 60;
							}
							return _timeMinutes;
						}
					}
					
					/** initial the global variable to keep the sleep timer state where
						* @timer store the amount of seconds the audio will be paused
						* @endTime store the point of time the audio is paused
						* @stObj store the setInterval variable  
						* @count store the number of steps (each step is 1 second) left to reach to timer end. Because setInterval not working properly when tab is inactive, so we need to regularly update this property to best match the real time going by.
						*/
					ssData.sleep = {
						timer: 0, 
						endTime: null, 
						siObj: null,
						count: null,
						enum: {"0": "Bỏ hẹn giờ",
							"-1": "Khi nghe hết chương hiện tại"
						}
					};

					/* initiate the datalist */
					let _defSleepTimes = [15, 30, 45, 60, 75, 90, 120, 180];
					//get array of sleep timer if xState saved that array
					if(xState.sleepTimers && Array.isArray(xState.sleepTimers)) _defSleepTimes = xState.sleepTimers;
					//populate the datalist
					_sleepTimersDatalist.innerHTML = _defSleepTimes.map(_time => {
						//because _time might be string, so we need to convert it to number for convertSleepTime to work as designed
						const _formattedTime = convertSleepTime( parseInt(_time) );
						// note that when select an option, content entered into input element will always come from the value attribute.
						return `<option value="${_formattedTime}" label="${_time} phút"></option>`;
					}).join(" ");
					
					
					/* function to active a sleep timer by the text in the _ipSleepTimer, also standardize _ipSleepTimer text (convert into hour format, e.g, if user type in '1h5' or '65', _ipSleepTimer text would be 1h5) */
					const _setSleepTimer  = _ => {
						
						// do some clean-up if user type in wrong-format string
						if(!_ipSleepTimer.checkValidity()){
							_ipSleepTimer.value = ssData.sleep.timer > 0 ? convertSleepTime(ssData.sleep.timer) : "";
							toast.showToast("Thời gian hẹn giờ nhập không đúng định dạng", toast.ToastType.Error);
							_popupDiv.classList.remove("shortPoupShow");
							return;
						}

						/** function to stop Sleep-Timer 
							* @param interuptOldTimer {boolean}
							* 	@value false or missing: meaning the current Sleep timer reach to the end, so we need to stop it
							* 	@value true: user decide to disable current sleep timer
						*/
						const stopSleepTimer = interuptOldTimer => {
							const _sleepObj = ssData.sleep;
							clearInterval(_sleepObj.siObj);

							//const to know if there is an sleep timer is counting down
							const _AN_TIMER_ACTIVE = _sleepObj.siObj !== null;

							//reset sleep variables
							_sleepObj.timer = 0;
							_sleepObj.count = 0;
							_sleepObj.siObj = null;
							_sleepObj.endTime = null;

							//reset appearance of show popup button
							_btnShowPopup.classList.remove("sleepTimerActive");

							//hide the count down span
							_stCountdownCtn.classList.add("elm-hidden");
							//clear the blinking class (added when the timer when there is 30 seconds left)
							_stCountdownSpan.classList.remove("almostReachingEnd");

							//clear timer input
							_ipSleepTimer.value = "";
							
							//stop audio only for the case when the Sleep timer reached to the end
							if(!interuptOldTimer){
								xAudio.pause();

								toast.showToast("Dừng phát audio do đã tới thời gian hẹn giờ tắt", toast.ToastType.Warning, {duration: 1e4});
							}
							else if(_AN_TIMER_ACTIVE){
								toast.showToast("Tắt đồng hồ hẹn giờ trước hạn hoặc đặt hẹn giờ mới thay thế.", toast.ToastType.Warning, {duration: 1e4});
							}
						}

						//remove all spaces
						let newSleepTimeTxt = _ipSleepTimer.value.replace(/\s/g, "");
						
						//Check if timer string is empty or 0 (disable timer)
						if (!newSleepTimeTxt || newSleepTimeTxt === '0'){
							// if there is an active timer, stop it
							if(ssData.sleep.timer > 0) 
								stopSleepTimer(true); //interupt to end current timer without stopping audio
							_popupDiv.classList.remove("shortPoupShow");
							return;
						}

						//convert newSleepTimeTxt to number of minutes to compare with label's option
						let newSleepTime = convertSleepTime(newSleepTimeTxt);

						//Check if new timer was already there in the timer datalist, if not, push it in the datalist and saved new list to xState
						if(!_sleepTimersDatalist.querySelector('[label^="' + newSleepTime + ' "]')){
							// search right location to add newSpeed
							let i = 0;
							while (i < _sleepTimersDatalist.options.length && parseInt(_sleepTimersDatalist.options[i].label) < newSleepTime) {
								i++;
							}
							
							let _newOption = new Option("", convertSleepTime(newSleepTime) ); //text, value
							_newOption.label = newSleepTime + " phút";

							//add new speed before location just found
							_sleepTimersDatalist.insertBefore(_newOption, _sleepTimersDatalist.options[i]);
							
							//save the new list of Sleep Timers into xState
							xState.sleepTimers = [..._sleepTimersDatalist.options].map(_opt => parseInt(_opt.label));
						}

						/* NOW, SETTING a NEW Sleep TIMER */
						stopSleepTimer(true); // interupt and stop timer, do some clean up of old (but still active) timer (if any)

						//convert the number of minutes into hour format in the input box
						_ipSleepTimer.value = convertSleepTime(newSleepTime);

						//update ssData.sleep
						const _sleepObj = ssData.sleep;
						_sleepObj.count = _sleepObj.timer = newSleepTime * 60; //in seconds
						// set the time that the Sleep timer ends, specified by the number of seconds elapsed since the epoch
						_sleepObj.endTime = (Date.now() / 1000  << 0) + _sleepObj.timer;

						//change appearance of show popup button
						_btnShowPopup.classList.add("sleepTimerActive");

						// show the count down sleep timer text (below workart)
						_stCountdownCtn.classList.remove("elm-hidden");

						//start an interval to update the count-down sleep timer string and to pause audio (and do some resetting) when sleep time is reached
						_stCountdownSpan.textContent = toHhMmSs(_sleepObj.count);
						_sleepObj.siObj = setInterval(_ => {
							_sleepObj.count --;
							_stCountdownSpan.textContent = toHhMmSs(_sleepObj.count);
							//console.log(_sleepObj.count);

							// note that when a tab is inactive, the setInterval may work incorrectly (See 'Timeouts in inactive tabs' in setTimeout function from Mdn), especially when page is NOT playing sound using a Web Audio API AudioContext (even an audio is playing but being mute). Also, setInterval always being delayed (see mdn), so we need to update _sleepObj.count regularly based on system time to make sleep timer work more correctly. See this link https://stackoverflow.com/a/16033979/36866 for limits the minimum interval on inactive tab for different browsers
							//document.hidden && 
							if(_sleepObj.count % 10 == 0 || _sleepObj.count < 30) {
								// we re-update the counter based on system time every 10 times setInterval invoked or when timer reaching to the end
								_sleepObj.count = _sleepObj.endTime - (Date.now() / 1000  << 0);
							}

							//blinking the timer when there is 30 seconds left 
							if(_sleepObj.count == 30) {
								_stCountdownSpan.classList.add("almostReachingEnd");
							}

							// when timer reach to the very end
							if(_sleepObj.count <= 0) {
								stopSleepTimer();
								/* console.log("Reached end at: " + toHhMmSs(xAudio.currentTime) + ". Paused = " + xAudio.paused);
								xAudio.pause(); //just for sure, can be removed since it already been done on stopSleepTimer()
								console.log(xAudio.paused); */
							}
						}, 1000);						

						_popupDiv.classList.remove("shortPoupShow");
					}

					/* function to handle when user click outside the popup or press Escape. It just keep the old timer (or there was no sleep timers set, keep it that way) */
					const _inputBlured = _ev => {
						const _sleepObj = ssData.sleep;
						_ipSleepTimer.value = _sleepObj.timer == 0 ? "" : convertSleepTime(_sleepObj.timer / 60);
						_popupDiv.classList.remove("shortPoupShow"); //close the popup
					}					
					
					//keyup event to handle some specfic key like Enter or Escape
					_ipSleepTimer.onkeyup  = _ev => {
						//Shift+backspace, Escape to clear the textbox
						if(_ev.shiftKey && _ev.code=="Backspace") _ipSleepTimer.value = "";

						//Enter to set the Sleep Timer
						if( ["Enter", "NumpadEnter"].includes(_ev.code) ) {
							//_ipSleepTimer.blur();
							_setSleepTimer();
						}

						if (_ev.code === "Escape") {
							_inputBlured();
						}					

						_ev.stopPropagation();
					}

					//user click outside the small popup would work as click Escape in above onkeyup
					_ipSleepTimer.addEventListener("focusout", _inputBlured);

					//This function has only one job to avoid event propagate upward in the DOM, so that key press on this textbox not bubbling up, so keydown event handlers of main page would not does what it is intended to do such as pause/stop audio, key -/+ can decrase/increase audio playbackRate, open book sdd or chapter sdd
					_ipSleepTimer.addEventListener("keydown", evt => {evt.stopPropagation()});
				}
			}

			/* Handle small popup for button functions Seek to a duration time for audio to play */
			function showSeekAudioDurationPopup() {
				let _popupDiv = document.getElementById("seekDurationDivPopup");
				let _ipDuration2Seek = document.getElementById("ipAudioDuration");
				// the second part of regex (after |) is for ±.ss format
				const _pattern = /^([\+\-]?(([1-5]?\d[.,:])?([0-5]?\d)[.,:])?([0-5]?\d))|([\+\-]?[.,:][0-5]?\d)$/; //accept . or , or : as duration seperator
				let _maxDuration = xAudio.duration;
				if (!_maxDuration) _maxDuration = 0;

				_ipDuration2Seek.setAttribute("pattern", _pattern.source); //pattern to check valid
				_popupDiv.querySelector("label[for]").innerHTML = "Nhập thời gian muốn tua nhanh đến theo định dạng (dấu <b>+</b> hoặc <b>–</b> là độ lệch thời gian tua đến tính từ thời gian hiện tại): <b>[±]H.mm.ss</b>, <b>[±]mm.ss</b>, <b>[±]mm</b> hoặc <b>[±].ss</b><br/>(Thời lượng không quá <b>" + toHhMmSs(_maxDuration) + "</b>)";
				_ipDuration2Seek.value = ""; 

				_popupDiv.classList.add("shortPoupShow"); //show the popup
				SddDropdown.prototype.glowingElem(_popupDiv); //glow the popup to attract user attention
				_ipDuration2Seek.focus({ focusVisible: true, preventScroll: false });

				if (!_ipDuration2Seek.onkeyup) { //check this, so these event defined only one time
					let seekAudioTo = () => {
						let _toTime = _ipDuration2Seek.value.trim(); //time in  H.mm.ss format 
						if (_pattern.test(_toTime)) {
							let _toDur = 0; //duration to jump to

							let plusMinus = _toTime[0];
							if ("+-".indexOf(plusMinus) > -1) {
								_toTime = _toTime.slice(1); //remove the +/- sign to get the time in h:mm:ss only
							}
							else plusMinus = ""; //there is no sign at all

							_toTime = _toTime.replaceAll(/[\.\,]/g, ":"); //change to H:mm:ss format
							let _seekDistanceMsg = plusMinus == "" ? "" : (plusMinus == "+" ? "Tiến thêm " : "Lùi lại ") + _toTime;

							//convert string to number of seconds
							if (_toTime.indexOf(":") == -1) //format mm
								_toTime = parseInt(_toTime) * 60
							else //the other two format, including ":ss" format
								_toTime = toSeconds(_toTime);

							//handle +/- sign
							if (plusMinus === "+") _toTime += xAudio.currentTime;
							if (plusMinus === "-") _toTime = xAudio.currentTime - _toTime;

							if (_toTime >= 0 && _toTime < xAudio.duration) { //if within the audio duration
								if (_seekDistanceMsg != "") toast.showToast(_seekDistanceMsg)
								xAudio.currentTime = _toTime; //this will raise audio onseeked event
								//xAudio.onseeked();
							}
							else
								toast.showToast(_toTime < 0 ? "Thời gian không được nhỏ hơn 0" : "Thời gian bạn nhập lớn hơn tổng thời lượng của chương truyện", toast.ToastType.Warning);
						}
						else {
							if (_toTime) //only show message when user type something
								toast.showToast("Thời gian bạn nhập không đúng format", toast.ToastType.Error);
						}

						_popupDiv.classList.remove("shortPoupShow");
					}

					/* Capture when user click Enter/Escape */
					_ipDuration2Seek.onkeyup = (_ev) => {
						//console.log(_ev.code);
						if (_ev.code === "Enter" || _ev.code === "NumpadEnter") {
							_ev.preventDefault();
							//if we call seekAudioTo() here, it would be invoked twice with one more time at focusout event. So, I call blur() to make textbox lost focus
							_ipDuration2Seek.blur();
						}

						if (_ev.code === "Escape") {
							_popupDiv.classList.remove("shortPoupShow"); //do nothing
						}
						_ev.stopPropagation();
					}

					//user click outside the small popup would work as click Escape in above onkeyup
					_ipDuration2Seek.addEventListener("focusout", seekAudioTo);

					//This function has only one job to avoid event propagate upward in the DOM, so that key press on this textbox not bubbling up, so keydown event handlers of main page would not does what it is intended to do such as pause/stop audio, key -/+ can decrase/increase audio playbackRate, open book sdd or chapter sdd
					_ipDuration2Seek.addEventListener("keydown", evt => {evt.stopPropagation()});
				}
			}
		
			document.getElementById("sleepTimerButton").addEventListener("click", showSleepTimerPopup);

			document.getElementById("seekDurationButton").addEventListener("click", showSeekAudioDurationPopup);
		})();

		/* Class contains handler for utility buttons and some other task. I wrap it in a class for easier to track source code */
		class guiUtils {
			/* update new artwork to notification center */
			static updateNCWorkart() {
				if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
					//it seems after assigned, navigator.mediaSession.metadata being read-only
					let _meta = navigator.mediaSession.metadata; //old one
					//assign the new MediaMetadata with same old data, except the new artwork
					navigator.mediaSession.metadata = new MediaMetadata({
						title: _meta.title,
						artist: _meta.artist,
						album: _meta.album,
						artwork: [
							{ src: elmArtwork.src, sizes: '512x512', type: 'image/png' }
						]
					});
				}
			}

			/** show/hide the workart image and hide/show the NoInternet svg image
				* @param _show {boolean}. Default is navigator.onLine value
				* 	true: show the workart and hide the NoInternet icon
				* 	false: vice versa
				*/
			static showNoInternet(_show = navigator.onLine ){
				document.getElementById("elmArtwork").parentElement.classList.toggle("elm-hidden", !_show);
				document.querySelector(".noInternetImg").classList.toggle("elm-hidden", _show);
			}

			/** Set the state checked, indeterminate or unchecked for a textbox
				@param _chkBox {HTML element} : the checkbox to set state
				@param _state {interger}: 	0 : unchecked
									1 : checked
									2 : indeterminate
			*/
			static setChkboxState(_chkBox, _state) {
				if (_state === 0) {
					_chkBox.indeterminate = false; //to avoid UI mess-up when browser does not know the state of checkbok
					_chkBox.checked = false;
				}
				else if (_state === 1) {
					_chkBox.indeterminate = false; //to avoid UI mess-up when browser does not know the state of checkbok
					_chkBox.checked = true;
				}
				else _chkBox.indeterminate = true;
				_chkBox.dataset.stateVal = _state;
			}

			/** Re-calculate location of ::before pseudo which contain the tooltip 
				@param parentElem {HTML element}: the element that contains all the descendant element who has tooltip (has attribute data-tooltip)
				@param options {JSON}: might contain some property
					@attribute container {HTMLElement}: HTML element that tooltip is not allowed to go off its edges. If missing, the default container is top-level div which contains almost all of the page div.[name="divContainer"]
					@attribute selfElem {HTMLElement}: re-position tooltip for this selfElem itself. 
					@attribute fixSmallPopup: fix location for small popup (see UtilityHandles class). If this set to true, selfElem has to set to button that trigger the popup. parentElem set to null
			*/
			static reposTooltips(parentElem, options) {

				let _container = options?.container ?? document.querySelector('[name="divContainer"]');
				let _containerPos = _container.getBoundingClientRect();
				/* Calculate left,right for element {_ttElem} having top/bottom tooltip */
				function calculateTooltipPos(_ttElem) {
					
					let _ttPos = _ttElem.getBoundingClientRect();
					//the element currently invisible (maybe just because its parent invisible), so any calculation is pointless
					if(_ttPos.width == 0) return;

					let fixSmallPopup = options?.fixSmallPopup ?? false;
					//fixSmallPopup to fix location for smallPopup. Otherwise, set for tooltip
					let _ttBeforePos = !fixSmallPopup ? getComputedStyle(_ttElem, '::before') : _ttElem.nextElementSibling.getBoundingClientRect();

					let _ttLocation = _ttElem.dataset.tooltipLocation;
					if (!["left", "right", "bottom"].includes(_ttLocation)) _ttLocation = "top";

					if (_ttLocation == "top" || _ttLocation == "bottom" || fixSmallPopup) {
						/* //left, right of ::before calculted in the distance from parent
						let _ttBeforeLeft = parseFloat(_ttBeforePos.getPropertyValue("left"));
						let _ttBeforeRight = parseFloat(_ttBeforePos.getPropertyValue("right")); */

						let _ttBeforeWidth = (!fixSmallPopup) ? parseFloat(_ttBeforePos.getPropertyValue("Width")) : _ttBeforePos.width;

						/* Because ::before and ::after was initially set in CSS left:50%, so before all translate, the initial left (before all translate() action) of ::before is (_ttPos.left + _ttPos.width/2) */
						let _ttBeforeInitalLeft = _ttPos.left + _ttPos.width / 2;
						/* if translateX(-50%), then the right, left of ::before changes to (_ttBeforeLeft ± _ttBeforeWidth/2) */
						let _ttBeforeTX50Left = _ttBeforeInitalLeft - _ttBeforeWidth / 2;
						let _ttBeforeTX50Right = _ttBeforeInitalLeft + _ttBeforeWidth / 2;

						// check to see if tooltip goes off on left/right side of container when set 'transform: translateX(-50%)' for it. In the case of going off, calculate --data-translateX which is number of poxel need to move left (if <0) or right(if>0) from initial position (also this overides translateX(-50%)) so that tooltip is positioned inside
						let _elemToFix = (!fixSmallPopup) ? _ttElem : _ttElem.nextElementSibling;
						//with fixSmallPopup, need more property to set for pseudo ::afterm which is a pointing-up triangle
						if (fixSmallPopup) _elemToFix.style.setProperty("--data-translateX-pseudo-after", `${_ttPos.left + _ttPos.width / 2 - 19}px`); //19px is get from trial&error
						if (_ttBeforeTX50Left < _containerPos.left) { //the left side of tooltip goes off
							_elemToFix.style.setProperty("--data-translateX", `-${_ttBeforeInitalLeft - _containerPos.left - 5}px`);
						}
						else if (_ttBeforeTX50Right > _containerPos.right) { //the right side of tooltip goes off
							_elemToFix.style.setProperty("--data-translateX", `-${_ttBeforeInitalLeft + _ttBeforeWidth - _containerPos.right + 5}px`);
						}
						else { // if it already fit in, remove this style in case it was set last time page resize
							_elemToFix.style.removeProperty("--data-translateX");
							_elemToFix.style.removeProperty("--data-translateX-pseudo-after");
						}
					}
				}

				//if parentElem is specified and it currently is visible (not being hidden such as having css like display:none). Note that if an parent is invisible, all of its descendant invisible, too. In that case, calculateTooltipPos() would not work correctly because all dimension of invisible element are 0
				if (parentElem && parentElem.offsetParent)
					parentElem.querySelectorAll("[data-tooltip]").forEach(_ttElem => {
						calculateTooltipPos(_ttElem);
					})
				if (options?.selfElem)
					calculateTooltipPos(options.selfElem);
			}

			/* Re-position tooltip for element that hard-code in the page HTML, some element adaptively created by js is not the concern here */
			static reposAllTooltips() {
				/* I. Re-postion for all markup-hard-coded elements having tooltips */
				//adjust tooltip for buttons in extra audio controls
				guiUtils.reposTooltips(document.querySelector('[name="divCtnAudioControl"]'));

				//tooltip for big total playing time
				guiUtils.reposTooltips(document.getElementById("elmBookTotalDuration"));

				//reposition for small popup such as one for audio seeking and one for set sleep timer
				document.querySelectorAll(".havingShortPopup > button").forEach(_elem => guiUtils.reposTooltips(null, { selfElem: _elem, fixSmallPopup: true }));

				//repos tooltip for .ap-time--remains element which contains TimeRanges for audio.played, audio.buffered, audio.seekable
				//guiUtils.reposTooltips( null, {selfElem: document.querySelector('.ap-time--remains')} );
				//or this to include .ap-reload-btn button
				guiUtils.reposTooltips(document.querySelector('.ap--playback'), {container: document.body}); 

				//guiUtils.reposTooltips(document.querySelector('[name="divChapterGroupControls"]') );

				/*	TODO: Each time History Back/Forward buttons is click, its tooltip content changes, so might need to re-position for those button to update the changes
				*/

				/* II. Re-postion for all added-by-js elements having tooltips */
				//re-position tooltip for Book Infor svg icons
				guiUtils.reposTooltips(document.getElementById("elmBookInfo"));

				//re-position tooltip for Chapter Infor svg icons
				guiUtils.reposTooltips(document.getElementById("elmChapterInfor"));

				//re-calculate location for Book Kit/Set view checkbox in modalSetting
				//guiUtils.reposTooltips(document.querySelector(".modalPopupContent > :first-child"), {container: document.querySelector(".modalPopupContentWrapper") });
			}
		
		}

		/** playlist object which handle #elmPlaylist actions, chap-group-label and playlist-related buttons such as togglePlaylistExtraTitles, gotoPlayingChapter or checkbox #allChapGrpChkbox */
		function Playlist(){
			const _elmPlaylist = document.getElementById("elmPlaylist"); //Chapter Playlist

			/* ----- HANDLER FOR BUTTONS ----- */

			/* Scroll to chapter in playlist that is playing. This would be invoked when new chapter is playing or when user click on scroll to playing chapter button */
			function gotoPlayingChapter() {
				let _liNewChap = _elmPlaylist.querySelector("li.beingPlay");
				if (!_liNewChap) return; //this should never happen

				let _liParent = _liNewChap.parentElement;
				// flag got value TRUE when section (which contains current playing chapter) is already expanded or there is no section at all
				let _wasSectionExpanded = true;
				let _chapGrpCheckbox = null; //checkbox that control the expand/collapse state of a section

				// if new playing chapter is inside a chapter group, then open that group if it currently close
				if (_liParent.nodeName == "SECTION") { //can use tagName or localName
					_chapGrpCheckbox = _liParent.previousElementSibling.previousElementSibling;
					_wasSectionExpanded = _chapGrpCheckbox.checked;

					//expand the group if it not yet expanded. Here using click() command so that collapsed state of this chap-group is saved to xState
					!_wasSectionExpanded && _chapGrpCheckbox.click();
					//_chapGrpCheckbox.checked = true; //expand the group if it not yet expanded

					/* if(!_isSectionExpanded)
					//update UI of #allChapGrpChkbox
					updateAllChapGrpChkboxUI(); */
				}

				/** function to scroll to current playing chapter and doing rescroll when necessary
				 */
				function _scrollToView(){
					
					//scroll to make _liNewChap in the middle of #elmPlaylist with 'smooth' effect
					const scrollFn = _ => SddDropdown.prototype.scrollToElement(_elmPlaylist, _liNewChap, 'smooth', true); 
					scrollFn();

					// function to do rescroll if _liNewChap still out of view, scroll it again to make it in the middle of #elmPlaylist (its container). Rescroll or not, we finally need to fix group-chapter-labels overlap
					const reScroll = _ => {
						//sometime DOM update too slow, this rescroll might run on old li.beingPlay (and thus it scroll to last playing chapter instead of new one), so I do the check here which look very unreasonable
						if(!_liNewChap.classList.contains("beingPlay")) return;

						//distance from _liNewChap top to top of container
						const _topDistance = _liNewChap.getBoundingClientRect().top - _elmPlaylist.getBoundingClientRect().top;
						//if _liNewChap still out of view, scroll it again
						if( _topDistance < 0 || _topDistance > _elmPlaylist.offsetHeight ) scrollFn();
						
						// update UI of #allChapGrpChkbox. An then, if some sections label overlap, make it move down a bit to avoid overlapping
						_chapGrpCheckbox && !_wasSectionExpanded && setTimeout(_ => {
							//update UI of #allChapGrpChkbox
							//updateAllChapGrpChkboxUI();
							//avoid overlapping, if any
							preventChapGroupLabelsOverlap();
						}, 100);
					}

					/* Doing rescroll (if necessary) and fix group-chapter-labels overlap */
					// waiting in msec so that we can approximately know that scroll has ended
					const _WAIT2RESCROLL = 100;

					/* //first way may be as simple as this approach: wait for some pre-defined duration until above smooth scrolling animation ends.Clearly, this approach does not work some time, especially when elmPlaylist has been loaded with huge new data (when book changes) and we need to scroll to last playing chapter
					setTimeout(reScroll, 3*_WAIT2RESCROLL); */

					//2nd approach: roughly polyfill scrollend event (https://developer.chrome.com/blog/scrollend-a-new-javascript-event) and do rescroll when scrollend
					let _TOid;
					function tempFnc(evt){
						//console.log("scroll");
						//clear old timeout when it has not finished, but there is new 'scroll' event fired
						if(_TOid) clearTimeout(_TOid);

						//set the new timeout so that when this timeout expires and before that there is no any scroll event fired, we do rescroll and some extra clean-up
						_TOid = setTimeout(_ => {
							// do rescroll and fix group-chapter-labels overlap
							reScroll();
							//remove scroll handler
							_elmPlaylist.removeEventListener("scroll", tempFnc);
							clearTimeout(_TOid);
						}, _WAIT2RESCROLL);
					}
					_elmPlaylist.addEventListener("scroll", tempFnc);
					//small-hack: scroll playlist up and down a bit to fire 'scroll' event in-case that the above scrollFn() does not scroll playlist at all, so 'scrollend' polyfill has no chance to removed the event handler tempFnc. So if user manually scroll away from current playing chapter, tempFnc will be invoked to scroll back to current playing chapter. Other method (2nd method) is to set a timeout to remove 'scroll' event after some time, doesn't care if it has been removed or not
					setTimeout(_ => _elmPlaylist.removeEventListener("scroll", tempFnc), _WAIT2RESCROLL*10); //2nd method
					/* setTimeout(_ => { 
						_elmPlaylist.scrollTop += 1; _elmPlaylist.scrollTop -= 1;
					}, _WAIT2RESCROLL*3); */

					//update UI of #allChapGrpChkbox only when necessary
					_chapGrpCheckbox && !_wasSectionExpanded && updateAllChapGrpChkboxUI();

					/* _liNewChap.scrollIntoView({
						behavior: 'smooth', //smooth sometime does not scroll to the location of playing chapter. Change to 'auto' might lack of scroll animation, but when the page first start, it can scroll into playing chapter
						block: 'center', //vertically centered
						inline: 'end'
					}) */
				}

				if (_wasSectionExpanded) _scrollToView()
				else{
					//setTimeout(_scrollToView, 800); //wait for closed section to be expanded before scrolling

					//wait for the section animation to be finished then scroll to the playing chapter. Note that _liParent is <section> element which directly contains the li.beingPlay playingChapter
					_liParent.addEventListener("transitionend", function tempFunc(){
						//remove the event listener when done
						_liParent.removeEventListener("transitionend", tempFunc);
						//scroll to playingChapter
						_scrollToView();
					})
				}
			}

			/** function to toggle Extra Titles for #elmPlaylist. On Windows, the playlist content not be shifted (scrolled), but on iOS, when toggle content is scrolling, so we need to move back to current playing chapter */
			function togglePlaylistExtraTitles(){
				const _classAdded = _elmPlaylist.classList.toggle('hideOptionExtraTitle');
				//if hide extra title, save that state into xState
				if(_classAdded) xState.flags.hideExtraTitles = 1
				else delete xState.flags.hideExtraTitles;

				// if not in Windows, move back to current playing chapter
				if(!checkOS(1)) gotoPlayingChapter();
			}
			
			document.querySelector('[name="gotoPlayingChapter"]').onclick = gotoPlayingChapter;
			
			document.querySelector('[name="togglePlaylistExtraTitles"]').onclick = togglePlaylistExtraTitles;

			// initialized on page load to show/hide extra titles for #elmPlaylist
			if(xState.flags.hideExtraTitles) togglePlaylistExtraTitles();
			
			/* ----- HANDLER FOR CHILDREN OF #elmPlaylist DELEGATION ----- */

			/* Handling event for children of #elmPlaylist, namely: li chapter item, chapter-group-label using event-delegation technique on bubbling event: click */
			_elmPlaylist.addEventListener("click", _elmPlaylistClickDelegation);
			function _elmPlaylistClickDelegation(evt) {
				let _target = evt.target;
				//console.log(_target);

				// user click on chapter-group-label which fire on-click to checkbox right before it
				//if (_target.tagName === "INPUT" && _target.getAttribute("id").startsWith("chapGrpChkbox_")) {
				if(_target.matches(`input[type="checkbox"][id^="chapGrpChkbox"]`)){
					// expand or collapse a chapter group
					chapGrpChkboxClick(_target)
				}
				else {
					// in case user click on a child of chapter li item
					let _liChapItem = _target.closest("li[attr-stt]");
					if (_liChapItem) { //if indeed click on li or its child
						let _chapStt = parseInt(_liChapItem.getAttribute("attr-stt"));
						if (!isNaN(_chapStt)) changeChap(_chapStt); //change to chapter
					}
				}
			}
			
			/* ----- HANDLER FOR CHAP-GROUP-LABELS ----- */

			// initialize playlistObserver to watch for chapter-group-label to pinned at top. Adapt the very nice trick from https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/#aa-creating-a-position-sticky-event
			const playlistObserver = new IntersectionObserver(
			(entries, observer) => {
				entries.forEach(entry => {
					entry.target.classList.toggle("stickyPinned", entry.isIntersecting);

					//console.log("IntersectionObserver: " + entry.target.getAttribute("for"), entry.isIntersecting );

				} );

				/* let entry = entries[0];
				// condition 'entry.boundingClientRect.top <= entry.rootBounds.top' is ONLY able to catch the case label enter the top. 
				entry.target.classList.toggle("stickyPinned", (entry.intersectionRatio < 1 && entry.boundingClientRect.top <= entry.rootBounds.top));
				//console.log("IntersectionObserver: " + entry.target.getAttribute("for") + ". " + entry.intersectionRatio ); */

				/* let _targetlId = entry.target.getAttribute("for"); //or any attribute to identify {target}
				if(entry.isIntersecting){ //from lowerer {entry.intersectionRatio} go through {threshold} to higher one, meaning the {target} just got fully appeared inside the {root}
					//the following code might work only at the case that height of {root} is at least 10% higher than height of {target}.
					if ( (entry.boundingClientRect.top - entry.rootBounds.top)/entry.boundingClientRect.height < 0.05) //if {target} top just go down less than 5% of its height
						console.log(_targetlId + ": leave the top [scroll down]");
					else if ((entry.rootBounds.bottom - entry.boundingClientRect.bottom)/entry.boundingClientRect.height < 0.05) //if {target} bottom just go up less than 5% of its height
						console.log(_targetlId + ": leave the bottom  [scroll up]");
				}
				else //from higher {entry.intersectionRatio} go through {threshold} to lower one, meaning the {target} just got partly hidden by the {root}
				{
					if(entry.boundingClientRect.top <= entry.rootBounds.top) 
						console.log(_targetlId + ": enter the top  [scroll up]");
					else if(entry.boundingClientRect.bottom >= entry.rootBounds.bottom) 
						console.log(_targetlId + ": enter the bottom  [scroll down]");
				} */

			},
				{ threshold: [0], root: _elmPlaylist, rootMargin: "0px 0px -100% 0px" }
			);

			/* Handle event for #allChapGrpChkbox, so if it is changed, all chapters group collapse/expand accordingly */
			document.getElementById("allChapGrpChkbox").onclick = evt => {
				let _chkExpandChapterGrp = evt.target;
				let _allChapChkbox = _elmPlaylist.querySelectorAll("input[id^='chapGrpChkbox']");
				let _isChecked = _chkExpandChapterGrp.checked;
				_allChapChkbox.forEach(_chkBox => {
					_chkBox.checked = _isChecked;
				});

				let _bookxState = xState.history.books[xAudio.getAttribute("attr-book")];

				//scroll #elmPlaylist
				if (_isChecked) {
					//wait 500 second for expand/collapse animation to finish, then scroll to chapter being played
					setTimeout(_ => { _elmPlaylist.querySelector("li.beingPlay").scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'end' }); }, 500);
					_bookxState.chapGrpCollapse = []; //meaning no group is collapsed
				}
				else {
					//scroll to top, so sticky label not overlap each others
					_elmPlaylist.scrollTo({ top: 0, left: 0, behavior: "smooth" });
					_bookxState.chapGrpCollapse = [...Array(_allChapChkbox.length).keys()]; //fill with array from 0 to _allChapChkbox-1, meaning all groups are collapsed 
				}
				//chapGrpChkboxClick() on the a label will take care of fixing the tooltip content & location of allChapGrpChkbox checkbox's label
				//chapGrpChkboxClick(_elmPlaylist.querySelector("input[type='checkbox']:has( + label.is-sticky)"));

				updateAllChapGrpChkboxUI();
			}

			/** This change UI (checked, indeterminate, not checked) and tooltip of #allChapGrpChkbox based on state of each of #chapGrpChkbox_* which decide a chapter group is collapsed or expanded */
			function updateAllChapGrpChkboxUI() {
				let _allChapChkbox = _elmPlaylist.querySelectorAll("input[id^='chapGrpChkbox']");

				//count the number of expanded chapter group
				let _chkCount = 0, _chkTotal = _allChapChkbox.length;
				_allChapChkbox.forEach(_chkBox => {
					if (_chkBox.checked) _chkCount++;
				});

				let _chkExpandChapterGrp = document.getElementById("allChapGrpChkbox");
				let _chkLabel = _chkExpandChapterGrp.nextElementSibling;
				//watch for the tooltip change, so position it properly
				ssData.ttMutationObserver.observe(_chkLabel, { attributes: true, attributeFilter: ["data-tooltip"] });

				//update the tooltip
				_chkLabel.setAttribute("data-tooltip", `Đóng/mở tất cả các chapter group\n` + ((_chkCount == 0 || _chkCount == _chkTotal) ? `Tất cả các ${_chkTotal} nhóm chương đang ${_chkCount == 0 ? "đóng" : "mở"}` : `Hiện có ${_chkCount} trong ${_chkTotal} nhóm chương đang mở`));

				//update the checkbox state and UI
				guiUtils.setChkboxState(_chkExpandChapterGrp,
					_chkCount == 0 ? 0 : (_chkCount == _chkTotal ? 1 : 2));
			}

			/* When chap-groups expand/collapse, it might push some chap-group-label up but not enough for that group-label to be pinned at the top of playlist, which cause overlapping of chap-group-labels which look very ugly. This function will push that overlapped chap-group-label down a bit to avoid overlapping */
			function preventChapGroupLabelsOverlap(){
				// Put in setTimeout to wait for animation to be finished
				setTimeout(_ => { // && !isChecked
					//the very first chap-group-label which always on the top of #elmPlaylist
					const _label0 = _elmPlaylist.querySelector("input[type='checkbox'] + label.is-sticky");
					//the first unppined sticky chap-group-label
					const _labelNotPin = _elmPlaylist.querySelector("input[type='checkbox'] + label.is-sticky:not(.stickyPinned)");

					// if the first label is not pinned (then others labels are not pinned, too) or not found any unppined label (which should never happen, just make the check as a good practice), there would be no .is-sticky labels overlap, then nothing todo
					if(_label0.classList.contains("stickyPinned") && _labelNotPin){
						//bottom of the top label
						const _lbl0_BOTTOM = _label0.offsetTop + _label0.offsetHeight;
						// top of unppined label
						const _unpin_TOP = _labelNotPin.offsetTop;
						if(_unpin_TOP <= _lbl0_BOTTOM){ //overlap
							_elmPlaylist.scrollBy({ left: 0, top: (_unpin_TOP - _lbl0_BOTTOM - 4), behavior: "smooth" }); //4 is label's margin-top/bottom (4px)
						}
					}
				}, 800); //800msec is safe interval for all transitions finished
			}

			/** handler for chapter group changing state from expand to collapse and vice versa. And if somehow a group-chap-label overlap with other ones, scroll it down a bit to avoid overlapping. This is used in _elmPlaylistClickDelegation() function above
			 * @param _chapGrpChkbox {checkbox}: the #chapGrpChkbox_* checkbox of chapter-group which is changing state		
			*/
			function chapGrpChkboxClick(_chapGrpChkbox) {
				//let _chapGrpChkbox = evt.target;
				let _grpNo = parseInt(_chapGrpChkbox.getAttribute("attr-grpNo"));

				let _bookxState = xState.history.books[xAudio.getAttribute("attr-book")];
				if(!_bookxState.chapGrpCollapse) return;

				let _idx = _bookxState.chapGrpCollapse.indexOf(_grpNo);
				let isChecked = _chapGrpChkbox.checked;

				if (_idx > -1 && isChecked)
					_bookxState.chapGrpCollapse.splice(_idx, 1); //remove it
				if (_idx === -1 && !isChecked)
					_bookxState.chapGrpCollapse.push(_grpNo); //add it
				
				updateAllChapGrpChkboxUI(); //update allChapGrpChkbox UI when a group chapter change collapse/expand state

				preventChapGroupLabelsOverlap();
			}

			/* ----- PUBLIC METHODS, PROPERTIES ----- */
			return{
				//intersectionObserver object to watch to pin chap-group-label when it reach the top of playlist
				pinnedObserver: playlistObserver,
				//function to change state of #allChapGrpChkbox and its tooltip when a #elmPlaylist's chap-group-label expand or collapse
				updateAllChapGrpChkboxUI: updateAllChapGrpChkboxUI
			}			
		}
		
		/* Class to handle history buttons and functions */
		class historyCls {
			/* Change the button enable/disable state and their tooltips, titles.
			Because this function is sort of PRIVATE func, so you can access it by calling historyCls.prototype.buttonAppeance()
			*/
			buttonAppeance() {
				let _hist = xState.history;
				let _elmF = document.getElementById("elmHistoryGoForward");
				let _elmB = document.getElementById("elmHistoryGoBackward");
				//let _elmC = document.getElementById("elmHistoryClear");

				//if history data is empty
				if (_hist.hisList.length <= 1) {
					_elmF.classList.add("elm-disabled");
					_elmB.classList.add("elm-disabled");
					//_elmC.classList.add("elm-disabled");
					return;
				}
				//else _elmC.classList.remove("elm-disabled");

				if (_hist.currHis == _hist.hisList.length - 1) { //if current book is the last one in history
					_elmF.classList.add("elm-disabled")
				}
				else {
					const _adjHist = historyCls.prototype.getAdjHist(1); //get next book in history list

					if(_adjHist){
						//observer the tooltip changes to fix its position
						ssData.ttMutationObserver.observe(_elmF, { attributes: true, attributeFilter: ["data-tooltip"] });
						_elmF.classList.remove("elm-disabled");
						
						_elmF.setAttribute("data-tooltip", makeBrk(_adjHist.mc) + " " + _adjHist.title);
					}
				}

				//current book is the first one, just disable #elmHistoryGoBackward button
				if (_hist.currHis == 0) _elmB.classList.add("elm-disabled")
				else {
					const _adjHist = historyCls.prototype.getAdjHist(-1); //get previous book in history list

					if(_adjHist){
						//observer the tooltip changes to fix its position
						ssData.ttMutationObserver.observe(_elmB, { attributes: true, attributeFilter: ["data-tooltip"] });
						_elmB.classList.remove("elm-disabled");
						
						_elmB.setAttribute("data-tooltip", makeBrk(_adjHist.mc) + " " + _adjHist.title);
					}
				}
			}

			// flag to avoid adding the book shown by historyCls.historyGo() into on top of History List
			static histCallFlag = false;

			/** function for Clear history button. This function clear all history information, just keep the information of current Book, current Chapter */
			static historyClear() {
				let _hist = xState.history;
				//get current playing book store in xAudio element
				const _currBook = xAudio.getAttribute("attr-book"), _currChap = xAudio.getAttribute("attr-chap");
				_hist.currHis = 0;
				_hist.hisList.length = 0; //empty history list
				_hist.hisList.push(_currBook); //keep only current playing book
				xState.lb = _currBook; //make last book to be _currBook (just in case)

				//delete the history details of each book, except information of current chapter of current book
				for(let _book in xState.history.books) {
					if(_currBook !== _book)
						//delete information about all books except current book
						delete xState.history.books[_book];
					else{
						// keep information of current chapter of current book
						let _histBook = xState.history.books[_currBook];
						
						//delete information about all other chapter except current chapter
						Object.keys(_histBook)
							//filter all attributes that is a number, those are the chapter AND make sure it is NOT _currChap
							.filter( _attr => _attr.match(/^\d+$/) && _attr != _currChap )
							//delete information about the chapters
							.forEach(_chap => delete _histBook[_chap]);
						//make last book to be _currChap (just in case)
						_histBook.lc = _currChap;
					}
				}
				toast.showToast("Đã xóa toàn bộ lịch sử nghe sách", toast.ToastType.Success, {persistance: true});

				historyCls.prototype.buttonAppeance();
			}

			/** Add a new play book to history. This is called from changeBook() function. The book will be added to the end of history.hisList
				* @param _bookId {8-chars string} the book Id
			*/
			static addToHistory(_bookId) {
				let _hist = xState.history;
				if (this.histCallFlag) { //If changeBook() is called from History go backward or forward (see historyGo below), not add this book into history-database
					this.histCallFlag = false; //reset flag
				}
				else {
					//check to see of the new loading book is already in hisList
					const _bookIdx = _hist.hisList.indexOf(_bookId);
					//if the book is already in the hisList, remove it out of old position, then push it in the top of hisList
					if(_bookIdx > -1 ) _hist.hisList.splice(_bookIdx, 1);

					//push the new loaded book into the top of hisList and update the pointer accordingly
					_hist.hisList.push(_bookId);
					_hist.currHis = _hist.hisList.length - 1;
					//if(history.state?.bookId !== _bookId) history.pushState({bookId: _bookId, curr: _hist.currHis}, null, null);
				}				

				historyCls.prototype.buttonAppeance(); //history buttons enable/disable
			}

			/* // add historyCls.prototype.handlePopstate() to pageEventHandlers() in init()
			handlePopstate(){
				window.addEventListener('popstate', function(e) {
					var histState = e.state;
				
					if (histState != null) {
						//historyCls.historyGo(histState.bookId);
						changeBook(histState.bookId);
						console.log(histState);
					} else {
						window.history.back();
					}
				});
			} */
			
			/** function to get adjacent book in history list. If it not exist, clear all not-exist-anymore book from history list AND xState and get again
				* @param dir {1 or -1}: 1: get next book in history list. -1: get previous
				* 		Or in some rare case (such as calling from bookDataInitial() ), dir=0 just to clean the history and get the last book in history list
				* @return: - if after being purged, the list is empty, it return {null}.
				* 			- if the adjacent book is out of range of history List (-1 or hisList.length), return {undefined}.
				* 			- else the book data of the adjacent book in history list.
			*/
			getAdjHist(dir){
				let _hist = xState.history;
				if(_hist.hisList.length == 0){
					_hist.currHis = 0;
					historyCls.prototype.buttonAppeance(); //change appearance
					return null;
				}

				let _new_currHist = _hist.currHis + dir; //new currHis if item before it being purged
				if(_new_currHist < 0 || _new_currHist >= _hist.hisList.length) return undefined;
				const _adjBook = ssData.bookData.findBookFromId(_hist.hisList[_new_currHist]);
				if( _adjBook ) return _adjBook; //book still exists, return it

				/* Books not exist, need to clean history list from not-existed books.
				This should never be happening, because in bookDataInitial(), the xState.history has been clean to remove all unexisted-books. */
				historyCls.cleanHist(); //clean the history
				return historyCls.prototype.getAdjHist(dir); //get again, but on all-existed-books history list
			}

			/** function to clean history in the case that some books stored in xState.history that not existed anymore (because of the change in DBs setting (DB which contains that book is not being set to load in this page session) or the change in DB itself)
				* @note after being purged, the xState.history.currHis also being updated so that it still point to the same-old book it has pointed to before being purged.
				* @note after being purge, if the hisList is empty, we will get some random-existed book to be the initial book, this book will be loaded when the page loaded
				* @important this is only being invoked from BookData.bookDataInitial() to clean the history before working on the page
				
				* @return: the newly-updated xState.history.currHist
			*/
			static cleanHist(){
				
				let _hist = xState.history;
				/* This choose a random book to be the first book to load to the page when history is empty (when the page loaded very first time or after being historyCls.wipeAll(0) ). Filling in xState.history will be taken care by bookDataInitial() function */
				const _setFirstBook = _ => {
					//hisList after being purge is empty, we need to get an ramdom-existed book to be set as initial book
					const _bookdefault = Math.floor(Math.random() * ssData.bIds.length); //0 //the book that would be load when page is load in very first time in user's device
					let _lastBook = ssData.xData[_bookdefault].bookId; //default to load the first book
					//TODO: set this _lastBook and do historyCls.wipeAll() on the console, there is an error
					//_lastBook = '1bbc350f';
					
					// after setting xState["lb"], the rest task of loading book/chapter, and by the same time adding information to xState.history will be taken care by selBookGroup.onchange() call in bookDataInitial() function.
					xState["lb"] = _lastBook; 

					_hist.currHis = 0;
				}

				if(_hist.hisList.length == 0){
					_setFirstBook();

					//_hist.currHis = 0;					
					return null;
				}

				let _currHist = _hist.currHis; //now, use _currHist as alias for _hist.currHis
				
				let  purgeIdxArr = []; //array of purged indexes
				//go backward, so purgeIdxArr is in decreasing order
				for(let i= _hist.hisList.length - 1; i >=0; i--  ){ //ssData.bIds contains bookId of all existing books
					if(
						// not found in book Ids list
						!ssData.bIds.includes(_hist.hisList[i]) || 
						//or found in hidden book Ids list (added 6/5/2025)
						(ssData.bIdsHidden ?? []).includes(_hist.hisList[i])
					){
						purgeIdxArr.push(i);

						if(i <= _currHist) _currHist--;
					}
				};

				//remove information about not-existed-anymore books
				if(purgeIdxArr.length > 0){
					toast.showToast(`Có ${purgeIdxArr.length} cuốn sách không còn tồn tại bị xóa khỏi lịch sử nghe sách`, toast.ToastType.Warning, {persistance:true});

					//remove books whose index stored in 
					purgeIdxArr.forEach(_idx => {
						const _book_id = _hist.hisList[_idx];
						//remove information about the book from xState
						if( _hist.books.hasOwnProperty(_book_id) ) delete _hist.books[_book_id];

						//remove purged item out of history list
						_hist.hisList.splice(_idx, 1);
					} );

					// after remove old books, there may be two consecutive books duplicate. If so, remove one of them. Note, this should not be the case anymore
					/* let i= _hist.hisList.length - 1;
					while( i > 0  ){
						if(_hist.hisList[i] == _hist.hisList[i-1]) {
							_hist.hisList.splice(i, 1);
							if(i <= _currHist) _currHist--;
						}
						i--;
					}; */
				}

				if(_hist.hisList.length == 0) {
					//initialize the history when it is empty
					_setFirstBook();
					_currHist = 0;					
				}
				else {
					if(_currHist < 0) 
						_currHist= 0
					else if(_currHist >= _hist.hisList.length) 
						_currHist = _hist.hisList.length - 1;
					
					_hist.currHis = _currHist; //update position for current item in history list
					xState["lb"] = _hist.hisList[_currHist];
				}				

				return _currHist;
			}
			
			/** Go back and forward in history list 
				@param _dir: =-1 go backward, 1 go forward
					if @_dir is 8-char string, it is book Id
			*/
			static historyGo(_dir) {
				let _hist = xState.history;
				this.histCallFlag = true; //turn this flag on so addToHistory() above function know that changeBook() is called from historyGo, so addToHistory() will not add the book into history

				// if _dir is direction, go next or previous in history list
				if('number' === typeof _dir){
					_dir = _dir == 1? 1: -1;					

					const _adjHist = historyCls.prototype.getAdjHist(_dir);
					if(_adjHist){
						_hist.currHis += _dir; //update position of current history item
						//load the book. This will invoke changeBook(), but because histCallFlag is set to true above, so the loaded book will not be added into history list again.
						ssData.bookData.goGetBook(_adjHist.bookId); //note that goGetBook reload the elmSelBookTitles book list
					}
				}
				//if _dir is book id
				else if('string' === typeof _dir){
					//now, _dir is bookId
					const _bookId = _dir;
					let _bookIndex = _hist.hisList.indexOf(_bookId);
					//if the bookId not in history list, do nothing
					if(_bookIndex == -1) return;
					//update position of current history item
					_hist.currHis = _bookIndex;
					//call getAdjHist() in case that the book is removed because the change in the DBs
					const _adjHist = historyCls.prototype.getAdjHist(0);
					if(_adjHist){						
						//load the book. This will invoke changeBook(), but because histCallFlag is set to true above, so the loaded book will not be added into history list again.
						ssData.bookData.goGetBook(_adjHist.bookId); //note that goGetBook reload the elmSelBookTitles book list
					}
				}
				
				historyCls.prototype.buttonAppeance();
			}

			/** Clear all information saved in xState, not just books reading history, but also other information such as last playing time, grpLine, urlLine 
				* @param mode 
						@value 0 or missing: completely wipe out xState (which store environment variable across page session) and xDBFilesCfg (which store setting for DBs file)
					@value 1: just clean xState, keep xDBFilesCfg so next session, the page would load only DBs that user set
			*/
			static wipeAll(mode) {
				mode = mode ?? 0;
				if (!confirm("Bạn muốn xóa toàn bộ lịch sử trang Web đã lưu?\n\n Sẽ cần phải nạp lại trang Web.")) return;
				xState = {}; //clear the xState
				localStorage.clear(); //clear local storage
				
				// if mode =1, save back the changes in xDBFilesCfg
				if(mode == 1) localStorage.setItem('xDBFilesCfg', JSON.stringify(xDBFilesCfg)); else xDBFilesCfg=null;
				
				//Force a hard reload to clear the cache if supported by the browser
				window.location.reload(true);
			}
		}

		/* Class to allow items of a list to be DRAG AND DROP */

		/** constructor
			@param	_dragItemsQuery: json contain the parent container and css query string to get list of children which is dragitems. Format: {"parent": wrapper element, "queryString" : "li"}
			@param	_exchangeFnc: callback function to do something after each drop
		*/
		let dragDropList = function (_dragItemsQuery, _exchangeFnc) {
			let dragItemsQuery = _dragItemsQuery;
			let dragItems = _dragItemsQuery["parent"].querySelectorAll(_dragItemsQuery["queryString"]);

			let exchangeFnc = null;
			if (_exchangeFnc) exchangeFnc = _exchangeFnc;

			//Setter to set callback function to change the list after drag and drop. This will take two parameter fromIdx, toIdx which are the index of drag&drop item 
			function setExchangeFnc(_exchangeFnc) {
				exchangeFnc = _exchangeFnc;
			}

			/* all action to deal with drag & drop */
			function handleDragDrop() {
				// (PART B) FLAG FOR "CURRENT ITEM BEING DRAGGED"
				let dragged;
				let cancelDefault = (event) => {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}

				// (PART C) DRAG-AND-DROP MECHANISM
				dragItems.forEach((_item, _idx) => {
					// (C1) LIST ITEM IS DRAGGABLE
					_item.draggable = true;
					_item.setAttribute("attr-dragIdx", _idx);

					// (C2) ON DRAG START - SET FLAG & DATA TRANSFER
					_item.ondragstart = event => {
						dragged = _item;
						const _dt = event.dataTransfer;
						_item.classList.add("activeDragItem");
						_dt.dropEffect = "move";
						_dt.effectAllowed = "move";
						//_dt.setData("text/html", _item.innerHTML);
						_dt.setData("text/plain", _item.getAttribute("attr-dragIdx"));

						const offsetX = 0, offsetY = 0;
						const createDragImage = function($node, x, y) {
							const _ghostNode = document.createElement("div"); // $node.cloneNode(true);
							const _node$pos = $node.getBoundingClientRect();
							_ghostNode.innerHTML = "Dragging: " +  $node.innerHTML;
							_ghostNode.style.top =  _node$pos.top  + "px"; //$node.offsetTop // Math.max(0, y - offsetY) + "px";
							_ghostNode.style.left = _node$pos.left + "px"; // $node.offsetLeft // Math.max(0, x - offsetX) + "px";
							_ghostNode.style.width = $node.offsetWidth + "px";
							_ghostNode.style.height = $node.offsetHeight + "px";
							_ghostNode.classList.add("draggingGhostElem");
							
							document.body.appendChild(_ghostNode);

							setTimeout(_ => document.body.removeChild(_ghostNode));

							return _ghostNode;
						};
						var ghostNode = createDragImage(dragged, event.pageX, event.pageY);
							_dt.setDragImage(ghostNode, offsetX, offsetY);
						//event.dataTransfer.setDragImage(_item, 664, 44);
						//dragItems.forEach(_item => _item.querySelector("div:has(> span.dbFileBookList)")?.classList.add("elm-hidden"));
					};

					// (C3) ON DRAG OVER - NECESSARY PREVENT DEFAULT FOR DROP TO WORK
					_item.ondragover = event => {
						//event.preventDefault();
						cancelDefault(event);
					}

					// (C4) ON DROP - "SWAP POSITION"
					_item.ondrop = event => {
						//event.preventDefault();
						cancelDefault(event);
						if (dragged != _item) {
							//dragged.innerHTML = _item.innerHTML;
							//_item.innerHTML = event.dataTransfer.getData("text/html");

							let _fromIdx = event.dataTransfer.getData("text/plain"),
								_toIdx = _item.getAttribute("attr-dragIdx");
							_fromIdx = parseInt(_fromIdx), _toIdx = parseInt(_toIdx);
							if (exchangeFnc) exchangeFnc(_fromIdx, _toIdx); //invoke callback function to do the real exchange on the list outside

							//paint item just being dragged differently
							dragItemsQuery["parent"].querySelector(`[attr-dragIdx = "${_fromIdx}"]`).classList.add("beingPlay");

							//update attr-dragIdx for all item effected by the drag&drop action
							if (_fromIdx > _toIdx) {
								dragItems[_fromIdx].setAttribute("attr-dragIdx", _toIdx);
								for (let i = _toIdx; i < _fromIdx; i++) {
									dragItems[i].setAttribute("attr-dragIdx", i + 1);
								}
							}
							else {
								dragItems[_fromIdx].setAttribute("attr-dragIdx", _toIdx);
								for (let i = _fromIdx + 1; i <= _toIdx; i++) {
									dragItems[i].setAttribute("attr-dragIdx", i - 1);
								}
							}

							//we need to re-assign dragItems to update the items' order changes
							dragItems = dragItemsQuery["parent"].querySelectorAll(dragItemsQuery["queryString"]);

							//dragItems.forEach(_item => _item.querySelector("div:has(> span.dbFileBookList)")?.classList.remove("elm-hidden"));
						}
					};

					// (C5) NOT REALLY IMPORTANT - COSMETICS
					_item.ondragenter = (event) => { _item.classList.add("activeDropItem"); cancelDefault(event); }
					_item.ondragleave = (event) => { _item.classList.remove("activeDropItem"); cancelDefault(event); }
					_item.ondragend = (event) => {
						dragItems.forEach((_itm) => {
							_itm.classList.remove("activeDragItem", "activeDropItem");
						});
					};
				});
			}

			/* public methods */
			return {
				exchangeFnc: setExchangeFnc, /* setter function for callback function exchangeFnc */
				handleDragDrop: handleDragDrop /* Function to handle drag & drop */
			}
		}

		/* Class deal with user-setting on book group, show/hide books for each group, and show/hide circle progress on Play/Pause buttons 
		To optimize user experience, every time a check box (which define the group visible or hidden) is clicked, everytime a group is drag and drop, this function is called automatically to save the change in setting right away, without any further action to click on some kind of "save setting" buttons
		*/
		function Setting() {
			let _dragObj = null; // instance object of dragDropList class to handle drag&drop
			const xBookGrp = ssData.xBookGrp;
			
			/**
			* HELPER FUNCTIONS
			*/
			
			/* move an item of array ${arr} from index ${fromIndex} to index ${fromIndex} */
			function arrayMove(arr, fromIndex, toIndex) {
				let element = arr[fromIndex];
				arr.splice(fromIndex, 1); //take fromIndex item out
				arr.splice(toIndex, 0, element); //insert to toIndex
			}

			/* Compare two json object. Return TRUE if equals 
			Adapt from https://www.30secondsofcode.org/js/s/object-comparison/
			*/
			function objsEqual(obj1, obj2) {
				if (obj1 === obj2) return true;

				if (obj1 instanceof Date && obj2 instanceof Date)
					return obj1.getTime() === obj2.getTime();

				if (!obj1 || !obj2 || (typeof obj1 !== 'object' && typeof obj2 !== 'object'))
					return obj1 === obj2;

				if (obj1.prototype !== obj2.prototype) return false;

				const keys = Object.keys(obj1);
				if (keys.length !== Object.keys(obj2).length) return false;

				return keys.every(k => objsEqual(obj1[k], obj2[k]));
			};

			/** bind the checkbox to xState.flags enviroment variable so that the xState variable got updated with the changes of the checkbox, and checkbox take the initial 'checked' value from xState variable each time the page reloaded
			 * @param chkboxEl {HTMLElement} the checkbox element
			 * @param xStateVarName {string} the name of the variable that would contains the 'checked' value of @chkboxEl 
			 * @param option {json}: the json contains other params, which can be
			 * 		@property defVal {boolean}: the @chkboxEl 's checked value when xState variable not existed in xState.flags. Note that this default value is the initial 'checked' value of @chkboxEl . Depend on value of @inversed property, the value of xState.flags enviroment variable would take the same value OR reversed of it
			 * 		@property inversed {boolean} if set to two, the xState variable will take the inversed value of the @chkboxEl 'checked' state
			 *		@property clickedCallback: the callback function when @chkboxEl checkbox is clicked
			*/
			function bindCheckbox2StateVar(chkboxEl, xStateVarName, option){
				const _stateVal = xState.flags[xStateVarName];
				// set initial 'checked' state of chkboxEl to xState.flags[xStateVarName] (if exists) or to option.defVal
				let initialChecked = 
				xState.flags.hasOwnProperty(xStateVarName) ? (option.inversed? !_stateVal : _stateVal) : (option?.defVal ?? false);
				chkboxEl.checked = initialChecked;

				// this check to make sure the event handlers inside the if block are set only one time
				if(!chkboxEl.boundVar){
					chkboxEl.boundVar = 1;

					// set onclick to be the onclick callback
					if('function' === typeof option.clickedCallback) chkboxEl.onclick = option.clickedCallback;

					//synchronize chkboxEl 'checked' state with xState.flags' variable
					chkboxEl.addEventListener("click", _evt => {
						//depend on value of @inversed property, the value of xState.flags enviroment variable would take the same value of reversed of it
						const _isChecked = option.inversed? !chkboxEl.checked : chkboxEl.checked;
						if(_isChecked)
							xState.flags[xStateVarName] = 1;
						else delete xState.flags[xStateVarName];
					});
				}
			}

			/** function to add control for global checkbox and bind its value to a xState.flags enviroment variable 
			 * @param which tell which checkbox to be handled
			 * 	@value 1: handle #chkDisableCircleProgressButton which control if circle progress bar (which circumstance the audio play/paused button) is visible or hidden
			 * 	@value 2: handle #chkHideBufferBar which control if buffered+played audio bar is visible or hidden
			 * 	@value 3: handle #chkStickyAudioPanel which control if  audio control panel is sticked at the top of the page when page scroll or not
			 * @value missing (undefined): run for ALL of above choices.
			*/
			function handleEnvironmentChkbox(which) {
				//setting for visibility of audio buffered+played bar canvas
				function handleBufferBarChkbox() {
					let _chkHideBufferBar = document.getElementById("chkHideBufferBar");
					
					//checkbox onclick callback function
					const _chkHideBufferBarOnclickCB = (_ev) => { //user make change to show/hide buffer bar.
						const _isNotChecked = !_chkHideBufferBar.checked;

						const _elPlayedBar = document.querySelector(".ap-played-bar");
						_elPlayedBar.classList.toggle("elm-hidden", _isNotChecked);

						document.querySelector(".ap-buffer-bar").classList.toggle("elm-hidden", _isNotChecked);

						if (!_isNotChecked) {
							//this property would force the canvas of played bar to clear and redraw a new plain background
							_elPlayedBar.clearRequired = true;

							//turn on flag so the toast Message that would fire by xAudio.onseeked()  will not display
							toast.depressToast(true);						
							// onseeked() will update UI of the buffer bar
							xAudio.onseeked();
						}
					}
					// bind checkbox to xState variable so that checkbox state can be kept through page sessions
					bindCheckbox2StateVar(_chkHideBufferBar,"hideBufferBar", {defVal: true, inversed: true, clickedCallback : _chkHideBufferBarOnclickCB});
				}

				//setting for visibility of circle progress in audio play/pause buttons
				function handleCircleProgressChkbox() {
					let _chkDisableCircleProgress = document.getElementById("chkDisableCircleProgressButton");
					
					const _chkDisableCircleProgressOnclickCB = (_ev) => { //user make change to circle progress button setting.
						const _isNotChecked = !_chkDisableCircleProgress.checked;

						//update the Play/Pause button interface by changing the class of svg sprite #icnSvgPlayPauseProgress. See AudioPlayer.switchPlayPauseButton() for more details.
						document.getElementById("icnSvgPlayPauseProgress").classList.toggle("isPPP-noProgress", _isNotChecked);

						// if show circle progress bar, force updateTime to update the progress bar right away
						if(!_isNotChecked) ssData.audioPlayer.updateTime(true);
					};

					// bind checkbox to xState variable so that checkbox state can be kept through page sessions
					bindCheckbox2StateVar(_chkDisableCircleProgress,"disableCircleProgressButton", {defVal: true, inversed: true, clickedCallback : _chkDisableCircleProgressOnclickCB});
				}

				handleBufferBarChkbox();
				handleCircleProgressChkbox();

				/* 
				//if no parameter is set, run for all
				if(which == undefined) {
					[1,2,3].forEach(_which => handleEnvironmentChkbox(_which));
					return;
				}

				switch(which){
					case 1:
						//handle setting for circle progress button
						handleCircleProgressChkbox();
						break;
					case 2:
						//handle setting for buffered-bar in audio player
						handleBufferBarChkbox();
						break;
					case 3:
						//handle setting for audio player panel to be sticky or not
						handleStickyAudioPanelChkbox();
						break;
					default: return;
				}
				 */
			}
			/* Function to change the UI of Book Kit checkbox depending on checked state of all of its book set checkbox. This function is called only  in bookSet view mode (which having #chkbox-BK-* checkbox) 
			This function should be put inside bookSetList(), but because of event delegation handler _showhideBookChkboxClickDelegation(), we have to move it out
			*/
			let updateBKchkboxUI = _bkIndex => {
				let _chkBookKit = document.getElementById(`chkbox-BK-${_bkIndex}`);
				if (!_chkBookKit) return; //if this book kit has only one book set, so there is no book kit checkbox

				//now count the number of checked book sets
				let allChkboxCount = 0, checkedCount = 0;
				document.querySelectorAll(`.modalPopupContent input[type='checkbox'][attr-bookkit-father='${_bkIndex}']`).forEach(_liChkBox => {
					allChkboxCount++;
					if (_liChkBox.checked) checkedCount++;
				});
				guiUtils.setChkboxState(_chkBookKit, checkedCount === 0 ? 0 : (checkedCount === allChkboxCount ? 1 : 2));

			};

			/**
				* TABS FUNCTIONS
				*/

			//ol that display all sub-group and books of a group way
			const lstBookTitlesSetting = document.getElementById("lstBookTitlesSetting");
			/* handle with the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item 
				_grpLine {integer}: the index of group line, which is also selected index of selPopupBookGroup
			*/
			function bookSetList(_grpLine) {
				let xbookGrp_grp = xBookGrp[_grpLine].grp;

				//shortcut for making svg icon
				const makeSvgStr = _type => makeSvgFromSprite(_type,{class:"svg-img-infor", style:"font-size:.85em"});

				lstBookTitlesSetting.innerHTML = ""; //clear the last book dropdown list
				let gStt = 1;
				for (let j = 0; j < xbookGrp_grp.length; j++) {
					let bookGrpItem = xbookGrp_grp[j];
					let _numberOfBooks = bookGrpItem.books.reduce((_total, _currItem) => { return _total + _currItem.bList.length }, 0);
					
					// get HTML contains detail of each book name
					const listOfBooks = `<div class='detailBookNames'><p class='dbFileBookList'>` +
						bookGrpItem.books.map(_book => 
							//detail information for each book
							`<code>${_book.bName} ${_book.bList.length > 1? makeBrk(_book.bList.length):""}</code>`
						)
						.join("")
					+ `</p></div>`;

					/* set HTML for each <li> item, each contains details about one book set */
					let _liGrpTitle = document.createElement('li');
					_liGrpTitle.innerHTML = `<input type="checkbox" ${bookGrpItem.bHidden ? "" : "checked"} role="switch" attr-BookKit-Father="${bookGrpItem.bookKit}" /><code data-rAlignGroup="itemOrder">${makeBrk(gStt++)}</code> <span>${bookGrpItem.label} ${makeSvgStr("icnSvgId")}${bookGrpItem.bookKit},${bookGrpItem.gId} ${makeSvgStr("icnSvgBooks")}${_numberOfBooks}</span>${listOfBooks}`;
					_liGrpTitle.setAttribute("attr-grpID", bookGrpItem.gId);
					//_liGrpTitle.setAttribute("attr-BookKit-Father", bookGrpItem.bookKit);

					lstBookTitlesSetting.appendChild(_liGrpTitle);
				}

				// fire onclick() of checkbox #chkShowHideBooksDetails so that book names can be hidden or shown depending on the 'checked' value of the checkbox
				document.getElementById("chkShowHideBooksDetails").onclick();

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						// console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _itemDrop = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + t + "']");
						if (f > t)
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop);
						else
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						arrayMove(xbookGrp_grp, f, t); //re-arrange for xBookGrp
						arrayMove(xState.grpCfg[_grpLine].grp, f, t); //re-arrange for xState.grpCfg

						//re-calculte book kit rank
						ssData.bookData.calculateBookKitRank(_grpLine);
					}
					_dragObj = dragDropList({ "parent": lstBookTitlesSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated

				/* Create checkbox for book Kit that has more than 1 book sets, so that user can show/hide multiple book sets (that belong to the same book kit) at the same time */
				(function bookKitChkboxes(){const bookKitInfor = ssData.bookKitInfor;
					let bkCounts = bookKitInfor.map(_it => 0);
					xBookGrp[_grpLine].grp.forEach(_it => bkCounts[_it.bookKit]++);
					let bookKitHTML = "";
					let _stt = 0;
					for (let i = 0; i < bkCounts.length; i++) {
						if (bkCounts[i] <= 1) continue;
						let _bkIdx = bookKitInfor[i].bkIdx;
						bookKitHTML += `<div class="bookKitNo${_stt++}"><input id="chkbox-BK-${_bkIdx}" type="checkbox" role="switch" attr-BookKit="${_bkIdx}" class="!text-[20px]"/>
						<label for="chkbox-BK-${_bkIdx}">${bookKitInfor[i].label}<sup>${_bkIdx}</sup></label></div>`;
					}
					let bookKitChkboxContainer = document.querySelector('[name="bookKitChkboxContainer"]');
					//add book kit checkboxes
					bookKitChkboxContainer.innerHTML = bookKitHTML;

					//update UI of book kit checkboxes and binding css class for book set checkbox inside lstBookTitlesSetting to each of those book kit checkbox
					bookKitChkboxContainer.querySelectorAll("input[type='checkbox'][role='switch'][id*='chkbox-BK-'][attr-bookkit]").forEach(chkBox => {
						//get book kit ID
						let _bkIdx = chkBox.getAttribute("attr-bookKit");

						//update Book Kit UI corresponding with its Book Sets checked state
						updateBKchkboxUI(_bkIdx); 

						// get all checkbox that set the show/hide state of each book set
						let _bookSetsChilds = lstBookTitlesSetting.querySelectorAll(`input[type='checkbox'][attr-bookkit-father='${_bkIdx}']`);

						// add class for all Book sets children of this Book Kit, so when hover the Book Kit, all of its book sets will highlight (using CSS)
						let _clsName = chkBox.parentElement.classList[0];
						_bookSetsChilds.forEach(_liChkBox => {
							_liChkBox.parentElement.classList.add(_clsName + "-Childs");
						});
					});

					/* event delegation to handle when user click on book-kit checkbox, the its children book sets checkboxes (in lstBookTitlesSetting) would change state accordingly */
					if(!bookKitChkboxContainer.onclick)
					bookKitChkboxContainer.onclick = _evt => {
						const chkBox = _evt.target;
						// if not click on the book0kit checkbox
						if(!chkBox.matches("input[type='checkbox'][role='switch'][id*='chkbox-BK-'][attr-bookkit]"))
						return;

						//get book kit ID
						let _bkIdx = chkBox.getAttribute("attr-bookKit");
						// get all checkbox that set the show/hide state of each book set
						let _bookSetsChilds = lstBookTitlesSetting.querySelectorAll(`input[type='checkbox'][attr-bookkit-father='${_bkIdx}']`);

						const _grpLine = document.getElementById("selPopupBookGroup").selectedIndex;
						// make all Book Set that belong to the Book Kit be shown/hidden with the checked state of the Book Kit checkbox
						_bookSetsChilds.forEach(_liChkBox => {
							_liChkBox.checked = chkBox.checked; // change book set UI

							let _gid = _liChkBox.parentNode.getAttribute("attr-grpid"); //book set Id
							xState.grpCfg[_grpLine].grp.find(_it => _it.gId === _gid).bHidden = !_liChkBox.checked; //update to xState.grpCfg

							xBookGrp[_grpLine].grp.find(_it => _it.gId === _gid).bHidden = !_liChkBox.checked; //update to xBookGrp
						});
						
						// scroll to the book kit's middle book set <li> element inside lstBookTitlesSetting
						SddDropdown.prototype.scrollToElement(lstBookTitlesSetting, _bookSetsChilds[_bookSetsChilds.length/2 <<0], 'smooth', true);
					};
				})();
			}

			/* handle with the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item 
				_grpLine {integer} the index of group line, which is also selected index of selPopupBookGroup
			*/
			function bookKitList(_grpLine) {

				//rank of each book kit in this group line
				const bookKitInfor = ssData.bookKitInfor;
				let _tempRank = bookKitInfor.map(_it => { return { bkIdx: _it.bkIdx, rank: _it.grpRanks[_grpLine].rank } });

				//sort book kit list by the rank
				let _tempBookKitInf = bookKitInfor.toSorted((x, y) => _tempRank[x.bkIdx].rank - _tempRank[y.bkIdx].rank);

				/* Count number of hidden book set for each book kit */
				bookKitInfor.forEach(_it => _it.grpRanks[_grpLine].bsHidden = 0);//reset hidden book set Count to 0 for this group line
				let xbookGrp_grp = xBookGrp[_grpLine].grp;
				for (let j = 0; j < xbookGrp_grp.length; j++) {
					let bookGrpItem = xbookGrp_grp[j];
					let _bkIdx = bookGrpItem.bookKit;

					if (bookGrpItem.bHidden) bookKitInfor[_bkIdx].grpRanks[_grpLine].bsHidden++;
				}

				//shortcut for making svg icon
				const makeSvgStr = _type => makeSvgFromSprite(_type,{class:"svg-img-infor", style:"font-size:.85em"});

				document.querySelector('[name="bookKitChkboxContainer"]').innerHTML = ""; //clear all book Kit Chkbox of Book set view
				lstBookTitlesSetting.innerHTML = ""; //clear the last book dropdown list
				let gStt = 1;
				for (let j = 0; j < _tempBookKitInf.length; j++) {
					let _bookKitItem = _tempBookKitInf[j];
					let _numberOfBooks = _bookKitItem.endIdx - _bookKitItem.startIdx + 1;
					let _numOfBookset = _bookKitItem.grpRanks[_grpLine].bsCount;
					let _bkIdx = _bookKitItem.bkIdx;

					// get HTML contains detail of each book set and book names in each book set
					const listOfBooks = `<div class='detailBookNames'>` +
						//filter book sets that belong to current book kit
						xbookGrp_grp.filter(_xBookGrp => _xBookGrp.bookKit == _bkIdx)
						//map to HTML for each book set
						.map(_bookSet => {
							// get number of books for this book set
							let _numberOfBooks = _bookSet.books.reduce((_total, _currItem) => { return _total + _currItem.bList.length }, 0);

							//HTML for book set details
							return `<p class='dbFileBookList'><i>${_bookSet.gId}. ${_bookSet.label} ${makeBrk(_numberOfBooks)}</i>` +
								//get HTML contains detail for all book names belong to each book set
								_bookSet.books.map( _book => 
									`<code>${_book.bName}${_book.bList.length > 1? makeBrk(_book.bList.length):""}</code>`
								).join("")
							+ `</p>`;
						}).join("")
					+ `</div>`;

					/* set HTML for each <li> item, each contains details about one book kit */
					let _liGrpTitle = document.createElement('li');
					_liGrpTitle.innerHTML = `<input attr-bookKit="${_bkIdx}" type="checkbox" role="switch" checked /><code data-rAlignGroup="itemOrder">${makeBrk(gStt++)}</code> <span>${_bookKitItem.label} ${makeSvgStr("icnSvgId")}${_bkIdx} ${makeSvgStr("icnSvgBooks")}${_numberOfBooks} ${_numOfBookset==1?"" : makeSvgStr("icnSvgBookSets") + _numOfBookset}</span>${listOfBooks}`;
					_liGrpTitle.setAttribute("attr-bookKitIdx", _bkIdx);
					//_liGrpTitle.setAttribute("attr-BookKit-Father", bookGrpItem.bookKit);

					let _chkBookKit = _liGrpTitle.querySelector("input[type='checkbox']");
					//update UI for Book Kit checkbox
					let _ranksInfor = bookKitInfor[_bkIdx].grpRanks[_grpLine];
					_chkBookKit.title = `${_ranksInfor.bsHidden} out of ${_ranksInfor.bsCount} hidden`;
					guiUtils.setChkboxState(_chkBookKit, _ranksInfor.bsHidden === _ranksInfor.bsCount ? 0 : (_ranksInfor.bsHidden === 0 ? 1 : 2));

					lstBookTitlesSetting.appendChild(_liGrpTitle);
				}

				// fire onclick() of checkbox #chkShowHideBooksDetails so that book names can be hidden or shown depending on the 'checked' value of the checkbox
				document.getElementById("chkShowHideBooksDetails").onclick();

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						//console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _fBKidx = _itemDrag.getAttribute("attr-bookKitIdx"); //book kit id of From element
						let _itemDrop = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + t + "']");
						let _tBKidx = _itemDrop.getAttribute("attr-bookKitIdx"); //book kit id of To element

						if (f > t)
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop);
						else
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						//a. update bookKitInfor rank 
						lstBookTitlesSetting.querySelectorAll("li").forEach((_it, _idx) => {
							let _bkIdx = _it.getAttribute("attr-bookKitIdx");
							bookKitInfor[_bkIdx].grpRanks[_grpLine].rank = _idx; // the new rank of this book kit is its order in lstBookTitlesSetting
						});

						//b. update xState and xBookGrp together. Note that array xState.grpCfg[_grpLine].grp is part of array xBookGrp[_grpLine].grp (which has been assigned to variable bookGrp_grp), and most importantly, these two arrays are always aligned
						let _bsLocation = []; //location (index) of all book sets belong to from book kit
						let _fxState = [], _fxBookGrp = []; //store all book sets of dragged book kit
						let xstate_grpCfg = xState.grpCfg[_grpLine].grp; //short name for xState grp
						for (let j = 0; j < xbookGrp_grp.length; j++) {
							if (xbookGrp_grp[j].bookKit == _fBKidx) _bsLocation.push(j);
						}

						// take all book sets out of xBookGrp and xState. Because going from end to beginning of array, the taken out array would be revesed in order
						for (let j = _bsLocation.length - 1; j >= 0; j--) {
							_fxBookGrp = _fxBookGrp.concat(xbookGrp_grp.splice(_bsLocation[j], 1));
							_fxState = _fxState.concat(xstate_grpCfg.splice(_bsLocation[j], 1));
						}
						_fxBookGrp = _fxBookGrp.reverse(); //the order need to be reversed back
						_fxState = _fxState.reverse();

						if (f < t) { //dragging down: move all book sets of From book kit right after the last book set of To book kit
							let _tLastIdx = -1; //find the last index of 
							for (let j = xbookGrp_grp.length - 1; j >= 0; j--) {
								if (xbookGrp_grp[j].bookKit == _tBKidx) {
									_tLastIdx = j;
									break;
								}
							}
							// put back all book sets has been taken out after _tLastIdx
							xbookGrp_grp.splice(_tLastIdx + 1, 0, ..._fxBookGrp); //using Spread syntax
							xstate_grpCfg.splice(_tLastIdx + 1, 0, ..._fxState);
						}
						else { //dragging up: move all book sets of From book kit right before the first book set of To book kit
							let _tFirstIdx = -1; //find the last index of 
							for (let j = 0; j < xbookGrp_grp.length; j++) {
								if (xbookGrp_grp[j].bookKit == _tBKidx) {
									_tFirstIdx = j;
									break;
								}
							}
							// put back all book sets has been taken out right before _tFirstIdx
							xbookGrp_grp.splice(_tFirstIdx, 0, ..._fxBookGrp); //using Spread syntax
							xstate_grpCfg.splice(_tFirstIdx, 0, ..._fxState);
						}
					}
					_dragObj = dragDropList({ "parent": lstBookTitlesSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated
			}

			/* function to handle the content of Book Setting tab */
			function addBookSettingTab(){				
				
				//listbox show all kind of group in xBookGrp
				let selPopupBookGroup = document.getElementById("selPopupBookGroup");

				// checkbox to show book kit or book set in lstBookTitlesSetting
				const _chkShowBookKit = document.getElementById("chkShowBookKit");
				//checkbox onclick callback function
				const _chkShowBookKitOnclickCB = _ => {
					selPopupBookGroup.onchange(); //show book set/kit lists

					let _chkboxLabel = _chkShowBookKit.nextElementSibling;
					_chkboxLabel.innerText = _chkShowBookKit.checked ? "Book Kit view" : "Book Set view";

					let _tooltipTxt = _chkShowBookKit.checked ?
						"Danh sách hiển thị phía dưới là Book Kit. Mỗi item có dạng\n'[4] Sherlock Holmes ^3 [22] [3]', trong đó:\n[4]: stt của Book Kit (tủ sách) Sherlock Holmes.\n^3: id của Book Kit.\n[22]: số books của Book Kit này.\n[3]: số Book Set (bộ sách) của Book Kit này. Tủ sách chỉ có 1 bộ sách sẽ không hiện thông tin này. \n\nChú ý: Trong chế độ Book Kit, nếu thay đổi thứ tự một Book Kit, toàn bộ Book Set của Book Kit đó sẽ được chuyển cùng nhau, có thể làm mất thứ tự các Book Set bị xen kẽ trong Book Set của các Book Kit khác." :
						"Danh sách hiển thị phía dưới là Book Set. Mỗi item có dạng\n'[2] Harry Potter^1,$4 [7]', trong đó:\n[2]: stt của Book Set Harry Potter.\n^1: id của Book Kit cha.\n$4: id của Book Set.\n[7]: số books của Book set này.";
					_chkboxLabel.setAttribute("data-tooltip", _tooltipTxt);

					//we might use MutationObserver to watch for this _chkboxLabel changes the tooptip-data, but it is not required in this case because the tooltip content is long enough so its width not change

					// wait 100ms for settingModal and tooltip to be render before re-calculate its position
					setTimeout(_ => guiUtils.reposTooltips(null, { selfElem: _chkboxLabel, container: document.querySelector(".modalPopupContentWrapper") }), 100);
				};
				// bind checkbox to xState variable so that checkbox state can be kept through page sessions
				bindCheckbox2StateVar(_chkShowBookKit,"bookKitSetView", {defVal: false, clickedCallback : _chkShowBookKitOnclickCB});
				
				//checkbox to show/hide all book names of each book set or book kit
				const _chkShowHideBooksDetails = document.getElementById("chkShowHideBooksDetails");
				//checkbox onclick callback function
				const _chkShowHideBooksDetailsOnclickCB = _ => {
					const _isNotChecked = !_chkShowHideBooksDetails.checked;
					let _pLineHeight;
					lstBookTitlesSetting.querySelectorAll("li .detailBookNames").forEach(_div => {
						_div.classList.toggle("hide-details", _isNotChecked);
						/* following block of code to set to one columns mode for div.detailBookNames that has less than 3 lines of text */
						if(!_isNotChecked && !_div.columnFixed){
							_div.columnFixed = 1; //so this fix does not run again for the same content
							// calculate lineHeight if it is not calculated before
							if(!_pLineHeight) _pLineHeight = parseInt(_div.css("line-height"), 10);
							//count number of lines of text
							if(_div.clientHeight / _pLineHeight < 3)
								_div.style.columnCount = 1;
						}
					});
				};
				// bind checkbox to xState variable so that checkbox state can be kept through page sessions
				bindCheckbox2StateVar(_chkShowHideBooksDetails,"bookSettingShowBookNames", {defVal: false, clickedCallback: _chkShowHideBooksDetailsOnclickCB});

				//populate book group way list
				(function () {
					let _defGrpLabels = xBookGrp.map(_ => { return _.grpWay }); //get list of group name

					selPopupBookGroup.innerHTML = "";

					for (let i = 0; i < _defGrpLabels.length; i++) {
						let opt = document.createElement('option');
						opt.value = i;
						opt.innerHTML = makeBrk(pad(i + 1, 2)) + " " + _defGrpLabels[i];
						selPopupBookGroup.appendChild(opt);
					}
				})();
				selPopupBookGroup.selectedIndex = xState.grpLine;
				// make the replaced spinner to have the same color with elmSelBookTitles
				//selPopupBookGroup.style.backgroundImage = document.getElementById("elmSelBookTitles").style.backgroundImage;

				if(!selPopupBookGroup.onchange) selPopupBookGroup.onchange = _ => {
					let newGrpIdx = selPopupBookGroup.selectedIndex;
					if (_chkShowBookKit.checked) bookKitList(newGrpIdx);
					else bookSetList(newGrpIdx);

					//right-align some elements (for now, just the bookKit/bookSet)
					SddDropdown.prototype.rightAlignElems(lstBookTitlesSetting, "li");
				}
				_chkShowBookKit.onclick(); // this also invokes selPopupBookGroup.onchange()

				/* HANDLING EVENTS */

				//Handling event for clicking on checkbox inside #lstBookTitlesSetting to show/hide book kit/set using event-delegation technique on bubbling event: click
				lstBookTitlesSetting.addEventListener("click", _showhideBookChkboxClickDelegation);
				function _showhideBookChkboxClickDelegation(evt) {
					let _target = evt.target;
					//console.log(_target);
					//if not checkbox, return
					//if (_target.tagName !== "INPUT" || _target.type !== "checkbox") return;
					//check to see if _target is checkbox that show/hide a book set (having attribute attr-bookkit-father) or a book kit (having attribute attr-bookKit)
					if(!_target.matches(`input[type="checkbox"][role="switch"]:is([attr-bookkit-father], [attr-bookKit])`)) return;

					let _grpLine = document.getElementById("selPopupBookGroup").selectedIndex;
					let xbookGrp_grp = xBookGrp[_grpLine].grp;
					let xState_grp = xState.grpCfg[_grpLine].grp;

					//mode can also be identified by value of document.getElementById("chkShowBookKit").checked

					//book Set view mode
					if (_target.hasAttribute("attr-bookKit-father")) {
						let _bkIndex = _target.getAttribute("attr-BookKit-Father");
						updateBKchkboxUI(_bkIndex);

						let _gid = _target.parentNode.getAttribute("attr-grpID"); //book set Id
						xbookGrp_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update hidden state to xBookGrp
						xState_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update to xState.grpCfg
					}

					//book Kit view mode
					if (_target.hasAttribute("attr-bookKit")) {
						//get book Kit id
						let _bkIdx = parseInt(_target.getAttribute("attr-bookKit"));
						if (isNaN(_bkIdx)) return; //should not happen, just check for sure

						//go through all xBookGrp[_idx].grp to find all book sets belong to book kit with id = _bkIdx
						for (let j = 0; j < xbookGrp_grp.length; j++) {
							let bookGrpItem = xbookGrp_grp[j];
							// if this book set belong to current book kit with bkIdx == _bkIdx
							if (bookGrpItem.bookKit == _bkIdx) {
								bookGrpItem.bHidden = !_target.checked; //update to xBookGrp
								let _gid = bookGrpItem.gId;

								xState_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update to xState.grpCfg
							}
						}
					}
				}
			}

			/* Deploy radio options to config the Toast, and handle any option changes */
			function addToastSettingControl() {
				let toastSettingDiv = document.querySelector('div[name="Toast-Setting"]');
				//check if control has deployed, we don't have to do that again
				if (!toastSettingDiv.hasAttribute("controlDeployed")) toastSettingDiv.setAttribute("controlDeployed", "done")
				else return;

				//initial xState.toastCfg if it not existed yet
				if (!xState.toastCfg) xState.toastCfg = {};
				let xToastCfg = xState.toastCfg;

				/** create HTML for radio buttons of a Toast configuration
					@param _cfgName {string}: a toast configuration such as theme, mode, animation, animation direction (animDir)
					@param _choiceLabel {string}: a title for current config
					@param _checkedIdx {integer}: a number (start from -1) to specify which radio button would be checked. set @null to check no button
					@param _innerHTMLOnly {boolean, optional}: @true if return innerHTML. Default return outterHTML
					*/
				function makeToastRadios(_cfgName, _choiceLabel, _checkedIdx, _innerHTMLOnly) {
					let _resHtml = "";
					let _attrStr = "toastSetting_" + _cfgName;
					//if _checkedIdx is undefined, make it default value = -1. Note that if _checkedIdx param == null, it will keep that value and no radio button is selected
					_checkedIdx = (_checkedIdx === undefined) ?  -1 : _checkedIdx;

					if(!_innerHTMLOnly) _resHtml += `<div class="fancyRadioContainer" name="${_attrStr}_container">`;
					_resHtml += `<div style="font-weight:bold;color:darkblue" data-checkeditem='${_checkedIdx}'>${_choiceLabel}: </div>`;
					
					let i = -1;
					for (let _item of ["Random"].concat(toast.toastChoices[_cfgName + "s"])) {
						let _labelText = _item;

						if (_cfgName == "theme") _labelText = (_item.match(/\-(.+)\-/) || ["", _item])[1].toProperCase(); //get 'random' or 'light', 'dark' or 'mono'

						let _otherFancyLabelCls = "";
						if (i == -1) _otherFancyLabelCls = 'fancyRadioLabelPurple'
						else{
							//toast mode: mode 0 is manual mode
							if (_cfgName == "mode" && i == 0) _otherFancyLabelCls = 'fancyRadioLabelBlue';

							//toast animation
							if (_cfgName == "animation") {
								let _possDirs = toast.toastChoices.posssibleAnimDirs(_labelText, "TOP-RIGHT"); //using some fake location
								//mark the animation having no direction with blue color
								if(!_possDirs.dir) {
									_otherFancyLabelCls = 'fancyRadioLabelBlue';
								}
								//in-place twited  animation, use gold color
								else if(_labelText.indexOf("--i") > -1)
								_otherFancyLabelCls = 'fancyRadioLabelGold';

								//extract suffix --m or --i from animation name
								_labelText = _possDirs.anim.toProperCase();
							}
						}

						// data-aIndex attribute mark the index of items in choices array. data-aChoice store config name (theme, mode, animation,...)
						_resHtml += `<input type="radio" id="${_attrStr}_${_item}" name="${_attrStr}" data-aIndex="${i}" data-aChoice="${_cfgName}" class="fancyRadioHidden" value="${_item}" ${_checkedIdx == i ? 'checked' : ''}>
						<label for="${_attrStr}_${_item}" class="fancyRadioLabel ${_otherFancyLabelCls}">${_labelText}</label>`;

						i++;
					}
					if(!_innerHTMLOnly)  _resHtml += `</div>`;
					return _resHtml;
				}

				//deploy all toast-setting radio options
				let _divHtml = "";
				_divHtml += makeToastRadios("theme", "Tông màu Toast", xToastCfg.theme);
				_divHtml += makeToastRadios("mode", "Vị trí Toast", xToastCfg.mode);
				_divHtml += makeToastRadios("animation", "Kiểu animations", xToastCfg.animation);
				toast.toastChoices["animDirs"] = [];
				_divHtml += makeToastRadios("animDir", "Chiều animations", xToastCfg.animDir);
				
				toastSettingDiv.innerHTML = _divHtml;

				let [_modeChoiceDivWrap, _animChoiceDivWrap, _animDirChoiceDivWrap] = ["mode", "animation", "animDir"].map( _choice => document.querySelector(`[name="toastSetting_${_choice}_container"]`) );

				//Using event-delegation technique to handle any radio option changes
				toastSettingDiv.addEventListener('click', function toastSettingHandler(evt) {
					let _target = evt.target;
					if (_target.tagName !== 'INPUT' && _target.type != 'radio' && !_target.classList.contains('fancyRadioHidden')) return;
					//console.log(_target);

					radioHandle(_target);

					evt.stopPropagation(); //stop the event propagate up to minimize events for upper Element in DOM tree

				});

				//force clicked on 'mode', 'animation' checked radio to update UI the dependent radios ('animation' and 'animDir')
				[_modeChoiceDivWrap, _animChoiceDivWrap].forEach(_wrapper => {
					let _checkedRadio = _wrapper.querySelector('input[type="radio"]:checked');
					if(_checkedRadio) _checkedRadio.click();
				});
				
				/* Main function to handle radio button click */
				function radioHandle(radioElem) {
					let _cfgName = radioElem.dataset.achoice;
					let _idx = parseInt(radioElem.dataset.aindex);

					//update to xState
					if(_idx == -1) delete xToastCfg[_cfgName]
					else xToastCfg[_cfgName] = _idx;

					const _container = radioElem.parentElement;
					_container.setAttribute("data-checkedItem", _idx);

					//remove the old label mark of page random choice that user not choose or choose random
					if( parseInt(_container.dataset.checkeditem) !== -1 )
					radioElem.parentElement.querySelectorAll("label.fancyRadioLabel.fancyRadioLabelRandomChoose").forEach(_lbl => _lbl.classList.remove("fancyRadioLabelRandomChoose"));
					
					/* 1. handle for 'MODE' radio buttons */
					if (_cfgName == "mode") {

						if (_idx == -1 || _idx == 0) { //random or manual mode
							
							fancyRadioAnimWrapperUI(true, _idx == 0? null: -1);
							makeAnimDirChoices([], true, _idx == 0? null: -1);
						}
						else {//auto mode "Bottom-Right", "Top-Right", "Top-Left", "Bottom-Left"
							let _lastAnimIdx = _animChoiceDivWrap.dataset.checkeditem ?? _animChoiceDivWrap.querySelector('input[type="radio"]:checked')?.dataset.aindex ?? -1;
							fancyRadioAnimWrapperUI(false, _lastAnimIdx);
							let _checkedAnimRadio = _animChoiceDivWrap.querySelector('input[type="radio"]:checked');
							_checkedAnimRadio && _checkedAnimRadio.click();
						}
					}

					/* 2. handle for 'ANIMATION' radio buttons */
					if (_cfgName == "animation") {
						let _possDirs = toast.toastChoices.posssibleAnimDirs( radioElem.value, _modeChoiceDivWrap.querySelector('input[type="radio"]:checked').value);
												
						if (_possDirs.dir) { //having directions
							toast.toastChoices["animDirs"] = _possDirs.dir;
							makeAnimDirChoices(toast.toastChoices["animDirs"], false, xToastCfg["animDir"] ?? -1); //-1
						}
						else{
							makeAnimDirChoices([], true, _idx == -1? -1 : null);
						}
					}

					/* Helper functions */
					/** Function to update UI for animation radio buttons
						@param _disabled {boolean}: to disable (true) or enable (false) the whole div container of all animation choices
						@param _checkedIdx {integer start from -1}: to check the radio having attribute 'data-aindex' of {_checkedIdx}. Set _checkedIdx = @null to check none.
						*/
					function fancyRadioAnimWrapperUI(_disabled, _checkedIdx){
						/* if(_checkedIdx == -1 || _checkedIdx == null) delete xToastCfg.animation
						else xToastCfg.animation = _checkedIdx; */

						_animChoiceDivWrap.classList.toggle("setting-elm-disabled", _disabled);
						let _checkedRadio = _animChoiceDivWrap.querySelector('input[type="radio"]:checked');
						if(_checkedRadio) _checkedRadio.checked = false;
						if(_checkedIdx !== null){
							let _newCheckedRadio = _animChoiceDivWrap.querySelector(`input[data-aindex="${_checkedIdx}"]`);
							if(_newCheckedRadio) _newCheckedRadio.checked = true;
						}
					}
					
					/** Function to deploy and update UI for animation Direction radio buttons
						@param _animDirArray {array}: the array of animDir choices. This depend on Toast location and Animation type
						@param _disabled {boolean}: to disable (true) or enable (false) the whole div container of all animation choices
						@param _checkedIdx {integer start from -1}: to check the radio having attribute 'data-aindex' of {_checkedIdx}. Set _checkedIdx = @null to check none.
						*/
					function makeAnimDirChoices(_animDirArray, _disabled, _checkedIdx){
						if(_checkedIdx == -1 || _checkedIdx == null) delete xToastCfg.animDir
						else xToastCfg.animDir = _checkedIdx;

						toast.toastChoices["animDirs"] = _animDirArray;
						_animDirChoiceDivWrap.classList.toggle("setting-elm-disabled", _disabled);

						_animDirChoiceDivWrap.innerHTML = makeToastRadios("animDir", "Chiều animations", _checkedIdx, true);
					}
				}
			}
			
			/* Mark the label of choice that not set by the user, but randomly choose by the page */
			function markToastRandomChoose(){
				const _toastChoices = toast.getToastConfig(); //page toast setting
				const _toastCfg = xState?.toastCfg ?? {}; //user toast setting
				/** Function to mark a label that randomly chosen by the page
					* @_container {HTMLElement}: the div container that contains all radio+label which present a choice for a toast config (such as mode, theme, animation)
					* @_choiceIdx {integer from 0}: the index of a choice made by the page (where user does not choose any choice for this toast config)
					*/
				const _markLabel = (_container, _choiceIdx) => {
					//removed the mark of old marked label
					_container.querySelectorAll("label.fancyRadioLabel.fancyRadioLabelRandomChoose").forEach(_lbl => _lbl.classList.remove("fancyRadioLabelRandomChoose"));

					//mark the new one
					const _markedLabel = _container.querySelector(`input[type="radio"].fancyRadioHidden[data-aindex="${_choiceIdx}"] + label.fancyRadioLabel`);
					if(_markedLabel) _markedLabel.classList.add("fancyRadioLabelRandomChoose");
				}
				const _cfgChoices = ["theme", "mode", "animation"];
				const _toastChoicesPropName = ["theme", "mode", "animMode"];
				_cfgChoices.forEach((_choice, i) => {
					if(!_toastCfg.hasOwnProperty(_choice) || _toastCfg[_choice] === -1) _markLabel(document.querySelector('div.fancyRadioContainer[name="toastSetting_' + _choice + '_container"]'), _toastChoices[_toastChoicesPropName[i]]);
				});

			}

			/* Function to deal with adding Database files and display its content including db variables, Book Kits inside and books in each bookKit */
			function addJsDatabaseFileReport(){
				/** generate HTML for statistics of a books collection 
					* @param _dbSummary {json}: which normally the returned value of BookData.prototype.booksStatistics()
					* @param _verbose {boolean}: default false. If true, adding names in Vietnamese of each statistic value
					* @return HTML code
				*/
				const statisticsHTML = (_dbSummary, _verbose = false) => {
					//📚📜🎧
					const _VERB = _verbose? [" bộ sách. ", " quyển sách. ", " nhóm chương. ", window.innerWidth < 500? " chương." : " chương sách."] : new Array(4).fill("");
					//shortcut for making svg icon
					const makeSvgStr = _type => makeSvgFromSprite(_type,{class:"svg-img-infor"});

					//for iPhone, using simple backslash to separate between totolDur and RealListeningTime so that the DbFile Header not break into more than 3 lines
					const _SEPARATOR = window.innerWidth < 300 ? "/ " : makeSvgStr("icnSvgListenTime");

					return `<dfn style="font-size:.85em;font-weight:600">
						${_dbSummary.bookSetsCount && _dbSummary.bookSetsCount !== _dbSummary.booksCount?makeSvgStr("icnSvgBookSets") + _dbSummary.bookSetsCount + _VERB[0] : ""}
						${makeSvgStr("icnSvgBooks")}${_dbSummary.booksCount}${_VERB[1]}
						${_dbSummary.chapGroupsCount ? makeSvgStr("icnSvgChapGroupIcon") + commaNum(_dbSummary.chapGroupsCount) + _VERB[2] : ""}
						${makeSvgStr("icnSvgChapters")}${commaNum(_dbSummary.chaptersCount)}${_VERB[3]}${_verbose?"<br/>":""}
						${makeSvgStr("icnSvgDuration")}${toHhMmSs(_dbSummary.totalDur, _verbose? 2: 0)}
						${_SEPARATOR}<var attr-duration="${_dbSummary.totalDur}">${toHhMmSs(_dbSummary.totalDur / xState.audio.speed, _verbose? 1: 0)}</var></dfn>`;
				}
					
				/** Display information of all Book of a Book Kit - which is a database variable whose name is _jsDBName (see the code)
					* @param _liElem {HTMLElement} the li element of ol#lstJsFileDataSetting element. We extract dbName from this _liElem, and use the global variable has that {dbName} to extract information and put on _liElem
					* @param _failCount 
					@value == undefined (is missing)
					- show Book infor if _jsDBName has data
					- show notification if variable whose name is {_jsDBName} not exists
					@value _failCount == number (usually > 10): show error notification

					* @return: - null if {_jsDBName} not exists
						- json in format {bookSetsCount: , booksCount: , chaptersCount: , totalDur: } store statistics for the whole database inside DB files
				*/
				function addJsDataFilesDetails(_liElem, _failCount){
					//name of db files also name of db variable
					const _jsDBName = _liElem.getAttribute("attr-Data-jsFile-Name");

					//create div element to show detail books of this database
					/* const _divBookDetailElem = document.createElement('div');
					_divBookDetailElem.classList.add("detailContent"); */

					const _divBookDetailElem = _liElem.querySelector('div.detailContent');

					let _jsDBFile = ssData.jsDBFiles.find(_dbFile => _dbFile.dbName == _jsDBName );
					
					//database not exists
					if(!_jsDBFile || (!window[_jsDBName])) {
						_divBookDetailElem.innerHTML = `<h2>File <b style='color:#9f5c28'>${_jsDBName}.js</b> hoặc Cơ sở dữ liệu <b style='color:darkblue'>${_jsDBName}</b> không tồn tại.</h2>` +
						(_failCount == undefined? `` : `<div style="column-span: all">Database ${_jsDBName} đã load không thành công ${_failCount} lần. Nếu vẫn muốn nạp lại file này, hãy chuyển nút checkbox thành 'Fresh Load'</div>`);
						_liElem.appendChild(_divBookDetailElem);
						return;
					}

					let _ulInnerHtml = [];
					const _totalSummary = _jsDBFile.dbs.reduce((_acc, _dbName) => {
						//book set data 
						const _bkRawData = window[_jsDBName][_dbName];

						//statistics for the book set
						const _bkSummary = BookData.prototype.booksStatistics(_bkRawData.books);
						
						//list all books inside this book set
						let _bookTitles = [], titleCounter = {}, _bookSetsCount = 0;
						_bkRawData.books.forEach(_book => {
							//find if this title already in the list
							let _idx = _bookTitles.indexOf(_book.title);
							if(_idx == -1){
								_bookTitles.push(_book.title);
								// this is not very exact way to count the number of book Sets since there are some books with different name but actually in the same book Set 
								_bookSetsCount++;
							}
							else{
								titleCounter[_idx] = titleCounter[_idx] ?? 1;
								titleCounter[_idx]++; //increase the title count
							}
						});
						//update some approximate bookSets Count
						_bkSummary.bookSetsCount = _bookSetsCount;

						//update the sum-up statistics
						_acc.booksCount += _bkSummary.booksCount;
						_acc.chapGroupsCount += _bkSummary.chapGroupsCount;
						_acc.chaptersCount += _bkSummary.chaptersCount;
						_acc.totalDur += _bkSummary.totalDur;
						_acc.bookSetsCount += _bookSetsCount;
						
						//create HTML string
						let _ulItemHtml = `<p class='dbFileBookList'>` +
							//add book kit name and statistics
							`<i>${_bkRawData.meta.name}</i> ` + statisticsHTML(_bkSummary) +
							//book kit details
							_bookTitles.map((_bookTit, _idx) => `<code>${_bookTit}</code>${titleCounter[_idx] ? " [" + titleCounter[_idx] + "]":""}`).join("") +
						"</p>";
						_ulInnerHtml.push(_ulItemHtml);

						return _acc;
					}, {bookSetsCount: 0, booksCount: 0, chapGroupsCount: 0, chaptersCount: 0, totalDur: 0});

					_divBookDetailElem.innerHTML = _ulInnerHtml.join("");
					_liElem.appendChild(_divBookDetailElem);

					return _totalSummary;
				}
				
				/** getting book data inside an Database. If it is already exist (because the DB has been loaded before, by loadPage() for example), use that data. If it is not, using loadJS to download the DB file and use book data inside downloaded file to show the book report for that DB.
					* This function alse is taken care of create html overlay for li element (which contain the report for each database), downloading database from js DB file (when necessary) and making details reports and statistical to put
					* @param _jsDBName {string}: the name of the DB file also name of single variable inside it, such as 'data_0', 'data_3'
					*/
				function showingDataReportFromDB(_jsDBName){
					// xDBFilesCfg item contain config data of current _jsDBName
					const _jsFileItem = xDBFilesCfg.toLoad.find(_item => _item.dbName === _jsDBName);

					//li element which contain all report, including report header. Note that when a DB having new edition, we need to update report for that new edition, _liDBreport was create before when the JsFileDataSetting tab is first active
					let _liDBreport = document.querySelector(`[attr-data-jsfile-name="${_jsDBName}"]`);
					// if it has not been creacted, create it
					if(!_liDBreport) {
						_liDBreport = document.createElement('li');
						_liDBreport.setAttribute("attr-Data-jsFile-Name", _jsDBName);

						//ol that display all data files and book kits, books inside it
						let lstJsFileDataSetting = document.getElementById("lstJsFileDataSetting");
						lstJsFileDataSetting.appendChild(_liDBreport);
					}

					//make version string (that next to DB name)
					let _version = _jsFileItem.dbUrl.match(/v\=(\d+)/)?.[0] ?? "";
					_version = _version == "" ? "" : " (" + _version + ", " + (_jsFileItem.hasOwnProperty("edt")?"Edt=" + _jsFileItem.edt + ", ":"") + _jsFileItem.failCount + ")";

					//create overlay HTML for the li
					_liDBreport.innerHTML = `
					<div>
						<details open=""><summary><span>${_jsDBName}${window.innerWidth>600? _version:""}</span><br/><samp name="dbSummary"></samp></summary></details>
						<span><input type="checkbox" role="switch" id="jsDataFileChkbox_${_jsDBName}" attr-chkbox-Data-jsFile="${_jsFileItem.fileNo}"/> <label for="jsDataFileChkbox_${_jsDBName}"></label></span>
					</div>
					<div class="detailContent"></div>`; //div.detailContent will contains the list of book inside the database named {_jsDBName}

					// set checkbox state with loadMode value
					guiUtils.setChkboxState(_liDBreport.querySelector("input[type='checkbox']"), _jsFileItem.loadMode);					

					// js database files loaded before in loadPage() or somewhere else
					// first condition (before OR operator): is a short way for [DBFiles.LMODE.freshLoad, DBFiles.LMODE.cacheLoad].includes(_jsFileItem.loadMode)
					// second condition: check if window[_jsDBName] is Json like object
					if(_jsFileItem.loadMode > 0 || (window[_jsDBName] && window[_jsDBName].constructor === ({}).constructor )) {
						//adding details and calculate statistics for whole DB file
						const _dbSummary = addJsDataFilesDetails(_liDBreport);
						//adding statistics for whole DB file to the title of li element
						if(_dbSummary) {
							_liDBreport.querySelector('[name="dbSummary"]').innerHTML = statisticsHTML(_dbSummary);
						}
					}
					else { // js database files HAS NOT loaded in loadPage(), temporarily load it to get general information
						// if a database file has been failed too many time, no point to reload it Except when user set loadMode to 1
						if(_jsFileItem.failCount >= 10){
							// show the notification for this file without loading it
							addJsDataFilesDetails(_liDBreport, _jsFileItem.failCount);
							return;
						}
						// if variable not yet existed, temporarily load it from data js file, showing its books list (and some statisticals) them remove the variable to save memory
						DBFiles.loadJS({
							allowReload: true, //using this in case the DB has new edition but loadMode=0(no-show), so its script has been loaded before in loadPage() function (and even its script element has already been removed) but its data has been remove. now we need to load again							
							freshLoad: false, //get DB from cache if feasible
							url: _jsFileItem.dbUrl,
							//see DBFiles.loadJS for explanation of some properties of extAttr
							extAttr: {
								//fileNo: _jsFileItem.fileNo, //this property is actually not use
								jsDBName: _jsDBName, 
								loadMode: _jsFileItem.loadMode
								//Old: DBFiles.LMODE.tempLoad, //to mark that this load js not for adding data to xData, it is for showing book and book kit for user to decide or not to show this database next session. This might not be neccessary since in .then(), .catch() below we don't update back loadMode into xDBFiles, so we can set this loadMode to DBFiles.LMODE.cacheLoad or DBFiles.LMODE.freshLoad
							}
						})
						.then((_prom) => {
							// Here we run loadJS for a single DB file, so _prom point to script elements created inside createLoadJS()
							const _jsDBName = _prom.extAttr.jsDBName;

							// add data to data collected variable ssData.jsDBFiles
							if(typeof window[_jsDBName] == "object")
							DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _prom.extAttr.loadMode);
							
							//adding details and calculate statistics for whole DB file
							const _dbSummary = addJsDataFilesDetails(_liDBreport);
							//adding statistics for whole DB file to the title of li element
							if(_dbSummary) {
								_liDBreport.querySelector('[name="dbSummary"]').innerHTML = statisticsHTML(_dbSummary);
							}

							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							//reset failCount
							if(_dbFileCfgItm) _dbFileCfgItm.failCount = 0;

							//if(_prom.extAttr.loadMode == DBFiles.LMODE.tempLoad) //maydo some extra check before cleaning DB variable
							window[_jsDBName] = undefined; //clean the variable that stored inside DB script
						})
						.catch((err) => { //error when page cannot load the database js files
							addJsDataFilesDetails(_liDBreport);
							//console.log(err);
							//err.target point to script element itself
							const _jsDBName = err.target.extAttr.jsDBName;
							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							toast.showToast(`Không tải được database ${err.target.src}`, toast.ToastType.Error);
							//increase failCount
							if(_dbFileCfgItm) {if(typeof _dbFileCfgItm.failCount == 'number')_dbFileCfgItm.failCount++; else _dbFileCfgItm.failCount = 1;}
						})
					}
				}

				//ol that display all data files and book kits, books inside it
				let lstJsFileDataSetting = document.getElementById("lstJsFileDataSetting");
				//remove mark of dragged li of last time using setting
				lstJsFileDataSetting.querySelectorAll("li.beingPlay").forEach(_li => _li.classList.remove("beingPlay") );

				//make sure the following event handler run only once in one session
				if (!lstJsFileDataSetting.hasAttribute("controlDeployed")) lstJsFileDataSetting.setAttribute("controlDeployed", "done")
				else return;
			
				// add showingDataReportFromDB as a prototype function of addJsDatabaseFileReport, so that it can be used in handyCheckDBsEdition 
				addJsDatabaseFileReport.prototype.showingDataReportFromDB = showingDataReportFromDB;				

				/* Load detailed information for each DB files */
				lstJsFileDataSetting.innerHTML = ""; //clear the last book dropdown list
				
				//showing report for each of database file based on database name
				xDBFilesCfg.toLoad.forEach(_toLoadItem => {
					const _jsDBName = _toLoadItem.dbName;
					
					/* showingDataReportFromDB is taken care of create html overlay for li element (which contain the report for each database), downloading database from js DB file (when necessary) and making details reports and statistical to put */
					showingDataReportFromDB(_jsDBName);
				});

				/* Show whole DB statistics, only count ones that user's setting loadMode !=0 */
				const _wholeStatistics = BookData.prototype.booksStatistics(ssData.xData);
				//count number of Book Sets according to grpWay 0
				_wholeStatistics.bookSetsCount = ssData.xBookGrp[0].grp.reduce((_acc, _grp) => _acc += _grp.books.length, 0);				

				const _DBStatisticselem =document.querySelector('[name="DBStatistics"]');
				const _nextCheckText = window.innerWidth > 500? "Lần tự động kiểm tra phiên bản DB tiếp theo: " : "Next auto-check for new DBs edition: ";

				_DBStatisticselem.innerHTML = statisticsHTML(_wholeStatistics, true) + `<br/><dfn name='lastCheckDBUpdateStatus'>${_nextCheckText}<svg class="!text-[15px] button-svg-img"><use href="#icnSvgCheckDBsUpdate"/></svg> <mark style='color:darkred' data-tooltip='Khoảng cách giữa hai lần tự động kiểm tra là ${toHhMmSs(_DEFAULT_CFG.cDBFilesEdt.checkEdtDelay, 2)}.&#10Bấm vào đây để đóng/mở tất cả thông tin sách cho từng CSDL.'></mark></dfn>`;

				/* Event handler for component of this tab */
				const _checkDBUpdateElem = _DBStatisticselem.querySelector('dfn[name="lastCheckDBUpdateStatus"] > mark');

				//click on the <mark> element containing next time checking DB for new edition to expand.collapse all book reports
				_checkDBUpdateElem.addEventListener("click", (evt) => {
					const _lstJsFileDataSetting = document.getElementById("lstJsFileDataSetting");
					//get all book report details element
					const _allReports = _lstJsFileDataSetting.querySelectorAll('details:has(> summary)');
					let _openCount = 0;
					_allReports.forEach(_dtl => {if(_dtl.open) _openCount++});
					//expand if number of currently expands <details> element is less than half of all
					const _tobeExpanded = _openCount < _allReports.length / 2;
					_allReports.forEach(_dtl => _dtl.open = _tobeExpanded);
				});
				function updateLastDBsEditionCheck(event) {
					//event && console.log(event.detail.updateDBs);
					/* const _lastDBChecked = new Date(ssData.lastDBCheck);
					const _timeDateStr = _lastDBChecked.toLocaleTimeString('vi') + '—'  + _lastDBChecked.toLocaleDateString('vi'); */
					const _timeDateStr = (new Date(ssData.lastDBCheck + 1000 * _DEFAULT_CFG.cDBFilesEdt.checkEdtDelay)).toLocaleString("vi-VI"); //format to 'time Date' form
	
					_checkDBUpdateElem.textContent = _timeDateStr;
				}
				// Add event handler for custom event 'DbsFileGotNewEditionEvent' which if fired in Setting.handyCheckDBsEdition() function right below. This event is fired every time the page checking DBs edition, and handler is taking care of showing the new time for next check
				window.addEventListener("DbsFileGotNewEditionEvent", updateLastDBsEditionCheck);
				updateLastDBsEditionCheck(); //update for the first time
				
				/* delegation to handle checkbox click and save to change to global variable xDBFilesCfg (and later to localStorage) */
				lstJsFileDataSetting.addEventListener("click", (evt) => {
					let _target = evt.target;
					//console.log(_target);
					evt.stopPropagation(); //stop click events to be bubbled to upper layers

					// handle event for load/unload js file checkbox
					//if (_target.tagName == "INPUT" && _target.type == "checkbox" && _target.hasAttribute("attr-chkbox-Data-jsFile")) {
					if(_target.matches(`input[type="checkbox"][attr-chkbox-Data-jsFile]`)){
						let _currVal = parseInt(_target.dataset.stateVal ?? 0);
						//order of loadMode: 0 - no load --> 2-load, using cache if applicable --> 1-load fresh, no cache.
						const _stateArr = [0, 2, 1];
						let _newVal = _stateArr[(_stateArr.findIndex(_st => _st==_currVal) + 1) % 3];

						guiUtils.setChkboxState(_target, _newVal);

						const _fileNo = _target.getAttribute("attr-chkbox-Data-jsFile");
						if(_fileNo == undefined) return;
						
						//if this DB is set to no-show, we need to make sure that there is at least one DB is set to Cache-Load or Fresh-Load
						if(_newVal == 0){
							// get all other DB-file checkbox, except the current _target
							const _allOtherCheckboxes = lstJsFileDataSetting.querySelectorAll(`input[type="checkbox"][attr-chkbox-Data-jsFile]:not([attr-chkbox-Data-jsFile="${_fileNo}"])`);
							//count if there is any of those other DBs being Cache-Load(2) or Fresh-Load(1)
							let _DBLoadCounter = 0;
							_allOtherCheckboxes.forEach(_chkBox => {if(parseInt(_chkBox.dataset.stateVal ?? 0) != 0) _DBLoadCounter++});

							if(_DBLoadCounter == 0){ //if all of them are no-show
								toast.showToast('Phải có ít nhất một CSDL đặt chế độ Load', toast.ToastType.Error);
								guiUtils.setChkboxState(_target, _currVal);
								return;
							}
						}						

						let toLoadArr = xDBFilesCfg.toLoad;
						toLoadArr.find(_lm => _lm.fileNo == _fileNo).loadMode = _newVal;
					}
				});

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						// console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstJsFileDataSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _itemDrop = lstJsFileDataSetting.querySelector("li[attr-dragidx='" + t + "']");
						if (f > t)
						lstJsFileDataSetting.insertBefore(_itemDrag, _itemDrop);
						else
						lstJsFileDataSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						arrayMove(xDBFilesCfg.toLoad, f, t); //re-arrange for xBookGrp
						
						//re-calculte book kit rank
						//calculateBookKitRank(_grpLine);
					}
					_dragObj = dragDropList({ "parent": lstJsFileDataSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated
			}
			
			/** Function to reload 'config.js', chech edition number to see if there is any DBs having new edition. If there are, download the new edition (and version) of those DBs. If among them, there is DBs that currently not in hidden mode (loadMode = cacheLoad(2) or freshLoad(1)), ask user to restart the page to get data inside those DBs got updated
			If found some DB having new edition (does not matter that DB is in hidden or shown mode), this function also update the report for those DB in JsFileDataSetting Setting tab. However, for now it does not update the total statisticals (at the bottom of the tab) for all the shown books
				* @param _showFailedCheck (boolean): 
					@value true show the toast that tell there is no new DBs or failed to load config.js.
				@value false (default), not show the message
				* @return nothing
			*/
			function _handyCheckDBsEdition(_showFailedCheck = false){
				//success or not, we need to update this lastDBCheck, otherwise in case of continuos fails (lost internet, for example), page will keep checking updates
				ssData.lastDBCheck = Date.now(); //update last checked time

				//get checkbox that control the active state of JsFileDataSetting tab
				const _radioTabJsFileDataSetting = document.getElementById("radioTabJsFileDataSetting");

				// an flag to tell if the tab-content is appeared in user view
				const _isTabActive = Boolean(_radioTabJsFileDataSetting.nextElementSibling.nextElementSibling.offsetParent);

				//function to run after each script load is successfully downloaded
				function _promiseCallback(_scriptElm){
					const _extAttr = _scriptElm.extAttr;
					const _jsDBName = _extAttr.jsDBName;
					// if JsFileDataSetting tab is currently active, replace report for DB has new edition
					if(_isTabActive)
						addJsDatabaseFileReport.prototype.showingDataReportFromDB(_jsDBName);
					// for DB in hidden mode, remove variable to save memory
					if(_extAttr.loadMode === DBFiles.LMODE.noShow)
						window[_jsDBName] = undefined;
				}
				//function to run after all script load is settled down and its general information is shown up in Setting modal tab
				function _allSettleCallback(){
					const _radioTabJsFileDataSetting = document.getElementById("radioTabJsFileDataSetting");

					// if ssData.setting.handyCheckDBsEdition invoked automatically when the time to check for new DB edition is reached and page just got focus AND the JsFileDataSetting tab is currently NOT active, next time that tab got active, the big addJsDatabaseFileReport() function will be invoked to re-load reports for ALL databases
					if(_isTabActive)
					delete _radioTabJsFileDataSetting.dataset.beenActive;
					//else: tab is not active, then _promiseCallback above take care of updating report for DB having new edition alone, without having reload report for ALL databases
				}
				
				//"config.js" has no "?v={version_number}" so it will be added in loadJs. This make config.js always in Fresh-load mode. allowReload=true allow config.js is reloaded even it has loaded before by the same old loadJS
				DBFiles.loadJS( {url: "config.js", allowReload: true} )
				.then((_ret) => {
					// this array store list of DB files that has newer editions. If none has or fail to load 'config.js', it is null					
					//See return in DBFiles.checkDBFilesEdition for the format of returned value
					let _DBsHasNewEdition = DBFiles.importDBfromFiles(
						//mark that invoke from Setting.handyCheckDBsEdition()
						1,
						//callback function which will be invoked each time a DB script file is loaded succesfully
						_promiseCallback,
						//callback function which is invoked when all DBs has been loaded (each might be sucessful or failed)
						_allSettleCallback
					);

					//if there is no DBs has new edition
					if(_showFailedCheck && _DBsHasNewEdition.length==0) toast.showToast("Cơ sở dữ liệu hiện có đã là mới nhất.", toast.ToastType.Infor, {duration: 1e4});

					//fire event that notifying that DBs has just been checked for updates, so the Settinng modal will update accordingly in case user are opening it (see Setting.addJsDatabaseFileReport() function right above which catch this event to update the last time checking DBs edition)
					window.dispatchEvent(new CustomEvent("DbsFileGotNewEditionEvent", {
						detail: { updateDBs: _DBsHasNewEdition, caller: 'Setting.handyCheckDBsEdition' }
					}));
				})
				.catch(err => {
					console.error(err);
					if(_showFailedCheck) toast.showToast("Không nạp được file config.js.", toast.ToastType.Error, {duration: 1e4});
				});
			}

			/** to list listening history  */
			function addListeningHistory(){
				let _hist = xState.history;

				//get the current book, chap play by xAudio
				let _xAudioCurrBook = xAudio.getAttribute("attr-book"),
				_xAudioCurrChap = parseInt(xAudio.getAttribute("attr-chap"));
				//update current time of chapter of current book to xState history
				let _xAudioCurrTime = xAudio.currentTime;
				//in case the new chapter is still loading, xAudio Current time might be NaN
				if(isNaN(_xAudioCurrTime)) _xAudioCurrTime = 0;

				if(!_hist.books.hasOwnProperty(_xAudioCurrBook)) _hist.books[_xAudioCurrBook] = {_xAudioCurrChap: _xAudioCurrTime, lc: _xAudioCurrChap, urlLine: 0}
				else _hist.books[_xAudioCurrBook][_xAudioCurrChap] = _xAudioCurrTime;
				
				//the outer div that contains ul, which contains all the history books
				const _lhWrapperElm = document.querySelector("#ListeningHistoryWrapper");

				//nothing in history yet
				if(_hist.hisList.length == 0){
					_lhWrapperElm.textContent = "No history yet";
					return null;
				}

				//get the list of id of all books has been listend and recored by xState
				let _bookListenedIds = Object.keys(_hist.books);

				/* //get list of all orphaned books, the book that recorded in _hist.books but not in _hist.hisList (see historyCls.addToHistory() for the reason)
				let _orphanedBookIds = [];
				_bookListenedIds.forEach(_bId => {if(!_hist.hisList.includes(_bId)) _orphanedBookIds.push(_bId)}); */

				/** function to generate svg icon along with tooltip and css style for each type of information
				* @param _type: inforType, see the code for details
				*/
				let makeSvgStr = _type => {
					//let _iconTitle = ["Tên sách", "Số thứ tự chương", "Tác giả", "Người đọc", "Thời lượng đã nghe"];
					let _iconNames = ["icnSvgBooks", "icnSvgChapters", "icnSvgMaleAuthor", "icnSvgMicrophone", "icnSvgDuration"];
					let _inlineStyle = "", _class = "svg-img-infor";

					return `${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}`; //
				}
				
				/* this var is used to count the ordinal for history books, starts from the most recently one */
				let _bookStt = 0;				

				/** function to create html code for a book in history
					* @param _bookId {8-char string} the book id that got from history to show information (mostly about chapter that user was listenning but not finished)
					*/
				const _makeTreeLi = _bookId => {
					//the data from xData for the book
					const bData = ssData.bookData.findBookFromId(_bookId);
					if(!bData){
						// this should never be happening, because in bookDataInitial(), the xState.history has been clean to remove all unexisted-books
						return "";
					}

					//if somehow this book not yet has statistic data, calculate it. The reason would be the book is listened before, but its group has been set hidden in Book Setting Tab, so it is not loaded into SDD ssData.sddBooks, so its statictics has not been calculated
					if(!bData.hasOwnProperty("statistics")) BookData.prototype.bookStatistics(bData);

					// the history information of the book got from xState
					const _histBook = _hist.books[_bookId];

					const _SEP_CHAR = '&hairsp;/&hairsp;'; //'&#8198;/&#8198;';
					//id for for checkbox and label
					const _elmId = 'BLH_' + _bookId; 
					//label for li that show book information
					let _liLabel = `<b>${++_bookStt}</b> ${makeSvgStr(0)}<span class='histTitle' style='font-weight:600'>${bData.title}</span> [${_bookId}] ${makeSvgStr(1)}${bData.statistics.chaptersCount}${_SEP_CHAR}${toHhMmSs(bData.statistics.totalDur)} ${makeSvgStr(2)}${bData.author} ${makeSvgStr(3)}${bData.mc}`; //ஃ&thinsp;
					
					//filter all attributes that is a number, those are the chapter
					let _chapSttList = Object.keys(_histBook).filter(_attr => _attr.match(/^\d+$/) );
					
					//get information for all listened chapters of the current books, each put in an li element
					let _chapsLiHtml = _chapSttList.map(_chap => {
						_chap = parseInt(_chap);
					
						const _chapData = bData.parts[_chap-1];
						//get title of the chapter, in case it is missing we need to generate from wildcart
						let _chapTit = _chapData.tit;
						//if there is no chap title or chap title contains wildcart string, we need to run wildcart generation for chapter titles
						if(!_chapTit || _chapTit.includes(ssData.wildCartStr)) {
							BookData.prototype.generateWCLinks(_bookId);
							_chapTit = _chapData.tit;
						}

						//li html code for current chapter information
						let _chapLiHtml = `<li class='chapter_li ${_chap == _histBook.lc? 'last-playing-chapter' : ''}' data-bookId='${_bookId}' data-chapter='${_chap}'>
							<label>
								${makeSvgStr(1)}<code data-rAlignGroup='chapStt'>${_chap}</code> 
								${makeSvgStr(4)}<b data-rAlignGroup='listenedTime'>${toHhMmSs(_histBook[_chap])}</b>/<code data-rAlignGroup='chapTime'>${_chapData.dur}</code> 
								<span class='histTitle'>⏵&thinsp;${_chapTit}</span>
							</label></li>`;
						return _chapLiHtml;
					}).join(" ");

					//li code for information about the book, including uncompleted was-listening-book.
					let _html = 
						`<li class="parent_li ${_bookId == xState.lb? 'last-playing-book':''}" data-bookid='${_bookId}'> 
							<input type="checkbox" id="${_elmId}" checked />
							<label for="${_elmId}">${_liLabel}</label>
							<ul>${_chapsLiHtml}</ul></li>`;
					return _html;
				}

				//list the books in reversed order, so that the most recent listened book on top
				let _booksLiHtml = _hist.hisList.toReversed().map(_bookId => _makeTreeLi(_bookId)).join(" ");

				_lhWrapperElm.innerHTML = 
					`<ul>
						<li class="parent_li"> 
						<input type="checkbox" id="outer_listening_history" checked />
						<label for="outer_listening_history">Lịch sử nghe sách</label>
						<ul>${_booksLiHtml}</ul>
					</ul>`;
				
				//query all ul that directly contains li that is chapter_li
				_lhWrapperElm.querySelectorAll('li.parent_li > ul :has(> li.chapter_li)')
					//right-align chapter stt and chapter listening time for all chapters belong to a book
					.forEach(_ulChap => SddDropdown.prototype.rightAlignElems(_ulChap, 'li.chapter_li > label'));

				/* function to middle the horizontal tree line (with the small triangle and dot) for parent_li. We can remove this function, so that all _parent_li will used the '--horizon-lines-top' default value set in CSS of #ListeningHistoryWrapper element (for now is 25px) */
				const centerParentLiTreeLine = function() {
					let _ParLi_Padding_Top = 0;
					_lhWrapperElm.querySelectorAll('li.parent_li:not(.treeview > ul > li.parent_li)').forEach(_parentLi => {
						//get the padding-top of parent_li element. Since all parent_li (which is not outer-most li.parent_li) has the same padding-top, so we need to get this value only one time and used for all li.parent_li
						if(_ParLi_Padding_Top == 0)
						_ParLi_Padding_Top = parseFloat(_parentLi.css('padding-top'));

						//get the height of label that is direct child of _parentLi (one that display information about book)
						const _labelElem = _parentLi.querySelector('label[for]');
						const _label_height = _labelElem.getBoundingClientRect().height;

						//in case the lable has not been fully-rendered yet
						if(_label_height > 0) 
							//set a customized css variable '--horizon-lines-top' uniquely for this _parentLi, so the horizontal tree line will be at the middle of the label of current _parentLi
							_parentLi.style.setProperty('--horizon-lines-top', (_ParLi_Padding_Top + _label_height/2) + 'px');						
					});
				}
				//wait for sometime until the tree is completely-rendered
				setTimeout(centerParentLiTreeLine, 500) ;

				/* make a delegation event handler on the wrapper div to catch the click event on chapter li, so to play the clicked chapter */
				if(!_lhWrapperElm.dataset.loaded){
					// so that all code in this block (which are all elements' handler) is loaded only one time
					_lhWrapperElm.dataset.loaded = true;

					/* A. Handler for elmHistoryClear button */
					document.querySelector('#elmHistoryClear').onclick = evt => {
						//clear history
						historyCls.historyClear();
						//reload the tab content to update the cleared history
						addListeningHistory();
					}

					/* B. Handler for chkShowHideAllHistChapDetails checkbox, so when that checkbox changes, all book listening history is collapsed/expanded accordingly */
					const _chkShowHideAllBooksDetail = document.querySelector('#chkShowHideAllHistChapDetails');
					_chkShowHideAllBooksDetail.onclick = evt => {
						let _isChecked = _chkShowHideAllBooksDetail.checked;
						//query all checkbox that control the expand/collapse state of a book history information
						_lhWrapperElm.querySelectorAll('li[data-bookid] > input[type="checkbox"][id^="BLH_"]').forEach(_bookChkbx => _bookChkbx.checked = _isChecked);
					}

					/* X. Handler when click on chapter's label to play the corresponding chapter */
					_lhWrapperElm.addEventListener('click', evt => {
						const _target = evt.target;
						//console.log(_target);

						/** function to sync master checkbox #chkShowHideAllHistChapDetails state with all BLH_ checkboxes. Each BLH_ checkbox control the collapsed/expanded state of one book listening history details */
						function syncMasterUI2BLHcheckboxes(){
							//query all checkbox that control the expand/collapse state of a book history information
							const _allBookHistCheckboxes = _lhWrapperElm.querySelectorAll('li[data-bookid] > input[type="checkbox"][id^="BLH_"]');
							//count the number of expanded book history information
							let _chkCount = 0, _chkTotal = _allBookHistCheckboxes.length;
							_allBookHistCheckboxes.forEach(_bookChkbx => {
								if (_bookChkbx.checked) _chkCount++;
							});

							//update the master checkbox state and UI
							guiUtils.setChkboxState(document.getElementById("chkShowHideAllHistChapDetails"),
								_chkCount == 0 ? 0 : (_chkCount == _chkTotal ? 1 : 2));
						}

						/* X.1. Handler when click on book's label to collapse/expand book's chapter listening history */
						//if(_target.tagName == 'INPUT' && _target.type == 'checkbox' && (_target.getAttribute('id') ?? '').startsWith('BLH_') ){
						if(_target.matches(`input[type="checkbox"][id^="BLH_"]`)){
							//re-sync master checkbox #chkShowHideAllHistChapDetails with all BLH_ checkboxes after one changes expand/collapse state
							syncMasterUI2BLHcheckboxes();
						}

						/* X.2. Handler when click on chapter's label to play the corresponding chapter */

						// note that we can catch click on label, so we need to get the li element that parent of clicked label (and label's children)
						const _liElem = _target.parentElement; // since in CSS we set 'pointer-events: none;' for all label's children, so can simply use _target.parentElement, instead of expensive _target.closest('li.chapter_li');
						//if it is chapter li. Note that for outer-most li>label, _liChapElem = null
						if(_target.tagName == 'LABEL' && _liElem && _liElem.classList.contains('chapter_li') ){
							
							//get the li element that mother of clicked label
							const _bookLi = _target.closest('li.parent_li');

							//if clicked label not in li that is current playing chapter, switch the class that mark li>label is current playing chapter
							if(!_liElem.classList.contains('last-playing-chapter')){
								const _lastPlayingChap = _bookLi.querySelector('li.last-playing-chapter');
								_lastPlayingChap && _lastPlayingChap.classList.remove('last-playing-chapter');
								//set UI of clicked li to be playing-chapter
								_liElem.classList.add('last-playing-chapter');
							}
							
							//get the bookId and chapter number from curren history chapter li element
							const _loadingBookId = _liElem.dataset.bookid, 
								_loadingChapterNum = _liElem.dataset.chapter;
							//re-acquire the book Id
							_xAudioCurrBook = xAudio.getAttribute("attr-book");
							//_xAudioCurrChap = parseInt(xAudio.getAttribute
							// ("attr-chap"));

							//if current li belong the the same book that are playing by xAudio, just change the chapter (changeChap will take care of re-play current playing chapter)
							if(_xAudioCurrBook === _loadingBookId){
								changeChap(_loadingChapterNum);
							}
							else{
								//change the UI of books
								//get the li that is currently marked as current played book
								const _lastPlayedBookELm = _lhWrapperElm.querySelector("li.last-playing-book");
								_lastPlayedBookELm && _lastPlayedBookELm.classList.remove("last-playing-book");
								//mark the new clicked book to be the new playing book
								_bookLi.classList.add("last-playing-book");

								//change the lc (last chapter) property of current book in xState, so that when loading the book, this chapter will be loaded
								_hist.books[_loadingBookId].lc = parseInt(_loadingChapterNum);
								//then just load the book without adding it to the history list
								historyCls.historyGo(_loadingBookId);
								//ssData.bookData.goGetBook(_loadingBookId);
							}
						}

						/* X.3. Handle event when click on little triangle of book li */
						// if we don't check _target.tagName, this might run twice, one on the label, one on the checkbox that the label associated with.
						if(_target.tagName == 'LABEL' && _liElem && _liElem.classList.contains('parent_li') ){
							/* Check if click on little triangle which drawed by label::before pseudo element. More accurate, but expensive condition: we compare the x-position (in relative to the vewport) to the left side of li element (again, relative to the viewport) 'evt.clientX < _liElem.getBoundingClientRect()' */
							//number -3 here is the left-most position of the little dot (sized 6px (set in {--dot-size} attribute of {li.parent_li.last-playing-book > label::after}) drawed by label::after pseudo element) in relative to the _liElem. Note that offsetX is The X coordinate of the mouse pointer relative to the position of the padding edge of the target node.
							if (evt.offsetX < -3) {
								const _bookId = _liElem.dataset.bookid;
								//console.log("Click on little triangles: " + _bookId);
								/* The process to remove book and chapter items from xState.history is exacly the same as historyCls.historyClear() */
								if(_bookId == xState.lb){
									// keep information of current chapter of current book
									let _histBook = _hist.books[_bookId];
									const _currChap = _histBook.lc;
									
									//delete information about all other chapter except current chapter
									Object.keys(_histBook)
										//filter all attributes that is a number, those are the chapter AND make sure it is NOT _currChap
										.filter( _attr => _attr.match(/^\d+$/) && _attr != _currChap )
										//delete information about the chapters
										.forEach(_chap => delete _histBook[_chap]);
									//make last book to be _currChap (just in case)
									_histBook.lc = _currChap;

									//remove all li that contains purged xState.history chapter of current _bookId out of DOM
									_liElem.querySelectorAll("ul > li.chapter_li:not(.last-playing-chapter)").forEach(_subLi => _subLi.remove());									
								}
								else{
									//delete all  information about _bookId out of xState.history.books
									delete _hist.books[_bookId];
									//delete the _bookId from xState.history.hisList and update currHis
									const _histIdx = _hist.hisList.findIndex(_book => _book == _bookId);
									if(_histIdx > -1) {
										_hist.hisList.splice(_histIdx, 1);
										//update currHis so that it still point to the old last-book before removing this _bookId
										if(_hist.currHis > _histIdx) _hist.currHis--;
									}

									//update history button in case the removal might affect
									historyCls.prototype.buttonAppeance();

									//remove book li out of DOM
									_liElem.remove();

									//re-sync master checkbox #chkShowHideAllHistChapDetails with all BLH_ checkboxes after one is removed
									syncMasterUI2BLHcheckboxes();
								}

								//notify the user of removing book from history
								toast.showToast(`Đã xóa khỏi lịch sử nghe sách các chương đang nghe${_bookId == xState.lb?' (ngoài chương đang được phát)':''} của cuốn sách '${_target.querySelector('.histTitle').textContent}'.`, toast.ToastType.Warning);

								// prevent the tree expand/collapse
								evt.preventDefault();
								//evt.stopPropagation();
							}	
						}
						evt.stopPropagation();
					});					
				}
			}

			/* function to show all hot keys that support by the page along with some introduction, copyright, hints */
			function showHotKeys(){
				const hkWrapper = document.querySelector('div[name="hotkeysSettingWrapper"]');
				//break string of hotkey separated by "," or "+" into list of separate keys
				const _mapKey2Img = (_key, _ignoreMap = false) => {
					_key = _key.trim().replace(/^Key/,"");
					if(_ignoreMap) return _key;

					const _keysMap = [{key: "NumpadAdd", img: "Numpad+"},{key: "NumpadSubtract", img: "Numpad-"}];
					/* [{key: "ArrowUp", img: "↑"},{key: "ArrowDown", img: "↓"},
					{key: "ArrowLeft", img: "←"},{key: "ArrowRight", img: "→"},
					{key: "Backspace", img: "⌫"},{key: "Escape", img: "ESC"},
					{key: "NumpadAdd", img: "Numpad+"},{key: "NumpadSubtract", img: "Numpad-"},
					{key: "Shift", img: "⇧"},{key: "Alt", img: "⌥"},{key: "Ctrl", img: "⌘/⌃"},
					{key: "ControlRight", img: "⌘/⌃Right"},{key: "ShiftRight", img: "⇧Right"}]; */

					const _findKey = _keysMap.findIndex(k => k.key == _key);
					if(_findKey > -1) return _keysMap[_findKey].img; else return _key;
				}
				const breakKeys = (keyString, keySeparator = "<br/>", _ignoreModifierKeys = false) => {
					if(!Array.isArray(keyString)) keyString = keyString.split(",");
					return keyString.map(keys => 
						keys.trim().split("+").map(key => `<kbd${_ignoreModifierKeys?' class="ignoreModifierKeys"':''}>${_mapKey2Img(key)}</kbd>`).join(" + ")
					).join(keySeparator);

				}
				//list all hotkeys of a hotkey collection such as ssData.sddBooks.hotKeys
				const listHotKeys = (hkCollection, keySeparator = "<br/>") => {
					let _html = hkCollection.map(hk => `<samp data-task="${hk.task}">${breakKeys(hk.kCode, keySeparator, hk.ignoreModifier)}</samp><label>${hk.desc}</label>`);
					return _html.join("");
				}
				//add following in to field-set to make it land-scape layout with the full-width: ' class="lanscape-content" style="grid-column: span 2;" '
				hkWrapper.innerHTML = `<div>
				<fieldset style="grid-row: span 3;align-self: stretch;">
					<legend>Phím tắt cho Search–Dropdown</legend>
					<span class="commonGuide">— Trong danh mục các <b>tựa sách / chương sách</b>, kết hợp phím <samp modifier-key="true">${breakKeys(ssData.sddBooks.settings.makeSelectKey)}</samp> / <samp modifier-key="true">${breakKeys(ssData.sddChaps.settings.makeSelectKey)}</samp> (theo thứ tự) với các phím thay đổi mục (option) để phát ngay <b>tựa sách / chương sách</b>.</span><span class="commonGuide">— Chuyển chế độ tìm kiếm '<b>không dấu</b>' hoặc '<b>nguyên dấu</b>' bằng cách bấm phím tắt hoặc bấm nút lệnh <object style='display: inline-block; width: 20px; height: 20px; border: 1px solid; border-radius:4px;padding: 2px;'>${ssData.sddBooks.rootElement.querySelector(".search-diacritics-option-button > svg").outerHTML}</object> ở bên phải ô tìm kiếm.<br/>— App vẫn tìm kiếm trong tiêu đề phụ (nếu có) ngay cả khi nó bị ẩn (nút lệnh <object style='display: inline-block; width: 20px; height: 20px; border: 1px solid; border-radius:4px;padding: 2px;'>${ssData.sddBooks.rootElement.querySelector(".toggle-extra-title-button > svg").outerHTML}</object>).<br/>— App luôn luôn tìm kiếm không phân biệt chữ hoa-thường (case-insensitive). Tuy nhiên, tùy thuộc các chữ trong xâu tìm kiếm, ta có các cách tìm khác nhau:<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là chữ hoa, chế độ tìm kiếm sẽ theo '<b>Chữ cái đầu tiên</b>' của các từ liên tiếp. Ví dụ: So sánh tìm <kbd>TĐ</kbd> trong chế độ tìm dấu nêu trên.<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là chữ thường, chế độ tìm kiếm sẽ là tìm '<b>Cụm từ</b>' (như indexOf). Ví dụ: So sánh tìm <kbd>đại kinh</kbd> theo một trong hai chế độ tìm dấu. Trong chế dộ 'không dấu', so sánh kết quả tìm <kbd>Tinh do</kbd> vs <kbd>tinh do</kbd>; <kbd>dai kinh</kbd> vs <kbd>kinh dai</kbd>.<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là số (và dấu <kbd>.</kbd>), chế độ tìm kiếm là '<b>Số</b>'. Có thể bấm số kết thúc bằng dấu <kbd>.</kbd> để tìm nhanh đến mục có số thứ tự tương ứng. Ví dụ: <kbd>30.</kbd><br/>&emsp;⨁ Trường hợp còn lại là chế độ tìm kiếm '<b>Khớp từ</b>', chuỗi kết quả là chuỗi chứa từng từ trong chuỗi tìm kiếm theo thứ tự bất kỳ. Ví dụ, tìm <kbd>Dai kinh</kbd> trong chế độ 'không dấu' sẽ tìm được cả 'Đại Kinh' và 'Kinh Tạng Đại Thừa'</span>
					${listHotKeys(ssData.sddBooks.hotKeys)}
				</fieldset>
				<fieldset>
					<legend>Phím tắt cho Audio–Player</legend>
					<span class="commonGuide">— Bấm các phím chức năng <kbd>Ctrl</kbd>/<kbd>Shift</kbd>/<kbd>Alt</kbd> cùng các phím tua nhanh để tua 40/30/20 giây.<br/>— Bấm phím chức năng <kbd>Alt</kbd> cùng các phím tăng/giảm âm lượng để thay đổi âm lượng 10%.<br/>— Bấm các phím chức năng <kbd>Shift</kbd>/<kbd>Alt</kbd> cùng các phím tăng/giảm tốc độ phát để thay đổi 0.2/0.1.<br/>— Nháy đúp vào {bên trái/bên phải} của [khung đếm thời gian/ảnh bìa/lề của trang] để tương ứng tua {về trước/về sau} lần lượt [15/20/30] giây. Nút lệnh tua [nhỏ/to] tua [10/20] giây. Nút tua trong Notification Center tua 15 giây.</span>
					${listHotKeys(ssData.hotKeys.audioPlayer)}
				</fieldset>
				<fieldset>
					<legend>Phím tắt cho trang ngoài</legend>
					${listHotKeys(ssData.hotKeys.mainPage, ", ")}
				</fieldset>
				<fieldset style="align-self: stretch;">
					<legend>Phím tắt trong cửa số cấu hình</legend>
					${listHotKeys(ssData.hotKeys.settingModal, ", ")}
				</fieldset>
					<fieldset style="align-self: stretch;">
					<legend>Hints</legend>
					<div style='grid-column: span 2;text-align: justify;'>Với các biểu tượng và một số thành phần không biết ý nghĩa, người dùng có thể di chuột lên (với máy tính) hoặc bấm vào/nhấn giữ (với thiết bị cầm tay thông minh) để hiện tooltip (chữ trắng, nền đen mờ) hướng dẫn về chức năng và thông tin bổ sung (nếu có) của thành phần đó.</div>
				</fieldset>
				<fieldset style='align-self:end'>
					<legend>Who made this web-app</legend>
					<div name="coryright">🄲<span style="font-size:1.05em">②⓪②④</span>&puncsp;<div name="authorName"></div></div>
					<div style='grid-column: span 2;text-align: justify;'>This web-app has been made in my leisure time from May 2024 with the purpose of learning and applying state-of-the-art web technologies, so it might be a-bit of resource-consuming. It would perform well with latest browsers such as Chrome, Safari and Edge.</div>
				</fieldset>
				
				</div>`;
				/* <fieldset>
					<legend>Điều khiển phím tắt</legend>
					<input id="keyboard-hotkeys-disabled" type="checkbox" role="switch" class="!text-[25px]">
					<label for="keyboard-hotkeys-disabled">Khóa tất cả các Hot Keys</label>
				</fieldset> */
			}
			
			/**
				* SETTING MODAL FUNCTIONS
				*/

			//store one copy of xState.toastCfg when openning the setting then compare later when close setting to see if there is any change
			let _toastConfigSetting = {};
			//store one copy of xState.grpCfg when openning the setting then compare later when close setting to see if there is any change in current groupLine
			let _xGrpCfgSetting = [];
			//contains a copy of xDBFilesCfg.toLoad global variables to track-changes if user has change the setting (loadMode, order) in DB files
			let _xDBFilesCfg_filtered_toLoadSetting = {};
			
			/* Function to initialate setting event handlers, run only once when create setting instance */
			function initSettingModal() {
				//reset beenActive attribute to tell that in this openSetting sessions, this tab has not been clicked at all
				//document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]').forEach(_tab => _tab.dataset.beenActive = "");

				const modalPopupTabsGroup = document.querySelector(".modalPopup .tabs-group");

				/* _TAB_IDS contains information for each tab. If you re-order the tab, then change the idx attribute accordingly. The 'reloadRequired' attribute to tell the page if this tab need to reload each time Setting modal is openned and that tab got click. For now, only tabBookSetting need refresh to update that changes if user change grpWay (through #selBookGroup element) */
				const _TAB_IDS = [ 
					{idx: 0, name: "tabBookSetting", reloadRequired: true}, 
					{idx: 1, name: "tabListenHistory", reloadRequired: true}, 
					{idx: 2, name: "tabUISetting"}, 
					{idx: 3, name: "tabDBFilesSetting"}, 
					{idx: 4, name: "tabHotkeysSetting"} ];

				//assign id for each tabs
				const _allTabCheckboxs = [...document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]')];
				_allTabCheckboxs.forEach( (_tabChkbx,i) => {
					const _tab_id = _TAB_IDS.find(_item => _item.idx === i);
					_tabChkbx.setAttribute("tabName", _tab_id.name);
					
					if(_tab_id.reloadRequired) 
						//so that each time open Setting, data-beenActive will be reset
						_tabChkbx.setAttribute("reloadRequired", 1);
					_tabChkbx.dataset.tabIndex = _tab_id.idx;
				} );
				
				//this is for container property in reposTooltips() only. I've used modalPopupTabsGroup as container, but tooltip got cut-out 
				const modalPopupContentWrapper = document.querySelector(".modalPopupContentWrapper");

				//delegation click event to tab-group to capture click on tab checkboxes
				const _tabGroupsDelegatedClickHandlers = _evt => {
					const _inputTab = _evt.target;
					//check if this is tab checkbox, which control the visibility of tab-content
					//if(_inputTab.tagName === "INPUT" && _inputTab.type === "radio" && _inputTab.getAttribute("name") === "tabs-component"){
					if(_inputTab.matches(`input[type="radio"][name="tabs-component"]`)){

						/* function for each tab that run only one time when the tab got clicked very first time in whole Page session. For now, this is responsible for fix tooltip position (because before tab clicked, its content is hidden, so all of its children do not have dimension, yet) */
						if(!_inputTab.runOnlyOnce){
							let  _inputTabContent = _inputTab.nextElementSibling.nextElementSibling; // the div contain tab content
							if(_inputTab.checked) setTimeout(_ => guiUtils.reposTooltips( _inputTabContent, {container: modalPopupContentWrapper} ), 1000) //wait 1sec for UI to be rendered
							_inputTab.runOnlyOnce = true; //so next time it not run again
						}

						const _tabIdx = parseInt(_inputTab.dataset.tabIndex);
						const _tab_id = _TAB_IDS.find(_item => _item.idx === _tabIdx);

						//only load content again if beenActive flag is off or missing
						const _requiedReload = !Boolean(_inputTab.dataset.beenActive);
						
						switch(_tabIdx){
						case 0:
							// TAB 1: the book kits/sets setting
							if(_requiedReload) addBookSettingTab();
							break;
						case 1:
							// TAB 2: the listening history
							if(_requiedReload) addListeningHistory();
							break;	
							
						case 2:
							//TAB 3: deploy radio option buttons for toast-setting and handle option changes
							
							if(_requiedReload){
								addToastSettingControl();
								
								//handle setting for circle progress button
								//handle setting for audio buffered+played bar in audio player
								//handle setting for audio player panel to be sticky or not
								handleEnvironmentChkbox();
							}
							markToastRandomChoose();
							break;
						case 3:
							//TAB 4: add database files and books it contains
							if(_requiedReload) addJsDatabaseFileReport();
							break;
						case 4:
							//TAB 5: show Hotkeys
							if(_requiedReload) showHotKeys();
							break;									
						}
						//console.log("Tab visit: " + (_tabIdx+1) + " - requiedReload:" + _requiedReload);
						

						//mark that this tab is active
						_inputTab.dataset.beenActive = 1;
					}
				};
				modalPopupTabsGroup.addEventListener("click", _tabGroupsDelegatedClickHandlers);

				/* keydown event provide short-cut keys for some frequently used functions 
				NOTE: audio hotkeys function created in AudioPlayer class also handles the document's keydown event
				*/
				const pageKeyDown = (evt) => {
					/** function to active adjacent tab 
						* @param _goNext {boolean} true - go next; false: go previous
					*/
					const _goAdjTab = _goNext => {
						const _len = _allTabCheckboxs.length;
						// curent tab
						let _currTabIdx = _allTabCheckboxs.findIndex(_radio => _radio.checked);
						// adjacent tab
						_currTabIdx = ( _currTabIdx + _len + (_goNext ? 1 : -1) ) % _len;
						const _currTab = _allTabCheckboxs[_currTabIdx];
						_currTab.click(); //active the tab
						//show the notification
						const _tabLabelElem = _currTab.nextElementSibling.querySelector('code');

						toast.showToast(`Chuyển đến tab ${_tabLabelElem.innerHTML} [${_tabLabelElem.dataset.tooltip.split('\n')[0].replace(/[,\.]([^,\.]+)\:/,".")}]`);
					}					

					//full list of hotkeys with callback functions
					const hotkeyOptions = [

						// Z, ControlRight: open Books List dropdown
						{task: "settingModal_closeModal", kCode: ["Escape"], desc: "Đóng cửa sổ cấu hình.", callback: () => {
							ssData.setting.closeSettingModal();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},
						
						// PageUp, Shift+Tab: activate previous tab
						{task: "settingModal_prevTab", kCode: ["Shift+Tab", "PageUp"], noNotify: true, desc: "Về tab ngay trước.", callback: () => {
							_goAdjTab(false);
							evt.preventDefault();
							evt.stopImmediatePropagation();
							}
						},

						// PageDown, Tab: activate next tab
						{task: "settingModal_nextTab", kCode: ["Tab", "PageDown"], noNotify: true, desc: "Sang tab tiếp theo.", callback: () => {
							_goAdjTab(true);
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}
						}
					];

					// if this function run without {evt} parameter, it just save the hotkeys List into ssData.hotKeys.mainPage to notify to user
					if(!evt && !ssData?.hotKeys?.settingModal){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.settingModal){
							ssData.hotKeys.settingModal = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return;
					}

					/* //find if the key just press in the list of supported shortcuts
					const hotkeyOpts = hotkeyOptions.filter(keyItem => keyItem.kCode.indexOf(evt.code)>-1);
					//if found, do the corresponding job
					hotkeyOpts.forEach(hotkeyOpt => hotkeyOpt.callback()); */

					//search if a key just press matched any key specify above, then take the corresponding action (stopPropagation and preventDefault)
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions, 3);
					
				};
				pageKeyDown(); //to get the list of hotKey and saved in ssData.hotKeys.mainPage
				modalPopupContentWrapper.focus();
				modalPopupContentWrapper.addEventListener("keydown", pageKeyDown); 

				//re-position tooltip for svg icons in tab headers of Setting modal.				
				setTimeout(() => {
					_allTabCheckboxs.forEach(_tabChckbox => 
					guiUtils.reposTooltips( _tabChckbox.nextElementSibling, {container: modalPopupContentWrapper} ))
				}, 1000);				
			}			
			
			/** function to filter to keep only dbName and loadMode properties of toLoad array, so the page will not false-alarm that there is a change in DB setting (even change might be on dbUrl or edition), filter this way, we will know exactly when user change the loadMode of a DB
				* @param _DBFileCfg kind of _DBFileCfg
				* @return let say an item of @param _DBFileCfg.toLoad is '{"fileNo":3,"dbName":"data_3","dbUrl":"data_3.js?v=178","loadMode":0,"failCount":0,"edt":117}', the returned json of that item now is only {"dbName":"data_3", "loadMode":0}
			*/
			const _filterDBFileCfg = _DBFileCfg => xDBFilesCfg.toLoad.map(_itm => { return {dbName: _itm.dbName, loadMode: _itm.loadMode} });

			/* When setting modal shows up */
			function openSettingModal() {
				//make a deep copy of xState.toastCfg to track changes
				_toastConfigSetting = structuredClone(xState.toastCfg);
				
				//make a deep copy of xState.grpCfg to track changes
				_xGrpCfgSetting = structuredClone(xState.grpCfg);

				//make a deep copy of xDBFilesCfg to track changes
				_xDBFilesCfg_filtered_toLoadSetting = structuredClone( _filterDBFileCfg(xDBFilesCfg) );

				document.getElementById("modalSettingPopup").classList.add("activeModalPopup"); //show the modal

				//run initSettingModal() if this is the very first time settingModal got opened
				if(!this.inited) {
					initSettingModal();
					this.inited = true; // so that initSettingModal won't run again next time open Setting
				}

				//now, open a last tab and reload HTML if required
				const _allTabCheckboxes = document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]');
				let _lastActiveChkbox;
				_allTabCheckboxes.forEach(_tabChkbx => {
					//so that this tab will be refresh in this open Setting session
					if(_tabChkbx.hasAttribute("reloadRequired")) delete _tabChkbx.dataset.beenActive;
					if(_tabChkbx.checked) _lastActiveChkbox = _tabChkbx;
				});
				//force to last active tab to be active. If not exist, force the first one
				(_lastActiveChkbox || _allTabCheckboxes[0]).click();				
			}

			/* Clean-up, make change when modal closed */
			function closeSettingModal() {
				
				(function () {
					//clear the group listbox and books ol, and the same time clear all event handler (such as onchange or drag&drop) for each element and its children
					document.getElementById("selPopupBookGroup").innerHTML = "";
					document.getElementById("lstBookTitlesSetting").innerHTML = "";
					document.querySelector('.modalPopupContent [name="bookKitChkboxContainer"]').innerHTML = "";

					//clear the listening history (but keep the event)
					document.querySelector("#ListeningHistoryWrapper").innerHTML = "";
				})();
				_dragObj = null;

				//Save xState, xDBFilesCfg into localStorage. Only after done saving, we do some other work. The reason is when there are changes in DB files settings, and require user to restart the page to update the setting, we need to wait for the saveState2Disk() to save new xDBFilesCfg before restarting
				saveState2Disk(false).then(_ => {
				
					//re-populate the ssData.sddBooks if current group line configuration has any changes
					if( !objsEqual(_xGrpCfgSetting[xState.grpLine].grp, xState.grpCfg[xState.grpLine].grp) ){
						//turn on this flag so the Toast message called inside next function will not display
						//toast.depressToast(true);
						toast.showToast(`Có thay đổi trong thiết đặt cấu hình sách, nhóm số ${xState.grpLine}: '${xBookGrp[xState.grpLine].grpWay}'`);
						//make all the book setting take effect on main page, in case there is some changes in user-setting related to order or hidden-state of books
						document.getElementById("selBookGroup").onchange();
					}

					//update new toast mode only if there is any change. 
					if(!objsEqual(_toastConfigSetting, xState.toastCfg) ){
						toast.setToastMode();
						toast.showToast("Có thay đổi trong thiết đặt cấu hình thông báo Toast!");
					}

					//check if there is any changes in DB files settings
					//TODO: note that when addJsDatabaseFileReport() trying to load a DBfile that has loadMode = 0 (no show) and its failed, then xDBFilesCfg.toLoad[idx].failCount would increase by 1 (see the .catch in addJsDatabaseFileReport()), so the below objsEqual() will return @true even if there is no user-change in the DBfiles setting, thus it will false-alarm the user that there is a change.
					if( !objsEqual(_xDBFilesCfg_filtered_toLoadSetting, _filterDBFileCfg(xDBFilesCfg)) ){
						if (confirm("Có thay đổi trong Database Files Setting.\nBạn có muốn nạp lại trang Web?")) 
							//Force a hard reload to clear the cache if supported by the browser
							window.location.reload(true);
					}

					//close the modal
					document.getElementById("modalSettingPopup").classList.remove("activeModalPopup");
				});
			}

			/* PUBLIC METHOD */
			return {
				openSettingModal: openSettingModal,
				closeSettingModal: closeSettingModal,
				handyCheckDBsEdition: _handyCheckDBsEdition
			};
		}

	</script>

	<!-- MAIN PLAYER CONTROLS -->
	<script>
		"use strict";
		/* CLASS deal with audio player
			settingParam: json object to specify some initial value. For example, it can be {speed: 1.4, volume: 1} to specify the initial speed for audio playback is 1.4, audio volume to 1 (100%)
		
			modified from https://github.com/likev/html5-audio-player
		*/
		let AudioPlayer = function (settingParam) {
			let isSeeking = false, isPlaying, rightClick = false;
			//let volumeLength; //vars for seeking by mouse and by touching
			const apContainerEl = document.querySelector(".ap-container");
			const elVolumeBtn = apContainerEl.querySelector('.ap-volume-btn');
			const elRemTime = apContainerEl.querySelector('.ap-time--remains');
			const elTrackTitle = apContainerEl.querySelector('.ap-title');
			const elProgressBar = apContainerEl.querySelector('.ap-progress-bar');
			const elPreloadBar = apContainerEl.querySelector('.ap-progress-preload-bar');
			const elVolumeBar = apContainerEl.querySelector('.ap-volume-bar');
			const elPlayBtn = apContainerEl.querySelector('.ap-play-pause-btn');
			const elPrevBtn = apContainerEl.querySelector('.ap-prev-btn');
			const elNextBtn = apContainerEl.querySelector('.ap-next-btn');
			const elReloadBtn = document.querySelector('.ap-reload-btn');
			const elPlayingTimeLabel = document.getElementById("elmPlayingTime"); //playing time big display
			
			let _xDuration = 0; //hold the duration of the current playing audio

			xAudio.autoplay = true; //this actually not doing anything
			
			/* Check if internet connection is alive or dead
			If dead, swich some element showing that internet is dead
			*/
			function checkInternetAlive() {
				if (navigator.onLine) return true;

				//no internet
				//switchBigPlayingTime(-1); //showing no internet error
				//show the no-internet icon
				document.querySelector(".noInternetSignal").classList.remove("elm-hidden");

				// search "Audio readyState mdn" for meaning of readyState and its value
				if (xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA) {
					xAudio.pause(); //pause audio
					switchPlayPauseButton(1, 0); // Play icon but 3 buttons got disabled
				}
				return false;
			}

			/* ==========  WINDOW + DOCUMENT EVENT BINDING ========== */
			{
				window.addEventListener("offline", (e) => {
					toast.showToast("Mất kết nối Internet", toast.ToastType.Error, {persistance: true});
					//show the no-internet icon
					document.querySelector(".noInternetSignal").classList.remove("elm-hidden");
				});

				// this event only fires when connection is lost and got back again
				window.addEventListener("online", (e) => {
					toast.showToast("Kết nối Internet", toast.ToastType.Success, {persistance: true});

					//hide the no-internet icon
					document.querySelector(".noInternetSignal").classList.add("elm-hidden");

					// remove "no internet" text from big font playing time;
					retextPlayingTime({time: toHhMmSs(xAudio.currentTime), dur: toHhMmSs(xAudio.duration)});
					//elmPlayingTime.textContent = toHhMmSs(xAudio.currentTime) + " / " + toHhMmSs(xAudio.duration); 

					let _elmArtwork = document.getElementById("elmArtwork");
					//if _elmArtwork is currently hidden
					if(!_elmArtwork.offsetParent){
						//show cover img and hide No-Internet sprite svg image
						guiUtils.showNoInternet();
						//reload cover image. For youtube image, if using "?v=" + performance.now().toFixed() the image will not load, because youtube take param 'v=' for other meaning
						_elmArtwork.src = _elmArtwork.src + "?" + performance.now().toFixed();

						//update new artwork to notification center
						guiUtils.updateNCWorkart();
					}					

					//the param should be true for most of the cases, but I use 'xAudio.paused' instead of 'true' for the case lost internet, audio having buffer still playing, now got internet back, we let audio continue playing
					if (xAudio.paused) {
						switchPlayPauseButton(1, 1); //enable buttons and show Play icon

						//compare the width of progressBar and its container (parent), if it is equal (or not-possible longer), meaning the audio is paused at the very end of its full duration, we just make it  jump to next chapter
						if(elProgressBar.parentElement.offsetWidth <= elProgressBar.offsetWidth){ //can use xAudio.ended instead
							playNextPrev(1); //play next chapter
						}
						//we only reload audio src when there is no audio buffer left, using naive-stupid method to check that condition is to compare the width of progressBar (audio duration played so far) with that of preloadBar (the audio duration has been buffered by browser)
						if(elPreloadBar.offsetWidth <= elProgressBar.offsetWidth)
						reloadSrc(true); //reload src, force Pause
					}
					else
						switchPlayPauseButton(0, 1); //enable buttons and show Pause icon
				});

				//resize some elements and change some variable with window resize
				window.addEventListener("resize", _ => {
					//resize the audio played, buffered canvas 
					trCanvas.onresize();
					//reposition and re-calculate the immediate variables to show audio time tooltip at current mouse position
					audioTimeTooltip.onresize();

					// variable used to update progress bar width at UpdateTime()
					_PROGRESS_BAR_WIDTH = elProgressBar.parentElement.offsetWidth;
				});
			
				/* keydown event provide short-cut keys for some frequently used functions */
				const audioKeyDown = (evt) => {
					//evt && console.log(evt.code);

					//customize change rate based on modifier key pressed for volume, seeking and speed
					const _VOLUME_CHANGE = evt?.altKey? 0.1 : 0.05;
					const _TIME_CHANGE = evt?.ctrlKey ? 40: ( evt?.shiftKey ? 30: (evt?.altKey? 20 : 10) );
					const _SPEED_CHANGE = evt?.shiftKey ? .2: (evt?.altKey? .1 : .05) ;
					
					//const _NO_MODIFIER_KEY = !(evt?.ctrlKey || evt?.metaKey || evt?.shiftKey|| evt?.altKey);

					/* See the comments on function SddDropdown.prototype.runHotkey to see the format and meaning of each shortcut */
					//full list of hotkeys with callback functions
					const hotkeyOptions = [
						// ArrowLeft: rewind current audio
						{task: "audio_rewind", kCode: ["ArrowLeft"], desc: "Tua lùi về sau (rewind) 10 giây.", ignoreModifier: true, noNotify: true, callback: () => xAudio.currentTime -= _TIME_CHANGE},
						// ArrowRight: fastforward current audio
						{task: "audio_fastforward", kCode: ["ArrowRight"], desc: "Tua tiến về trước (fastforward) 10 giây.", ignoreModifier: true, noNotify: true, callback: () => xAudio.currentTime += _TIME_CHANGE},

						// ArrowUp: increase audio volume by 5%
						{task: "audio_volumeUp", kCode: ["ArrowUp"], desc: "Tăng âm lượng audio 5%.", ignoreModifier: true, noNotify: true, callback: () => changeAudioVolume(xAudio.volume + _VOLUME_CHANGE)},
						// ArrowDown: increase audio volume by 5%
						{task: "audio_volumeDown", kCode: ["ArrowDown"], desc: "Giảm âm lượng audio 5%.", ignoreModifier: true, noNotify: true, callback: () => changeAudioVolume(xAudio.volume - _VOLUME_CHANGE)},
						// keyM: increase audio volume by 5%
						{task: "audio_toggleVolume", kCode: ["Delete", "KeyM"], desc: "Bật/Tắt âm lượng.", callback: volumeToggle.bind(elVolumeBtn)},

						// Speed UP
						{task: "audio_speedUp", kCode: ["Equal", "NumpadAdd"], ignoreModifier: true, desc: "Tăng tốc độ phát 0.05 từ " + xState.audio.speed, noNotify: true, callback: () => bSpeed.incStep()},
						// Speed DOWN
						{task: "audio_speedDown", kCode: ["Minus", "NumpadSubtract"], ignoreModifier: true, desc: "Giảm tốc độ phát 0.05 từ " + xState.audio.speed, noNotify: true, callback: () => bSpeed.decStep()},
						// Speed Normal
						{task: "audio_normalSpeed", kCode: ["Digit0", "Numpad0"], desc: "Đưa tốc độ phát về 1.0.", callback: _ => {bSpeed.setSliderSpeed(1); xAudio.playbackRate=1}},

						// PageDown: next audio track
						{task: "audio_nextTrack", kCode: ["PageDown"], desc: "Phát chương sách tiếp theo.", callback: () => {elNextBtn.click()} }, //shift+PgDown for next book in history
						// PageUp: previous audio track
						{task: "audio_prevTrack", kCode: ["PageUp"], desc: "Phát từ đầu chương (<30s) hoặc chương sách trước.", callback: () => {elPrevBtn.click()} },  //shift+PgUp for previous book in history

						// ["Space", "Enter"]: previous audio track
						{task: "audio_playPauseAudio", kCode: ["Space", "Enter"], desc: "Phát / Dừng phát chương sách.", callback: () => elPlayBtn.click()}
					];

					// if function is invoked without {evt} parameter,  it just save the hotkeys List into ssData.hotKeys.audioPlayer to notify to user
					if(!evt && !ssData?.hotKeys?.audioPlayer){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.audioPlayer){
							ssData.hotKeys.audioPlayer = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return; //the case that we run audioKeyDown() below just get the hotKey list
					}

					//search if a key just press matched any key specify above, then take the corresponding action. Set parameter keyPreventation = 3 to avoid page scroll when using hotKey
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions);
					//evt.preventDefault(); //to avoid page scroll when using hotKey
				}; 
				audioKeyDown();
				//assign handler to page keydown event 
				document.addEventListener("keydown", audioKeyDown);
			}
			
			/* ==========  AUDIO HTML ELEMENT EVENT BINDING ========== */
			/* see spec for summary list of events https://html.spec.whatwg.org/multipage/media.html#mediaevents */
			{//set event handler for audio element
				/* When audio lack of data, and need to load, the event order would be: Waiting [> Progress] > Stalled [> Progress] > CanPlay > Playing > Progress 
				However, on stupid Apple Safary, after firing Stalled event, browser does not fire any other event except timeUpdate and sometime progress
				*/
				xAudio.onloadstart = (event) => { //start loading media, so we need to wait until oncanplay
					console.log("Load Start");

					//reset the audio duration variable, so that updateTime, movingAudioTimeTooltip and some other functions does not use the duration of old audio
					_xDuration = NaN;

					elRemTime.innerHTML = "-:-- / -:--";
					retextPlayingTime({time:"0:00", dur: "0:00"});
					//reset progress bar
					elProgressBar.style.width = '0%';
					elPreloadBar.style.width = '0%';

					if (!checkInternetAlive()) return;

					switchBigPlayingTime(0); //change playing time from spinning HourGlass to current numbered time
					switchPlayPauseButton(-1, 0); //show loading icon

					//reset circle progress bar to 0% (beginning)
					updateCircleProgressBar(0);

					trCanvas.hideCanvas(); //clean the buffer bar
				};

				// The canplay event is fired when the user agent can temporarily play the media, canplaythrough fired when it can play the media up to its end without stopping for content buffering.
				xAudio.oncanplay = (event) => { //the audio can now play
					// console.log("Can Play");

					//normally, this is not necessary because oncanplay is usually fired after ondurationchange (where already did update the playing time)
					//retextPlayingTime({time: toHhMmSs(xAudio.currentTime), slash: "/", dur: toHhMmSs(xAudio.duration)});

					updateTime();
					switchBigPlayingTime(1);

					//because of html audio element's autoplay attribute, we have to check the playing state to show corresponding buttons
					switchPlayPauseButton(xAudio.paused ? 1 : 0, 1);					
				};

				/* 
				//The waiting event is fired when playback has stopped because of a temporary lack of data. this is fired before on-stalled
				xAudio.onwaiting = () => {console.log("Waiting")};
				//The progress event is fired periodically as the browser loads a resource.
				xAudio.onprogress = () => {console.log("Progress")};
					*/

				//when the user agent is trying to fetch media data, but data is unexpectedly not forthcoming.
				xAudio.onstalled = (event) => { //this is similar to onwaiting ?
					console.log("Stalled !!!");
					checkInternetAlive();
					toast.showToast("Trying to fetch data.");
					//switchPlayPauseButton(); //show loading icon. TODO: If run this, we have to deactive it on some other event, see above for this problem
				};

				// when a seek operation completed, the current playback position has changed
				xAudio.onseeked = (event) => {
					//console.log("Seeked");
					// note that if user click mouse (without moving) to seek, this event fired before Mouse-up event, so isSeeking still true, thus the following Toast will not show
					if (!isSeeking) toast.showToast("Audio is seeked to " + toHhMmSs(xAudio.currentTime));
					updateTime(true); //after being seeked, the audio data need to buffer, sometime this take times until the audio can continue playing. So we need to update UI of the page
					//updateBufferCanvas(); //this is already called in updateTime with parameter forceHeavyUIUpdate = true
				};

				xAudio.onpause = (event) => {
					//console.log("on-Paused");
					toast.showToast("Audio paused !!!", toast.ToastType.Warning);
					//When having problem (such as lost internet), onpaused is fired after onstalled, so draw button according to condition if have future data or not
					switchPlayPauseButton(1, xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA ? 0 : 1); //show play icon

					//updateTime(true);
				};
				xAudio.onplay = (event) => { //onplaying fired twice each time audio play
					//it seems that on lastest version of some browser, the audio speed always reset to 1.0 when play a new audio source, so we just set audio speed every time playing new audio
					bSpeed.change();

					//console.log("Playing");
					toast.showToast("Đang phát chương sách... ✕" + xAudio.playbackRate);

					switchPlayPauseButton(0, 1); //show pause icon
				};

				/* Some important events */
				xAudio.onended = (event) => { //note that playback has stop before fire this event
					//console.log("on-ended");
					if (checkInternetAlive()) playNextPrev(1);
				}; //when reach to end, play the next chapter: 
				
				//The user agent stops fetching the media data before it is completely downloaded, but not due to an error. However, this event fire every time change audio source
				/* xAudio.onabort = (event) => { 
					//console.log("audio onabort");
					toast.showToast('Hủy lệnh phát Audio khi dữ liệu media đang được tải về.', toast.ToastType.Error);
				}; */

				//somehow, sometimes the speed change back to normal withour user's request, so we need to change it back.  
				xAudio.onratechange = (event) => { 
					//console.log("audio onRateChange");
					bSpeed.change(); 					
				}; 

				xAudio.ondurationchange = (event) => { 
					// console.log("Duration changes");
					_xDuration = xAudio.duration; //update duration to variable

					// we do the full re-text the playing time since it might has been "No internet"
					retextPlayingTime({time: toHhMmSs(xAudio.currentTime), dur: toHhMmSs(_xDuration)});

					//console.log(toHhMmSs(xAudio.duration));

					/* // to get real duration to update to ssData.xData
					if(!window["durs"]) window["durs"]={};
					durs[xAudio.getAttribute("attr-chap")] = toHhMmSs(_xDuration);  */
				};
				xAudio.addEventListener('timeupdate', _ => updateTime(), false);
				xAudio.addEventListener('error', audioError, false);
				function audioError(evt) {
					console.log("audio error event");
					toast.showToast('Phát Audio bị lỗi', toast.ToastType.Error);
					checkInternetAlive(); //update buttons UI

					switchPlayPauseButton(1, 0); // Play icon but 3 buttons got disabled
				}
			}

			/** Function contains sub-function that relate to audio source control including: load audio source, play it and handle its fail. Also, provide function to switch audio source among multple audio source provided by the page */
			function sourceControl(){
				/** load new source for audio
					@param _src {string}		: mp3 link for playing audio
					@param _justReload {boolean} :
						@value TRUE: If failed, just trying audio.load() to reload audio sr, skip step 3 of tryingLoadAudio()
						@value FALSE: if failed again after audio.load(), try others url src
					*/
				function loadSrc(_src, _justReload) {

					//reset the value that is used to lighten the heavy-burden of updateTime() function, that is, just update UI after some specific interval of time, not in every audio 'timeupdate' event firing
					_lastAudioPosition = 0;

					//reset the updateBufferCanvas counter
					_ubcCounter = 0; 

					xAudio.src = _src;
					tryingLoadAudio(_justReload);
				}

				/** Function using promise chain to try playing audio 
					1. Try audio.play() with current source
					2. If failed, using audio.load() to reload (same) source. Sometime media from archieve.org need to load 2-3 times for it to play
					3. Still failed: playing other sources (if there are any else)
					4. Still failed: notify user, change buttons UI.
				
					@param _justReload {boolean}
						@value True: just try reload current source without trying other url src line (skip step 3 above)
						@value False: include step 3
				*/
				function tryingLoadAudio(_justReload) {
					if (!checkInternetAlive()) return; //check internet connection, if lost: change button UI and return

					
					let chainToast = new toast.ChainToasts("Nạp dữ liệu media chương sách");

					/* let playPromise = xAudio.play();
					if (playPromise !== undefined) {
						playPromise.then(_ => { */
						xAudio.play().then(_ => {
							//console.log("Lan 1");
							chainToast.checkoutToast("Bắt đầu phát");
						})
						.catch(_err => {
							// You can put a breakpoint here to see the detail of _err, all its properties and built-in error constant code
							console.log(`[tryingLoadAudio]: [${_err.code}]${_err.name}: ${_err.message}`);

							if ([0, _err.ABORT_ERR, _err.NETWORK_ERR, _err.NOT_FOUND_ERR, _err.NOT_SUPPORTED_ERR, _err.NO_DATA_ALLOWED_ERR, _err.TIMEOUT_ERR].indexOf(_err.code) > -1) {
								//pass toast notification to next .then()
								return _err;
							}
							/* else
								toast.showToast(`[tryingLoadAudio]: [${_err.code}]${_err.name}: ${_err.message}`, toast.ToastType.Warning); //other error, just show error details
								*/

							//console.log("[tryingLoadAudio]: trying audio.load()");
							chainToast.showNextToast(`[tryingLoadAudio]: trying reload audio`, toast.ToastType.Warning);
							xAudio.load(); //trying to reload source ONE time
							return xAudio.play(); //throw new promise for next catch() to catch if there is any more error
						})
						.then(_res2 => {
							//console.log("Lan 2");
							//Check to see if this .then got from xAudio.play() promise. Note that other return because of error last .catch() give back _err.code
							if (_res2 instanceof Promise)
								chainToast.checkoutToast("Chương truyện có thể phát.", toast.ToastType.Infor);
							else if (_res2 instanceof Error) { //if is error got from return _err;
								let _errMsg = "Không rõ lỗi", _toastType = toast.ToastType.Error;
								let _throwErr = false;
								switch (_res2.code) {
									case 0:
										//[0]NotAllowedError: play() failed because the user didn't interact with the document first. See https://goo.gl/xX8pDD
										_errMsg = `Phải bấm nút Play để nghe truyện`;
										_toastType = toast.ToastType.Warning;
										break;
									case _res2.NETWORK_ERR:
										_errMsg = `Mất kết nối Internet`;
										break;
									// [20]AbortError: The play() request was interrupted by a new load request. See https://goo.gl/LdLk22
									case _res2.ABORT_ERR:
										_errMsg = `Lệnh phát chương truyện bị hủy`;
										break;
									case _res2.NOT_FOUND_ERR:
										_errMsg = 'Nguồn phát media không tồn tại';
										_throwErr = true;
										break;
									case _res2.TIMEOUT_ERR:
										_errMsg = 'Quá thời gian tải cho phép';
										_throwErr = true;
										break;
									//NotSupportedError: Failed to load because no supported source was found.
									case _res2.NOT_SUPPORTED_ERR:
									//source type not allow
									case _res2.NO_DATA_ALLOWED_ERR:
										_errMsg = 'Không hỗ trợ phát nguồn media';
										_throwErr = true;
										break;
									//other error, just show error details	
									default:
										_errMsg = `[tryingLoadAudio]: [${_res2.code}]${_res2.name}: ${_res2.message}`;
										_toastType = toast.ToastType.Warning;
								}
								
								//throw error so the next .catch would try on another url line (if any)
								if(_throwErr) {
									class CustomAudioPlayError extends Error {
										constructor(_code, _msg, ...params) {
											super(...params); // Pass remaining arguments (including vendor specific ones) to parent constructor
											this.code = _code;
											this.message = _msg;
											this.name = "CustomAudioPlayError";
										}
									};
									toast.showToast(_errMsg, _toastType); //chainToast.showNextToast
									throw new CustomAudioPlayError(_res2.code, _errMsg, {cause: _res2.message});
								}
								else chainToast.checkoutToast(_errMsg, _toastType);
							}
							else // other unknown reason
								chainToast.checkoutToast("Có thể phát truyện dù không rõ lí do.", toast.ToastType.Warning);
						})
						//this catch would catch error from xAudio.play() in previous .catch or throw error in previous .then
						.catch(_err => {
							toast.showToast(`[tryingLoadAudio]: audio reload() thất bại.[${_err.name}]`, toast.ToastType.Error); //chainToast.showNextToast
							console.log(`[tryingLoadAudio]: audio.load() Failed.\n[${_err.code}] ${_err.name}: ${_err.message}`);

							let _switchSrcBtn = document.querySelector(".switchChapterAudioSrc");
							// Change audio source if there are more than one
							if (!_justReload && _switchSrcBtn) {
								console.log("[tryingLoadAudio]: Try loading other source");
								chainToast.checkoutToast(`[tryingLoadAudio]: Nạp nguồn link khác theo của chương truyện.`, toast.ToastType.Warning);
								changeAudioSrc(true); //trying load audio src WITHOUT fail-safe to play other url line if current url line failed
							}
							else {
								chainToast.checkoutToast("Không phát được chương truyện. Chọn chương hoặc truyện khác", toast.ToastType.Error);
								switchPlayPauseButton(1, 0); //paint UI (Play icon, disabled) for some buttons telling that audio cannot play

								elRemTime.textContent = "-:-- / -:--";
								retextPlayingTime({time:"-:--", dur: "-:--"});
								//reset progress bar
								elProgressBar.style.width = '0%';
								elPreloadBar.style.width = '0%';

								//change playing time from spinning HourGlass to current numbered time
								switchBigPlayingTime(1);

								//reset circle progress bar to 0% (beginning)
								updateCircleProgressBar(0);

								trCanvas.hideCanvas(); //clean the buffer bar
							}
						});
					//}
				}
				
				/** Change audio source for chapter that has multiple audio links. Note that this function need to interactive with database, DOM elements which create and handled outside AudioPlayer object. It is not optimal to keep this function here, but it is for the sake of convenience
				 * @param _justReload {boolean} : 
				 * 		@value TRUE: If failed, just trying audio.load() to reload audio src, skip step 3 of tryingLoadAudio() 
				 * 		@value FALSE: if failed again after audio.load(), try other url src if there are multiple url src for this chapter
				*/
				const changeAudioSrc = (_justReload) => {
					let _currBook = xAudio.getAttribute("attr-Book");
					let _currChap = parseInt(xAudio.getAttribute("attr-chap"));
					//chapDataUrl is an array (if it is not, it has been converted to array in changeChap() function) 
					// the ChangeSrc button only show up when chapDataUrl has at least two items
					let chapDataUrl = ssData.bookData.findBookFromId(_currBook).parts[_currChap - 1].url;

					let elmMp3Links = document.getElementById("elmMp3Links");

					//find current playing items
					let cSrcIdx = -1, _audioSrc = "";
					let _allMediaAnchors = elmMp3Links.querySelectorAll("li[role='audioSrc']> a");
					//find current playing source
					_allMediaAnchors.forEach((_anchor, _i) => {
						if (_anchor.classList.contains("srcPlaying")) cSrcIdx = _i
					});

					//cSrcIdx==-1: this is the case when this function is being called from changeChap(), so there has no .srcPlaying anchor yet
					if (cSrcIdx == -1) {
						cSrcIdx = parseInt(xState.history.books[_currBook]["urlLine"]); //the index of item in chapData.url that should be played
						if (isNaN(cSrcIdx)) { cSrcIdx = xState.history.books[_currBook]["urlLine"] = 0 }
						if (chapDataUrl.length <= cSrcIdx) cSrcIdx = 0;
					}
					//cSrcIdx > -1: this is the case when this function is being invoked from ChangeSrc button, when there is already one .srcPlaying anchor which set by invocation from changeChap()
					else {
						//switch to next url line
						cSrcIdx = (cSrcIdx + 1) % chapDataUrl.length;
						//update new urlLine for next chapter in this book to select mp3 source to play
						xState.history.books[_currBook]["urlLine"] = cSrcIdx;
					}

					//trying load audio src WITHOUT/WITH fail-safe to play other url line if current url line failed
					loadSrc(chapDataUrl[cSrcIdx], _justReload ?? false);
					//note that there is a LOOP invocation: audioPlayer.loadSrc() -> audioPlayer.tryingLoadAudio() -> call changeAudioSrc(true) when failed loading with current audio source, and trying load next audio source. However, becaause call with param True, audioPlayer.tryingLoadAudio() will not invoke changeAudioSrc() again, so there is no dead Loop

					//each time a mp3 url is played (by change chapter or by Change Src button), we need to change the appearance of mp3 link accordingly
					(function changePlayingMp3Style(cSrcIdx) {

						//format mp3 links that is played by audio element
						let elmMp3Links = document.getElementById("elmMp3Links");
						elmMp3Links.querySelectorAll("a.srcPlaying").forEach(_ => { _.classList.remove("srcPlaying") });
						let _newMp3Anchor = elmMp3Links.querySelector("li[role='audioSrc']:nth-of-type(" + (cSrcIdx + 1) + ") > a");
						if (_newMp3Anchor) {
							let _mp3Link = _newMp3Anchor.getAttribute("href");
							let _linkHash = _mp3Link.hashCode();
							_newMp3Anchor.setAttribute("hash-code", _linkHash);
							_newMp3Anchor.classList.add("srcPlaying");
							//get file-size if possible
							if (!_newMp3Anchor.classList.contains("gotFileSize"))
								getFileSize(_mp3Link, _msg => {
									// check if the current a.srcPlaying's link has the same hashCode with that of the one to request for file-size
									if (!_msg.success || document.querySelector("#elmMp3Links a.srcPlaying")?.getAttribute("hash-code") != _linkHash) return;
									_newMp3Anchor.innerHTML += ` ${_msg.msg}`;
									//mark that file size has achived, don't load again next time
									_newMp3Anchor.classList.add("gotFileSize");

									//note that when adding filesize to a.srcPlaying, it might push other elements (which each is <li> element containing a <code> element having tooltip) left, right or down, so we need to re-calculte the tooltip position for those which been moved
									guiUtils.reposTooltips(document.getElementById("elmChapterInfor"));
								});
						};
					})(cSrcIdx);
				}

				/** fetch the media url to get its size (in B) and return it to callback function
					@param path {string}: url to media
					@param callback: callback function to pass result to. There are two cases:
						@case if successed: the result pass to would be like: {success: 1, msg: the-message-content}
						@case if failed: the result pass to would be like: {success: 0, msg: ""}
				*/
				function getFileSize(_urlPath, _callback) {
					_callback = _callback ?? (_msg => { console.log(_msg.msg) });
					//currently, only these two sites accept Cors
					if (!_urlPath.match(/archive\.org|www\.google|medialib\.qlgd/)) return _callback({ success: 0, msg: "" }); //archive\.org|

					/** format number of bytes into highest unit possible 
						* @return {str: string of formatted size with unit, idx: the index of unit in UNITS array}: idx is added for purpose of formating
						* @refer at: https://www.30secondsofcode.org/js/s/pretty-print-number-of-bytes/
					*/
					const prettyBytes = (num, precision = 2, addSpace = false) => {
						const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
						if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0];

						const exponent = Math.min(
							Math.floor(Math.log2(num < 0 ? -num : num) / 10),
							UNITS.length - 1
						);

						const n = Number(
							((num < 0 ? -num : num) / 1024 ** exponent).toFixed(precision)
						); //Math.pow(2,10) = 1024

						return {str: (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent], unit: UNITS[exponent], indx: exponent};
					};

					//create ChainToasts object
					const chainToast = new toast.ChainToasts("Đang lấy dữ liệu dung lượng file");
					//get only small HEAD
					fetch(_urlPath, { method: 'HEAD', cache: "force-cache" })
						.then(function (response) {
							/* let _contentType = response.headers.get("content-type");
							let _lastModified = response.headers.get("Last-Modified");
							console.log(`Content type: ${_contentType}. Last modified: ${_lastModified}`); */

							let _contentSize = response.headers.get("content-length");
							if (!_contentSize) {
								chainToast.checkoutToast(`Không lấy được dữ liệu dung lượng file.`, toast.ToastType.Error);
								return _callback({ success: 0, msg: "" });
							}

							_contentSize = parseInt(_contentSize, 10);

							//two array for unit and corresponding color
							//const _UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
							const _UNITS_COLOR = ['Black', 'Blue', 'Green', 'Red', 'DarkBlue', 'DarkGreen', 'DarkRed', 'DarkRed', 'DarkRed'];
							//pretty print the file size
							const {str: _fileSize, unit: _unit, indx: _idx} = prettyBytes(_contentSize);

							const _sizeStr = `<code style='color:${_UNITS_COLOR[_idx]}'>${_fileSize}</code>`;
							chainToast.checkoutToast(`Dung lượng file media vừa được cập nhật ${_fileSize}`, toast.ToastType.Success);
							_callback({ success: 1, msg: _sizeStr, size: _fileSize, unit: _unit, inbyte: _contentSize });

						}).catch(
							error => {
								chainToast.checkoutToast(`[${error.message}] Không lấy được dữ liệu dung lượng file.`, toast.ToastType.Error);
								_callback({ success: 0, msg: "" });
								console.warn('[fetchHead] Error on fetching header:', error.message); //error
							});
				}

				/* ------- PUBLIC METHOD ------- */
				return {
					setSource: changeAudioSrc,
					getFileSize: getFileSize
				}
			}
			//create source Control object
			const srcControl = sourceControl();

			/* ==========  AUDIO CONTROL BUTTONS HANDLER =========== */
			document.querySelectorAll("button:has(svg > use[svg-icon-name='PlayPauseIcon'])").forEach(_btn => _btn.addEventListener('click', playStop, false)); //handler for the two Play/Pause buttons

			elPrevBtn.addEventListener('click', () => playNextPrev(0), false);
			elNextBtn.addEventListener('click', () => playNextPrev(1), false);
			//Handler for buttons on notification center
			if ('mediaSession' in navigator) {
				let _mediaSession = navigator.mediaSession;
				_mediaSession.setActionHandler("previoustrack", () => {playNextPrev(0); saveState2Disk()});
				_mediaSession.setActionHandler("nexttrack", () => {playNextPrev(1); saveState2Disk()});
				_mediaSession.setActionHandler("play", () => playStop());
				_mediaSession.setActionHandler("pause", () => {playStop(); saveState2Disk()});

				_mediaSession.setActionHandler("seekbackward", () => { xAudio.currentTime -= 15 });
				_mediaSession.setActionHandler("seekforward", () => { xAudio.currentTime += 15 });
			}

			function playStop() {
				//readyState = 4: video is playing
				if (xAudio.paused) {
					xAudio.play();
				}
				else {
					xAudio.pause();
				}
			}

			//isNext = 1: playing next, 0 or missing: playing previous
			function playNextPrev(isNext) {
				let _currChap = parseInt(ssData.sddChaps.value);
				if (isNaN(_currChap)) _currChap = 1;				

				if (isNext) {
					if (_currChap < ssData.sddChaps.length) {
						changeChap(_currChap + 1); //if not the very last chapter, play the next one

					} else toast.showToast("Đã là chương cuối rồi!", toast.ToastType.Warning);
				}
				else {
					// if audio current time before 30 sec, will play previous chapter
					if (_currChap > 1 && xAudio.currentTime < 30) {
						changeChap(_currChap - 1);
					}
					// if audio current time after 30 sec, seek to the beginning of current chapter
					else xAudio.currentTime = 0;
				}
			}

			elReloadBtn.addEventListener('click', reloadSrc, false);
			function reloadSrc(_forcePause) {
				if (!navigator.onLine) {
					toast.showToast("Không có kết nối Internet", toast.ToastType.Error);
					return;
				}
				let _currTime = xAudio.currentTime;
				if (!_currTime) _currTime = 0;
				xAudio.load();
				xAudio.currentTime = _currTime;

				if (_forcePause) xAudio.pause();
			}

			const icnSvgPlayPauseProgress = document.getElementById("icnSvgPlayPauseProgress");
			/** Display Play/Pause/Loading icons and enable/disable for play-pause button depending on playing state of audio element. The fastforward, rewind button got enable/disable accordingly 
				@param _playIconType: 
					-1: show spinning loading icon, and the same time, disable all 3 buttons
					0 - show Pause icon on play-pause button (meaning audio is playing)
					1 - show Play icon on play-pause button (meaning audio is paused)
				@param _disableButton: enable/disable 3 buttons
					-1: do nothing
					0: disable
					1: enable
			
			*/
			let switchPlayPauseButton = (_playIconType, _disableButton) => {

				//change link to svg icon for PlayPause buttons
				document.querySelectorAll("[svg-icon-name='PlayPauseIcon']").forEach(_elm => {
					// put right svg icon sprite into button
					_elm.setAttribute("href", _playIconType === -1 ? "#icnSvgSpinWaiting" : "#icnSvgPlayPauseProgress");
				});

				// if button svg icon is #icnSvgPlayPauseProgress, then we set its appearance based on audio is playing or not
				if(_playIconType !== -1) icnSvgPlayPauseProgress.classList.toggle("isPPP-play", _playIconType===0);				

				if (_disableButton === undefined) _disableButton = -1;
				if (_playIconType === -1) _disableButton = 0;
				
				if (_disableButton !== -1) {
					//change state for PlayPause buttons
					document.querySelectorAll("button:has(svg > use[svg-icon-name='PlayPauseIcon'])").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});

					// blinking #elmPlayingTime when audio is paused
					elPlayingTimeLabel.classList.toggle("paused", _playIconType === 1);

					//change state for Rewind buttons
					document.querySelectorAll("button.ap-rewind-btn").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});

					//change state for Fastforward buttons
					document.querySelectorAll("button.ap-fastforward-btn").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});
				};
			}

			/** function to update the text for #elmPlayingTime
				* @param _parts {json} has following properties
				* 	@property time: the current playing time
				* 	@property slash: the text put in the slash. This property should never be used since slash in div.plt-slash is drawn by css (not using the char /)
				* 	@property dur: the audio duration
				*/
			function retextPlayingTime(_parts){
				//map the name of property with the index of corresponding element in elmPlayingTime.children
				const _map = {time: 0, slash: 1, dur: 2};
				for(const _part  in _parts)
					elPlayingTimeLabel.children[ _map[_part] ].textContent = _parts[_part];
			}
			/** Switch appearance of Playing time 
			@param _state {integer}: how playing time would be show up
				-1: internet connection lost, showing "No internet" on playingTime Elem
					0: show spinning clock to tell user that chapter is loading
					1: show current time / duration telling that audio is playing
			*/
			function switchBigPlayingTime(_state) {
				//playing time
				elPlayingTimeLabel.classList.toggle("elm-hidden", _state == 0);
				//spinning glass hour
				document.querySelector("div[name='HourglassSpining']").classList.toggle("elm-hidden", _state !== 0);
				
				//audio progress-bar 
				document.querySelector(".ap-progress").classList.toggle("ap-progress-bar--loading", _state == 0);

				//show state of internet if it is lost
				if (_state === -1) retextPlayingTime({time: "", slash: "No Internet", dur: ""})
				//elmPlayingTime.textContent = "No Internet";
			}
			
			/* ========== AUDIO SPEED ========== */
			/* Object to handle audio speed */

			/**
				Speed slider component
				- Range: 0.25 .. 2.5
				- Step: 0.05 (ticks every 0.05)
				- Labels only at 0.25 steps (0.5,0.75,1.0,1.25,... displayed as '1.5' etc)
				- Tick hierarchy:
					large -> values divisible by 0.5 (including 2.5)
					medium -> values divisible by 0.25 (but not by 0.5)
					small -> other 0.05 steps
					1.0 -> special mid color
				- Animation for fill and handle on change
				- + / - buttons to increase/decrease by step
				@param spdOption {json} Integration with external code:
					@property initSpeed (number): the slider initializes to that value.
					@property onSpeedChange (callback function): The slider will call onSpeedChange(newSpeed, {fromUser: boolean}) whenever its value changes.
				@return json, which include following property, which are all function
					
					@property change : function to update audio speed to speed saved in xState (xState.audio.speed)
					@property decStep: function to increase speed a value {STEP} (which is hard-coded to be 0.05)
					@property incStep: function to decrease speed a value {STEP} (which is hard-coded to be 0.05)
					@property getSliderSpeed(value) to get current slider's speed (which also should be xState.audio.speed).
					@property setSliderSpeed(value) to set speed  programmatically.
			*/
			const bSpeed = (function(spdOption){
				// config
				const MIN = 0.25, STEP = 0.05;
				//get last MAX from xState if there saved. Note that when page init, xState.audio object has been created if it not yet existed
				let MAX = xState.audio.maxSpeed ?? 2.0;
				const LABEL_STEP = 0.25; // where labels appear
				const BTN_GAP = 8;

				// elements
				const popup = document.getElementById('spd_popup');
				//button to show the speed popup along with span that play as a button label containing the current speed
				const btn = document.getElementById('spd_btn');
				const btnVal = btn.querySelector('.spd_btnValue');

				//slider parts
				const track = document.getElementById('spd_track');
				const fill = document.getElementById('spd_fill');
				const handle = document.getElementById('spd_handle');
				const ticksWrap = document.getElementById('spd_ticks');

				//popup header part
				const curSpdLabel = popup.querySelector('.spd_currentSpdLabel');
				const incBtn = document.getElementById('spd_inc');
				const decBtn = document.getElementById('spd_dec');

				// state
				let current = 1.0; //xState.audio.speed; //
				let dragging = false;

				// === helper functions ===
				//function to avoid set speed out of range, clamp to min/max
				function clamp(v){ return Math.min(MAX, Math.max(MIN, v)); }
				// ensure value is rounded to nearest step
				function toFixedStep(v){
					// ensure rounding to nearest step and avoid fp issues
					const n = Math.round(v / STEP) * STEP;
					return Number(n.toFixed(2));
				}
				// format speed value for display, e.g. 1.5 instead of 1.50
				function fmtShort(v){
					// short label: 1 instead of 1.00, 1.5 instead of 1.50, no '×'
					//if (Math.abs(v - Math.round(v)) < 1e-9) return String(Math.round(v));
					
					// remove trailing zeros, so 1.0 instead of 1 or 1.00; 1.5 instead of 1.50
					return v.toFixed(2).replace(/0$/,"") ; //Number(v.toFixed(2)).toString();
				}
				// speed to percent
				function speedToPercent(s){ return ((s - MIN)/(MAX - MIN))*100; }

				// call external hook if spdOption.onSpeedChange presents
				function callExternal(newSpeed, meta){
					// meta: { fromUser: boolean }
					if (typeof spdOption?.onSpeedChange === 'function'){
					try { spdOption.onSpeedChange(newSpeed, meta); } catch(e){ console.error('onSpeedChange error', e); }
					}
				}

				// set speed (will animate because CSS transitions applied)
				function setSpeed(raw, {fromUser=false} = {}){
					const s = toFixedStep(clamp(raw));
					current = s;
					const pct = speedToPercent(current);

					// update UI
					// animate fill and handle via CSS transitions
					fill.style.width = pct + '%';
					handle.style.left = pct + '%';
					//handle.dataset.value = current;
					curSpdLabel.textContent = btnVal.textContent = fmtShort(current) + "x"; //✖ ×

					// highlight active tick and label - the ones that match current speed
					ticksWrap.querySelectorAll('.spd_tick-label, .spd_tick').forEach(el=>{
						// using data-active attribute so CSS can highlight active tick/label
						el.dataset.active = (Number(el.dataset.value) === current) ? 'true' : 'false';
					});
					/* ticksWrap.querySelectorAll('.spd_tick').forEach(el=>{
						el.dataset.active = (Number(el.dataset.value) === s) ? 'true' : 'false';
					}); */

					// tiny handle "pop" animation
					//handle.classList.add('spd_handle_anim');
					// ensure a short scale flash (toggle class to trigger CSS)
					handle.classList.add('shrink');
					setTimeout(()=> handle.classList.remove('shrink'), 160);

					// external callback
					callExternal(current, { fromUser });

					return current;
				}

				// increase/decrease by one/two step(s)
				function incStep(twice){ setSpeed(current + (twice?2:1) * STEP, {fromUser:true}); }
				function decStep(twice){ setSpeed(current - (twice?2:1) * STEP, {fromUser:true}); }

				// convert pixel x -> value (then setSpeed will snap to nearest step)
				function pxToVal(clientX){
					const rect = track.getBoundingClientRect();
					const ratio = Math.min(1, Math.max(0, (clientX - rect.left) / rect.width));
					return MIN + ratio * (MAX - MIN);
				}

				// === build ticks and labels ===
				function buildTicks(){
					ticksWrap.innerHTML = '';

					// make the max speed select element
					function makeMaxSpeedSlt(){
						// 1. Create select element
						const selElm = document.createElement('select');
						//selElm.id = 'spd_maxSpeedSel';
						selElm.className = 'spd_tick-label spd_tick-maxSpeedSel';
						selElm.dataset.value = MAX; //.toFixed(2);
						selElm.title = 'Tốc độ tối đa (nhấn đúp để đặt tốc độ hiện tại bằng tốc độ tối đa)';

						// 2. Add options for max speed
						[2, 2.5, 3, 3.5, 4].forEach(value => {
							const option = document.createElement('option');
							option.value = option.textContent = fmtShort(value);
							option.selected = value == MAX; //mark current MAX as selected
							selElm.appendChild(option);
						});

						// 3. Add change event listener
						selElm.onchange = function () {
							MAX = parseFloat(this.value);
							
							//rebuld the tick
							buildTicks();
							//re-update the location of current speed
							setSpeed(current, {fromUser:false});

							//Note that when page init, xState.audio object has been created if it not yet existed
							xState.audio.maxSpeed = MAX;
							saveState2Disk();
						};

						// 4. Add dblclick event listener to set speed to MAX
						selElm.ondblclick = function(evt){
							//re-update the location of current speed
							setSpeed(MAX, {fromUser:false});

							//avoid dblclick to select text
							evt.preventDefault();
						}

						return selElm;
					}

					// count the number of labels so that limit that number to avoid labels overlapping
					const labelSteps = Math.round((MAX - MIN) / LABEL_STEP);
					const stepGotLabel = labelSteps > 14 ? 50 : 25;

					// number of small steps
					const steps = Math.round((MAX - MIN) / STEP);
					for(let i=0; i<=steps; i++){
						const v = Number((MIN + i*STEP).toFixed(2));
						const pct = speedToPercent(v);

						// add ticks at 0.05 steps 
						const tick = document.createElement('div');
						tick.className = 'spd_tick';
						tick.dataset.value = v.toFixed(2);

						// compute cents to avoid fp issues
						const cents = Math.round(v * 100); // e.g., 150 for 1.50
						if (cents === 100){ // special mid 1.0
							tick.classList.add('spd_tick-one');
						} else if (cents == 140){ // special my favorite speed 1.4
							tick.classList.add('spd_tick-fav');
						} else if (cents % 50 === 0){
							// divisible by 0.50 => largest ticks (includes 2.5)
							tick.classList.add('spd_tick-large');
						} else if (cents % 25 === 0){
							tick.classList.add('spd_tick-medium');
						} else {
							tick.classList.add('spd_tick-small');
						}

						tick.style.left = pct + '%';
						ticksWrap.appendChild(tick);

						//add tick labels at 0.25 steps (short form)
						if (cents === 100 * MAX){
							// for max speed, we will use a select element instead of fixed label so user can change max speed on their own
							const selElm = makeMaxSpeedSlt();
							selElm.style.left = pct + '%';
							ticksWrap.appendChild(selElm);
						} else if (cents % stepGotLabel === 0){
							const lbl = document.createElement('div');
							lbl.className = 'spd_tick-label';
							lbl.style.left = pct + '%';
							lbl.textContent = fmtShort(v);
							lbl.dataset.value = v.toFixed(2);
							//lbl.addEventListener('click', ()=> setSpeed(v, {fromUser:true}));
							ticksWrap.appendChild(lbl);
						}
					}

					// labels at 0.25 steps (short form)
					/* const labelSteps = Math.round((MAX - MIN) / LABEL_STEP);
					for(let i=0;i<=labelSteps;i++){
						const v = Number((MIN + i*LABEL_STEP).toFixed(2));
						const pct = speedToPercent(v);
						const lbl = document.createElement('div');
						lbl.className = 'spd_tick-label';
						lbl.style.left = pct + '%';
						lbl.textContent = fmtShort(v);
						lbl.dataset.value = v.toFixed(2);
						//lbl.addEventListener('click', ()=> setSpeed(v, {fromUser:true}));
						ticksWrap.appendChild(lbl);
					} */

					//click delegation for ticks and labels
					if(!ticksWrap.handlerAdded){
						// so the handler is added only one time
						ticksWrap.handlerAdded = 1;

						ticksWrap.addEventListener('click', (evt)=> {
							const _target = evt.target;
							//click on tick or label
							if(_target.matches('.spd_tick, .spd_tick-label') && _target.tagName !== 'SELECT'){
								//click on tick or label
								const v = Number(_target.dataset.value);
								//set speed to that value
								if(!isNaN(v)) setSpeed(v, {fromUser:true});

								evt.stopPropagation();
								evt.preventDefault();
							}
						})
					}
				}

				// === interactions: open/close popup + positioning ===
				function placePopup(){
					const butRect = btn.getBoundingClientRect();
					const pw = popup.offsetWidth;
					const ph = popup.offsetHeight;
					const vw = window.innerWidth;
					const vh = window.innerHeight;
					let top, left;
					const gap = BTN_GAP;

					function getViewportOffsets() {
						if (window.visualViewport) {
							return {
							x: window.visualViewport.offsetLeft,
							y: window.visualViewport.offsetTop
							};
						}
						return { x: 0, y: 0 };
					}

					// prefer below if space; else above
					if (vh - butRect.bottom > ph + gap) {
						// popup below button
						top = butRect.bottom + gap;
						popup.classList.remove("spd-popup-above");
						popup.classList.add("spd-popup-below");
					}
					else {
						// popup above button
						top = butRect.top - ph - gap;
						popup.classList.remove("spd-popup-below");
    					popup.classList.add("spd-popup-above");
					}

					// == center align with button, but keep on screen with 10px margin ==
					// calculate left to center align with button
					//left = r.left + (r.width/2) - (pw/2);
					left = butRect.left + (butRect.width/2) - (pw * 3/4); //shift left a bit to look better. You can change 3/4 to other value (e.g to 1/2 to center align, or to 2/3 to shift left a bit less)
					// clamp to screen
					left = Math.max(10, Math.min(left, vw - pw - 16));
					// account for scroll position
					left = Math.round(left + window.scrollX + offsets.x);
					// set position
					popup.style.left = left + 'px';
					popup.style.top = Math.round(top + window.scrollY + offsets.y) + 'px';

					const offsets = getViewportOffsets();
					// Tính vị trí arrow dựa trên vị trí button
					const arrowCenter = offsets.x + butRect.left + butRect.width / 2 - left;
					const maxArrow = pw - 20; // giới hạn arrow không ra ngoài
					const arrowLeft = Math.max(10, Math.min(maxArrow, arrowCenter));
					toast.showToast(`vw: ${vw}, pw: ${pw}, Arrow left: ${arrowLeft.toFixed(0)}px`, toast.ToastType.Info, 1000); //debug

					// Set CSS variable --arrow-left để định vị trí arrow
					popup.style.setProperty('--arrow-left', `${arrowLeft}px`);
				}
				
				// change the popup position when user changes ACP (audio control panel) sticky mode, so the ACP might move up or down, we need to reposition the popup so it still sticks with the button (inside ACP)
				(function(){ 
					const _apcStickySelEl = document.querySelector(".ap-sticky-select");
					// we have to use addEventListener instead of apcStickySelEl.onchange because the latter was already used by stickyAudioPanelHandler() function
					_apcStickySelEl.addEventListener('change', (e) => {
						//console.log('Selected:', e.target.value);
						onWinChange(); //reposition popup
					});
				})();

				/* event handler function */
				function openPopup(){
					popup.dataset.open = 'true';
					requestAnimationFrame(()=>{ 
						popup.classList.add('no-top-transition'); //avoid top transition on showing popup
						placePopup(); 
						handle.focus({preventScroll:true});
						popup.classList.remove('no-top-transition'); //restore top transition after popup shown
					});

					document.addEventListener('mousedown', onDocDown);
					window.addEventListener('resize', onWinChange);
					window.addEventListener('scroll', onWinChange, {passive:true});
					popup.addEventListener('keydown', onKey);
				}
				
				function closePopup(){
					popup.dataset.open = 'false';

					document.removeEventListener('mousedown', onDocDown);
					window.removeEventListener('resize', onWinChange);
					window.removeEventListener('scroll', onWinChange);
					document.removeEventListener('keydown', onKey);
				}
				function togglePopup(){ 
					if(popup.dataset.open==='true') closePopup(); 
					else openPopup(); 
				}
				
				// close if clicking outside of popup or button
				function onDocDown(e){ if(popup.contains(e.target) || btn.contains(e.target)) return; closePopup(); }
				//function onWinChange(){ if(popup.dataset.open==='true') placePopup(); }
				// Use debounce technique to lighten heavy scroll work.
				const onWinChange = debounce(() => {
					// do expensive stuff in placePopup() once
					//console.log('scroll stopped');
					if(popup.dataset.open==='true') placePopup();
				}, 50);
				
				// handle keyboard on the popup
				function onKey(e){
					if(e.key === 'Escape'){ closePopup(); return; }
					if(popup.dataset.open === 'true'){
						//if(e.key === 'ArrowLeft'){ e.preventDefault(); e.stopPropagation(); decStep(); }
						//if(e.key === 'ArrowRight'){ e.preventDefault(); e.stopPropagation(); incStep(); }
						if(['ArrowUp', 'ArrowRight', '+'].includes(e.key)){ e.preventDefault(); e.stopPropagation(); incStep(e.shiftKey); }
						if(['ArrowDown', 'ArrowLeft', '-'].includes(e.key)){ e.preventDefault(); e.stopPropagation(); decStep(e.shiftKey); }
					}

					//e.stopPropagation();
				}

				btn.addEventListener('click', togglePopup);

				// === dragging and clicking on track ===
				function startDrag(ev){
					dragging = true;
					document.body.style.userSelect = 'none';
					moveDrag(ev);
				}
				function moveDrag(ev){
					if(!dragging) return;
					const x = (ev.touches?.[0]?.clientX) ?? ev.clientX;
					setSpeed(pxToVal(x), {fromUser:true});
				}
				function endDrag(){ dragging = false; document.body.style.userSelect = ''; }

				// mouse
				handle.addEventListener('mousedown', startDrag);
				track.addEventListener('mousedown', startDrag);
				window.addEventListener('mousemove', moveDrag);
				window.addEventListener('mouseup', endDrag);

				// touch
				handle.addEventListener('touchstart', (e)=>{ e.preventDefault(); startDrag(e); }, {passive:false});
				track.addEventListener('touchstart', (e)=>{ e.preventDefault(); startDrag(e); }, {passive:false});
				window.addEventListener('touchmove', moveDrag, {passive:false});
				window.addEventListener('touchend', endDrag);

				// click on track to jump
				track.addEventListener('click', (e)=>{
					if(dragging) return;
					setSpeed(pxToVal(e.clientX), {fromUser:true});
				});

				// +/- buttons
				incBtn.addEventListener('click', ()=> setSpeed(current + STEP, {fromUser:true}));
				decBtn.addEventListener('click', ()=> setSpeed(current - STEP, {fromUser:true}));

				// keyboard on handle for accessibility
				/* handle.addEventListener('keydown', (e)=>{
					if(e.key === 'ArrowLeft' || e.key === 'ArrowDown'){ e.preventDefault(); decStep(); }
					if(e.key === 'ArrowRight' || e.key === 'ArrowUp'){ e.preventDefault(); incStep(); }
					if(e.key === 'Home'){ e.preventDefault(); setSpeed(MIN, {fromUser:true}); }
					if(e.key === 'End'){ e.preventDefault(); setSpeed(MAX, {fromUser:true}); }
					e.stopPropagation();
				}); */

				// If external variable window.initSpeed exists (number), use it as initial value.
				// Otherwise default is 1. You can also set window.initSpeed before this script runs.
				function initInitialSpeed(){
					if(typeof spdOption?.initSpeed === 'number'){
						setSpeed(spdOption.initSpeed, {fromUser:false});
					} else {
						setSpeed(current, {fromUser:false});
					}
				}

				/* This function is invoked on onratechange event of audio element, and onchange event of speed dropdown element*/
				function changeAudioSpeed() {
					if (xAudio.playbackRate != xState.audio.speed) {
						xAudio.playbackRate = xState.audio.speed; //parseFloat(elmSltSpeed.value)
						setSpeed(xState.audio.speed);
					}
				}

				// build + init
				buildTicks();
				initInitialSpeed();

				/* -- PUBLIC METHODS -- */
				return {
					change: changeAudioSpeed,
					decStep: decStep,
					incStep: incStep
					// === public API for integration ===\
					// , getSliderSpeed : function(){ return current; }
					// , setSliderSpeed : function(v, {fromUser=false} = {}){ return setSpeed(v, {fromUser}); }
				}

			})({
					//initial speed to bet set when popup first loaded
					initSpeed: xState.audio.speed,
					//callback function which is invoked everytime speed changes
					onSpeedChange: function(spd){
						//change audio playbackRate accordingly, save new speed to Storage
						xState.audio.speed = xAudio.playbackRate = spd;
						//toast.showToast(`Tốc độ phát ${spd}`);
					}
				});

			/* ========== STICKY MODE for AUDIO CONTROL PANEL ========== */
			/* IIFE function to set sticky mode for audio controls panel AND using IntersectionObserver watch when it is hidden */
			void function stickyAudioPanelHandler() {
				// insert a Dummy sentinel element to observe when Audio controls panel is sticked at top of the page
				apContainerEl.insertAdjacentHTML("beforebegin", `<div id="acp_sentinel" style="height: 1px"></div>`);
				// sentinel is a tiny (1px height) element placed just before the .ap-container element which is used to trigger the observer when sentinel appears/disappears
				const dummySentinelEl = document.getElementById("acp_sentinel");

				// the main div which is direct parent of apContainerEl
				const mainDivContainerEl = apContainerEl.parentElement; //document.querySelector('[name="divContainer"]');

				// for apple device and when .ap-container is in sticky bottom mode, we add  because .ap-container is set bottom bigger (20px), so we need to set padding a bit bigger for [name="divCtnBottom"] (which is element right before .ap-container) so that control panel not too close to the text 
				if(checkOS(2)) {
				//if(1){
					//by adding this css class, the padding-bottom of div[name="divCtnBottom"] also is set with higher number when apContainerEl pinned at the bottom
					apContainerEl.classList.add('apc--apple');
				}

				// sticky modes select element
				const apcStickySelEl = document.querySelector(".ap-sticky-select");

				/* populate the options for the select element */
				void function(){
					const _options = ['✕ Không bám dính', '⤒ Dính đầu trang', '⤓ Dính đáy màn hình', '⇟ Gắn ở cuối trang (simple-cheap)', '↡ Gắn ở đáy màn hình (expensive)'];
					const _optGrps = ["Chế độ bám dính khi cuộn trang", "Chế độ gắn cố định chân trang"];
					
					/* const _optGrp = document.createElement('OPTGROUP');
					_optGrp.label = "Chọn chế độ bám dính/gắn";
					apcStickySelEl.appendChild(_optGrp); */
					
					let _optGrp;
					_options.forEach((_option, _idx) => {
						if([0,3].includes(_idx)){
							_optGrp = document.createElement('optgroup');
							_optGrp.label = _optGrps[_idx==0?0:1];
							apcStickySelEl.appendChild(_optGrp);
						}
						let opt = document.createElement('option');
						opt.value = _idx;
						opt.textContent = _option;
						_optGrp.appendChild(opt);
					});
				}();

				/** function to move, in DOM, the @ACP - audio control panel element .ap-container to the bottom of div[name="divContainer"] OR back to its original location when no stick at all
				 * @param toBottom decide where to move .ap-container element
				 * 	@value false (default) move back to its original location like there is no sticky at all
				 * 	@value true: move to the very end of its parent (div[name="divContainer"]) for sticky bottom to work				 
				 */
				function moveACPelem(toBottom = false, includeSentinel = false){

					// const to see if .ap-container element already at bottom of its parent DOM (its parent is mainDivContainerEl - div[name="divContainer"])
					const _isCurrentlyAtBottom = apContainerEl.previousElementSibling !== dummySentinelEl; //apContainerEl.nextElementSibling === null;
					
					//toBottom = false: move back to original location which right after to dummySentinelEl #acp_sentinel
					if(!toBottom && _isCurrentlyAtBottom) mainDivContainerEl.insertBefore(apContainerEl, dummySentinelEl.nextElementSibling);

					//toBottom = true: move to the end of its parent
					if(toBottom && !_isCurrentlyAtBottom) mainDivContainerEl.insertBefore(apContainerEl, null);
					
					//mainDivContainerEl.insertBefore(apContainerEl, toBottom ? null : dummySentinelEl.nextElementSibling);
				}
				
				/** Use ResizeObserver to watch when div[name="divContainer"] changes its height in nail-bottom mode (4) */
				const mainDivHeightObserver = new ResizeObserver(([entry]) => {
					//debounce(() => {
						//add/remove class to change ACP position to 'sticky' when div[name="divContainer"] height is more than viewport height, otherwise change to 'absolute'
						apContainerEl.classList.toggle("apc-nail-bottom--fix-top", mainDivContainerEl.offsetHeight <= window.innerHeight - 10); // window.innerHeight - 10 === calc(100dvh - 10px) which is mainDivContainerEl's css min-height set for nail-bottom mode (3,4)
						/* if(checkOS(2)) //show toast debug on iOS
						toast.showToast(mainDivContainerEl.offsetHeight  + " --- " + window.innerHeight);
						else
						console.log(performance.now(), mainDivContainerEl.offsetHeight  + " --- " + window.innerHeight, apContainerEl.css("position")); */
					//}, 500)();

					//console.log('New height:', entry.contentRect.height, apContainerEl.css("position"));
				});

				/** Use IntersectionObserver to watch when sentinel is in or out of view to control the pinned state of apContainerEl .ap-container element.
				 * @note this observer only take care of sticky-top mode (1) and sticky-bottom mode (2). nail-bottom mode (4) will be taken care by mainDivHeightObserver above
				 */
				const stickyACPobserver = new IntersectionObserver( ([entry]) => {
						//_isSentinelOutOfView = true if sentinel is being scrolled out of user's view
						const _isSentinelOutOfView = !entry.isIntersecting;

						//console.log(_isSentinelOutOfView, xState.acpPinMode);

						
						// For other mode: add/remove pin class to .ap-container when it is/isn't pinned when sentinel is in/out of user's view
						apContainerEl.classList.toggle("apc--pinned", _isSentinelOutOfView);

						// when sticky at the bottom, there are few extra work to do
						if(xState.acpPinMode == 2){
							//_isSentinelOutOfView = true: sentinel being out of user's view , so we know we should pin apContainerEl at the bottom of the viewport by moving DOM element .ap-container to the very end of its parent for sticky bottom to work
							//_isSentinelOutOfView = false: sentinel being visible in user's view, so we move .ap-container back to original location like there is no sticky at all. Otherwise, it will stay at the end of its parent even .ap-container-sticky-bottom has been removed
							moveACPelem(_isSentinelOutOfView);
						}

						// glowing the audio control panel when apContainerEl being pinned
						_isSentinelOutOfView && SddDropdown.prototype.glowingElem(apContainerEl);
					},
					{
						//root: document.body,
						//rootMargin: "0px 0px 0px 0px",
						threshold: 0
					}
				);

				/** onchange event handler for the apcStickySelEl select box, which set sticky mode for .ap-container
				 * apcStickySelEl.value can take following value with corresponsing behavior of Sentinel (apcStickySelEl #acp_sentinel) and ACP - audio control panel (apContainerEl .ap-container):
				 * 		@value 0: no sticky at all. 
				 * 			@behavior : @ACP stays in its original place All the time.
				 * 		@value 1: stick at the top when page scroll that hide the original @ACP .
				 * 			@behavior : @ACP stays in its original place. Using class 'ap-container-sticky-top' for @ACP
				 * 				@codeWork Add class '.apc--pinned' to @ACP when @Sentinel is out of user view, otherwise remove.
				 * 		@value 2: stick at the bottom when page scroll that hide the original @ACP . Using class 'ap-container-sticky-bottom' for @ACP
				 * 			@behavior : @ACP DOM stays in its original place when page not scroll. When page scroll so that @Sentinel is out of view, @ACP is moved bottom of its parent DOM.
				 * 				@codeWork Add class '.apc--pinned' to @ACP when @Sentinel is out of user view, otherwise remove.
				 * 		@value 3: stay at the bottom of page all the time, no matter where page scroll to. Using class 'ap-container-nail-bottom' to @ACP
				 * 			@behavior : @ACP are moved to bottom of its parent DOM all the time. This is simple and much cheaper (in the sense of workload and performance) version of nail-bottom mode (4)
				 * 				@codeWork move @ACP to to bottom of its parent DOM. Add class 'ap-container-nail-bottom' to @ACP
				 * 		@value 4: nail at the bottom of viewport all the time, no matter where page scroll to. Using class 'ap-container-nail-bottom' for @ACP
				 * 			@behavior : @ACP are moved to bottom of its parent DOM all the time. Note that when mainDivContainerEl's height more than viewport height, this mode behaves exactly the same with mode 3, but more expensive workload
				 * 				@codeWork 
				 * 					- move @ACP to to bottom of its parent DOM. Add class 'ap-container-nail-bottom' to @ACP
				 * 					- Using an ResizeObserver to Add class '.apc-nail-bottom--fix-top' to @ACP when mainDivContainerEl - div[name="divContainer"] height more than viewport height, otherwise remove. 
				*/
				apcStickySelEl.onchange = _ => {
					//old mode before changing to new one
					//const _oldMode = xState.acpPinMode;

					// update the sticky mode to xState.acpPinMode (Audio Control Panel Pinned Mode)
					const _selVal = xState.acpPinMode = Number(apcStickySelEl.value);
					
					//use a shortcut var to control apContainerEl's classList
					const _clsList = apContainerEl.classList;

					// just unwatch the sentinel, and re-watch below Only when in mode 1 and 2. We have to disconnect before doing any change to apContainerEl class, so the old observer does not be passively fired with those change until we proactively re-observe and relocate the panel (if necesssary)
					stickyACPobserver.disconnect();

					// just unwatch the main Div, and re-watch below Only when in mode 4 (complex nail-bottom).
					mainDivHeightObserver.disconnect();

					//reset extra class that used to control special case in each of sticky mode
					_clsList.remove("apc--pinned", "apc-nail-bottom--fix-top");
					
					// add class for sticky top for mode = 1, otherwise remove it
					_clsList.toggle("ap-container-sticky-top", _selVal == 1);
					// add class for sticky bottom for mode = 2 otherwise remove it
					_clsList.toggle("ap-container-sticky-bottom", _selVal == 2);

					// add class for stay bottom for mode 3 (simple stay-bottom) and mode 4 (complex nail-bottom) otherwise remove it. If added, glowing ACP
					_clsList.toggle("ap-container-nail-bottom", [3,4].includes(_selVal)) && ('function' === typeof SddDropdown.prototype.glowingElem) && SddDropdown.prototype.glowingElem(apContainerEl);
					
					// mode 3 (simple stay-bottom) and mode 4 (complex nail-bottom)are quite troublesome when we have to manually move .ap-container element to the very end of its parent DOM (see function comment for more behavior details). So, when not in stay-bottom/nail-bottom mode, we need to move it back to its original location, which is correct location for other mode (0 and 1). Although in sticky-bottom mode (2) we also need to move ACP down in bottom of its parent DOM, but we do that only when the Sentinel is out of user's view (and move back when not), and we handle that in stickyACPobserver callback
					moveACPelem([3,4].includes(_selVal));					

					//now re-watch
					if(_selVal == 4) {
						// in nail-bottom mode (4), we use ResizeObserver to watch for the change
						//watch for div[name="divContainer"] change height in nail-bottom mode (4)
						mainDivHeightObserver.observe(mainDivContainerEl);

						//calculte apContainerEl to save in css attribute, this make sure we have lastest correct height of ACP (even that height does not change for one screen dimension)
						apContainerEl.style.setProperty('--acp-height', apContainerEl.offsetHeight + 'px');
					}
					else
						// in sticky-top mode (1) and sticky-bottom mode (2), we use IntersectionObserver to watch for the change
						//re-watch the sentinel ONLY for mode 1 and 2. intersectionObsever will also put the ACP (audio control panel) at the right place according to sticky mode user select and the current position of page scroll
						if([1,2].includes(_selVal)) stickyACPobserver.observe(dummySentinelEl);
					
					// naive trick to trigger window scroll event so that bSpeed object's scroll handler can place the speed popup along with the ACP (see onWinChange inside bSpeed)
					//window.scrollBy(0, 1); window.scrollBy(0, -1);

					//save xState to disk
					saveState2Disk(); //.then(_ => console.log('saved states'));
				}

				// set initial option for apcStickySelEl based on xState.acpPinMode
				apcStickySelEl.value = xState.acpPinMode ?? 0;
				apcStickySelEl.onchange(); //make change to inittial option
			}();

			/* ========== PLAYED BAR CANVAS && BUFFERED BAR CANVAS ========== */
			const trCanvas = ( function timeRangeCanvas(){
				/* == PREPARE AND INITIATION == */
				// canvas that shows the audio buffers
				const bufferBarCanvas = document.querySelector('.ap-buffer-bar');
				// canvas that shows the audio part that is/has been playing
				const playedBarCanvas = document.querySelector('.ap-played-bar');
				// all canvases that this function controls
				const _ALL_CANVAS = [playedBarCanvas, bufferBarCanvas];
				//the canvas background color
				const _CANVAS_BGRND = '#bdbdbd'; //'lightgray';

				// if setting is to hide the canvases, hide them
				if (xState.flags.hideBufferBar) {
					_ALL_CANVAS.forEach(_canvas => _canvas.classList.add("elm-hidden"));
				}

				_createHiPPICanvas();				
				_hideCanvas(); //initialize the UI of buffer bar				

				/* == MAIN FUNCTIONS == */

				/** function to clear the canvas
				 * @param canvas {HTMLCanvasElement} could be playedBarCanvas or bufferBarCanvas. If leave empty, this function will call on both that canvas
				 */
				function _hideCanvas(canvas) {
					//if param canvas is missing, clear for ALL canvases
					if(canvas === undefined){
						/* _clearCanvas(playedBarCanvas);
						_clearCanvas(bufferBarCanvas); */
						_ALL_CANVAS.forEach(_hideCanvas);
						return;
					}

					//might check if canvas parameter is a HTMLCanvasElement like
					//if( !(canvas instanceof HTMLCanvasElement) ) return;

					// just hide the canvas, will show it again when neccessary in _drawCanvas()
					canvas.classList.add("elm-hidden");

					//reset the tooltip
					canvas.dataset.tooltip = "";

					//turn on the flag so _drawCanvas() would force to clean the canvas background before drawing. For now this property only has effect on playedBarCanvas which does not require to redraw the canvas background on every TimeRange update (because next TimeRange cover the previous one). bufferBarCanvas, on other hand, required redraw canvas background on every TimeRange update (because consecutive TimeRange might have nothing to do with each other).
					canvas.clearRequired = true;

					/* //if it is hidden when listening last chapter, then it is already cleaned
					if (canvas.classList.contains("elm-hidden")) {
						return;
					}
					else canvas.classList.add("elm-hidden"); //hide it, will show it again when user seek the audio

					let context = canvas.getContext('2d');

					const _w = canvas.wt; //canvas.offsetWidth; //canvas.width;
					const _h = canvas.ht ; //canvas.offsetHeight; //canvas.height;

					context.clearRect(0, 0, _w, _h);
					context.fillStyle = _CANVAS_BGRND; //'#bdbdbd'; //'lightgray';
					context.fillRect(0, 0, _w, _h);
					 */
				}

				/** function to draw the canvas based on the timeRanges value of corresponding canvas. It would be xAudio.played for playedBarCanvas; xAudio.buffered for bufferBarCanvas
				 * @param canvas {HTMLCanvasElement} could be playedBarCanvas or bufferBarCanvas. 
				 * 	@value If leave empty, or is a Boolean this function will call on both that canvas. in this case, @param canvas would play the role of @param forceRedraw as follows: if @param canvas is missing of False, @param forceRedraw = false, otherwise True
				 * 
				 * @param forceRedraw {Boolean}: optional parameter. This param is used to deal with the case where page resize or zooming, in that case canvas dimensions and/or devicePixelRatio change(s), so the drawing on canvas not correct anymore and might be disappear, in that case we need to force to redraw the canvases
				 * 	@value false or missing, redraw based on the state of the canvas
				 * 	@value true: force to redraw the canvas no matter what, this usually used in _canvasResize() to force the canvas to redraw because of canvas (logical and physical) dimensions change or window.devicePixelRatio changes
				 */
				function _drawCanvas(canvas, forceRedraw) {
					//if user don't want to show buffer bar, do nothing
					if (xState.flags.hideBufferBar) return;

					//if param canvas is missing, or take only one parameter, we redraw for ALL canvases
					if( !(canvas instanceof HTMLCanvasElement) ){
						// redraw for all canvases in {_ALL_CANVAS} array, and @param {canvas} now play the role of @param {forceRedraw}
						_ALL_CANVAS.forEach(_cvs => _drawCanvas(_cvs, !!canvas) );
						return;
					}

					let _timeRanges, clearCanvas, _fillColor;
					// flag to decide if show or hide canvas
					let hideCanvas;
					const _ACCEPT_START_OFFSET = 10; //amount of offset (in seconds) from start and end of audio that we would take as real start/end of audio

					/* CUSTOMIZE ACTIONS for each type of TimeRange */
					if(canvas === playedBarCanvas){
						//alias for played timeRanges which of the part of audio that user has played (see spec https://html.spec.whatwg.org/multipage/media.html#playing-the-media-resource)
						_timeRanges = xAudio.played;

						//not necessary to clear the canvas each time update the new one except the case user change from hide buffer bar to show buffer bar in Setting modal. Here we use clearRequired to set to true in Setting modal (see function handleBufferBarChkbox) to force playedBarCanvas would draw a new plain background
						clearCanvas = true; //canvas.clearRequired ?? false;
						_fillColor = 'crimson'; //cadetblue	darkgoldenrod crimson #f50

						//decide if we should show or hide the canvas
						hideCanvas = (_timeRanges.length === 0);
						hideCanvas = hideCanvas || (_timeRanges.length === 1 && _timeRanges.start(0) <= _ACCEPT_START_OFFSET && _timeRanges.end(0) === xAudio.currentTime );
					}

					if(canvas === bufferBarCanvas){
						//alias for played timeRanges which of the part of audio that user has played (see spec https://html.spec.whatwg.org/multipage/media.html#playing-the-media-resource)
						_timeRanges = xAudio.buffered;
						clearCanvas = true; //buffer changes through times, so each time update the canvas, we need to clear it first before drawing the lastest one
						_fillColor = '#0062ff'; //cadetblue	darkgoldenrod crimson #f50

						//decide if we should show or hide the canvas.
						hideCanvas = (_timeRanges.length === 0) || ( _timeRanges.length === 1 && _timeRanges.start(0) <= _ACCEPT_START_OFFSET); // && _timeRanges.end(0) === _xDuration );						
					}

					/* DECIDE TO SHOW OR HIDE THE CANVAS */
					let _clsList = canvas.classList;
					/* //if there is only one played time range and that time range start at something less than 10 seconds, the played time range and progress-bar would be exactly the same, so we don't draw the played timeRange
					if( (_timeRanges.length === 0) ||
						(_timeRanges.length === 1 && _timeRanges.start(0) <= _ACCEPT_START_OFFSET) 
					) {*/
					if(hideCanvas){
						// hide the canvas when it is not giving different information from progress-bar and preload-bar
						_clsList.add("elm-hidden");
						return;
					}
					else{
						//show canvas if it was hidden					
						if (_clsList.contains("elm-hidden")) _clsList.remove("elm-hidden");
					}

					/* DECIDE IF NEED RE-DRAWING */					
					// flag to decide if redraw the canvas. For xAudio.played, we always redraw the canvas because its TimeRanges always changes when playing audio unless user replay part that he just played. But for xAudio.buffered, we only redraw when TimeRanges changes
					if(canvas === bufferBarCanvas && !forceRedraw){
						//compare current TimeRange which one stored in canvas's timeRange property
						const _matchTimeRange = _compareTimerangeArray(_timeRanges, canvas.timeRange);
						//if there is something changes in TimeRanges, store the lastest TimeRange to canvas's timeRange property
						if(!_matchTimeRange){
							//console.log('Buffered Time range changes', window.devicePixelRatio);
							if(canvas.timeRange?.length) canvas.timeRange.length = 0; // clear old array to prevent memory leak
							canvas.timeRange = _timerange2Array(_timeRanges);
							//console.log(canvas.className, ' Time range changes');
						}
						//no need to redraw the canvas when there is nothing new
						else return;
					}

					/* START (RE)DRAWING */
					canvas.clearRequired = false; //set back to false (if it was true) so next time playedBarCanvas do not need to redraw the background

					// because of command 'getContext("2d").scale' in _createHiPPICanvas, here we need to use element width and height (in pixel) of the canvas
					// wt, ht is two properties added by _createHiPPICanvas(), which approximately offsetWidth, offsetHeight, respectively
					const _w = canvas.wt; //canvas.offsetWidth; //canvas.width;
					const _h = canvas.ht ; //canvas.offsetHeight; //canvas.height;

					const context = canvas.getContext('2d');
					const inc = _w / _xDuration;

					/* clean the canvas and draw the new background */
					// if fillStyle not the one that assigned in _clearCanvas, it means the canvas has not been clean for the new one, so we need to redraw blank canvas
					if (clearCanvas) { // && context.fillStyle !== _CANVAS_BGRND
						//clean the canvas
						context.clearRect(0, 0, _w, _h);

						//draw background
						context.fillStyle = _CANVAS_BGRND; //'lightgray';
						context.fillRect(0, 0, _w, _h);
					}

					context.fillStyle = _fillColor;
					context.strokeStyle = "#000"; //_CANVAS_BGRND; //white

					//clearBufferBar();

					// display TimeRanges
					for (let i = 0; i < _timeRanges.length; i++) {
						let startX = _timeRanges.start(i) * inc;
						let endX = _timeRanges.end(i) * inc;

						//param for fillRect(), strokeRect() and rect(): x,y,width,height
						context.fillRect(startX, 0, endX - startX, _h);
						context.strokeRect(startX, 0, endX - startX, _h);

						/* context.rect(startX, 0, endX - startX, _h);
						context.fill(); 
						
						context.rect(startX, 0, endX - startX, _h);
						context.stroke(); */
					}
				}

				/* == HELPER FUNCTIONS == */
				/** function to convert an TimeRange to 2-dimension array contains start and end of each time range inside @_timeRange
				 * @param _timeRange {TimeRange} a TimeRange, for now used for xAudio.buffered
				 * @return 2-dimension array 
				*/
				const _timerange2Array = _timeRange => {
					const _trArray = [];
					let i = 0, len = _timeRange.length;
					while (i < len) {
						_trArray.push([_timeRange.start(i), _timeRange.end(i)]);
						i++;
					}
					return _trArray;
				}

				/** function to compare an -timeRange and an array that was created by _timerange2Array()
				 * @param _timeRange {TimeRange} a TimeRange, for now used for xAudio.buffered
				 * @param _trArray {Array} 2-dimension array that contains start and end of each time range generated by _timerange2Array()
				 * @return	true if they store the same information, other return false
					 */
				const _compareTimerangeArray = (_timeRange, _trArray) => {
					// if any of params is empty
					if(_timeRange.length === 0 || !Array.isArray(_trArray) || _trArray.length === 0) return false;

					//length not match
					if(_timeRange.length !== _trArray.length) return false;

					// now, match each time range
					let i = 0, _retVal = true, len = _timeRange.length;
					while (i < len) {
						_retVal = _retVal && 
						(_trArray[i][0] === _timeRange.start(i) &&  _trArray[i][1] === _timeRange.end(i));

						//if false, return right away
						if(!_retVal) return false;

						i++;
					}
					return _retVal;
				}

				/** function to fix the blur canvas drawing by adjusting canvas logical size to physical size based on devicePixelRatio. adapted from https://stackoverflow.com/a/65124939
				 * @param canvas {HTMLCanvasElement} could be playedBarCanvas or bufferBarCanvas. If leave empty, this function will call on both that canvas
				 */
				function _createHiPPICanvas(canvas) {
					if(canvas === undefined){
						// get current hidden/shown state of the two canvas, by the same time temporarily hide it, so the viewport resize would work
						const _hState = _ALL_CANVAS.map(_cvs => {
							//see if current canvas is hidden (true) or visible (false)
							const _isHidden = _cvs.classList.contains("elm-hidden");
							//temporarily hide the canvas
							_cvs.classList.add("elm-hidden"); // on page resize, the following only work if ALL canvases are hidden
							return _isHidden;
						});					
						
						/* createHiPPICanvas(bufferBarCanvas);
						createHiPPICanvas(playedBarCanvas); */
						_ALL_CANVAS.forEach(_createHiPPICanvas); //fixing the dpi of canvas
						
						/* playedBarCanvas.classList.remove("elm-hidden");
						bufferBarCanvas.classList.remove("elm-hidden"); */

						//restore the hidden/visible state of ALL canvases
						_ALL_CANVAS.forEach( (_canvas, i) => {
							_canvas.classList.toggle("elm-hidden", _hState[i]);
						});
						return;
					}

					//might check if canvas parameter is a HTMLCanvasElement like
					//if( !(canvas instanceof HTMLCanvasElement) ) return;

					const ratio = window.devicePixelRatio;
					// make the width is 100% of container. This is why we need to hide the canvases each time window resize
					const w = document.querySelector(".ap-progress-container").getBoundingClientRect().width;
					const h = 4; // make the height is 4px

					//canvas logical width and height (unit size)
					canvas.width = w * ratio;
					canvas.height = h * ratio;

					//canvas element's physical width and height (pixel)
					canvas.style.width = w + "px";
					canvas.style.height = h + "px";

					// scale unit size to pixels
					canvas.getContext("2d").scale(ratio, ratio);
					//canvas.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);

					// Because of line 'getContext("2d").scale' above, we need to add two properties for quick use on drawing canvas later. See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale for more
					canvas.wt = w; 
					canvas.ht = h;
					//above two are the number which is width and height in pixel of canvas element in the viewport					
				}
				
				/* Function to show all the TimeRanges of audio played, buffered and seekable to be used as tooltip of '#elmPlayingTime' element */
				function _getTimeRanges(){
					// audio properties that return a TimeRange is  buffered, seekable, and played (see spec https://html.spec.whatwg.org/multipage/media.html#timeranges)
					const _TIMERANGE_OBJS = [
						{obj: "played", desc: "Khoảng audio đã phát (played)", color: "crimson"},
						{obj: "buffered", desc: "Khoảng audio đã tải (buffered)", color: "#0062ff"},						
						{obj: "seekable", desc: "Khoảng audio có thể tua (seekable)", color: null}
					];
					const _NEWLINE = "\n"; // "&#xa"; //"<br/>"

					let _retHTML = [];
					for(const _tl of _TIMERANGE_OBJS) {
						// display TimeRanges
						const _timeRanges = xAudio[_tl.obj];
						let _subHtml = [];
						for (let i = 0; i < _timeRanges.length; i++) {
							const startX = _timeRanges.start(i);
							const endX = _timeRanges.end(i);
							const isEnd = endX > xAudio.duration - 1; //to ignore the decimal in audio duration
							if(startX < 1 && isEnd)
								_subHtml.push('Toàn bộ audio')
							else
								_subHtml.push(`${startX?toHhMmSs(startX):'Start'}—${isEnd?'End':toHhMmSs(endX)}`);
						}
						_retHTML.push(`${_tl.desc}:${_NEWLINE}${_subHtml.join(", ")}`);
					}
					return _retHTML.join(_NEWLINE);
				}

				/* == EVENTS HANDLERS == */
				/* function to resize the canvas size and coordinate space so that it would not be blurry. Note that zooming also fire resize event (see https://stackoverflow.com/questions/995914/catch-browsers-zoom-event-in-javascript), so this function also take care of user' zooming actions. Note that when zooming, window.devicePixelRatio changes, so we need to reupdate canvas (logical and physical) dimensions and need to redraw the canvas, otherwise the canvas may disappear */
				const _canvasResize = _ => {
					//console.log('_canvasResize', window.devicePixelRatio);
					//resize the canvases
					_createHiPPICanvas();
					
					//redraw them in force redraw mode, meaning does not matter xAudio.buffered changes or not, buffer bar still being redrawed
					_drawCanvas(true);

					//reposTooltips(undefined, {selfElem: remTime});
					//delete remTime.fixTooltip; //so that next time mouse move to remTime, its tooltip will be re-positioned
				};
				
				//function to update the latest timeRanges and show it as .timeRangeInfoButton tooltip, also fixing the tooltip position so that it is inside the user screen
				function _showTimeRanges(event){
					// set the tooltip message
					this.dataset.tooltip = _getTimeRanges();

					//postition it
					guiUtils.reposTooltips(null, {selfElem: this, container: document.documentElement});

					event && event.stopPropagation();
				}

				const pltDurationEl = document.querySelector(".timeRangeInfoButton");
				// adding 'mouseover' event on remTime element so that the tooltip updates and show the latest timeRanges
				pltDurationEl.addEventListener("mouseenter", _showTimeRanges);
				// set the css variable to make the tooltip stay longer than usual
				pltDurationEl.style.setProperty('--tooltip-timeout', '10s');
				//pre-run so that first time hover on pltDurationEl, that element already has pre-content so that the tooltip does not changes from 0, which avoid the tooltip moves from outside of screen to inside of screen
				_showTimeRanges.call(pltDurationEl);
				
				//handle the window resize event to resize the canvases accordingly
				//window.addEventListener('resize', _canvasResize);

				/* == PUBLIC METHODS == */
				return {
					/* function to re-calculate canvas dimension when window resize */
					onresize: _canvasResize,

					hideCanvas: _hideCanvas,
					drawCanvas: _drawCanvas,
					// function to remove the events listeners that added by this object
					unplugEvents: _ => {
						elPlayingTimeLabel.removeEventListener("mouseover", _showTimeRanges);
						//window.removeEventListener('resize', _canvasResize);
					}
				}
			})();

			/* ========== PROGRESS BAR SEEKING (MOUSE, TOUCH) HANDLES ========== */
			const elProgressWrapper = elProgressBar.closest(".ap-progress-container"); //progressBar.parentNode.parentNode;
			elProgressWrapper.addEventListener('mousedown', progressbarMD, false);
			elProgressWrapper.addEventListener('mousemove', progressbarMM, false);
			document.documentElement.addEventListener('mouseup', seekingDone, false); //it must be documentElement to handle MouseUp because when user move the mouse, the mouse might go outside of elProgressContainer.
			//elProgressContainer.addEventListener('mouseup', seekingDone, false);

			function moveBar(evt, el, dir) {
				let value;
				if (dir === 'horizontal') {
					//Math.round for more precise location
					value = ((evt.clientX - el.offset().left) + window.pageXOffset) * 100 / el.parentNode.offsetWidth; //Math.round(((evt.clientX - el.offset().left) + window.pageXOffset) * 100 / el.parentNode.offsetWidth);
					el.style.width = value + '%';
					return value;
				}
				else {
					let offset = (el.offset().top + el.offsetHeight) - window.pageYOffset;
					value = Math.round((offset - evt.clientY));
					if (value > 100) value = 100;
					if (value < 0) value = 0;
					elVolumeBar.style.height = value + '%';
					return value;
				}
			}

			function progressbarMD(evt) {
				//console.log("Mouse down");
				rightClick = (evt.button === 2) ? true : false; //evt.which === 3, evt.which was deprecated
				isPlaying = !xAudio.paused; //flag to know if audio is playing
				if (isPlaying) xAudio.pause(); //if audio is playing, pause it so lots of temporary audio buffering, seeking,... is NOT invoked while seeking, that make the seeking perfectly smooth

				isSeeking = true;
				evt.preventDefault();
				progressbarMM(evt);
			}

			function progressbarMM(evt) {
				// console.log("Mouse move");
				if (isSeeking && rightClick === false && xAudio.readyState !== 0) {
					let value = moveBar(evt, elProgressBar, 'horizontal');
					xAudio.currentTime = _xDuration * (value / 100);
				}
			}

			function seekingDone(evt) {
				//console.log("Mouse up");
				//if mouse up on progress-bar, not the volume bar
				if (evt.target.closest(".ap-progress-container")) {
					toast.showToast(`Audio is seeking to ${toHhMmSs(xAudio.currentTime)}`);

					if (isPlaying && isSeeking) xAudio.play(); //audio, which was on playing, was paused for smooth seeking, now have to turn it back to playing
				}
				isSeeking = false; //turf off flag to mark the (progress and volume) seeking has finished
			}

			/* TOUCH EVENT */
			elProgressWrapper.addEventListener('touchstart', progressbarTS, false);
			elProgressWrapper.addEventListener('touchmove', progressbarTM, false);
			//document.documentElement
			elProgressWrapper.addEventListener('touchend', seekingDone, false);
			elProgressWrapper.addEventListener('touchcancel', seekingDone, false);

			let _progressbarLeft; //progress bar left value relative to the browser's viewport

			function progressbarTS(e) {
				//there are bunch of way to calculate this, depend on if there is scrollbar or not. Simply the most, I use this formula, hope it works.
				_progressbarLeft = elProgressBar.getBoundingClientRect().left; //progressBar.offset().left
				isPlaying = !xAudio.paused; //flag to know if audio is playing
				if (isPlaying) xAudio.pause(); //if audio is playing, pause it so lots of temporary audio buffering, seeking,... is NOT invoked while seeking, that make the seeking perfectly smooth
				isSeeking = true; //turn on flag showing that starting touch & move
				progressbarTM(e);
			}

			function touchMoveBar(e, el, dir) {
				let value;
				if (dir === 'horizontal') {
					value = Math.round((e.changedTouches[0].clientX - _progressbarLeft) * 100 / el.parentNode.offsetWidth);

					// console.log(`${_progressbarLeft} - ${el.parentNode.offsetWidth}`);
					// console.log(`touch-move: clientX=${touch.clientX} ~ ${value}`);

					//in case move over the progress bar
					if (value > 100) value = 100;
					if (value < 0) value = 0;
					el.style.width = value + '%';
				}
				else {
					/* Currently, I don't want to implement for vertical volume bar
					const diffY = touch.clientY - startY;
					value = Math.round( (el.offsetTop + diffY) * 100 / el.parentNode.offsetHeight  );
					if(value > 100) value = 100;
					if(value < 0) value = 0;
					volumeBar.style.height = value + '%'; */
				}

				e.preventDefault();
				return value;
			}

			function progressbarTM(evt) {
				if (isSeeking && xAudio.readyState !== 0) {
					let value = touchMoveBar(evt, elProgressBar, 'horizontal');
					xAudio.currentTime = _xDuration * (value / 100);
				}
			}

			/* ========== TIME DISPLAY & CIRCLE PROGRESS (ON PLAY BUTTONS) ========== */
			// element that is component of #icnSvgPlayPauseProgress svg sprite that store the circle progress
			const svgCircleElems = document.querySelector("#svgProgressCircleBar");

			/** Draw the Circle ProgressBar surround the play and pause buttons. There are two ways to archive this, old way (seems very costly) is usage of --audio-playing-current-progress-percent variable in div[name="divContainer"] element. 
			2nd way, using js to change directly to svg "stroke-dashoffset" attribute. This implement the 2nd way
				@param currPercent {float from 0 to 1}: the current percentage of playing
				*/
			function updateCircleProgressBar(currPercent) {
				let _prgress = 383.3; //default value, which make progress go to 0%
				if (isFinite(currPercent)) //currPercent is not infinity or NaN
					_prgress = ((1 - currPercent) * 383.3) << 0; //383.3 is value of stroke-dasharray which is circumference of a circle having radius of 61. See svg symbol having id="icnSvgPlayProgress"

				//old way: elmRoot.style.setProperty('--audio-playing-current-progress-percent', _prgress + 'px');

				//update circle progress bar by directly changing the value of stroke-dashoffset of the progress bar component inside the svg sprite symbol#icnSvgPlayPauseProgress
				svgCircleElems.setAttribute('stroke-dashoffset', _prgress);;
			}			
			
			/* The interval that the page do the update for some source-consuming UI update such as circle-progress-bar, audio progress bar, percentage of listened duration. 0.01 mean 1% of total audio duration, meaning through full audio duration, we redraw only 100 times */
			const _HEAVY_UPDATE_INTERVAL = 0.005;
			//variable to keep progress bar width so we don't need to get from element
			let _PROGRESS_BAR_WIDTH = elProgressBar.parentElement.offsetWidth;
			//an intenal variable that is used to lighten the heavy-burden of updateTime() function below. It helps to just update UI after some specific interval of time, not in every audio 'timeupdate' event firing
			let _lastAudioPosition = 0;
			// the updateBufferCanvas counter, which count the times heavy-load UI repaint in updateTime() such as paint progressBar, Circle Progress Bar, preload bar,... The updateBufferCanvas (which uses canvas to show the detailed picture of audio buffer) is called after _ubcCounter reach to a specific number (e.g 10), because updateBufferCanvas() is way more heavy than the other UI repaint
			let _ubcCounter = 0;			

			/** This function is called on audio timeUpdate event which happens 4 times a seconds. This function is in charge of updating UI for the audio 
				* @param forceHeavyUIUpdate {boolean}: value true will make heavy UI update right away without waiting after a specific of time (usually 1% of audio duration, depending on value of @_HEAVY_UPDATE_INTERVAL ). For now, the value true is only invoked from audio onseeked event. Note that when updateTime is invoked from event such as timeUpdate, forceHeavyUIUpdate is an event object (not a boolean value)
			*/
			function updateTime(forceHeavyUIUpdate = false) {
				// this is to prevent override "No Internet" message when connection lost
				if (xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA) return; //there is no data for next frame (google 'audio readyState mdn' for more)

				//saveLastPosition(); //this works very well but might put too much burden on computer
				if (document.hidden) return; //if page is currently not on user's view, stop all UI update

				let _currTime = xAudio.currentTime; //, _xDuration = xAudio.duration;
				
				//changing some time-text, it's quite light, so just update the text every audio 'timeupdate' event firing
				let _remTime = _xDuration - _currTime;
				elRemTime.innerHTML = toHhMmSs(_remTime) + " / " + toHhMmSs(_remTime / xAudio.playbackRate); //remaining time

				//update big font playing time
				retextPlayingTime({time: toHhMmSs(_currTime)}); //, slash: "/", dur: toHhMmSs(_xDuration)
				//elmPlayingTime.textContent = toHhMmSs(_currTime) + " / " + toHhMmSs(_xDuration); 

				/* REDRAW FOR HEAVY UI OPERATIONS */
				//check the interval from last time update resource-consuming UI to see if it over some specific percentage of total audio duration OR almost reach the end of audio. Note that for some UI, especially when dealing with 'width' css attribute, even we update UI in finer interval, the appearance of UI can't display it. For example, user can only see the change in progressBar barlength when the 'width' of progressbar changes by 1% of the whole length. Note that below, condition '_duration > 0' also includes '!isNaN(_duration)'				
				if( (_xDuration > 0) && (forceHeavyUIUpdate === true || Math.abs(_currTime - _lastAudioPosition) > _xDuration * _HEAVY_UPDATE_INTERVAL || _currTime > _xDuration - 10 ) ){
					//console.log(_lastAudioPosition + "\t" + _currTime);
					
					_lastAudioPosition = _currTime; //update new current time
				
					// 1. Update the audio progress-bar
					/* let barlength = Math.round(_currTime * (100 / _xDuration));
					elProgressBar.style.width = barlength + '%'; */
					let barLength = _PROGRESS_BAR_WIDTH * _currTime /  _xDuration ;
					elProgressBar.style.width = (barLength << 0) + 'px';

					// 2. Update preload progress bar, which only show the last chunk of audio buffered TimeRange. Instead, buffer bar .ap-buffer-bar would show all the chunk
					let buffered = xAudio.buffered;
					if (buffered.length) {
						//fastest way: just take the end() of last chunk
						elPreloadBar.style.width = `${(buffered.end(buffered.length - 1) * 100) / _xDuration}%`;

						/* //correct way: search backward to find last chunk that contain current playing time xAudio.currentTime
						for (let i = buffered.length-1; i >= 0; i--) {
							if (buffered.start(i) < _currTime) {
								preloadBar.style.width = `${(buffered.end(i) * 100) / _xDuration}%`;
								break;
							}
						} */
					}

					// 3. Update circle progress bar attached on Play/Pause button
					if (!xState.flags.disableCircleProgressButton) { //will not update circle progress for lighter burden on the page performance
						updateCircleProgressBar(_currTime / _xDuration);
					}

					// 4. Update the percentage of listened chapters (include elapsed time of current chapter), so far
					//may use id (#percentageListened) to refer to element
					const percentageListened = document.getElementById("percentageListened");
					//using property instead of attribute for faster access
					let lPP = percentageListened.listenedPercent ?? parseFloat(percentageListened.dataset.listenedPercent);

					// if not yet has property, get it from dataset attributes
					if(!percentageListened.hasOwnProperty('bookDur')){
						// listenedDuration contain the total duration of all books before current book in playlist
						percentageListened.listenedDuration = parseInt(percentageListened.dataset.listenedDuration);
						// bookDur contain the total duration of all books
						percentageListened.bookDur = parseInt(percentageListened.dataset.bookDur);
					}
					//total duration from the first book until current position of current book
					const lPD =  percentageListened.listenedDuration + _currTime;

					//update the elapsed time in the tooltip
					percentageListened.dataset.tooltip = percentageListened.dataset.tooltip.replace(/\[([\d\:]+)\]/, `[${ toHhMmSs(lPD)}]`);
					
					// keep percentage number with 1 decimal digit, we keep it as string so whole number such as 21 can keep the decimal to be '21.0'
					const _newLPP = (100 * lPD/percentageListened.bookDur).toFixed(1);
					
					// if there is a change in percentage
					if( _newLPP != lPP ){//note that _newLPP is a string, lPP is number
						//save the new listenedPercent, note that we keep
						percentageListened.listenedPercent = _newLPP;
						//change the listened Percent text and progress UI
						percentageListened.innerText = `${_newLPP}%`;
						percentageListened.style.backgroundSize = `${_newLPP}% 100%`;
					}

					// 5. Update buffer canvas every 10 times update the preload-bar. With _HEAVY_UPDATE_INTERVAL=0.01 (1%), this update only run every 10% of audio duration, meanning this update only 10 times for each chapter
					/* if(forceHeavyUIUpdate === true || ++_ubcCounter == 10){
						// trCanvas.drawCanvas();
						_ubcCounter = 0; //reset counter
					} */
					// this line should be inside above if statement, i keep it here for purpose of test
					trCanvas.drawCanvas(); // update the audio 'played' and 'buffered' canvas bars
				}
				
			}

			//function round2decimals(num){return ((num*100)<<0) / 100}
			
			/* IIFE (Immediately Invoked Function Expression) function to show the audio playback offset time (in the form of a tooltip) at current mouse position when user mouse moves on .ap--track area */
			const audioTimeTooltip = (function movingAudioTimeTooltip(){
				// the area that take mouse move event to show the tooltip
				const apTrackElm = document.querySelector(".ap--track"); // .ap-info ap-progress-container
				//the element that contain the tooltip content
				const elMovingTimerLabel = apTrackElm.querySelector("div.moving-audio-offset-time");
				
				const apInforEl = document.querySelector(".ap-info");
				let _PROGRESS_WIDTH, _PROGRESS_LEFT_POINT, _PROGRESS_RIGHT_POINT;

				//fix the top of the moving toltip to be the top of progress-bar container
				elMovingTimerLabel.style.top = (document.querySelector(".ap-progress-container").offsetTop + 4) + 'px'; //note that --arrow-size is 5px
				
				/* Function to calculate dimension to generate content and position the tooltip */
				function _calcDimension(){
					//const _bcr = apInforEl.getBoundingClientRect();
					// required .ap-info, ap-progress-container and .ap-progress-container all have padding-left and right is 0, so that the width of .ap-info is exactly the same the width of .ap-progress-bar
					_PROGRESS_WIDTH = apInforEl.offsetWidth;
					// the left position that start of progress-bar inside .ap--track
					_PROGRESS_LEFT_POINT = apInforEl.offsetLeft;
					// the right position that start of progress-bar inside .ap--track
					_PROGRESS_RIGHT_POINT = _PROGRESS_WIDTH + _PROGRESS_LEFT_POINT;
					
					//console.log(_PROGRESS_WIDTH, _PROGRESS_LEFT_POINT, _PROGRESS_RIGHT_POINT);
				}

				_calcDimension();

				/* handle the mousemove event to display and position the tooltip. I have borrowed some idea from https://codepen.io/EricPorter/pen/xdJLaG */
				function audioPositionHandler(_evt){
					//if(progressContainerElm !== _evt.target) return;

					//x position of mouse in relative to its target (which has same left and width with apTrackElm)
					const _x = _evt.offsetX;
					// the audio time at mouse position, but check the range that the .ap-progress-bar inside .ap--track
					const _tip = (_x >= _PROGRESS_LEFT_POINT && _x <= _PROGRESS_RIGHT_POINT) && _xDuration? toHhMmSs( _xDuration * (_x - _PROGRESS_LEFT_POINT) / _PROGRESS_WIDTH ) : "-:--";
					
					//console.log("time tooltip", (_x - _PROGRESS_LEFT_POINT) / _PROGRESS_WIDTH);
					
					elMovingTimerLabel.textContent = _tip;
					// set left attribute so that the tooltip moving with the mouse
					elMovingTimerLabel.style.left = _x + 'px';
					//elMovingTimerLabel.style.top = _evt.offsetY + 'px';

					_evt.stopPropagation();
				};
				apTrackElm.addEventListener("mousemove", audioPositionHandler, false);
				//movingTimeContainerElm.addEventListener("touchmove", audioPositionHandler, false);

				/* PUBLIC METHODS */
				return{
					/* function to re-calculate dimension when window resize */
					onresize: _calcDimension,
					// function to remove the events listeners that added by this object
					unplugEvents: _ => {
						movingTimeContainerElm.removeEventListener("mousemove", audioPositionHandler, false);
					}
				}
			})();
				
			/* ==========  VOLUME BUTTON & BAR  ========== */
			elVolumeBtn.addEventListener('click', volumeToggle, false);
			const elVolumeWrapper = elVolumeBar.closest(".ap-volume"); //elVolumeBar.parentNode.parentNode;
			elVolumeWrapper.addEventListener('mousedown', volumebarMD, false);
			elVolumeWrapper.addEventListener('mousemove', volumebarMM);
			document.documentElement.addEventListener('mouseup', seekingDone, false);
			//elVolumeWrapper.addEventListener('mouseup', seekingDone, false);

			function changeAudioVolume(_volume){
				_volume = parseFloat( _volume.toFixed(2) );
				let _vol = Math.max( Math.min(_volume, 1), 0); //volume should be from 0 to 1
				
				//volume already 0 or 1, cannot decrease/increase anymore
				if((xAudio.volume ===0 && _volume < 0) || (xAudio.volume ===1 && _volume > 1)) return;

				//update the new volume to xAudio and save to xState
				xState.audio.volume = xAudio.volume = _vol;
				//change the height of volume-bar accordingly
				elVolumeBar.style.height = _vol * 100 + '%';

				toast.showToast('Volume ' + (_vol * 100).toFixed() + '%');

				//toggle volume if when reach 0 or just got out of 0
				if( (_vol === 0 && !xAudio.muted) || (_vol > 0 && xAudio.muted)) volumeToggle.call(elVolumeBtn);
			}

			/* Get back VOLUME and MUTED state of the last session */
			//elVolumeBar.style.height = xAudio.volume * 100 + '%';
			changeAudioVolume(settingParam?.volume ?? 1); //use volume of last sesson
			
			//note that changeAudioVolume() above might set muted=false if volume>0, so to make sure if that is the volume-setting of last session, we need to force muted state to last session value
			xAudio.muted = !settingParam.muted; //get the inversed muted state from last session, so the next volumeToggle() call will get it back and by the same time, update the volume button UI
			volumeToggle.call(elVolumeBtn); //update UI

			//volumeLength = elVolumeBar.css('height');
			function volumeToggle() {
				if (xAudio.muted) {
					// if last time volume=0, when turn on make it 1
					if (xAudio.volume === 0) { //parseInt(volumeLength, 10) === 0
						/* volumeBar.style.height = '100%';
						xAudio.volume = 1; */
						changeAudioVolume(1);
					}
					else {
						//otherwise, use old volume
						elVolumeBar.style.height = xAudio.volume * 100 + '%'; //volumeLength;
					}
					xAudio.muted = false;
					this.classList.remove('muted');
				}
				else {
					xAudio.muted = true;
					elVolumeBar.style.height = 0;
					this.classList.add('muted');
				}
				//save muted state into xState
				xState.audio.muted = xAudio.muted;
			}

			function volumebarMD(evt) {
				rightClick = (evt.button === 2) ? true : false; //evt.which === 3, evt.which was deprecated
				isSeeking = true;
				volumebarMM(evt);
			}

			function volumebarMM(evt) {
				let volumeLength = elVolumeBar.css('height');
				if (isSeeking && rightClick === false) {
					let value = moveBar(evt, elVolumeBar.parentNode, 'vertical') / 100;
					if (value <= 0) {
						//xAudio.volume = 0;
						changeAudioVolume(0);
						elVolumeBtn.classList.add('muted');
					}
					else {
						if (xAudio.muted) xAudio.muted = false;
						//xAudio.volume = value;
						changeAudioVolume(value);
						elVolumeBtn.classList.remove('muted');
					}
				}
			}

			/*===== *  Helpers *=====*/
			function extend(defaults, options) {
				for (let name in options) {
					if (defaults.hasOwnProperty(name)) {
						defaults[name] = options[name];
					}
				}
				return defaults;
			}

			Element.prototype.offset = function () {
				let el = this.getBoundingClientRect(),
					scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
					scrollTop = window.pageYOffset || document.documentElement.scrollTop;

				return {
					top: el.top + scrollTop,
					left: el.left + scrollLeft
				};
			};

			/* ==========  PUBLIC METHODS  ========== */
			return {
				//playAudio: tryingLoadAudio,
				updateTime: updateTime, // for update UI when the page got focus again
				setSource: srcControl.setSource,
				getFileSize: srcControl.getFileSize
			};
		}
	</script>

	<!-- SEARCH DROPDOWN JS -->
	<script>
		"use strict";
		/** Class to create search-drop-down (SDD) element 
			* @params
			*    @sddContainerQry: string store query selector to container that contains the new created sdd
			*    @_setting = { 
			* 			@displayOneLine: true,  // the sdd display on one line, text maybe truncated
			* 			@maxHeight: max Height of dropdown content, in px
			*          @options: array of option data definition
			*          @optgroups:  array of option group definition or Null if no group
			*          @render: {
			*             option: function to render the option html
			*             optgroup_header: function to render the option group header html
			*          },
			*          @callbacks: {
			*             onChange: callback function that is invoked when selected item changed
			*          }
			* 		See the loadDropdown function for more attributes of _setting
			* 		Item of option attribute look like: 
			* 			{
						@gId: "$11", //group id, must match the id of optgroups. If this is missing, the dropdown would not have group
						@value: "DBR.PDS1",	//value for the option
						@label: "[1998] Pháo đài số", //option label
						@disabled: if true, this group header and all its children options will be disbaled. User can see those options, can go through them but cannot select them
						@{someextra_attributes}: //some user-specified extra properties can be used to render the option or for searching/filtering
						@attr: { "attr-book-array": "[72]" } //collection of attribute names and value that will be added to the option for manupulating later
					}
				Item of optgroups attribute look like: 
					{
						@gId: "$6",	//id for the option to group into. Also used as value of optgroup
						@label: "The Lord of the Rings", //label of optgroup, which is used to render the optgroup header
						@disabled: if true, this option will be disbaled. User can see this option, can go through it but cannot select it
						@{someextra_attributes}: //some user-specified extra properties can be used to render the optgroup header
						@attr: { "attr-gid": "$6" } //collection of attribute names and value that will be added to the optgroup for manupulating later
					}
			* @PUBLIC PROPERTIES
			*    @value {string get/set}: the value of selected item. When set, it will not invoke callback function. User can call sdd.onchange() to invoke the callback.
			*    @selectedIndex {number get/set}: the selectedIndex of selected item. When set, it will not invoke callback function. User can call sdd.onchange() to invoke the callback.
			*    @items {arrray of HTMLElement get}: list of all items
			*    @length {number get}: number of items
			*    @settings {json get}: the setting to create this SDD but {options} and {optgroups} has been removed
			*    @rootElement {HTMLElement get}: the root HTML Element that wrap all sdd
			*	  @displayElement {HTMLElement get}: the div element that left off to display the selected item when sdd closed
			*	  @hotKeys: list of hotkeys information that supported by SDD, in the form {task: task_id, kCode: evt.code of the pressed key, desc: task description}. Note that some keys in this list comprising with modifier-key set in setting.makeSelectKey can do another task
			* 
			* @PUBLIC FUNCTIONS
			*    @loadDropdown(_settingParam, selectInit): load data for the Dropdown, where _settingParam is user-defined setting, which later be added with default setting. selectInit is the index(number)/value(string) of initialized seleted item.
			*    @onchange(): function to invoke onChange(seletedItem) callback. This can be called after assign value/selectedIndex to make a new selectedItem to update the change
			*    @selectItem: see selectItem for details
			*    @sddUnregisterEvents: remove all event listener that added by this class
			* 	  @toggle: function to toggle (open/close) the dropdown
			* 
			* @USAGE: 
			*  Way 1, load sdd as create it: 
			*     const sddDropdown = new SddDropdown(".sdd-container", _setting);
			*  Way 2: create then load both setting and data at the same time. This way, _setting must contain attribute both for setting and data. See BookData.popuGrpBookTitles and BookData.popuBookTitles for example of this way
			*     const sddDropdown = new SddDropdown(".sdd-container");
			* 	Then
			* 		sddDropdown.loadDropdown(_setting
			* 	  Or
			*		sddDropdown.loadDropdown(_setting, ssData.sddChaps.LOAD_MODE_ENUM.All, 5);
			* Way 3: load the setting and then load the data, separatedly. See changBook() for the example using this
			* 		const sddDropdown = new SddDropdown(".sdd-container");
			* 		sddDropdown.loadDropdown(_setting, ssData.sddChaps.LOAD_MODE_ENUM.SettingLoadOnly); //this _setting does not have to has data options, optgroups
			*  	sddDropdown.loadDropdown({options:..., optgroups: ...}, ssData.sddChaps.LOAD_MODE_ENUM.DataLoadOnly);
		*/
		function SddDropdown(sddContainerQry, _settingParam) {
			let _uid = "id" + Math.random().toString(16).substr(2, 8); //class id for internally used
			if(!new.target) return console.error("SddDropdown class must be constructed with 'new' keyword");

			//private variables
			let _settings = null; //setting object for whole sdd class
			let _selectedItem, _activeOption, _items, _filteredItems;
			let _sddWrapper; //the root HTML element of whole sdd
			let _onChange  = null, _notifyFunction = console.warn; //store the onChange callback function which will be invoked when selected Item changes
			let sHighlite = null; //object that handle search and highlight function of the SDD
			let _hotKeysList; //array of shortcut keys supported by this SDD
			let _dropdownOpenFirstTime = true; //to identify first time open dropdown, so we can do something related to element dimension which only rendered when their wrapper appear
			//flag to tell if We do _rightAlignElems() for all marked-to-align-right elements (ones having attribute [data-rAlignGroup]) inside an option for collection of options (which can be inside a section or all options for sdd have no sections). Note that because _rightAlignElems() only work when all element need to be right-align are currently visible (otherwise, its width are all 0), so we can do right align in one of two cases: when dropdown open for the first time and all extra titles also visible OR dropdown already opened and all extra titles visible for the first time. That why we need this flag
			let _alignRightElementsDoneFlag = false;
			//flag to know if SDD might be very heavy when search because each SDD option has very complex html structure and SDD has too many options. See populateDropdown() to see the condition for this flag to be true. In heavy search mode, SDD wait the charater typed in search-box for some time then do the search, in normal mode SDD will search immediately when user typing in
			let _heavySearchMode = false;
	
			//wrap create core HTML into a function for nice code, only
			function makeSddCoreHtml(){
				const _CLEAR_SEARCH_BOX_SVG = `<svg viewBox="0 2 16 12"><path d="M6 2 0 8l6 6h10V2zm2 2 2 2 2-2 2 2-2 2 2 2-2 2-2-2-2 2-2-2 2-2-2-2z"/></svg>`; //clear search icon
				// can re-use the same svg already defined in main page to save few bytes: `<svg><use href="#icnSvgChapGroupIcon"></use></svg>`
				const _CLOSE_GROUP_SVG = `<svg viewBox="1 1 13 14"><path d="M1.5 1h2v1H2v12h1.5v1h-2l-.5-.5v-13zm6 6h-2L5 6.5v-2l.5-.5h2l.5.5v2zM6 6h1V5H6zm7.5 1h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 6h2V4h-2zm-3.5 6h-2l-.5-.5v-2l.5-.5h2l.5.5v2zM6 11h1v-1H6zm7.5 2h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 12h2v-2h-2zm-1-2H8v1h2zm0-5H8v1h2z"/></svg>`;
				//`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 20h1v1H1v-2h1zm20 0h-1v1h2v-2h-1zM1 5h1V4h1V3H1zm1 2H1v2h1zm0 4H1v2h1zm20-2h1V7h-1zm0 4h1v-2h-1zM2 15H1v2h1zm20 2h1v-2h-1zM5 4h2V3H5zm6 0V3H9v1zm2 0h2V3h-2zm6-1h-2v1h2zM5 21h2v-1H5zm4 0h2v-1H9zm4 0h2v-1h-2zm4 0h2v-1h-2zm4-17h1v1h1V3h-2zm-1 4v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1m-.999 2H19V8H5v2h14m1 4v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1m-.999 2H19v-2H5v2h14"/><path fill="none" d="M0 0h24v24H0z"/></svg>`;
				const _JUMP_TO_SELECTED = `<svg id="icnSvgJump2Selected" viewBox="2 2 20 20"><g fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="4"/><path d="M12 8v8m0 0 4-4m-4 4-4-4" stroke-linecap="round" stroke-linejoin="round"/></g></svg>`;
				const _DIACRATICS_OPTION = `<svg viewBox="0 0 15.98 16"><path d="M4 0h2v2h4v2H8.868a8.5 8.5 0 0 1-2.202 4.351c.8.388 1.691.617 2.633.646L10.274 6h2.453l3.25 10h-2.104l-.65-2H9.776l-.65 2H7.024l1.638-5.04A8.45 8.45 0 0 1 5 9.711 8.46 8.46 0 0 1 .5 11H0V9h.5a6.5 6.5 0 0 0 2.834-.649A8.5 8.5 0 0 1 1.752 6h2.27c.278.435.607.834.978 1.19A6.5 6.5 0 0 0 6.826 4H0V2h4zm8.574 12L11.5 8.697 10.427 12z"/></svg>`; //fill-rule="evenodd" clip-rule="evenodd"
				const _TOGGLE_EXTRA_TITLE = `<svg id="icnSvgToggleExtraTitlesBtn" viewBox="1 1 22 22"><path d="M9 22h6c5 0 7-2 7-7V9c0-5-2-7-7-7H9C4 2 2 4 2 9v6c0 5 2 7 7 7m8.5-4.92h-1.85m-2.68 0H6.5m11-3.76h-5.53m-2.7 0H6.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`; 

				/* CREATE STRUCTURE FOR SDD */
				const _sddWrapper = document.createElement("div");
				_sddWrapper.classList.add("sdd-wrapper");
				_sddWrapper.innerHTML = `<div class="sdd-controls"></div>
				<div class="sdd-dropdown-wrapper elm-hidden" role="listbox">
					<div class="input-wrapper">
						<input placeholder="🔍 Search..." type="text" class="sdd-search-box" pattern=".*\\S.*" title="" required>
						<div class="sdd-control-buttons">
							<button class="clear-input-button" data-tooltip="Xóa ô tìm kiếm" data-tooltip-location="bottom" style="--data-translateX: -99%;">${_CLEAR_SEARCH_BOX_SVG}</button>
							<button class="search-diacritics-option-button" data-tooltip="Tìm kiếm bỏ dấu (chữ nét, nền vàng) hay tìm kiếm nguyên dấu (chữ nhòe)" data-tooltip-location="bottom" style="--data-translateX: -99%;">${_DIACRATICS_OPTION}</button>
							<button class="toggle-extra-title-button" data-tooltip="Ẩn/Hiện tiêu đề phụ" data-tooltip-location="bottom" style="--data-translateX: -99%;">${_TOGGLE_EXTRA_TITLE}</button>
							<button class="jump-to-selected-item-button" data-tooltip="Cuộn tới mục đang được chọn" data-tooltip-location="bottom" style="--data-translateX: -89%;">${_JUMP_TO_SELECTED}</button>
							<button class="close-open-groups-button" data-tooltip="Đóng/Mở nhóm mục" data-tooltip-location="bottom" style="--data-translateX: -99%;">${_CLOSE_GROUP_SVG}</button>
						</div>
					</div>
					<div class="sdd-dropdown-content circus-background"></div>
					<div class="sdd-dropdown-border-bottom sdd-dropdown-border-bottom-stripes"></div>
				</div>`;
		
				const sddContainer = document.querySelector(sddContainerQry); //the container
				/* Using insertBefore(), insertAdjacentElement() and Element.insertAdjacentHTML(), there can be multiple option for user to add SDD to DOM. But it is rarely used, so I don't implement it */
				sddContainer.appendChild(_sddWrapper); //add sdd to the DOM
				return _sddWrapper;
			}
			
			_sddWrapper = makeSddCoreHtml();
			// some element variables
			const representativeDiv = _sddWrapper.querySelector(".sdd-controls"); //part that display when sdd closed
			const sddDropdownWrapper = _sddWrapper.querySelector( ".sdd-dropdown-wrapper" ); //wrapper of all hidden part when sdd closed

			const sddInputWrapper = sddDropdownWrapper.querySelector(".input-wrapper"); //wrapper of search textbox and few buttons
			const sddSearchBox = _sddWrapper.querySelector(".sdd-search-box"); //the search box

			const sddDropdownContent = _sddWrapper.querySelector( ".sdd-dropdown-content" ); //the container of all sdd options
			let sddDropdownStatusBar;
			
			/* PUBLIC PROPERTIES */
			Object.defineProperty(this, "value", {
				get() {
					return _selectedItem.value;
				},
				set(value) {
					if(_selectedItem?.value == value) return; //no new item to select
					selectItem(value.toString(), true); //no fire onChange event
				}
			});
	
			Object.defineProperty(this, "selectedIndex", {
				get() {
					return _items.indexOf(_selectedItem);
				},
				set(index) {
					index = parseInt(index);
					if (isNaN(index)) {
						return console.warn("SDD selectedIndex set: index is not a number");
					}
					if(_selectedItem == _items[index]) return; //no new item to select
					selectItem(index, true); //no fire onChange event
				}
			});

			Object.defineProperty(this, "selectedItem", {
				get() {
					return _selectedItem;
				},
				set(item) {
					if (_items.indexOf(item) > -1 && item != _selectedItem) {
						selectItem(item, true); //no fire onChange event
					}
					
				}
			});
	
			/* get all items of SDD, each item is an option which internally is asss div.sdd-dropdown-item */
			Object.defineProperty(this, "items", {
				get() {
					return _items;
				},
				set(val) {
					console.warn("sdd.items property is not changable");
					return null;
				}
			});
	
			Object.defineProperty(this, "length", {
				get() {
					return _items.length;
				},
				set(val) {
					console.warn("sdd.length property is not changable");
					return null;
				}
			});
	
			/* get the SDD setting config */
			Object.defineProperty(this, "settings", {
				get() {
					//return a deep copy of _setting, so that outside code cannot change the internal _settings
					return Object.assign({}, _settings);
				},
				set(val) {
					console.warn("sdd.setting property is not changable");
					return null;
				}
			});

			/* get/set the diacriticsFilter mode. true: filter diacritics before searching. false: no filter */
			Object.defineProperty(this, "diacriticsFilterMode", {
				get() {
					return _settings.diacriticsFilterMode;
				},
				set(val) {
					//this also changes sHighlite.diacriticsFilterMode and re-filter SDD items
					setDiacriticsFilterMode( Boolean(val) );
				}
			});

			/* get the session states that need to be saved across page session. For now, it inculdes two states: diacriticsMode and hideExtraTitle */
			Object.defineProperty(this, "savedState", {
				get() {
					let _returnedState = {};
					//make the whole json as object that saved into localStorage
					_returnedState[_settings.name] = _sddState
					return _returnedState;
				}
			});
	
			/* get the wrapper element which wrap the whole SDD */
			Object.defineProperty(this, "rootElement", {
				get() {
					return _sddWrapper;
				},
				set(val) {
					console.warn("sdd.rootElement property is not changable");
					return null;
				}
			});
			
			/* get the element which is left when SDD closed */
			Object.defineProperty(this, "displayElement", {
				get() {
					return representativeDiv;
				}
			});
	
			/* get the SDD Load Mode enum */
			Object.defineProperty(this, "LOAD_MODE_ENUM", {
				get() {
					//return a deep copy of _setting, so that outside code cannot change the internal _settings
					return loadSDDMode;
				}
			});
			//list of hotkeys
			Object.defineProperty(this, "hotKeys", {
				get() {
					//sole purpose is to initialize _hotKeysList variable. This not the best way to implement the hot keys list. But to initialize _hotKeysList in one pieces (inside onKeyDown for the callback - which use internal variables - to work), but still provide global property (sdd.hotKeys) for class-outside scope

					//run onKeyDown without {evt} parameter to get _hotKeysList if it is not existed, yet
					if(!_hotKeysList) _hotKeysList = onKeyDown().map(_hotKey => ({kCode: _hotKey.kCode, desc: _hotKey.desc}) ); //filter to export only kCode, desc

					return _hotKeysList;
				}
			});
			
			/** Select adjacent item without firing onChange event
				* @param _dir {1, -1}: 1 next item. -1: previous item
				* @return null: if adjacent item is out of bound (index -1 or _items.length) or _selectedItem currently undefined
				*/
			const goAdjacent = _dir => {
				let _currIdx = _items.indexOf(_selectedItem);

				//_selectedItem currently undefined, return null
				if(_currIdx == -1) return null;
				_dir = _dir == 1? 1 : -1;
				_currIdx += _dir;

				//out of bound, return null
				if(_currIdx < 0 || _currIdx >= _items.length) return null;

				selectItem(_currIdx, true); //no fire onChange event
				return _items[_currIdx];
			}

			/** Escapes a string for use within HTML. **/
			const escape_html = (str) => {
				return (str + "")
					.replace(/&/g, "&amp;")
					.replace(/</g, "&lt;")
					.replace(/>/g, "&gt;")
					.replace(/"/g, "&quot;");
				};
			/** populate options and optGroup for Dropdown 
				* @param initSelectedItem {string, number}: the default item to be the selected one when dropdown created. if string, it is value of selected item. If number, it is selected index
			*/
			function populateDropdown(initSelectedItem) {
				if(!_settings) return; // if there is no setting assign, do nothing

				sddDropdownContent.innerHTML = "";
	
				representativeDiv.classList.toggle( "single-line", !!_settings.displayOneLine );

				sddDropdownStatusBar = document.createElement("DIV");
				sddDropdownStatusBar.classList.add("sdd-dropdown-status-bar", "statusbar-hidden");
				sddDropdownStatusBar.innerText = "Statusbar";
				sddDropdownContent.appendChild(sddDropdownStatusBar);
	
				/** make item for dropdown 
					* @param optionData {json}: the pure data to create option. The {_settings.render.option} function will make option HTML from pure data
					* @param i {integer}: index of the option in {_settings.options}, mostly for the purpose of adding order number  (for now), which is in <em> element and being added to the first child of option
					* @param grpDisabled {boolean}: if parent group is disabled, all its children option being disabled accordingly.
				*/
				const makeOptionItem = (optionData, i, grpDisabled = false) => {
					const item = document.createElement("div");
					item.classList.add("sdd-dropdown-item");
					if (grpDisabled || optionData.disabled) item.classList.add("disabled");
					item.setAttribute("role", "option");
		
					//properties
					item.value = optionData[_settings.valueField].toString(); //default _settings.valueField is "value"
					item.setAttribute("value", item.value);
					item.dataset.index = i;
		
					//add attributes
					if ("object" == typeof optionData.attr) {
						const keys = Object.keys(optionData.attr);
						for (const key of keys) {
							if (optionData.attr.hasOwnProperty(key))
							item.setAttribute(key, optionData.attr[key]);
						}
					}
		
					//render inner HTML
					item.innerHTML = //`<em>${pad(i + 1, 2)}.</em>&emsp13;` +
						_settings.render.option(optionData, escape_html);
					
					//create <em> element to store the order-number of current option
					let _em = document.createElement("em");
					_em.classList.add("item-order");
					//data-rAlignGroup attribute to mark that this item is right-align
					_em.setAttribute("data-rAlignGroup", "itemOrder");
					_em.innerHTML = pad(i + 1, 2) + ".";

					//if first child of option is an <DIV>, add order-number to be the first child of that DIV. Otherwise, add <em> is the first child of item itself
					const _firstChild = item.firstChild;
					if(_firstChild instanceof HTMLDivElement) _firstChild.prepend(_em)
					else item.prepend(_em);

					return item;
				};

				/* make no-result notification in the form of an option item */
				const makeNoFoundItem = () => {
					const item = document.createElement("div");
					item.classList.add("no_results", "elm-hidden"); //initially, it is hidden
					item.innerHTML = _settings.render["no_results"]();
					return item;
				};
	
				/** Create optGroup
					* @param grp {json}: item of _settings.optgroups array, contain information about a group
					* @param grpI {number}: the index of current group in _settings.optgroups
					*/
				const makeOptionGroup = (grp, grpI) => {
					let _optGroupDiv = document.createElement("DIV");
					_optGroupDiv.classList.add("optgroup");
					_optGroupDiv.dataset.group = grpI;
					if (grp.value) _optGroupDiv.setAttribute("value", grp.value);
		
					const _chkBxId = "grpChkbox_" + _uid + "_" + grpI;
					let _grpLabel = escape_html(grp.label);
					if ("function" == typeof _settings.render.optgroup_header)
						_grpLabel = _settings.render.optgroup_header(grp, escape_html);
					_grpLabel = _grpLabel; //'<em></em>&emsp13;' + _grpLabel;
		
					_optGroupDiv.innerHTML = `<input type="checkbox" id="${_chkBxId}" attr-grpno="${ grp.gId }" checked>
						<label for="${_chkBxId}" class="optgroup-header ${ !!grp.disabled ? "disabled" : "" }">${_grpLabel}</label>
						<section></section>`;
		
					//add attributes
					if ("object" == typeof grp.attr) {
						const keys = Object.keys(grp.attr);
						for (const key of keys) {
							if (grp.attr.hasOwnProperty(key))
							_optGroupDiv.setAttribute(key, grp.attr[key]);
						}
					}
		
					return _optGroupDiv;
				};

				//generate group + options elements
				if (Array.isArray(_settings.optgroups)) {
					_settings.optgroups.forEach((grp, grpI) => {
						let _optGroupDiv = makeOptionGroup(grp, grpI);
						sddDropdownContent.appendChild(_optGroupDiv);
		
						const sectionElem = _optGroupDiv.querySelector("section");
		
						//add options having the same gId
						const _gId = grp[_settings.optgroupField] ; // default of _settings.optgroupField is "gId"
						_settings.options.forEach((optionData, i) => {
							if (optionData[_settings.optgroupField] == _gId)
							sectionElem.appendChild(makeOptionItem(optionData, i, !!grp.disabled));
						});
					});
				} else {
					// Loop All Options and Create Custom Option for Each Option And Append it to Inner Wrapper Element
					_settings.options.forEach((optionData, i) => {
						sddDropdownContent.appendChild(makeOptionItem(optionData, i));
					});
				}

				// the SDD control button which toggle extra titles
				const _toggle_extra_title_button = sddInputWrapper.querySelector(".toggle-extra-title-button");
				// show/hide the .toggle_extra_title_button button depends on if there is any SDD option (.sdd-dropdown-item) having div.item-2nd-main-div child (which contain the extra title)
				_toggle_extra_title_button.classList.toggle("elm-hidden", !sddDropdownContent.querySelector('div.sdd-dropdown-item > div.item-2nd-main-div'));
				// set hidden state for all extra titles (in div.item-2nd-main-div elements) based in the user-choice of last time SDD being loaded options data. The state of extra title is stored in attribute "attr-extra-title-hidden" of toggle_extra_title_button. We hide or show extra title by adding/removing '.hideOptionExtraTitle' class to _sddWrapper, css will take care the rest
				_sddWrapper.classList.toggle("hideOptionExtraTitle", _toggle_extra_title_button.hasAttribute("attr-extra-title-hidden"));

				//add no-result like an option
				sddDropdownContent.appendChild(makeNoFoundItem());

				// delete no-longer-needed data to save some memory
				_settings.options.length = 0;
				delete _settings.options;
				//optgroups not always exists
				let _optGrpLength = 0; //store number of optGroups if there any
				//remember the number of optGroup and delete the optgroups array in _setting 
				_settings.optgroups && (_optGrpLength=_settings.optgroups.length, _settings.optgroups.length = 0);
				delete _settings.optgroups;
				
				//store all items elements
				_items = Array.prototype.slice.call( sddDropdownContent.querySelectorAll("div.sdd-dropdown-item") ); //array of all option items

				/* for now, I use this naive approach to identify when SDD might be in heavy search mode which make search very slow */
				//has more than 200 options and each option has .item-2nd-main-div which play as extra title
				if(_items.length > 200 && _items[0].querySelector(".item-2nd-main-div.subTitle")){ // ".item-2nd-main-div"
					_heavySearchMode = true;
				
					//_settings.callbacks.notify(_settings.name + " debug: HEAVY search mode", {toastType: toast.ToastType.Error, persistance: true});
				}
				else _heavySearchMode = false;

				// add/remove class to search-diacritics-option-button to inform user if SDD is in heavy search mode
				sddInputWrapper.querySelector("button.search-diacritics-option-button").classList.toggle("heavySearchMode", _heavySearchMode);
				// if _heavySearchMode, we set the highlight mode to just highlight the very first match instead of all matches
				//if(sHighlite) sHighlite.highlightAll = !_heavySearchMode;

				//console.log( _settings.name + (_heavySearchMode? " debug: HEAVY search mode":"debug: Light search mode"));
	
				const sddSearchBox = _sddWrapper.querySelector(".sdd-search-box");
				sddSearchBox.placeholder = "🔍 " + _settings.searchBoxPlaceholder.replace("{_items_length}", _items.length) //`🔍 Search in ${_items.length} items ...`;
				//add the number of optGroups if there are any, use a trick on 1st param of .replace function
				.replace((_optGrpLength? '...': null),  `(${_optGrpLength} nhóm) ...`);
	
				//if ([null, undefined].includes(initSelectedItem)) initSelectedItem= 0;
				if(![null, undefined].includes(initSelectedItem) && "function" == typeof selectItem) {
					selectItem(initSelectedItem, false); //force raising onchange() event and invoking SDD.callbacks.onChange() callback fn.
				}
			}
	
			/* The following provides all the internal functions for dropdown to work. */

			/* delegation events handler catched on sddDropdownContent to handle click event on its div children, each of them is a dropdown item */
			function dropdownItemClickDelegation(evt) {
				let target = evt.target.closest(".sdd-dropdown-item");
				if (target) setSelected(target);
				evt.stopPropagation(); //prevent bubbling up
			}
	
			/** Sets the selected item in the dropdown menu of available options. *
				* @param option {HTMLElement}: the option to be set active
				* @param scroll {boolean, true}: scroll to its position or not
				* @param toMiddle {boolean, false}: if true, scroll so that the option is in the middle of its container.
				* @param behavior {"smooth", "auto" or "instant"} the animation scroll mode. see scroll() in mdn for more. If this is not set, @behavior will take value according to value of @toMiddle param (true -> "smooth", false -> "auto")
			*/
			function setActiveOption(option, scroll = true, toMiddle = false, behavior) {
				if (!option) return;
				//only apply smooth scroll behavior when scroll to middle
				behavior = behavior ?? (toMiddle ? "smooth" : "auto");

				//because _selectedItem is set active everywhere, so just remove it here for sure
				_selectedItem && _selectedItem.classList.remove("is-active");

				if(option === _activeOption) {
					option.classList.add("is-active"); //in-case its class was reset in clearSearch
					if (option && scroll) scrollToOption(option, behavior, toMiddle); //scroll to old active option in-case it is moved out of view
					return;
				}
	
				//clear old active
				//sddDropdownContent.querySelectorAll(".is-active").forEach(_itemElem => _itemElem.classList.remove("is-active"));
				_activeOption && _activeOption.classList.remove("is-active");
	
				//update new active option
				option.classList.add("is-active");
				_activeOption = option;
	
				if (scroll) scrollToOption(option, behavior, toMiddle); //scroll to active option
			}
	
			/** Get adjacent option item
				@param option {HTMLElement}: the current option to get its adjacent (which may not be adjacent DOM elements due to optGroup and filter)
				@parma direction {integer, 1}: -1 Go next down; 1: go next Up
					= -100 go Top, =100: go Bottom
					= -50: previous page, =50: next page
					= -35, 35, -36, 36: 
						-35: if active option not the very first one, go to the very first visible of the same group with current active option.Otherwise, go to the first visible option of previous visible option group
						35: go to first visible option of next visible option group (does not matter where current active option is)
						-36: go to last visible option of previous visible option group (does not matter where current active option is)
						36: if active option not the very last one, go to the very last visible of the same group with current active option. Otherwise, go to the last visible option of next visible option group
					= 0: just scroll to the selected Item
				@param makeSelect {boolean, false}
					False: just make new option active
					True: make new option to be selected item, and fire onChange event
			*/
			function getAdjacent(option, direction = 1, makeSelect = false) {
				const allItems = _filteredItems ?? _items; //depend on being filtered or not

				// no matched items, then nothing todo
				if(allItems.length == 0) return;

				let _currIdx = -1;
	
				//home and End key
				if ([100, -100].includes(direction)) {
					_currIdx = direction == 100 ? allItems.length - 1 : 0;
				}
				else {
					_currIdx = allItems.indexOf(option);
					if (_currIdx == -1) {
						_currIdx = 0;
					}
					else{
						const len = allItems.length;
						
						if(direction == 0){
							//nothing to do
						}
						//upArrow and downArrow key
						if ([1, -1].includes(direction)){
						_currIdx = (_currIdx + direction + len) % len;
						}

						//leftArrow and rightArrow key, go to very last/first visible option of the prev/next group
						if ([35, -35, 36, -36].includes(direction)){
							const optGroupCtn = option.closest(".optgroup");
							//no optGroup at all, nothing todo
							if(!optGroupCtn) return;

							//get all visible options of current group
							const _allVisibleOptions = [...optGroupCtn.querySelectorAll(".sdd-dropdown-item:not(.elm-hidden)")];

							//find the very first at(0) or last at(-1) visible option of same option group. direction = -35, 35 is go to first option; = -36,36 is go to last option
							let _adjOption = _allVisibleOptions.at(Math.abs(direction) == 35? 0: -1);

							//if current active option is actually the first/last option of current optGroup OR when go to first option of next group OR go to last option of previous group. In one of these case, we just go to first
							if(_adjOption == option || [35, -36].includes(direction) ){
								//all visible optGroups of SDD
								const _allVisibleOptGroups = [...sddDropdownContent.querySelectorAll(".optgroup:not(.elm-hidden)")];
								//get the adjacent visible optGroup Index. direction = -35, -36 is go to previous option group; = 35,36 is go to next option group
								const _adjOptGroupIndex = _allVisibleOptGroups.indexOf(optGroupCtn) + (direction < 0 ? -1 : 1);
								//check if it is not the very first/last visible option group
								if(_adjOptGroupIndex > -1 && _adjOptGroupIndex < _allVisibleOptGroups.length){
									//get first/last visible option of _adjOptGroupIndex option group. direction = -35, 35 is go to first option; = -36,36 is go to last option
									_adjOption = [..._allVisibleOptGroups[_adjOptGroupIndex].querySelectorAll(".sdd-dropdown-item:not(.elm-hidden)")].at(Math.abs(direction) == 35? 0: -1);
								}
							}
							
							_currIdx = allItems.indexOf(_adjOption);
						}

						//PageUp and PageDown keys
						if ([50, -50].includes(direction)) {
							//container height
							const _ctnHeight = sddDropdownContent.offsetHeight; //getBoundingClientRect().height;
							
							if(direction == 50){ //PageDown
								const _currTop = allItems[_currIdx].getBoundingClientRect().top;
								let i = _currIdx + 1;
								while(i < len){ //go down, search for first item of next page
									if(allItems[i].getBoundingClientRect().bottom - _currTop > _ctnHeight) break;
									i++;
								}
								_currIdx = Math.min(i - 1 , len - 1);
							}
		
							if(direction == -50){ //PageUp
								const _currBottom = allItems[_currIdx].getBoundingClientRect().bottom;
								let i = _currIdx - 1;
								while(i >= 0){  //go up, search for first item of previous page
									if(_currBottom - allItems[i].getBoundingClientRect().top > _ctnHeight) break;
									i--;
								}
								_currIdx = Math.max(i + 1, 0);
							}
						}
					}
				}
	
				const _chosenOption = allItems[_currIdx];
				if(makeSelect)
					//set adjacent option to be selected item, fire onChange() event but not close the dropdown
					setSelected(_chosenOption, false, false);
				else {
					//set adjacent option to be active without closing the SDD, so we need to handle the collapsed group and animation effect properly

					//function to set active option and animation effect for each case
					const _setAndScroll2ActiveOption = _ =>{
						if(direction == 0) 
							//scroll to selected option: smooth animation, middle of screen
							setActiveOption(_chosenOption, true, true, 'smooth') 
						else if([100,-100].includes(direction))
							//jump to beginning and end of SDD list: smooth animation, not necessarily middle of screen
							setActiveOption(_chosenOption, true, false, 'smooth') 
						else
							//othercase, just set active option with 'not smooth, not middle'
							setActiveOption(_chosenOption);
					}					
				
					//open optGroup containing the chosen option if there is any and it is closed and reveal the group header if the active option if the first visible option of its group
					const _optGroupFather = _chosenOption.closest(".optgroup");

					//no group at all
					if(!_optGroupFather) _setAndScroll2ActiveOption()
					else {//having group, need to handle the case group collapsed and the active option is the very first visible one of its group
						
						//function to scroll into option, then if it is the fist visible of its group, scroll to the header
						const _scroll2headerOrOption = _ => {
							//first, set active option and scroll to it
							_setAndScroll2ActiveOption();

							// show the group header if _currIdx is the top visible option of its group.
							// The condition is: if _currIdx is very top one (=0) 
							// OR its previous visible option is in another group (_chosenOption.getAttribute("attr-gid") !== allItems[_currIdx - 1].getAttribute("attr-gid")). Also, the direction has to be scroll up (direction < 0), because when scroll down and if we scroll to the header, the option might be hidden at the bottom of SDD
							if( _currIdx==0 || (_optGroupFather !== allItems[_currIdx - 1].closest(".optgroup") && direction < 0) )
								scrollToOption(_optGroupFather.querySelector(".optgroup-header"), 'smooth', direction == 0);
						}

						//if optGroup already open, just scroll to the option
						if(_optGroupFather.firstChild.checked) _scroll2headerOrOption()
						else{
							//wait for transition finish, then scroll
							_optGroupFather.lastChild.addEventListener('transitionend', 
								function _tmpFnc(e) {
									// remove this event listener so it only gets triggered once
									e.target.removeEventListener('transitionend', _tmpFnc);
									//scroll to the option
									_scroll2headerOrOption();
								}
							);
							//open the group, which will trigger event above
							_optGroupFather.firstChild.checked = true;
						}
					}
				}
			}
	
			/* Handle keydown event on search input textbox to move to another option or select it
			NOTE: if user hold ctrl+shift keys together (this key would be changed in _settings.makeSelectKey) when active new option, that option would be selected immediately without closing the dropdown, still onChange() event fires
			*/
			function onKeyDown(evt) {
				//remove the class so that hover is diseffective on option
				if(sddDropdownContent.classList.contains("allow-hover-on-item"))
					sddDropdownContent.classList.remove("allow-hover-on-item");

				//console.log(evt.code + " - " + evt.which); //ctrlKey, shiftKey
				
				// if user hold ctrl+shift keys together (or any modifier-key set in setting.makeSelectKey) when active new option, that option would be selected immediately without closing the dropdown, still onChange() event fires
				let _makeSelect = false;
				if(evt instanceof KeyboardEvent && _settings.makeSelectKey.trim() !==""){
					const _keyName = _settings.makeSelectKey.trim().toUpperCase();
					_makeSelect = true;
					if(_keyName.includes("CTRL")) _makeSelect &= evt.ctrlKey || evt.metaKey; //metaKey is controlKey in MAC, Window key in Window
					if(_keyName.includes("SHIFT")) _makeSelect &= evt.shiftKey;
					if(_keyName.includes("ALT")) _makeSelect &= evt.altKey;
				}

				//const _NO_MODIFIER_KEY = evt? !(evt.altKey || evt.shiftKey || evt.ctrlKey || evt.metaKey) : true;

				/* The evt.key to get the character, while the evt.code to get the “physical key code”. For example, evt.key=Shift while evt.code=ShiftLeft OR when user click shift+z: evt.key=Z while evt.code=keyZ */

				//full list of hotkeys with callback functions. See the comments on function SddDropdown.prototype.runHotkey below to see the format and meaning of each shortcut
				const hotkeyOptions = [
					// up: go previous option
					{task: "sdd_prevOption", kCode: ["ArrowUp"], ignoreModifier: true, desc: "Mục ngay trước.", noNotify: true, callback: () => getAdjacent(_activeOption, -1, _makeSelect)},
					// down: go to next option
					{task: "sdd_nextOption", kCode: ["ArrowDown"], ignoreModifier: true, desc: "Mục ngay sau.", noNotify: true, callback: () => getAdjacent(_activeOption, 1, _makeSelect)},
					
					// PageUp: go to option one page above
					{task: "sdd_pageUpOption", kCode: ["PageUp"], ignoreModifier: true, desc: "Lên một trang.", noNotify: true, callback: () => {
						//if(evt.shiftKey) return; //with shiftKey is for another task

						evt.preventDefault(); //prevent default because some browser Ctrl + PageUp switch the previous tab
						getAdjacent(_activeOption, -50, _makeSelect);
					}},
					// PageDown: go to option one page below
					{task: "sdd_pageDownOption", kCode: ["PageDown"], ignoreModifier: true, desc: "Xuống một trang.", noNotify: true, callback: () => {
						//if(evt.shiftKey) return; //with shiftKey is for another task

						evt.preventDefault(); //prevent default because some browser Ctrl + PageDown switch the next tab
						getAdjacent(_activeOption, 50, _makeSelect);
					}},
					
					// arrowLeft: go to first option of previous filtered optGroup
					{task: "sdd_prevFilterOptGrpFirstOption", kCode: ["ArrowLeft"], ignoreModifier: true, desc: "Tới mục đầu tiên của nhóm hiện tại (hoặc nhóm ngay trước).", noNotify: true, callback: () => {if(!evt.altKey) getAdjacent(_activeOption, -35, _makeSelect)}},
					// arrowRight: go to first option of next filtered optGroup
					{task: "sdd_nextFilterOptGrpFirstOption", kCode: ["ArrowRight"], ignoreModifier: true, desc: "Tới mục đầu tiên của nhóm tiếp theo.", noNotify: true, callback: () => {if(!evt.altKey) getAdjacent(_activeOption, 35, _makeSelect)}},

					// Alt+arrowLeft: go to last option of previous filtered optGroup
					{task: "sdd_prevFilterOptGrpLastOption", kCode: ["Alt+ArrowLeft"], ignoreModifier: true, desc: "Tới mục cuối cùng của nhóm ngay trước.", noNotify: true, callback: () => {if(evt.altKey) getAdjacent(_activeOption, -36, _makeSelect)}},
					// Alt+arrowRight: go to last option of next filtered optGroup
					{task: "sdd_nextFilterOptGrpLastOption", kCode: ["Alt+ArrowRight"], ignoreModifier: true, desc: "Tới mục cuối cùng của nhóm hiện tại (hoặc nhóm tiếp theo).", noNotify: true, callback: () => {if(evt.altKey) getAdjacent(_activeOption, 36, _makeSelect)}},

					// Ctrl+Home: go to the very first option
					{task: "sdd_firstOption", kCode: ["Ctrl+Home"], desc: "Tới mục đầu tiên.", callback: () => {{getAdjacent(_activeOption, -100, _makeSelect); evt.preventDefault()} }},
					// Ctrl+End: go to the very last option
					{task: "sdd_lastOption", kCode: ["Ctrl+End"], desc: "Tới mục cuối cùng.", callback: () => {getAdjacent(_activeOption, 100, _makeSelect)}},

					// Home, End: go back to selected option
					{task: "sdd_gotoSelectedOption", kCode: ["Home", "End"], desc: "Quay về mục đang được chọn.", callback: () => {getAdjacent(_selectedItem, 0)}}, //setActiveOption(_selectedItem, true, true)

					//Shift+Backspace: clear the search box
					{task: "sdd_clearSearchbox", kCode: ["Shift+Backspace"], desc: "Xóa ô tìm kiếm.", callback:_ => {
						clearSearch();
					}},
					
					//Insert: change the diacritics search mode
					{task: "sdd_toggleDiacriticsMode", kCode: ["Insert"], desc: "Đổi chế độ giữ dấu/bỏ dấu trước khi tìm kiếm.", callback: () => {setDiacriticsFilterMode(evt);evt.preventDefault();}},

					//Escape: close the dropdown
					{task: "sdd_closeDropdown", kCode: ["Escape"], desc: "Đóng Dropdown.", callback: toggleDropdown},

					//Ctrl+Insert: toggle (show/hide) the extra titles
					{task: "sdd_toggleExtraTitles", kCode: ["Ctrl + Insert"], desc: "Ẩn/hiện tiêu đề phụ.", callback:_ => toggleExtraTitles(evt)},

					//Tab: toggle the optGroups
					{task: "sdd_closeOptGroups", kCode: ["Tab"], desc: "Đóng/mở tất cả các nhóm mục.", callback: function(){
						evt.preventDefault(); //prevent default so that searchBox not loose focus
						toggleOptGroups.call(this, evt, 0); //0 for Tab key
					}},
					{task: "sdd_closeOptGroupsExceptSelective", kCode: ["Shift + Tab"], desc: "Đóng tất cả các nhóm mục ngoại trừ nhóm đang chứa mục được chọn và mục đang có con trỏ.", callback: function(){
						evt.preventDefault(); //prevent default so that searchBox not loose focus
						toggleOptGroups.call(this, evt, 1); //1 for Shift+Tab
					}},

					//Enter: select the option, close the dropdown
					{task: "sdd_selectOption", kCode: ["Enter", "NumpadEnter"], ignoreModifier:true, desc: "Chọn mục hiện tại. Bấm cùng phím Shift để chọn mục mà không đóng Dropdown.", callback: () => {
						//if _activeOption is a disabled one, don't make it selected
						if(_activeOption.classList.contains("disabled")) {
							console.warn("SDD setSelected: disabled item cannot be selected.");
							return _notifyFunction(`Sách '${_activeOption.textContent}' bị disabled, không thể chọn.`);
						}
						setSelected(_activeOption, false, !evt.shiftKey);
					}}
				];

				//if onKeyDown() is invoked without {evt} parameter, it just return value for _hotKeysList variable, no key is catched
				if(!evt){
					//extract hot keys list without callback, which is useless for outside scope
					const _hotKeysListTmp = hotkeyOptions.map(hotkey => {
						let _temp = Object.assign({}, hotkey); //create deep copy
						delete _temp.callback; //remove the {callback} attribute
						return _temp;
					});

					return _hotKeysListTmp; //return the hotKey List
				}

				//search if a key just press matched any key specify above, then take the corresponding action. Note that don't apply preventDefault() on this, otherwise, we can't use arrow keys to move between character in searchbox
				SddDropdown.prototype.runHotkey(evt, hotkeyOptions, 1, _settings.callbacks.notify);
		
				//this is necessary to stop some letter and digit key to propagate above, and maybe preventDefault above in the DOM, so those key does not work correctly (such as key 0 (which change audio speed to 1.0) has been preventDefault in the Document)
				evt.stopPropagation();
			}

			/** function to invoke and notify an action when a specified hotkey associated with that fuction is pressed.
				* @param evt {KeyboardEvent}: the event associated with key action((key down, key up or key press)
				* @param hotkeyOptions {json}: list of all supported hotkey. See SddDropdown.onKeyDown function for an example of its format. Each item is a json has following attributes
				* 		@propety task {string}: the task id
				* 		@propety kCode {array of string}: the array of keycode, can include modifer key (such as Ctrl, Alt, Shift, MetaKey) seperated by '+' to comprises the shortcut hotkey e.g: ["PageUp", "Alt+Home"], ["Ctrl+A", "Shift+ArrowLeft"] or even ['Alt+ShiftLeft']. Note that for a composite shortcut, there are two part. For example, shortcut like 'Ctrl+Shift+KeyA', the first part is modifier keys (Ctrl+Shift), the second part is evt.code (KeyA). But for shortcut like 'Shift+ControlRight', the action is only trigger if any Shift key is pressed AND Right Control key is pressed (that is, evt.code=='ControlRight'; in this case ControlRight is second part)
				* 		@propety ignoreModifier {boolean, optional}: If set to {true}, the modifier pressed along with hotkey will be ignored. In normal case when ignoreModifier=true or missing,  if kCode:["PageUp"], then only PageUp key alone will trigger the function, Ctrl+PageUp, Shift+PageUp will not. ignoreModifier:true is applied for some hotkey is actually modifier key (such as ShiftLeft or ControlRight) or some function that associate with different modifier key to make different action like audio seeking, audio volumn changing or SDD selecting while changing active option
				*  	@propety desc {string}: the descrition of the job will be carried out
				* 		@propety noNotify {boolean, optional}: if specified true, the description of the task will not be notified to user when it is invoked
				* 		@propety callback {function}: the function will be invoked when the corresponding key (and modifier key) is pressed
				* @param keyPreventation {number}: to stopPropagation or preventDefault. Convert {keyPreventation} decimal number to binary number. {evt} will stopPropagation when bit 0 = 1, {evt} will preventDefault when bit 1 = 1:
				* 	= 0: no stopPropagation, no preventDefault
				*  = 1: stopPropagation, no preventDefault
				*  = 2: no stopPropagation, preventDefault
				*  = 3: stopPropagation and preventDefault
				* @param notifyFnc {function}: the function, if specified, which show the functionality of hotkey action to the user. The default is simple Infor toast
				*/
			SddDropdown.prototype.runHotkey = function(evt, hotkeyOptions, keyPreventation = 3, notifyFnc = _msg => toast.showToast(_msg, toast.ToastType.Infor) ){
				/** function to find if a keycode that is part of a shortcut
					* @param _shortcut {string} the comprised key set in kCode attribute of hotkeyOptions item. E.g: "KeyZ", "Ctrl+keyA" or "Shift+ArrowLeft"
					* @param _code {string} the keyCode that user pressed, usually got from evt.code. E.g "KeyA", "ArrowLeft"
					* @note need to check if @_code is empty (of which all hotkey in @hotkeyOptions will be matched), because this happen sometime when typing a Vietnamese keyword such as 'TĐ' (this might be the problem of Vietnamese typer such as UniKey)
					*/
				const _matchKeycode = (_shortcut, _code) => _code && _shortcut.match(new RegExp(`\\b${_code}\\b`,"i")); //'\\b' to make sure to match whole word

				//console.log(evt.code);
				//find if the key just press in the list of supported shortcuts
				const hotkeyOpts = hotkeyOptions.filter(keyItem => 
					//find the key in kCode (array of keys)
					keyItem.kCode.some(_shortcut => _matchKeycode(_shortcut, evt.code))
				);

				const [_stopPropagation, _preventDefault] = [keyPreventation % 2, keyPreventation / 2 << 0];
				//if found, do the corresponding job
				hotkeyOpts.forEach(hotkeyOpt => {
					// this var is used to check if a modifier key (or composition of modifier keys) specified in ignoreModifier attribute is pressed
					let _modifierKeys = true;
					if(evt instanceof KeyboardEvent) {
						//if ignoreModifier is false or missing, then need to check corresponding modifier key pressed
						if(!hotkeyOpt.ignoreModifier){
							const _shortcut = hotkeyOpt.kCode.find(_shrtcut => _matchKeycode(_shrtcut, evt.code)).trim();

							//if the shortcut is a composition of key and modifier
							if(_shortcut.includes("+")){
								if(_matchKeycode(_shortcut, "Ctrl")) _modifierKeys &= evt.ctrlKey || evt.metaKey; //metaKey is controlKey in MAC, Window key in Window
								if(_matchKeycode(_shortcut, "Shift")) _modifierKeys &= evt.shiftKey;
								if(_matchKeycode(_shortcut, "Alt")) _modifierKeys &= evt.altKey;							
							}
							else {
								//check for special key code such as ControlRight(Left); ShiftRight(Left); AltRight(Left)
								const _modifierAsKey = _shortcut.match(/\b(Control|Shift|Alt)(Left|Right)\b/i);
								if(_modifierAsKey){
									//manually set _modifierKeys for evt.code is one of ControlRight, ControlLeft, ShiftRight(Left), AltRight(Left). For those key, such as ControlRight, ControlLeft, we need to set value of _modifierKeys = true if control key is pressed, but Shift, Alt key must not pressed
									const _modifierArray = ['alt', 'ctrl', 'shift', 'meta']; //list of all modifier key name
									//extract modifier key from shortcut
									let _modiKey = _modifierAsKey[1].toLowerCase();
									if(_modiKey == 'control') _modiKey = 'ctrl';

									_modifierArray.forEach(_mk => {
										if(_mk == _modiKey) 
											_modifierKeys &= evt[_mk + 'Key'];
										else 
											_modifierKeys &= !evt[_mk + 'Key'];
									})
								}
								else
								//no modifier key should be allowed
								_modifierKeys = !(evt.altKey || evt.shiftKey || evt.ctrlKey || evt.metaKey);
							}
						}
					}
					if(_modifierKeys){
						hotkeyOpt.callback();
						//notify if there is notifyFnc and the hotkey allow notify
						if('function' == typeof notifyFnc && !hotkeyOpt.noNotify) notifyFnc(hotkeyOpt.desc);

						//do some preventation depending on keyPreventation
						if(_stopPropagation) evt.stopPropagation();
						if(_preventDefault) evt.preventDefault();
					}
					/* if(hotkeyOpt.notify && hotkeyOpts.length==1)
					_settings.callbacks.notify(hotkeyOpt.desc); */
				});
			}
	
			/** Toggle for Display and Hide Dropdown.
				* @evt {any}
				* 	- click event: when user click on SDD to expand/collapse it
				* 	- keyboard event: when user press a key to expand the SDD (from page) or ESC to collapse the SDD (from SDD search box)
				* 	- -1: called from closeIfClickedOutside function
			*/
			function toggleDropdown(evt) {
				//idea to animation collapse/expand is borrowed from https://css-tricks.com/using-css-transitions-auto-dimensions/
				/* COLLAPSE */
				if (!sddDropdownWrapper.classList.contains("elm-hidden")) {
					//set max-height to collapse dropdown Content and trigger transition effect
					sddDropdownContent.style.maxHeight = '0px';

					//wait for transition to be finished, then hide sddDropdownWrapper and glowing the rest still visibled
					sddDropdownContent.addEventListener('transitionend', function _tmpFnc(e) {
						// remove this event listener so it only gets triggered once
						sddDropdownContent.removeEventListener('transitionend', _tmpFnc);
						
						//hide sddDropdownWrapper
						sddDropdownWrapper.classList.add("elm-hidden");
						
						//glowing the rest which still visible
						_glowingElem(representativeDiv);
					});

					// reset the active option to _selectedItem
					_activeOption = _selectedItem;

					//when close dropdown, saved the states into localStorage
					//_saveSDDstate();
		
					//clear search box and search result variables
					if(evt !== -1) clearSearch(); //not invoked from closeIfClickedOutside()
				} else { /* EXPAND */
					//need to remove hidden class before calculate dimension, otherwise getBoundingClientRect() return all 0
					sddDropdownWrapper.classList.remove("elm-hidden");

					//calculate max-height for sdd so that its bottom is not hidden, but sdd is not too short
					const _maxHeight = Math.max(_settings.maxHeight[0], 
						Math.min( _settings.maxHeight[1],
						window.innerHeight - sddDropdownContent.getBoundingClientRect().top - 30 )
					);
					/* const _maxHeight = Math.max(_settings.maxHeight[0], 
						Math.min( _settings.maxHeight[1],
						window.innerHeight - representativeDiv.getBoundingClientRect().bottom - 60 )
					); */

					//TODO: maybe sometime transitionend not fired or fired very late, we can use setTimeout 600sec instead
					// when the next css transition finishes, glowing the sddDropdownWrapper
					sddDropdownContent.addEventListener('transitionend', 
					//setTimeout(
						function _tmpFnc(e) {
							// remove this event listener so it only gets triggered once
							sddDropdownContent.removeEventListener('transitionend', _tmpFnc);
							//toast.showToast('sddDropdownContent transitionend');
							
							//choose the option to be active when SDD open. If _selectedItem is visible (here I check if offsetParent exists, because _selectedItem sometime hidden because it has class .elm-hidden, some other time because its parent optGrp is hidden), then use _selectedItem. If it is not, use _activeOption, if _activeOption not exist, then get the first filtered item
							//let _iniActiveOption = Boolean(_selectedItem.offsetParent)? _selectedItem : (Boolean(_activeOption.offsetParent) ? _activeOption : (_filteredItems ?? _items)[0]);
							let _iniActiveOption;
							if(!_selectedItem.classList.contains("elm-hidden"))
							_iniActiveOption = _selectedItem
							else if(!_activeOption.classList.contains("elm-hidden")) _iniActiveOption = _activeOption
							else _iniActiveOption = (_filteredItems ?? _items)[0];

							//scroll to last selected option
							if (_iniActiveOption) {
								//added 11/4/2025. TODO: expand the collapsed group when set active for an option inside it should be done in setActiveOption. But I don't know put it there can cause some unwanted side-effect 
								//open optGroup containing the chosen option if there is any and it is closed and reveal the group header if the active option if the first visible option of its group
								const _optGroupFather = _iniActiveOption.closest(".optgroup");
								// if optGroup does exist and it is currently collapsed, expand it before setActiveOption()
								if(_optGroupFather && !_optGroupFather.firstChild.checked) _optGroupFather.firstChild.checked = true;
								// end of added 11/4/2025

								setActiveOption(_iniActiveOption, true, true);
								//scrollToOption(_selectedItem, "auto", true);
							}

							_glowingElem(sddDropdownWrapper);
						}//, 550
					);

					///set max-height and trigger transition effect. This should be set after setting transitionend handler
					sddDropdownContent.style.maxHeight =  _maxHeight + "px";

					//set focus search box when on desktop
					if (!checkOS(-1)) sddSearchBox.focus();
		
					/* UI: when sdd open for the first time, Right align all marked-to-align-right elements (ones having attribute [data-rAlignGroup]) inside an option for collection of options (which can be inside a section or all options for sdd have no sections) */
					if(_dropdownOpenFirstTime){
						// // right align elements having having attribute [data-rAlignGroup]. (1) Note that this function will take care of the cases to do right align for corresponding elements. See the comment of the function for more. (2) Note that the function use value of {_dropdownOpenFirstTime} to know what to do, so this invocation need to be put before reseting value of _dropdownOpenFirstTime
						_doInternalAlignRight(); 

						//repos tooltip for control buttons. I don't want to use this outside function to position tooltips, but I have no choices ):-
						guiUtils.reposTooltips(sddInputWrapper, {container: document.documentElement}); //, {container: sddDropdownContent}

						// set initial state for hide extra titles. I have to put it here because this function can only work if the button.toggle-extra-title-button visible
						toggleExtraTitles();

						_dropdownOpenFirstTime = false; //so next time toggle, this will not run again, until a new SDD is loaded in
					}
				}

				//if stopPropagation, two sdd may open at the same time
				//evt && evt.stopPropagation(); //prevent bubbling up
			}

			/** Set Selected Option
				@param clickedOption: dropdown option to be set selected
				@param seizeOnChange {boolean, false}: if true, no fire the onChange() callback
				@param closeOnSelect {boolean, true}: after set selected Item, close the dropdown or not
			*/
			function setSelected(clickedOption, seizeOnChange = false, closeOnSelect = true) {
				//make select the alread-selected option, then nothing todo
				if (_selectedItem === clickedOption) {
					if('function' == typeof _settings.callbacks.notify) _settings.callbacks.notify("Bạn vừa chọn lại mục đang được chọn.");
					//return clickedOption;
				}
				else{
					//remove the last selected
					if (_selectedItem)
						_selectedItem.classList.remove("is-selected");
		
					//this is bound to dropdown item which is clicked
					_activeOption = _selectedItem = clickedOption;
					
					// Change the Text on Selected Element
					//representativeDiv.textContent = clickedOption.textContent;
					representativeDiv.innerHTML = _settings.render.select_option(clickedOption, escape_html);

					// Add Selected Class to Clicked Option
					clickedOption.classList.add("is-selected");	

					//invoke _onChange callback if it is set
					if ("function" == typeof _onChange && !seizeOnChange)
					_onChange(clickedOption);
				}
	
				// Reset Search Input Value, Remove Selected Class from Previously Selected Option;  And Show All Div if they Were Filtered
				clearSearch();
				
				// Close the Dropdown
				/* if (closeOnSelect) sddDropdownWrapper.classList.add("elm-hidden"); */
				if (closeOnSelect && !sddDropdownWrapper.classList.contains("elm-hidden")) {
					toggleDropdown();
				}
	
				return clickedOption;
			}
	
			/** reset SDD to the state of non-filter  */
			function resetFilter(){
				//hide statusBar
				sddDropdownStatusBar.classList.add("statusbar-hidden");

				//put no-result option into hidden
				sddDropdownContent.querySelector("DIV.no_results").classList.add("elm-hidden");

				_filteredItems = null; //clear _filteredItems data
				_items.forEach((option) => {
					// Remove active Class from Previously active Option
					if (option.classList.contains("is-active")) {
						option.classList.remove("is-active");
					}
					// And Show All Div if they Were Filtered
					if (option.classList.contains("elm-hidden"))
						option.classList.remove("elm-hidden");
		
					//remove last high-light if there any
					sHighlite.removeHighlight(option);
				});
		
				//show all the groups which are hidden by last search
				sddDropdownContent.querySelectorAll("div.optgroup")
					.forEach((_optGroup) => { _optGroup.classList.remove("elm-hidden"); });
			}
			
			/* clear the search */
			function clearSearch(evt) {
				
				// Reset Search Input Value
				sddSearchBox.value = "";
				//sddSearchBox.focus(); //this should not put here, it will cause keyboard to showup when close the dropdown on smart devices

				resetFilter(); //clear all the filter
				
				//make selectedItem to be active one and scroll to it. But sdd scroll to the middle if this clearSearch() function is invoked from .clear-input-button button (evt !== undefined), otherwise if clearSearch() is invoked without {evt} parameter, it scroll in usual way
				setActiveOption(_selectedItem, true, !!evt);

				(evt instanceof Event) && evt.stopPropagation(); //PointerEvent
			}
	
			// Filter the Items by searchStr
			function filterItems(evt) {
				
				// Get Value of Search Input
				let searchStr = sddSearchBox.value;
				/* searchStr = searchStr.replaceAll(/\s\s+/g, " "); //save and trim value of sddSearchBox, so there is no two consecutive space
		
				//reset the search to prepare for the new one. Side effect: set searchbox to empty
				clearSearch(); 
		
				sddSearchBox.value = searchStr; //get back the value of sddSearchBox
				searchStr = searchStr.trim(); //should not toLowerCase() here, because this will prevent "search by first char" mode, where all chars of searchStr is capital
		 		*/

				resetFilter();
				searchStr = searchStr.replaceAll(/\s\s+/g, " ").trim(); //should not toLowerCase() here, because this will prevent "search by first char" mode, where all chars of searchStr is capital
				if (searchStr == "") return;
		
				//set new query string for sHighlite to deal with
				sHighlite.queryString = searchStr;

				// Get Items that match the search
				const matchedItems = _items.filter((item) =>
					// using textContent for simplicity. TODO: can specify which field or which child-element of an item to test the match
					sHighlite.matchSearch(item.textContent)
				);
				// Get the Indexes of FilteredItems
				const indexesArr = matchedItems.map((item) =>
					_items.indexOf(item)
				);
		
				//filtered _items data
				_filteredItems = matchedItems;
		
				//show/hide statusbar to notify the seearch results
				if(matchedItems.length == 0)
					//hide statusBar if there is no found
					sddDropdownStatusBar.classList.add("statusbar-hidden")
				else{
					//if(sddDropdownStatusBar.classList.contains("elm-hidden"))
					sddDropdownStatusBar.classList.remove("statusbar-hidden"); //show statusBar
					//sddDropdownStatusBar.style.opacity = 1;
					sddDropdownStatusBar.innerHTML = `Tìm thấy <mark>${matchedItems.length}</mark> kết quả.${window.innerWidth < 500?'<br/>':' '}Mode <small><mark>${sHighlite.wordMode}</mark>＋<mark>${sHighlite.diacriticsFilterMode?'Bỏ dấu':'Nguyên dấu'}</mark></small>.`; //statusBar content
					
					//using sddDropdownStatusBar.lastTO to store the timeout ID of last setTimeout. If statusBar still visible when new filter taken, just clear last timeout so that the new search result would not be disapear before its own timeout
					if(!sddDropdownStatusBar.classList.contains("statusbar-hidden") && sddDropdownStatusBar.lastTO)
					clearTimeout(sddDropdownStatusBar.lastTO);

					//set the time out to disappear the statusBar
					sddDropdownStatusBar.lastTO = setTimeout(_ => {
						//sddDropdownStatusBar.style.opacity = 0;
						sddDropdownStatusBar.classList.add("statusbar-hidden");
					}, _settings.statusBarTimeout);
				}

				// hide the not-match items
				_items.forEach((item) => {
					const optionIdx = _items.indexOf(item);
					sHighlite.removeHighlight(item); //remove all old highlight if there are any
					item.classList.remove('is-active'); //remove is-active class
					if (!indexesArr.includes(optionIdx)) {
						// Check if Option is not Inside Filtered Indexes Array, then Hide it
						item.classList.add("elm-hidden");
					} else {
						// else if it is Inside Indexes Array and it is Hidden, then Show it
						//if ( item.offsetParent === null ) item.style.display = "block";
						if (item.classList.contains("elm-hidden"))
						item.classList.remove("elm-hidden");
		
						//high-light the matched text
						sHighlite.highlight(item);
					}
				});
		
				//Hide all optGroup that doest not have any matched options. Expand all optGroups having matched option(s).
				sddDropdownContent.querySelectorAll("DIV.optgroup")
					.forEach((_optGroup) => {
						if ( _optGroup.querySelectorAll( "section > .sdd-dropdown-item:not(.elm-hidden)" ).length == 0 )
							_optGroup.classList.add("elm-hidden");
						//else expand the optGroup
						else _optGroup.querySelector('[id^="grpChkbox"]').checked = true;
					});
		
				//toggle show/hidden of no-results option if there no match or not
				sddDropdownContent.querySelector("DIV.no_results").classList.toggle("elm-hidden", matchedItems.length > 0);

				//make the first matched option to be the currently active one
				if (matchedItems.length > 0) {
					if( matchedItems.includes(_selectedItem) )
						setActiveOption(_selectedItem, true, false) //if there is seletedItem, make it active. If scroll to middle, the UI freeze on iOS
					else
						setActiveOption(matchedItems[0]); //otherwise, make the first one active
				}

				evt && evt.stopPropagation();
			}
	
			// Close Dropdown if Clicked Outside Dropdown Element
			function closeIfClickedOutside(evt) {
				if ( !sddDropdownWrapper.classList.contains("elm-hidden") &&
					evt.target.closest(".sdd-wrapper") !== _sddWrapper 
					//evt.target !== _sddWrapper &&
				)  {
					//this close the dropdown but don't clear the search. Note that if click on representativeDiv, it also close the dropdown but clear the search also
					/* sddDropdownWrapper.style.opacity = 0; */
					//setTimeout(() => sddDropdownWrapper.classList.add("elm-hidden"), 600);
					toggleDropdown(-1); //with param -1, the dropdown would be collapsed without clearing search box
				}
			}
	
			/** toggle all option groups. There two place invoked this function:
				* 1. When user click the .close-open-groups-button 
				* 2. On onkeydown function which handle event when user press Tab or Shift + Tab
				* @param evt: the event, not really necessary here
				* @param type {number}: this param is only available for this function is invoked in key event handler.
				* 	@value 0 or missing (usually for Tab key), close or opens all optgroups (depending on the last state the button open or close or partially close)
				* 	@value 1 (usually for Shift+Tab key): close all optGroups except the one containing selected option and the one containing active option
			*/
			function toggleOptGroups(evt, type){
				const _toggleButton = sddInputWrapper.querySelector(".close-open-groups-button");
				
				const allChkboxElem = sddDropdownContent.querySelectorAll("div.optgroup > input[type='checkbox']");
				if(allChkboxElem.length === 0) return; //no optgroup at all
				
				//toggle all optGroups: open all if currenly less than half are opened and vice versa
				const checkedCount = [...allChkboxElem].reduce( (count, _chkBox) => count+(_chkBox.checked), 0 ); //count number of expanded group
				
				//expand all groups if less than half of group currently expand
				const toChecked = checkedCount < allChkboxElem.length /2; 			
				
				//open or close all group
				allChkboxElem.forEach(chkBox => chkBox.checked = toChecked);

				// if type is close all but current section containing selected item AND not in the mode that all group expanded
				if(type == 1 && !toChecked){ // all optGroups are closed, now just open one containing selected and active
					//open group that contains selected and active option
					sddDropdownContent.querySelectorAll("div.optgroup > input[type='checkbox']:has( +label+section>.sdd-dropdown-item:is(.is-selected,.is-active) )").forEach(chkBox => chkBox.checked = true);
				}

				//if all or some optGroups opens, scroll to selected option
				if(toChecked || type == 1) setTimeout( scrollToOption.bind(null,_selectedItem, 'smooth', true), 800); //wait for animation to finish, then scroll. On CSS, set the animation time is 500ms
				
				evt && evt.stopPropagation();
			}

			/** Function to show/hide the extra titles stored in div.item-2nd-main-div element of each SDD option (div.sdd-dropdown-item). The state of show/hide states of those extra titles stored in attribute "attr-extra-title-hidden" of "button.toggle-extra-title-button" buton 
			Also, because after show/hide the extra titles, the height of each option changes, so we need to re-scroll so that which chapters was in the sddDropdownContent viewport, after showing/hiding extra titles, they keep being in sddDropdownContent viewport
			@param evt
				@value undefined or missing: called from toggleDropdown() to set initial state for hideExtraTitle
				@value KeyboardEvent: invoked from keypress event, which handle by onKeyDown() function
				@value PointerEvent/MouseEvent: invoked from button .toggle-extra-title-button click event
			*/
			function toggleExtraTitles(evt){
				
				//evt && evt.preventDefault();

				// The state of extra title is stored in attribute "attr-extra-title-hidden" of .toggle-extra-title-button button. Note that extra titles will be hidden if extra button has attribute "attr-extra-title-hidden"
				const _toggle_extra_title_button = sddInputWrapper.querySelector(".toggle-extra-title-button");
				// if the button is currently hidden, no need to do anything. This is to prevent the button run when user press hotkey customized for .toggle-extra-title-button button (for now is Ctrl+Insert)
				if(!_toggle_extra_title_button.offsetParent) return;

				//find the middle option in the SDD content view, to be anchor option for re-scrolling
				let _middle_viewport_anchor_option = null;

				//find the option that about the middle of sddDropdownContent viewport
				_items.some(_item => { 
					if(
						//bottom of option is below the vertical middle line of sddDropdownContent viewport
						_item.offsetTop + _item.offsetHeight > sddDropdownContent.scrollTop + sddDropdownContent.offsetHeight/2 
						//check for sure, the top of option if still above bottom of sddDropdownContent viewport
						&& _item.offsetTop < sddDropdownContent.scrollTop + sddDropdownContent.offsetHeight) {
						_middle_viewport_anchor_option = _item; //save the middle item
						return true; //exit the loop immediately, so the first option meet the above condition would be the anchor option to scroll to
					}
				});
				
				//console.log(_middle_viewport_anchor_option.firstElementChild.textContent);

				// if evt is undefined, which is invoked from toggleDropdown() for the first time toggle the SDD dropdown. The purpose of this invocation is to set initial state (and of course, update the SDD components/elements accorsingly)
				if(evt !== undefined){
					// usually (except setting initial state commented above), we need to flip the state of hideExtraTitle
					_sddState.hideExtraTitle = !_sddState.hideExtraTitle;

					//save the state to localStorage right after hideExtraTitle has changed
					_saveSDDstate();
				}			

				//toggle attribute 'attr-extra-title-hidden' to mark the state is extra titles to be visible or invisible
				_toggle_extra_title_button.toggleAttribute("attr-extra-title-hidden", _sddState.hideExtraTitle);
				//We hide or show extra title by adding/removing '.hideOptionExtraTitle' class to _sddWrapper, css will take care the rest
				_sddWrapper.classList.toggle("hideOptionExtraTitle", _sddState.hideExtraTitle);

				// right align elements having having attribute [data-rAlignGroup]. Note that this function will take care of the cases to do right align for corresponding elements. See the comment of the function for more
				_doInternalAlignRight();

				if(!_middle_viewport_anchor_option)
					// if not find any anchor option (which should not be the case), simply scroll to selected option
					sddInputWrapper.querySelector(".jump-to-selected-item-button").click();
				else{
					// I have to use setTimeout to wait for the transition in div.item-2nd-main-div elements to be finished, until then the height and location of SDD options got re-calculated correctly. I commented the timeout because I removed the CSS handling appear/disappear animation for extra titles (see the CSS for '.item-2nd-main-div')
					//setTimeout(_ =>
						//scroll to anchor option in 'auto' mode (no animation at all)
						scrollToOption(_middle_viewport_anchor_option, 'auto', true)
					//, 800);//div.item-2nd-main-div take transition for only .3s, but somehow I need to set timer to .8s for the SDD scroll correctly to the anchor option					
					
					//small hack to get over the issue on iOS safary that when toggle extra title (especially from visible to hidden), the SDD dropdown content show blank-box (because all SDD options is scroll up over the top of SDD). This might be the fault of safari browser when calculating the height of SDD dropdown content when extra titles got hidden out. The way I hack is to scroll SDD-dropdown-content a small bit (user cannot aware of the scroll), so browser can re-calculating the dimemsion of dropdown-content, thus can moved SDD options to right location
					setTimeout(_ => sddDropdownContent.scrollTop-=.1, 100);
				}
			}
			
			/* .clear-input-button event handler */
			function clearSearchButtonClick(evt){
				//https://stackoverflow.com/questions/75686162/javascript-unable-to-set-focus-to-a-dynamically-created-textbox suggest that put it setTimeout might work
				setTimeout(_ => sddSearchBox.focus(), 0);
				clearSearch(evt);				
			}
			
			/* Function hook to mousemove event to restore :hover effect for sdd option after it is disabled by keydown event on search box */
			function restoreHoverOnOption(){
				//add the class so that hover is re-effective on option
				if(!sddDropdownContent.classList.contains("allow-hover-on-item"))
					sddDropdownContent.classList.add("allow-hover-on-item");
			}
			
			/** Function to switch search mode from Exact search and diacritics Search
				* @param _evt_forcedState {missing or boolean}:
				* 	- if missing: this function just do the swap state 
				* 	- if is an event: this function is invoked from '.search-diacritics-option-button' button event handler (see sddRegisterEvents, sddUnregisterEvents below) or by hotkey in onKeyDown() event handler , so it just do the swap state and change button appearance
				* 	- if a boolean specified, this function force _settings.diacriticsFilterMode to be its value and change the button appearance, accordingly.
				*/
			function setDiacriticsFilterMode(_evt_forcedState){
				const _sddDiacriticsOptionBtn = sddInputWrapper.querySelector(".search-diacritics-option-button");
				let _mode;
				
				if(_evt_forcedState !== undefined){ //missing param, nothing to set
					if(_evt_forcedState == event){
						//called from button event handler
						_mode =  !_settings.diacriticsFilterMode;
					}
					else if(typeof _evt_forcedState == "boolean"){
						//forced state
						_mode = _evt_forcedState;
					}

					/* if(_evt_forcedState == event || typeof _evt_forcedState == "boolean"){
						//invoke the callback function to tell outside the changes of search mode
						if("function" == typeof _settings.callbacks.diacriticsFilterModeOnChanged) _settings.callbacks.diacriticsFilterModeOnChanged(_settings.diacriticsFilterMode);
					} */				

					//change diacritics mode of SearchHighlite
					sHighlite.diacriticsFilterMode = _mode;
					//re-filter items
					filterItems();
				}
				else {
					//when _evt_forcedState is undefined, this function is invoked from loadDropdown() with the purpose is to set initial state for the diacriticsFilterMode
					_mode = _sddState.diacriticsMode;

					//change diacritics mode of SearchHighlite
					sHighlite.diacriticsFilterMode = _mode;

					//because SDD content not yet renders, even that SDD not has been load, so we cannot (and not necessarily) to invoke filterItems()
				}
				
				_sddState.diacriticsMode = sHighlite.diacriticsFilterMode = _settings.diacriticsFilterMode = _mode;

				//save the state to localStorage right after diacriticsMode has changed
				if(_evt_forcedState !== undefined ) _saveSDDstate();

				//change appearance of the button
				_sddDiacriticsOptionBtn.classList.toggle("search-diacritics-exactSearch", !_mode);

				_sddDiacriticsOptionBtn.dataset.tooltip = _mode ? "Chữ nét, nền vàng: Tìm kiếm bỏ dấu cả từ tìm (keyword) và đích tìm.\nVí dụ: nếu cần tìm 'hoàn Kiếm' hoặc 'Hoàng Kiệm' gõ 'hoan kiem', 'Họa KiẾM' hoặc 'hÓan kIêm' đều tìm được" : "Chữ nhòe: tìm kiếm nguyên dấu.\nVí dụ muốn tìm 'Hoàn Kiếm' thì phải gõ 'Hoàn Kiếm', nếu chỉ gõ 'Hoan Kiếm' sẽ không tìm ra."
			}

			/** HELPER FUNCTIONS */
	
			/** align right all sub-elements having attribute [data-rAlignGroup] inside of element (such as an option) inside a collection (such as SDD content which contains multiple optGroups, each optGroup contains multiple options). This function will right-align for each type of [data-rAlignGroup] sub-element of element (such as options) for all options inside a _container (can be whole SDD or each optGroup) 
			This function is set public below for using outside of this class, such as for #elmPlaylist or #lstBookTitlesSetting
			* @param _container {HTMLElement}: the container element such as whole SDD or a optGroup. For outside, it can be the whole ol or a section which store chapters for a chapGroup
			* @param _subContainerElemQueryStr {string}: the query string that _container can get the sub-container elements (which each in turn contains sub-sub-elements having [data-rAlignGroup] - those who need to be right-align). For example, for SDD _subContainerElemQueryStr can be "div.sdd-dropdown-item" which points to options. For playlist, _subContainerElemQueryStr can be "li" which point to list-items, each contains infor for a chapter
			*/
			const _rightAlignElems = (_container, _subContainerElemQueryStr = "div.sdd-dropdown-item") => {
				// get all sub-container (e.g, each of them is one SDD option div.sdd-dropdown-item or #elmPlaylist.li)
				const _allSubContainers = _container.querySelectorAll(_subContainerElemQueryStr);
				// if there is no more than 1 item, there is nothing to match right-align with
				if(_allSubContainers.length <= 1) return;

				// take one option and looking for elements inside that option having attribute [data-rAlignGroup], these elements should be the one that need align right. Get all that element into an array in form of query selector, looks like:  ["EM[data-rAlignGroup = 'itemOrder']", "CODE[data-rAlignGroup = 'chapterDuration']"], each item of _alignElemTags will looks like: { "tagName": "EM", "attrId": "itemOrder", "elemsArray": [], "maxWidth": 0 }
				const _alignElemTags = 
				Array.from(_allSubContainers[0].querySelectorAll("[data-rAlignGroup]")) //Array.from is the fastest way to create an Array from a NodeList
					.map(elem => {return {tagName: elem.tagName, attrId: elem.dataset.raligngroup, elemsArray:[], maxWidth:0 } });

				//go through all options, in each option find all elements having [data-rAlignGroup], collect them into some array (each type on one array) and by the same time, measure the max-Width of each array
				_allSubContainers.forEach(_option => {
					//in each option, find elements having[data-rAlignGroup] attribute, collect them into an array (elemsArray) and find the max-Width maxWidth
					_alignElemTags.forEach(_tag => {
						const queryStr = _tag.tagName + "[data-rAlignGroup = '" + _tag.attrId + "']";
						//the right-align element inside current option
						const _elem = _option.querySelector(queryStr);
						_tag.elemsArray.push(_elem); //collect elements
						_tag.maxWidth = Math.max(_tag.maxWidth, _elem.offsetWidth); //get the maxWidth
					});
				});
				
				//align-right for each type of element
				_alignElemTags.forEach(_tag => {
						//We need to make sure that the all elements having {_tag} is visible. If they are not visible, we don't set the width so in the future when those coming visible, we have chance to set their width again
						if(_tag.maxWidth > 0)
						//align-right for each type of element, with different value of [data-rAlignGroup] attribute. 
						_tag.elemsArray.forEach(_elem => _elem.style.width = _tag.maxWidth + "px" )
					}
				);
				//clean the temp Array
				_alignElemTags.length = 0;
			}

			/* function uses _rightAlignElems() to customizedly do the right-align for SDD only. Depending on cases of SDD opening for the first time AND extra titles visible or not, we do align right for corresponding component. See the code for more */
			const _doInternalAlignRight = _ => {
				// if align-right items had been completely done for whole SDD of this SDD session, do nothing
				if(_alignRightElementsDoneFlag) return;

				/** function to do right-align for sub-component of SDD
					* @param _subQueryStr {string} the query selector string to specify the subcomponent
					* 	@value missing or undefined, it will take the default value of parameter '_subContainerElemQueryStr' of _rightAlignElems() function, which for now is "div.sdd-dropdown-item"
					* @value not undefined, we need specify the child of div.sdd-dropdown-item to do righ-align on, for example: "div.sdd-dropdown-item > .item-2nd-main-div"
					*/
				const _doSubAlignRight = _subQueryStr => {
					const _allSections = sddDropdownContent.querySelectorAll("div.optgroup > section");
					//if having group and user set (which actually default) _settings.rightAlignInEachOptGroup = true
					if(_allSections.length>0 && _settings.rightAlignInEachOptGroup)
						//if there is optGroups, only right-align across options inside group
						_allSections.forEach( sectionElem => _rightAlignElems(sectionElem) )
					else _rightAlignElems(sddDropdownContent); //no optGroup
				}

				//flag to see of extra titles is hidden (true) or visible (false)
				const _extraTitleHidden = sddInputWrapper.querySelector(".toggle-extra-title-button").hasAttribute("attr-extra-title-hidden");
				
				if(_dropdownOpenFirstTime){
					//Case 1: if open SDD for the first time (when SDD has new data). This should be invoked from toggleDropdown
					if(_extraTitleHidden){
						//case 1.A: AND axtra titles currently is invisible, we have to NOT yet reset _alignRightElementsDoneFlag = true so when user set extra titles to visible, we know that we have to do right-align again. Also, we do align right for all direct children of 'div.sdd-dropdown-item' that not 'div.item-2nd-main-div' (those who contain extra titles)
						_doSubAlignRight("div.sdd-dropdown-item > :not(div.item-2nd-main-div)");
						//_alignRightElementsDoneFlag should still 'false'
					}
					else{
						//case 1.B: AND axtra titles currently is Visible, we do align right for everything and also set the flag to true to tell that right-align has been completely done, meaning next time we don't have to do right-align for anything
						_doSubAlignRight();
						_alignRightElementsDoneFlag = true; //mark align-right has been completely done
					}
				}
				else{
					//This should be invoked from toggleExtraTitles()
					// Case 2: This is not the first time dropdown open but align-right has not been done (_alignRightElementsDoneFlag still false), so when extra titles is changed from invisible to visible, and right-align elements in extra titles has not been right-align before
					if(!_extraTitleHidden && !_alignRightElementsDoneFlag){
						// we do align right only for 'div.item-2nd-main-div' (those who contain extra titles)
						_doSubAlignRight("div.sdd-dropdown-item > div.item-2nd-main-div");
						_alignRightElementsDoneFlag = true; //mark align-right has been completely done
					}
				}
			}
	
			/** Sets the dropdown_content scrollTop to display the option 
				* @param option {element}: the option need to scroll to if it is not shown in the viewport
				* @param behavior {string, 'auto'}: the scroll behavior
				* @param toMiddle {boolean, false}: 
				* 	if @value = true, scroll so that the {option} locates at middle of dropdown. 
				*  if @value = false: 	
				* 		- option is in the view, do nothing
				* 		- option is hidden above the dropdown, it will be scroll to top of dropdown
				*  	- option is hidden below the dropdown, it will be scroll to bottom of dropdown
			*/
			function scrollToOption(option, behavior = "auto", toMiddle = false) {
				_scrollToElement(sddDropdownContent, option, behavior, toMiddle);
			}

			/** Sets the dropdown_content scrollTop to display the option
				* @param container {HTMLElement}: the container where the scroll take place, the one that contains the @option 
				* @param option {HTMLElement}: the option need to scroll to if it is hidden
				* @param behavior {string, 'auto'}: the scroll behavior, 'auto' or 'smooth'
				* @param toMiddle {boolean, false}: 
				* 	if true, scroll so that the {option} locates at middle of dropdown. 
				*  if false: 	- option is in the view, do nothing
				* 				- option is hidden above the dropdown, it will be scroll to top of dropdown
				*  			- option is hidden below the dropdown, it will be scroll to bottom of dropdown
			*/
			function _scrollToElement(container, option, behavior = "auto", toMiddle = false) {
				if (!option) return;
	
				/** * Scroll the dropdown to the given position * */
				function scroll(scrollTop, behavior) {
					if (behavior) {
						container.style.scrollBehavior = behavior;
					}
					container.scrollTop = scrollTop;
					container.style.scrollBehavior = "";
				}
	
				const _containerHeight = container.clientHeight; //content + padding
				const scrollTop = container.scrollTop || 0;
				const _itemHeight = option.offsetHeight; // visible content + scrollbars (if any) + padding + border
				// y-coord: the distance of option top to container top
				const y =
					option.getBoundingClientRect().top -
					container.getBoundingClientRect().top +
					scrollTop; //getBoundingClientRect() return dimension and position relative to the viewport.
	
				//scroll to middle
				if (toMiddle)
					return scroll(y - _containerHeight / 2 + _itemHeight, behavior);
	
				//otherwise, scroll so that option is inside the view
				if (y + _itemHeight > _containerHeight + scrollTop) {
					scroll(y - _containerHeight + _itemHeight, behavior); //option at bottom
				} else if (y < scrollTop) {
					scroll(y, behavior); //option at top
				}
				//otherwise: option is inside the view, keep it that way
			}

			/** function to set the avatar for SDD. Avatar is a small icon that appear at the right end of representativeDiv - the div that is left when SDD closes. The purpose of this function is to re-use svg icons that loaded in the page to be used as background of representativeDiv::after pseudo
				* @param _spriteIcon : 
				* 	@value svg or symbol (svg sprite) element that contain the svg markup. Something like document.getElementById("icnSvgChapGroupIcon")
				* 	@value an url, something like 'https://uxwing.com/wp-content/themes/uxwing/download/file-and-folder-type/multiple-layers-icon.svg'
				* 	@value string but not url, we will take as id of svg icon or svg sprite, something like icnSvgChapGroupIcon
				*/
			function _setSDDAvatar(_spriteIcon){
				function svgSprite2Background(_sprite){
					//see https://pqina.nl/blog/set-svg-background-image-fill-color/ for the most simple format of svg as a background
					//we have to remove all \tab, new line, return char. Also, all " to be '
					const _pathMarup = _sprite.innerHTML.replace(/\"/g, '\'').replace(/[\t\n\r]/g,"");
					const _svgMarkup = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='${_sprite.getAttribute("viewBox")}'>${_pathMarup}</svg>`;
					return `url("data:image/svg+xml;utf8,${_svgMarkup}")`;
				}
				let _bgrndCss = "";

				if(_spriteIcon instanceof SVGElement)
					//is svg icon or sprite element
					_bgrndCss = svgSprite2Background(_spriteIcon);
				else if('string' === typeof _spriteIcon){
					if(_spriteIcon.match(/^https?:\/\//))
						// is url
						_bgrndCss = `url('${_spriteIcon}')`;
					else
						//is svg icon or sprite ID
						_bgrndCss = svgSprite2Background( document.getElementById(_spriteIcon) );
				}
				
				if(_bgrndCss)
				representativeDiv.style.setProperty('--sdd-avatar-icon', _bgrndCss )
			}		

			/* function to saved states of ALL SDD instance into localStorage */
			function _saveSDDstate(){
				//_sddStorage stores state of all SDD instance, not just current one
				setTimeout( _ => localStorage.setItem(_settings.name, JSON.stringify(_sddState)) ,
				0 );
			}

			/** Glowing element for 1 second  */
			const _glowingElem = _elem => {
				//glowing the element
				_elem.classList.add("glowing-border");
				/* setTimeout(_ => {
					_elem.classList.remove("glowing-border");
				}, 900); //hide the glowing after 1 sec */

				//hide the glowing after animation end (note that animation-iteration-count of .glowing-border is set to 1)
				_elem.addEventListener("animationend", function _tmp_glowing_end(evt){
					//console.log(`animation ended: \t ${evt.animationName}\t ${evt.elapsedTime}\t ${evt.pseudoElement}`);
					_elem.removeEventListener("animationend", _tmp_glowing_end);
					_elem.classList.remove("glowing-border");
				});
			}			
	
			/** Class to search and highlight matched strings
				@param queryStr {string} string to search, can contains multiple words separated by space (\s+), each word will be matched separatedly.
				@param diacriticsFilterMode {boolean}: false - search exactly queryStr (with breaking into words, of course)
					true: - removed diacritics from both searchStr and textContent (searched String) before matching
			*/
			function SearchHighlite(diacriticsFilterMode) {

let _diacriticsFilterMode = diacriticsFilterMode ?? false;
/* get/set the diacriticsFilter mode. true: filter diacritics before searching. false: no filter */
Object.defineProperty(this, "diacriticsFilterMode", {
	get() {
		return _diacriticsFilterMode;
	},
	set(val) {
		_diacriticsFilterMode = Boolean(val);
	}
});

/* TODO: add case-sensitive and case-insensitive mode if needed. This require modify asciifold */

/** Search mode: the algorithm to break string into word when searching. This mode and _diacriticsFilterMode would define how to match searched result. For now, all the search is case-insensitive.
	* Default is Break mode*/
const _WORD_MODE = Object.freeze({
	/* The mode that seach string is all number and \. (can add more separate letter when needed)(regex = /^[\d.]+$/). This mode is mostly used for searching the order number of an SDD option. Beside that, this mode is only used for decoration. E.g, keyword '123' or '123.' would automatically turn this mode on */
	'Number': 'Số',
	/* This is default mode, in which the keyword is broken into words (using space as seperator char), then match the content to each word. So, any content that match all those words (in any order) would be considered as matched content. E.g, keyword 'hoàn kiếm' would match 'Hoàn Kiếm' or 'Hoang phí vs Tiết Kiệm' when _diacriticsFilterMode = true */
	'Break': 'Khớp từ',
	/* if keyword is all capital-letter, this mode is turned on. In this mode, the keyword is broken into letters, then any content that having substring that having first letter of adjacent word match each letters of keyword (in the same order) would be considers as matched content. E.g: keyword 'HP'would find 'Harry potter' but not 'Phuong Hoang'  */
	'FirstLetter': 'Chữ cái đầu',
	/* if keyword is all lower-case-letter, this mode is turned on. In this mode, if content has substring (which starts as whole word) that matches the keyword, it is considered as matched. E.g, when _diacriticsFilterMode = true: keyword 'chi dien' would match 'Tam Quốc Chí Diễn Nghĩa' but keyword 'hi dien' (not start as whole word) or 'diễn chí' (not match the order of words) would not match that content */
	'Phrase': 'Cụm từ'
});

/* The word mode when searching to define how to match keyword with words in the content, could take one of modes in _WORD_MODE enum */
let _wordSearchMode = _WORD_MODE.Break;
/* get the word search mode. This mode depends on the keyword (number, all lower case, all upper case, mixed-case) and is set in makeSearchRegex() function */
Object.defineProperty(this, "wordMode", {
	get() {
		return _wordSearchMode;
	},
	/* set(val) {
		_wordSearchMode = val;
	} */
});

// when have new queryStr, we break queryStr into array of token keys, this var keep that array
let _pvtSearchTokensArray = [];
// keep the RegExp object for the mode _WORD_MODE.FirstLetter and _WORD_MODE.Phrase
let _pvtHighlightRegex = null;
/** get/set the queryString.
	* @get : return the searchKeys that being broken-up from queryStr
	* @set : set searchKeys from queryStr that usable for other function such as matchSearch or highlight. This set is usually called from filterItems() when there is new queryString, this call by the same time will break queryString into _searchKeys
	*/
Object.defineProperty(this, "queryString", {
	get() {
		return _pvtSearchTokensArray;
	},
	set(queryStr) {
		_pvtSearchTokensArray = queryStr2RegexWords(queryStr);

		// generate the RegExp object for the mode _WORD_MODE.FirstLetter and _WORD_MODE.Phrase to store in _pvtHighlightRegex, so SearchHighlite.highlight() public method does not need to unnecessary re-calculate each time highlight an option with the same queryStr
		if(_wordSearchMode == _WORD_MODE.FirstLetter){
			_pvtHighlightRegex = makeFirstCharModeRegEx(_pvtSearchTokensArray);
		}
		else if(_wordSearchMode == _WORD_MODE.Phrase){
			_pvtHighlightRegex = makePhraseModeRegEx(_pvtSearchTokensArray);
		}
		else _pvtHighlightRegex = null;
	}
});

// mode to decide to highligh all match (true) or just the first match (false)
let _pvtHighlightAll = true;
/** get/set the highlighAll flag, which will highlight all matches or just the first one
*/
Object.defineProperty(this, "highlightAll", {
	get() {
		return _pvtHighlightAll;
	},
	set(val) {
		_pvtHighlightAll = !!val;
	}
});

/* const removeVnAccents = (vnStr) => {
	const _repArr = [
		[/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a"],
		[/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e"],
		[/ì|í|ị|ỉ|ĩ/g, "i"],
		[/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o"],
		[/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u"],
		[/ỳ|ý|ỵ|ỷ|ỹ/g, "y"],
		[/đ/g, "d"],
		[/À|Á|Ạ|Ả|Ã|Â|Ầ|Ấ|Ậ|Ẩ|Ẫ|Ă|Ằ|Ắ|Ặ|Ẳ|Ẵ/g, "A"],
		[/È|É|Ẹ|Ẻ|Ẽ|Ê|Ề|Ế|Ệ|Ể|Ễ/g, "E"],
		[/Ì|Í|Ị|Ỉ|Ĩ/g, "I"],
		[/Ò|Ó|Ọ|Ỏ|Õ|Ô|Ồ|Ố|Ộ|Ổ|Ỗ|Ơ|Ờ|Ớ|Ợ|Ở|Ỡ/g, "O"],
		[/Ù|Ú|Ụ|Ủ|Ũ|Ư|Ừ|Ứ|Ự|Ử|Ữ/g, "U"],
		[/Ỳ|Ý|Ỵ|Ỷ|Ỹ/g, "Y"],
		[/Đ/g, "D"],
		[/[\u0300-\u036f]/g, ""],
	]; // Remove combining diacritical marks
	_repArr.forEach(
		(_rep) => (vnStr = vnStr.replace(_rep[0], _rep[1]))
	);
	return vnStr;
}; */

/* Adapt from https://github.com/brianreavis/sifter.js/blob/master/lib/sifter.js#L36 and https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.base.js */
const asciifold = (function () {
	const DIACRITICS = {
		0: "߀",
		a: "àáạảãâầấậẩẫăằắặẳẵÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄⱥɐɑ",
		b: "␢βΒB฿𐌁ᛒƀɓƃ",
		c: "ĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃꜿƈȼↄ",
		d: "đĐĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄðđɗɖᴅƌꮷԁɦ",
		e: "èéẹẻẽêềếệểễÈÉẸẺẼÊỀẾỆỂỄÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐεɛǝᴇɇ",
		f: "ƑƒḞḟꝼƒ",
		g: "ɢ₲ǤǥĜĝĞğĢģƓɠĠġǥɠꞡᵹꝿɢ",
		h: "ĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕħⱨⱶɥ",
		i: "ìíịỉĩÌÍỊỈĨÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉɨı",
		j: "ȷĴĵɈɉʝɟʲɉȷ",
		k: "ƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭ƙⱪꝁꝃꝅꞣ",
		l: "ŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌłƚɫⱡꝉꝇꞁɭ",
		n: "ŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋꞥƞɲꞑᴎлԉ",
		o: "òóọỏõôồốộổỗơờớợởỡÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօøǿɔɵꝋꝍᴑ",
		p: "ṔṕṖṗⱣᵽƤƥᵱƥᵽꝑꝓꝕρ",
		q: "ꝖꝗʠɊɋꝘꝙq̃ꝗꝙɋ",
		r: "ŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽɍɽꝛꞧꞃ",
		s: "ŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈ßȿꞩꞅʂ",
		t: "ŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭŧƭʈⱦꞇ",
		u: "ùúụủũưừứựửữÙÚỤỦŨƯỪỨỰỬỮŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪ʉ",
		v: "ṼṽṾṿƲʋꝞꝟⱱʋʋꝟʌ",
		w: "ẂẃẀẁŴŵẄẅẆẇẈẉⱳ",
		x: "ẌẍẊẋχ",
		y: "ỳýỵỷỹỲÝỴỶỸÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴƴɏỿ",
		z: "ŹźẐẑŽžŻżẒẓẔẕƵƶƶȥɀⱬꝣ",
		"/": "⁄∕",
		aa: "ꜳ",
		ae: "æǽǣ",
		ao: "ꜵ",
		au: "ꜷ",
		av: "ꜹꜻ",
		ay: "ꜽ",
		m: "ɱɯϻ",
		oe: "œ",
		oi: "ƣ",
		oo: "ꝏ",
		ou: "ȣ",
		th: "þ",
		tz: "ꜩ",
		vy: "ꝡ",
		hv: "ƕ",
	};

	let foreignletters = "";
	let lookup = {}; //map each foreign letter to latin letter
	for (const k in DIACRITICS) {
		if (DIACRITICS.hasOwnProperty(k)) {
		const chunk = DIACRITICS[k]; //.substring(2, DIACRITICS[k].length - 1);
		foreignletters += chunk;
		for (let i = 0, n = chunk.length; i < n; i++) {
		lookup[chunk.charAt(i)] = k;
		}
		}
	}
	let regexp = new RegExp("[" + foreignletters + "]", "g");
	return function (str) {
		return str
		.replace(regexp, function (foreignletter) {
			return lookup[foreignletter];
		})
		.toLowerCase();
	};
})();

/** Function to keep diacratics or normalize string and convert (almost) all dicratic unicode chars (which can see in Vietnamese, Polish,.., language) into 26-letter latin characters 
	* @param txtContent {string}: the string need to removed diacratics (or not, depending on _diacriticsFilterMode mode, and value of forceRemoveDiacratics)
	* @param forceRemoveDiacratics {boolean}: if true (default false), it force to remove diacritics no matter what the value of _diacriticsFilterMode
*/
const uni2Latin = (txtContent, forceRemoveDiacratics = false) => {
	//if we remove all space chars, highlightText() might work incorrectly for the node that starts with space like when hight light 'h' in " phu", it will highlight letter 'p'
	//txtContent =  txtContent.replaceAll(/\s\s+/g, " ").trim();

	//if diacriticsFilterMode, just return lower case string
	if(!_diacriticsFilterMode && !forceRemoveDiacratics) return txtContent.toLowerCase();

	// NFC — Normalization Form Canonical Composition. — Dựng Sẵn (mặc định)
	// NFD — Normalization Form Canonical Decomposition. — Tổ Hợp
	txtContent = txtContent.normalize("NFC").toLowerCase();

	return asciifold(txtContent); //removeVnAccents(txtContent); //
};

/** Prepare list of string-regex keywords that ready for regex matching. Depending on @queryStr , this also decide the word-search mode
	* @param queryStr {string}: the search string that used as keyword to search through the SDD
	* @return an {array of string}: depending on the queryStr, a corresponding mode would turn on (see the comments in _WORD_MODE enum and the code below)
	* @mode FirstLetter: array of regex so that each item correspond with one upper-case letter in Query string
	* @mode Phrase: array of one string that match (in the way of indexOf matching) query string
	* @mode Number and Break: break queryStr into list of keywords, sort by decending order of keyword length. Function returns array of all keyword which are separated by space in queryStr, with converting special escape character like ^$\...
*/
function queryStr2RegexWords(queryStr) {
	if (!queryStr) return null;
	queryStr = queryStr.replaceAll(/\s\s+/g, " ").trim();
	// all the chars including diacritics, got from https://stackoverflow.com/questions/30225552/regex-for-diacritics
	const _allLeters = '[A-zÀ-ÖØ-öø-įĴ-őŔ-žǍ-ǰǴ-ǵǸ-țȞ-ȟȤ-ȳɃɆ-ɏḀ-ẞƀ-ƓƗ-ƚƝ-ơƤ-ƥƫ-ưƲ-ƶẠ-ỿ]';
	const _matchLeterRegex = new RegExp(_allLeters, 'i');

	//Decide which wword-search mode should be
	//if queryStr is all numbers and '.', it is in number mode
	if(queryStr.match(/^[\d.]+$/))
		_wordSearchMode = _WORD_MODE.Number;
	//if queryStr is all capital chars, then we are in search by first char mode
	else if( queryStr.length > 1 && _matchLeterRegex.test(queryStr) && queryStr == queryStr.toUpperCase() )
		_wordSearchMode = _WORD_MODE.FirstLetter
	else if( queryStr.length > 1 && _matchLeterRegex.test(queryStr) && queryStr == queryStr.toLowerCase() )
		_wordSearchMode = _WORD_MODE.Phrase
	//Otherwise, it is in match word-by-word mode
	else _wordSearchMode = _WORD_MODE.Break;
	//console.log('_wordSearchMode = ' + _wordSearchMode);

	//force asciifold if _searchByFirstChar mode is true
	queryStr = uni2Latin(queryStr);

	const escape_regex = (str) => {
		return (str + "").replace(
		/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu,
		"\\$1"
		);
	};

	//break search string into keyword, and sort by decending order of the length of keyword
	let searchKeys;
	if(_wordSearchMode == _WORD_MODE.FirstLetter){
		const _word = _diacriticsFilterMode? '[A-z]*' : _allLeters + '*';//'[\\w]*'; //'[^\\s]*'
		searchKeys = queryStr.replace(/\s/g,"").split('').map((key) => escape_regex(key) + _word);
	}
	else if(_wordSearchMode == _WORD_MODE.Phrase){
		searchKeys = [queryStr.replace(/\s{2,}/g, " ").trim()];

	}
	//number and break mode
	else searchKeys = queryStr
		.trim()
		.split(/\s+/)
		.map((key) => escape_regex(key))
		.sort((a, b) => b.length - a.length);

	return searchKeys;
}

//list all chars can be identified as word seperator. In future, can add more char to this list
const _char_separator = '[\\s\\$\\(\\)\\*\\-–—\\+,;\\.!&*\\?\\[\\]\\^\\{\\|\\}\\\\]';
/** Function to create regex for first-char mode, which require every char in @queryStr is capital, each has to be the first char of adjacent word in order to be matched 
 * @param searchKeysArray {array of string} array of search key tokens (each is one letter) broken from @queryString by @function queryStr2RegexWords()
 * @return RegExp object that could match all phrases having words' first letter orderly match each item of searchKeysArray
*/
const makeFirstCharModeRegEx = (searchKeysArray) => {
	if(!searchKeysArray) return null; //when clear search, set queryString="", so _pvtSearchTokensArray == null

	//TODO: can extend word-separator to include more 
	//if using '\\s+', search might be incorrect because text from adjacent elements would be seperated by \s+ in item.textContent
	const _word_seperator = '[ ]+'; //'\\s+'; //`${_char_separator}+`;//
	//because of diacritics, we have to use naive '(?<=^|\\s)' or a bit more complex as code below instead of simple but powerful '\\b' to match the begin of word, so make sure it not middle of a word (such as if we find a word start with 'H', it match 'Hưng', but not match 'Nhưng')
	const _markBegin = _diacriticsFilterMode? "\\b" : `(?<=^|${_char_separator})`;
	const _markEnd = _diacriticsFilterMode? "\\b" : `(?=${_char_separator}|$)`;
	return new RegExp(_markBegin + searchKeysArray.join(_word_seperator) + _markEnd, "i");
}

/** Function to create regex for phrase mode, which require every char in @queryStr is lowercase, each has to be the one word of adjacent words (making a phrase, so the name) that will be matched with text content 
 * @param searchKeysArray {array of string} array of search key tokens (each is one letter) broken from @queryString by @function queryStr2RegexWords()
 * @return RegExp object that could match all phrases having words' first letter orderly match each item of searchKeysArray
*/
const makePhraseModeRegEx = (searchKeysArray) => {
	if(!searchKeysArray) return null; //when clear search, set queryString="", so _pvtSearchTokensArray == null

	//TODO: can extend word-separator to include more 
	const _word_seperator = '\\s+'; //`${_char_separator}+`;//
	//because of diacritics, we have to use naive '(?<=^|\\s)' or a bit more complex as code below instead of simple but powerful '\\b' to match the begin of word, so make sure it not middle of a word (such as if we find a word start with 'H', it match 'Hưng', but not match 'Nhưng')
	const _markBegin = _diacriticsFilterMode? "\\b" : `(?<=^|${_char_separator})`;
	//const _markEnd = _diacriticsFilterMode? "\\b" : `(?=${_char_separator}|$)`;
	return new RegExp(_markBegin + searchKeysArray.join(_word_seperator), "i");
}

/** Match function to match search string to text content. Depending on word-search mode, the algorithm are different. For example, in Break mode, the algorithm using AND operator to match all keywords (each is seperated by space in searchStr)
 * @param searchKeysArray {array of string} array of search key tokens (each is one letter) broken from @queryString by @function queryStr2RegexWords()
 * @param txtContent {string} the text content that will use @searchKeysArray as regex to match with
 * @return:  false if not match
		true: if searchStr empty or matched
*/
function matchSearch(searchKeysArray, txtContent) {
	if (!searchKeysArray) return true;

	txtContent = uni2Latin(txtContent);	
	
	let isMatched;
	if(_wordSearchMode == _WORD_MODE.FirstLetter){
		const regEx = makeFirstCharModeRegEx(searchKeysArray);
		isMatched = regEx.test(txtContent);
	}
	else if(_wordSearchMode == _WORD_MODE.Phrase){
		const regEx = makePhraseModeRegEx(searchKeysArray);
		isMatched = regEx.test(txtContent);
	}
	//number and Break mode
	else
		//txtContent has to match all keywords (logically AND)
		isMatched = searchKeysArray.reduce((ismatch, key) => {
			//if it not match in previous key testing, just return false without needing check any other key
			if(!ismatch) return false;

			const regEx = new RegExp(`(${key})`, "i");
			return (ismatch &= regEx.test(txtContent));
		}, true);

	return !!isMatched;
}

/** Highligt matched text for an element
 * @param elem {HTMLElement} the element that need to be highlight the matched text
 * @param regex {RegExp object} the RegExp object used to match the text
 */
const highlightOneKey = (elem, regex) => {
	if (regex === null) return; //when clear search, set queryString=""
	
	/** Replace a node 
	 * @param existing node to be replaced
	 * @param replacement node will be replaced the @existing node
	*/
	const replaceNode = (existing, replacement) => {
		if (existing.parentNode)
		existing.parentNode.replaceChild(replacement, existing);
	};

	// convet string to regex
	if (typeof regex === "string") {
		if (!regex.length) return;
		regex = new RegExp(regex, "i");
	}

	// Wrap matching part of text node with highlighting <span>, e.g.
	// Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i
	const highlightText = (node) => {
		var match = uni2Latin(node.data).match(regex);
		if (match && node.data.length > 0) {
			var spannode = document.createElement("span");
			spannode.className = "highlight";
			var middlebit = node.splitText(match.index);
			middlebit.splitText(match[0].length);
			var middleclone = middlebit.cloneNode(true);
			spannode.appendChild(middleclone);
			replaceNode(middlebit, spannode);
			return 1;
		}
		return 0;
	};

	// const to keep the function to highlight all occurance of just the first one. This should put in Object.defineProperty for "highlightAll" property, but I keep it here for the sake of code reading & debugging
	const _pvtHighlightAllOnce = _pvtHighlightAll ?
		/** function to highlight ALL occurance of the node as a task of highlightOneKey() function
		 * @param node {HTMLNode} the node that need to be highlight
		 * @param highlightRecursive {function} function to recursively look into @node offsprings (and descendent) for the matched text to highlight. This function is provided as private function inside highlightOneKey() function, that's why we have to put it as a parameter
		*/
		(node) => 
		//Array.prototype.forEach.call(node.childNodes, (_node) => {
		//somehow Array.from works perfectly, but above Array.prototype.forEach works but not correctly
		Array.from(node.childNodes).forEach((_node) => {
			highlightRecursive(_node);
		}) //this function would return undefined
		:
		/* function to highlight ONCE - the very first occurance of the node as a task of highlightOneKey() function */
		(node) => Array.prototype.some.call(node.childNodes, (node) => {
			//the loop will STOP immediately when there is a node is highlighted and highlightRecursive return any truthy value
			return highlightRecursive(node);
		}); // this function return true if one of child nodes is highlighted, other return false

	/** This function do the highlight for the text node. If not a text node, it Recurses element node, looking for child text nodes to highlight, unless element is childless, <script>, <style>, or already highlighted: <span class="hightlight"> 
	 * @param node {DOM Node including HTMLElement} the node/element to be highlighted. Note that this param not take generic node as a choice, it only take HTMLElement.
	 * @FYI An element is one specific type of node as there are many other types of nodes (text nodes, comment nodes, document nodes, Attr, CharacterData, etc...). See Node on mdn for more.
	*/
	const highlightRecursive = (node) => {
		//if text node, highlight immediately
		if (node.nodeType === Node.TEXT_NODE) { //Node.TEXT_NODE=3
			return highlightText(node);
		}
		
		/* highlightChildren(node);
		return 0; */

		//if element having childs, and not span.highlight, not <script>, <style>
		if (
			node.nodeType === Node.ELEMENT_NODE && //Node.ELEMENT_NODE = 1
			node.childNodes &&
			!/(script|style)/i.test(node.tagName) &&
			(node.className !== "highlight" || node.tagName !== "SPAN")
		) {
			/* if(_pvtHighlightAll){
				//This will highlight ALL matches of a node
				//Array.prototype.forEach.call(node.childNodes, (_node) => {
				Array.from(node.childNodes).forEach((_node) => {
					highlightRecursive(_node);
				});
			}
			else{
				// This only highlight first match of the node, thus it would be faster
				Array.prototype.some.call(node.childNodes, (_node) => {
					return highlightRecursive(_node);
				});
			} */
			
			//go through all children of node and run highlightRecursive on it
			return _pvtHighlightAllOnce(node);
		}
	};

	// highlight the elem
	highlightRecursive(elem);
};

/** * removeHighlight fn copied from highlight v5 and  edited to remove with(), pass js strict mode, and use without jquery 
 * @param elem {HTMLElement} the element need to be removed highlight, usually is a SDD option
*/
const removeHighlight = (elem) => {
	//only remove Hightlight if elem is highlighted before
	if(!elem.highlighted) return;

	delete elem.highlighted; //remove attributes to tell this has been cleared highligh

	var elements = elem.querySelectorAll("span.highlight");
	Array.prototype.forEach.call(elements, function (el) {
		var parent = el.parentNode;
		parent.replaceChild(el.firstChild, el); //replaceChild(newChild, oldChild) - replace <span.hightlight> node with text-node which is its textContent
		parent.normalize(); //join text nodes that adjacent to each other because of the command 'replaceChild' above replace old <span> with a text node in the middle of others text-node
	});
};

//SearchHighlite.prototype.removeHighlight = removeHighlight;

/* public functions that bind to current {queryStr} */
//word-search mode enum
this.WORD_MODE = _WORD_MODE;
//remove old hightlight from element
this.removeHighlight = removeHighlight;
//check to see if an element match the search or not
this.matchSearch = (txtContent) => {
	return matchSearch(_pvtSearchTokensArray, txtContent);
};
//hightlight part of matched search for an element
this.highlight = (elem) => {
	//if already highlighted, no need to hightlight again
	if(elem.highlighted) return;

	if(!_pvtSearchTokensArray) return;//when clear search, set queryString="", so _pvtSearchTokensArray == null

	if(_wordSearchMode == _WORD_MODE.FirstLetter || _wordSearchMode == _WORD_MODE.Phrase){
		highlightOneKey(elem, _pvtHighlightRegex);
	}
	else 
	_pvtSearchTokensArray.forEach((regexKey) => highlightOneKey(elem, regexKey));

	elem.highlighted = 1; //mark that this elem has been highlighted
}

/* return {					
	//makeSearchRegex: makeSearchRegex,
	removeHighlight: removeHighlight,
	matchSearch: (txtContent) => {
		return matchSearch(_searchKeys, txtContent);
	},
	highlight: (elem) =>
		_searchKeys.forEach((regexKey) => highlightOneKey(elem, regexKey))
}; */
}

			/* PUBLIC FUNCTIONS */
			/* Add event handlers for all inner controls of search-dropdown element */
			let sddRegisterEvents = () => {
				//event delegation for dropdown _items
				sddDropdownContent.addEventListener( "click", dropdownItemClickDelegation );

				//for now, main job of mousemove on sddDropdownContent is to restore hover effect on options
				sddDropdownContent.addEventListener( "mousemove", restoreHoverOnOption );

				representativeDiv.addEventListener("click", toggleDropdown);
		
				// Add Input Event to Search Input Element to Filter Items
				sddSearchBox.addEventListener("input", filterItems);
		
				// add keydown event to handle up/down, enter, esc,.. keys
				sddSearchBox.addEventListener("keydown", onKeyDown);
		
				// Add Click Event to Element to Close Custom Dropdown if Clicked Outside
				document.addEventListener("click", closeIfClickedOutside);

				/* Buttons */
				//handler for toggle all optGroups button
				sddInputWrapper.querySelector(".close-open-groups-button").addEventListener("click", toggleOptGroups);

				//handler for jump to selected option
				sddInputWrapper.querySelector(".jump-to-selected-item-button").addEventListener("click", _ => getAdjacent(_selectedItem, 0)); //setActiveOption(_selectedItem, true, true)

				//handler for show/hide 2nd extra title for each option
				sddInputWrapper.querySelector(".toggle-extra-title-button").addEventListener("click", toggleExtraTitles);

				//handler for clear Search box button
				sddInputWrapper.querySelector(".clear-input-button").addEventListener("click", clearSearchButtonClick);

				//handler search-diacritics-option button
				sddInputWrapper.querySelector(".search-diacritics-option-button").addEventListener("click", setDiacriticsFilterMode);
			};
	
			/* sddUnregisterEvents function of main class used to remove all event listeners when search-drop-down elements is removed or replaced */
			let sddUnregisterEvents = () => {
				//Remove event delegation for dropdown _items
				sddDropdownContent.removeEventListener( "click", dropdownItemClickDelegation );
				sddDropdownContent.removeEventListener( "mousemove", restoreHoverOnOption );
		
				representativeDiv.removeEventListener("click", toggleDropdown);
		
				// Remove Input Event to Search Input Element to Filter Items
				sddSearchBox.removeEventListener("input", filterItems);
		
				// Remove keydown event to handle up/down, enter, esc,.. keys
				sddSearchBox.removeEventListener("keydown", onKeyDown);
		
				// Remove Click Event to Element to Close Custom Dropdown if Clicked Outside
				document.removeEventListener("click", closeIfClickedOutside);

				//handler for toggle all optGroups button
				sddInputWrapper.querySelector(".close-open-groups-button").removeEventListener("click", toggleOptGroups);

				//handler for show/hide 2nd extra title for each option
				sddInputWrapper.querySelector(".toggle-extra-title-button").removeEventListener("click", toggleExtraTitles);

				//handler for clear Search box button
				sddInputWrapper.querySelector(".clear-input-button").removeEventListener("click", clearSearchButtonClick);

				//handler search-diacritics-option button
				sddInputWrapper.querySelector(".search-diacritics-option-button").removeEventListener("click", setDiacriticsFilterMode);

				//because of my lazy, for now I miss unregitered event handler for .jump-to-selected-item-button button
			};
	
			/* Set selected item for the dropdown
				@param option:
				number: select by index of item. Same as set sdd.selectedIndex
				string:: select by value of item. Same as set sdd. value
				HTML element: select by the element itself
			*/
			let selectItem = (option, seizeOnChange = false) => {
				/* number: select by index of item */
				if (typeof option === "number") {
					const _index = option;
					if (_index < 0 || _index >= _items.length) {
						console.warn("SDD selectedIndex set: index out of bound");
						return null;
					} else return setSelected(_items[_index], seizeOnChange);
				}
	
				/* string:: select by value of item. */
				if (typeof option === "string") {
					let value = option.toString().toLowerCase().trim();
					if (!value) {
						console.warn("SDD value set: no value to set");
						return null;
					}
					let foundItem = _items.filter(
						(item) => item.value.toLowerCase() == value
					);
					if (foundItem.length == 0) {
						console.warn("SDD value set: no such value");
						return null;
					}
					return setSelected(foundItem[0], seizeOnChange);
				}
	
				/* element: select by the element itself */
				if (typeof option === "object" && option instanceof HTMLElement) {
					if (_items.indexOf(option) == -1) option = _items[0];
					return setSelected(option, seizeOnChange);
				}
			};
			
			/* Load Mode enum to define some mode for loadDropdown() */
			const loadSDDMode = Object.freeze({
				SettingLoadOnly: "justSomeSettings", //load the setting, usually used for SDD that has fix setting but different data loads multiple time, such as sddChaps
				DataLoadOnly: "loadDataOnly", //use to load data multiple time after setting is initially loaded
				All: "SettingsAndData" //load both setting and data at the same time. This is mostly used for SDD that share by different kind of data, such as ssData.sddBooks (grpLine = 0 has different data format, callbacks, render function than grpLine = 1;2)
			});

			/* _sddState is variable stored states for current instance of SDD. */
			let _sddState = null;
			/** populate the data and functionalities for dropdown 
				* @param _settingParam {json, required}: can be just the setting, can be just the data {option, optgroups} or all the setting, depending the @param loadMode
				* @param loadMode {SddDropdown.LOAD_MODE_ENUM, optional - default loadSDDMode.All} to specify which mode to load. See enum loadSDDMode above for details
				* @param initSelectedItem {integer, string, HTMLElement - optional}: the index, value or Div.sdd-dropdown-item option for the item to be set selected when SDD just got populated. See selectItem() function for the requirement of this param
			*/
			function loadDropdown(_settingParam, loadMode = loadSDDMode.All, initSelectedItem){
				if ("object" !== typeof _settingParam) 
					return console.error("Search-Dropdown need to be initialized with a setting parameter");
				
				/* make SETTING */
				if(loadMode !== loadSDDMode.DataLoadOnly){
					//Default outer properties of setting
					const _DEFAULT_PROPS = {
						name: "sddDropdown", //the unique name of SDD in order to store SDD internal states such as diacriticsFilterMode, hideExtraTitles to localStorage so page can restore those states on next session. This propery is really important in order to store states correctly and not be missed stored between SDD instances (if those instances use the same name or not specify setting.name attribute)
						displayOneLine: false, //sdd display on only one line when close
						makeSelectKey: "Ctrl + Shift", //the key that would make active option immediately becoming selected option. See keydown event for more
						maxHeight: [400, 900], // the range for max-height of dropdown menu (div.sdd-dropdown-content - part that contains all options) when it is open. the height of SDD is set so that its bottom, when expanded, almost reaches to bottom of viewport. If the set-height out of this range, the height will be set to either end of the range.
						//backgroundCSSClass: null, //specify class that would decorate background for SDDDropdownContent. If not specified, the default class for background is .circus-background
						customizedCssClass: null, //this specify the customized css class for components of SDD, this should be a string that specify the name of customized class applied for whole .sdd-wrapper container. If we need to change the css for any component inside .sdd-wrapper, in CSS code we specify the query-selector path for that component and put css for that component inside that path. See changeBook() function for this customized setting for ssData.sddChaps
						avatarIcon: null, // this is used to customize the icon that locates at right side of representativeDiv, this can be an svg icon element, an url of an id pointing to svg icon/sprite. See function _setSDDAvatar() for more details
						searchBoxPlaceholder: "Search in {_items_length} items ...", //🔍 the text that will display as placeholder in search textbox, where {_items_length} would be replaced by the number of items of this dropdown
						statusBarTimeout: 5000, //the duration in ms that starusBar appear when user filter the items
						rightAlignInEachOptGroup: true, //for elements that having attribute [data-rAlignGroup] (see more in _DEFAULT_RENDER const below), they will be right align in each optGroup (true) or all SDD
						diacriticsFilterMode: true, //option (=false) to search matching with whatever user type in or (=true) removed diacritics from both searchStr and textContent (searched String) before doing the matching
						hideExtraTitleMode: false, // true to hide extra titles of SDD options, false if show. Extra titles can be found on ssData.sddBooks and ssData.sddChaps for some Xianxian books
						
						valueField: "value",	//The name of the property to use as the value when an item is selected.
						optgroupField: "gId", //The name of the property to group items by.
						searchField: [], //An array of property names to analyze when filtering options.
					};
					//default render functions
					const _DEFAULT_RENDER = {
						//function to render the option. escape is a buil-in function to escape all  HTML tag special character such as &<>'".... Any element in the rendering HTML which include attribute [data-rAlignGroup] class will be rendered vertically right-align from option to option. The value of [data-rAlignGroup] attribute is used to identify that element across option item, so if an option has multiple element need to right-aligned (that is, having [data-rAlignGroup] attribute), the value of [data-rAlignGroup] attribute of them HAS to be different. Avoid using "itemOrder" as value of [data-rAlignGroup] attribute since it has to be used for <em> element which contains the order of option. See render function in popuGrpBookTitles() for an example
						'option': (data, escape) => {
							return '<span>' + escape(data["label"]) + '</span>';
						},
						//function to extract element from current option to show on representatve DIV {div.sdd-controls}, the one left off sdd when sdd closed
						'select_option': (option, escape) => {
							return '<span>' + escape(option.textContent) + '</span>';
						},
						//function to render the header of option group. 
						'optgroup_header': (data, escape) => {
							return '<span>' + escape(data["label"]) + '</span>';
						},
						//function to render the notification text that notify no-result when search haven't found nothing
						'no_results': () => {
							return '<span>No results found</span>';
						}
					};
					//default render functions
					const _DEFAULT_CALLBACKS = {
						//callback function would be invoked when a new item selected. Note that when assign property {value} and {selectedIndex}, this callback will not be invoked to avoid loop code
						onChange: null,
						//function to notify user if SDD have something that end-user should know (such as select 'disabled item' is not allowed). See Toast.showBasicToast() for the options. Beside the standard options of Toast.showBasicToast(), user might add one property toastType to set the toast type, if missing the default would be toast.ToastType.Warning
						'notify': (message, options) => {
							toast.showToast(message, options?.toastType ?? toast.ToastType.Warning, options);
						}
						//callback function which will be invoked every time _setting.diacriticsFilterMode is changed (e.g: when user click on '.search-diacritics-option-button' button). This callback function will has one param, which is new value of _setting.diacriticsFilterMode
						/* , diacriticsFilterModeOnChanged: null */
					}

					if(_settingParam.maxHeight){ //if maxHeight properties not array of range, just remove it
						if(!Array.isArray(_settingParam.maxHeight)) delete _settingParam.maxHeight;
					}

					// merge the user-setting with default one
					_settings = {};
					_settings = Object.assign({}, _DEFAULT_PROPS, _settingParam); //outer properties
					_settings.render = Object.assign({}, _DEFAULT_RENDER, _settingParam.render); //render properties
					_settings.callbacks = Object.assign({}, _DEFAULT_CALLBACKS, _settingParam.callbacks); //callbacks properties

					//set customized css class (mostly background) for some SDD component, such as background for SDD Dropdown Content, decoration for SDD-dropdown-bottom-border. See _DEFAULT_PROPS for the detailed explanation, See changeBook() function for this customized setting for ssData.sddChaps
					const _customizedCss = _settings.customizedCssClass;
					if(_customizedCss) _sddWrapper.classList.add(_customizedCss);

					//set avatar icon if setting defines
					if(_settings.avatarIcon) _setSDDAvatar( _settings.avatarIcon );
					
					// class event callbacks
					_onChange = _settings.callbacks.onChange;
					if("function" == typeof _settings.callbacks.notify) _notifyFunction = _settings.callbacks.notify;

					//remove all space from the name, because the name will be used as attribute of sddState json which will be save to localStorage as environment variables
					let _sddName = _settings.name.replace(/\s/g,"");
					if(_sddName == "") {
						alert("SDD instance must have unique name defined in {settings.name} attribute. Different instances must has diffrent names !!!");
						return;
					}
					//adding prefix SDD_ to the name to easily identify
					_sddName = _settings.name = "SDD_" + _sddName;

					//get SDD states saved from last page session stored in localStorage
					function getFromStorage(_storageName){ //wrap function to restore json variable from localStorage
						let resState = localStorage.getItem(_storageName);
						if (resState != null) {
							try {
								resState = JSON.parse(resState);
							} catch (e) { resState = null }
						}
						return resState;
					}

					//get states for current sdd instance from local Storage with the name {_sddName}
					// for now, the full format of _sddState should be {diacriticsMode: true, hideExtraTitle: false}
					_sddState = getFromStorage(_sddName) ?? {diacriticsMode: _settings.diacriticsFilterMode ?? true, hideExtraTitle: _settings.hideExtraTitleMode ?? true};
					// this mean, the order of priority to set the value of _sddState.diacriticsMode (similarly with hideExtraTitle) is 1) from localStorage 2) from _settings.diacriticsFilterMode 3) true.

					//create sHighlite object that bind to current {searchStr}
					if(!sHighlite)
					sHighlite = new SearchHighlite();					

					//set the button appearance according to setting option
					setDiacriticsFilterMode();
				}
				/* DONE with SETTING */

				/* Load DATA */
				if(loadMode !== loadSDDMode.SettingLoadOnly){
					if(loadMode === loadSDDMode.DataLoadOnly){
						//assign new Data for SDD before populating
						_settings = Object.assign(_settings, _settingParam);
					}

					populateDropdown(initSelectedItem); //generate dropdown options and groups
					
					//new sdd, when open dropdown again, we need to re-caluculate dimension for right-aligned items and re-assign their width property
					_dropdownOpenFirstTime = true;
					//nes sdd, we need to re-rightalign elements having attribute [data-rAlignGroup]
					_alignRightElementsDoneFlag = false;
					//reset state of collapse/expand groups button
					sddInputWrapper.querySelector(".close-open-groups-button").dataset.toggleState = 0;

					//default: select first item, no onChange() event fire
					//if(initSelectedIndex == undefined) selectItem(0, true); 
				}				
			}
	
			/* PUBLIC FUNCTIONS ASSIGNMENT */

			//this.onChange = _onChange;
			//alias of onChange function without parameter
			this.onchange = () => {
				if('function' == typeof _onChange) _onChange(_selectedItem);
			};
	
			//fnc to load new data to existing SDD
			this.loadDropdown = loadDropdown;
			//fnc to select an item by index, value or element itself
			this.selectItem = selectItem;
			this.sddUnregisterEvents = sddUnregisterEvents;
			//public for toggle SDD by keypress
			this.toggle = toggleDropdown;
			
			//function to right-align sub-elements having attribute [data-rAlignGroup]. This is set public below for using outside this class, such as for #elmPlaylist or #lstBookTitlesSetting. This function is quite independent to whole class, so I put it in prototype
			SddDropdown.prototype.rightAlignElems = _rightAlignElems;
			SddDropdown.prototype.scrollToElement = _scrollToElement;

			//function to glowing an element
			SddDropdown.prototype.glowingElem = _glowingElem;
			//function to glowing the SDD (when it is collapsed)
			this.glowing = _ => _glowingElem(representativeDiv);
			
			//note that following 2 functions will NOT fire onChange() event
			this.nextItem = _ => goAdjacent(1);
			this.prevItem = _ => goAdjacent(-1);
	
			//if _settingParam is specified in SddDropdown, populate dropdown
			if ("object" == typeof _settingParam) loadDropdown(_settingParam);
			
			//register event handlers for sdd to response to user (mouse, keyboard, etc) actions
			sddRegisterEvents();
		}
	
		/* //Usage: const sddDropdown = new SddDropdown(".sdd-container", _setting);
	
		const sddDropdown = new SddDropdown(".sdd-container");
		sddDropdown.loadDropdown(_setting, 5); 
		*/
	</script>

	<!-- SVG ICONS LIBRARY -->
	<svg width="0" height="0" class="elm-hidden" id="core-svg-icon" xmlns="http://www.w3.org/2000/svg">
		<!-- Audio controls icons -->
		<symbol id="icnSvgReload" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 118.66">
			<path
				d="M 16.68,22.2 C 14.9,24.41 13.25,26.75 11.62,29.66 5.63,40.31 3.1,52.39 4.13,64.2 5.14,75.74 9.56,87.03 17.5,96.47 c 2.85,3.39 5.91,6.38 9.13,8.97 11.11,8.93 24.28,13.34 37.41,13.22 13.13,-0.12 26.21,-4.78 37.14,-13.98 3.19,-2.68 6.18,-5.73 8.91,-9.13 6.4,-7.96 10.51,-17.29 12.07,-27.14 1.53,-9.67 0.59,-19.83 -3.07,-29.66 C 115.6,29.4 110.27,21.07 103.31,14.54 96.7,8.33 88.59,3.76 79.2,1.48 76.26,0.77 73.26,0.3 70.21,0.11 c -3.06,-0.2 -6.19,-0.13 -9.4,0.22 -2.01,0.22 -3.46,2.03 -3.24,4.04 0.22,2.01 2.03,3.46 4.04,3.24 2.78,-0.31 5.49,-0.37 8.14,-0.19 2.65,0.17 5.23,0.57 7.73,1.17 8.11,1.96 15.1,5.91 20.84,11.29 6.14,5.75 10.85,13.12 13.94,21.43 3.21,8.61 4.04,17.51 2.7,25.96 -1.37,8.58 -4.96,16.73 -10.56,23.69 -2.47,3.07 -5.12,5.78 -7.91,8.13 -9.59,8.07 -21.03,12.15 -32.5,12.26 -11.47,0.11 -23,-3.76 -32.76,-11.61 C 28.33,97.41 25.61,94.76 23.1,91.77 16.18,83.55 12.33,73.68 11.45,63.57 10.54,53.19 12.77,42.58 18.02,33.24 19.61,30.42 21.23,28.17 23.03,26 l 0.53,14.7 c 0.07,2.02 1.76,3.6 3.78,3.53 2.02,-0.07 3.6,-1.76 3.53,-3.78 L 30.02,17.03 c -0.07,-2.02 -1.76,-3.59 -3.78,-3.52 -0.13,0.01 -0.25,0.02 -0.37,0.03 v 0 l -22.7,3.19 c -2,0.28 -3.4,2.12 -3.12,4.13 0.28,2 2.12,3.4 4.13,3.12 z M 98.2393,58.71 42.72725,89.104525 42.282275,31.187 Z" />
		</symbol>
		<symbol id="icnSvgFastForward" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M256 0c70.69 0 134.7 28.66 181.02 74.98C483.34 121.31 512 185.32 512 256.01c0 70.68-28.66 134.69-74.98 181.01C390.7 483.34 326.68 512 256 512s-134.69-28.66-181.02-74.98C28.66 390.7 0 326.69 0 256.01c0-70.68 28.66-134.7 74.98-181.03C121.31 28.66 185.32 0 256 0zm110.47 269.8c10.3-9.17 10.02-17.33 0-26.62l-86.09-76.78c-11.21-7.03-22.9-2.9-22.59 11.73l.12 43.14-61.54-54.87c-11.2-7.03-22.89-2.9-22.59 11.73l.45 154.47c.96 15.86 10.01 20.21 23.37 12.87l60.51-53.95.12 41.08c.96 15.86 10.01 20.21 23.36 12.87l84.88-75.67zm46.28-170.55C372.64 59.15 317.22 34.33 256 34.33S139.36 59.15 99.26 99.25c-40.11 40.11-64.93 95.55-64.93 156.76 0 61.21 24.82 116.63 64.93 156.74 40.1 40.1 95.52 64.92 156.74 64.92 61.21 0 116.64-24.82 156.75-64.92 40.1-40.11 64.92-95.53 64.92-156.74 0-61.23-24.82-116.65-64.92-156.76z" />
		</symbol>
		<symbol id="icnSvgSkipNext" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M255.99 0c70.68 0 134.7 28.66 181.02 74.98C483.33 121.3 512 185.31 512 256c0 70.68-28.67 134.69-74.99 181.01C390.69 483.33 326.67 512 255.99 512S121.3 483.33 74.98 437.01C28.66 390.69 0 326.68 0 256c0-70.67 28.66-134.7 74.98-181.02C121.3 28.66 185.31 0 255.99 0zm53.25 163.2h29.85c5.65 0 10.27 4.66 10.27 10.28v165.04c0 5.62-4.65 10.28-10.27 10.28h-29.85c-5.63 0-10.28-4.63-10.28-10.28V173.48c0-5.65 4.63-10.28 10.28-10.28zm-41.69 106.6c10.29-9.17 10.01-17.33 0-26.62l-82.3-76.78c-11.21-7.03-22.9-2.9-22.59 11.73l.44 154.47c.97 15.86 10.01 20.21 23.37 12.87l81.08-75.67zM412.74 99.25c-40.1-40.1-95.54-64.92-156.75-64.92-61.21 0-116.63 24.82-156.74 64.92-40.1 40.11-64.92 95.54-64.92 156.75 0 61.22 24.82 116.64 64.92 156.74 40.11 40.11 95.53 64.93 156.74 64.93 61.21 0 116.65-24.82 156.75-64.93 40.11-40.1 64.93-95.52 64.93-156.74 0-61.22-24.82-116.64-64.93-156.75z" />
		</symbol>
		<!-- complex svg sprite that can be controled by css class (see css symbol#icnSvgPlayPauseProgress), which can change the appearance of Play/Pause button in 1 of 4 choices: audio if playing/paused (using class .isPPP-play) and circle progress is shown/hidden (using class .isPPP-noProgress) -->
		<symbol id="icnSvgPlayPauseProgress" viewBox="2 2 138 138">
			<!-- group of play/pause icon located at the center of the symbol -->
			<g name="playpauseIcon">
			  <!--The play icon which is a triagle-->
			  <polygon name="svgPlayIcon" transform="translate(53 32), scale(0.6)" points="92.2,60.97 0,122.88 0,0 92.2,60.97"/>
			  <!--The Paused icon with if two parallel vertical bars-->
			  <path name="svgPauseIcon" transform="translate(16.2 16.2), scale(0.9)" style="fill-rule:evenodd;" d="M61.44,0c33.93,0,61.44,27.51,61.44,61.44c0,33.93-27.51,61.44-61.44,61.44S0,95.37,0,61.44 C0,27.51,27.51,0,61.44,0L61.44,0z M68.16,33.88H84.1V89l-15.94,0V33.88L68.16,33.88L68.16,33.88z M38.78,33.88h15.94V89l-15.94,0 V33.88L38.78,33.88L38.78,33.88z"/>
			</g>

			<!-- group of circle that circumference the symbol -->
			<g name="svgIsPPP-Border" transform="rotate(-90 71 71)">
			  <!--The circle to be the border of the button-->
			  <circle name="svgProgressCircleBackground" r="61" cx="71" cy="71" fill="transparent" 
			  stroke="var(--progress-background-color)" stroke-width="var(--progress-bar-width)" 
			  stroke-dashoffset="0" stroke-dasharray="383.3"/>
			  <!--The progress circle-->
			  <circle id="svgProgressCircleBar" r="61" cx="71" cy="71" fill="transparent" 
			  stroke="var(--progress-bar-color)" stroke-width="var(--progress-bar-width)" stroke-linecap="round" 
			  stroke-dashoffset="192" stroke-dasharray="383.3"/>
			</g>
		</symbol>
		  
		<symbol id="icnSvgVolumeOn" xmlns="http://www.w3.org/2000/svg" viewBox="0 1.01 16 13.99">
			<path
				d="M7 1.008a.99.99 0 0 0-.77.351L3 5H2C.906 5 0 5.844 0 7v2c0 1.09.91 2 2 2h1l3.23 3.64A.97.97 0 0 0 7 15zm6.46.96a1 1 0 0 0-.558.169 1.005 1.005 0 0 0-.27 1.39 7.995 7.995 0 0 1 0 8.946 1.005 1.005 0 0 0 .27 1.39 1.005 1.005 0 0 0 1.391-.27 10.015 10.015 0 0 0 0-11.187 1 1 0 0 0-.832-.437m-3.42 2.02A1.004 1.004 0 0 0 9 4.996v.059a.95.95 0 0 0 .2.535 4 4 0 0 1 0 4.816.97.97 0 0 0-.2.535v.063c0 .305.133.605.395.805a1 1 0 0 0 1.398-.2A5.98 5.98 0 0 0 12 8a6 6 0 0 0-1.207-3.613 1 1 0 0 0-.754-.399m0 0" />
		</symbol>
		<symbol id="icnSvgVolumeOff" xmlns="http://www.w3.org/2000/svg" viewBox="0 1.01 15.01 13.99">
			<path
				d="M7 1.008a.99.99 0 0 0-.77.351L3 5H2C.906 5 0 5.844 0 7v2c0 1.09.91 2 2 2h1l3.23 3.64A.97.97 0 0 0 7 15zM10 5a1 1 0 0 0-.707 1.707L10.586 8 9.293 9.293a1 1 0 1 0 1.414 1.414L12 9.414l1.293 1.293a1 1 0 1 0 1.414-1.414L13.414 8l1.293-1.293a1 1 0 1 0-1.414-1.414L12 6.586l-1.293-1.293A1 1 0 0 0 10 5m0 0" />
		</symbol>
		<symbol id="icnSvgMinusSign" xmlns="http://www.w3.org/2000/svg" viewBox="2.16 9.52 19.69 4.95">
			<path d="M21.845 12c0 1.367-1.152 2.475-2.573 2.475H4.728c-1.421 0-2.573-1.108-2.573-2.475s1.152-2.475 2.573-2.475h14.544c1.421 0 2.573 1.108 2.573 2.475"/>
		</symbol>
		<symbol id="icnSvgPlusSign" xmlns="http://www.w3.org/2000/svg" viewBox="4.06 4.07 15.87 15.86">
			<path d="M9.964 4.07h4.072c.242 0 .437.196.437.437v5.026H19.5c.241 0 .436.196.436.437v4.06a.436.436 0 0 1-.436.437h-5.026v5.026a.437.437 0 0 1-.437.437H9.964a.437.437 0 0 1-.436-.437v-5.026H4.5a.437.437 0 0 1-.436-.437V9.97c0-.242.195-.437.436-.437h5.027V4.507c0-.241.195-.437.436-.437"/>
		</symbol>

		<!-- functional buttons right below audio player -->
		<!-- <symbol id="icnSvgJump2PlayingChap" xmlns="http://www.w3.org/2000/svg" viewBox="3.74 4.53 16.35 14.79">
			<path d="M8.694 7.625V6.003h9.782v11.854H8.859v-1.292H7.238v2.761h12.859V4.534H7.073v3.09z" />
			<path d="m16.45 11.932-2.865 2.64-2.851 2.64v-3.24H3.742V9.71h6.992V6.65l2.851 2.642z" />
		</symbol> -->
		<symbol id="icnSvgRunJumping" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105.74 122.88">
			<path
				d="M3.07 79.92c4.32 1.19 29.57 17.12 32.69 10.85.32-.64 2.87-6.24 2.87-6.27l13.62 3.47c.44 1.39-5.97 12.95-7.23 14.27-1.6 1.68-3.21 2.68-4.93 3.57C34.31 108.79 6.82 94.12 0 93.16zm72.78 39.9c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zm10.94-7.69c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zm.33-11.66c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zM22.26 22.99c-.66-.15-1.03-.97-.83-1.83.19-.86.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm-2.47-10.86c-.66-.15-1.03-.97-.83-1.83.19-.86.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm5.9-8.98c-.66-.15-1.03-.97-.84-1.83s.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm13.28 44.06-2.86 17.67c-.58 6.69-.63 11.89 5.95 15 3.44 1.62 4.32 1.42 8.12 2.06l19.27-.42c1.04-.02 26.34 11.02 28.43 12.43l7.83-9.36c1.1-1.31-25.7-14.04-29.63-15.46-18.65-6.72-20.64 10.5-16.9-15.51 3.75 2.9 6.93 3.62 13.62 5.39 8.01 1.1 11.41-.86 17.65-3.7l9.22-4.57-7.14-10.84-7.05 4.2c-.26.12-.92.45-2.08 1.01-2.92 1.07-5.25 1.95-7.25 1.26-6.64-2.32-12.06-12.07-29.81-11.45-24.69.86-22.32-2.09-38.63 17.42l9.79 7.55c7.7-9.21 8.39-11.43 20.79-12.61.23-.04.45-.05.68-.07M59.12 9.04c6.83-3.12 14.89-.11 18 6.72 3.12 6.83.11 14.89-6.72 18-6.83 3.12-14.89.11-18-6.72-3.12-6.83-.11-14.89 6.72-18" />
		</symbol>
		<!-- https://uxwing.com/alarm-snooze-icon/ -->
		<symbol id="icnSvgSleepTimer" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 493 511.92">
			<path d="M277.16 41.75c49.87 6.77 94.55 29.89 128.47 63.79 40.67 40.67 65.83 96.87 65.83 158.93 0 62.08-25.15 118.28-65.83 158.96a227 227 0 0 1-25.34 21.83l27.24 38.33c5.68 8.18 3.65 19.42-4.54 25.11-8.19 5.68-19.44 3.65-25.12-4.54l-28.28-39.78c-30.84 15.91-65.83 24.89-102.92 24.89-37.7 0-73.23-9.28-104.43-25.69l-26.59 39.71c-5.54 8.28-16.76 10.5-25.04 4.95-8.29-5.55-10.5-16.75-4.95-25.03l26.07-38.95a226 226 0 0 1-24-20.83c-40.68-40.68-65.84-96.89-65.84-158.96 0-62.06 25.17-118.26 65.84-158.93 36.44-36.44 85.34-60.4 139.74-65.03 16.45-1.4 33.38-.97 49.69 1.24m5.6 195.95 65.46-.03v31.57H234.68V239l63.71-63.71h-62.95v-31.57h110.69v30.24zM177.59 355.19l44.18-.03v21.31h-76.64v-20.41l43.01-43h-42.49v-21.31h74.71v20.41zm304.1-210.46c17.29-41.28 15.24-84.52-9.52-113.49-29.69-34.76-83.39-38.75-133.25-14.3 53.01 36.36 101.11 78.78 142.77 127.79m-470.15 1.35C-6.1 104.02-4.01 59.97 21.21 30.45 51.47-4.97 106.18-9.03 156.99 15.88c-54 37.06-103.03 80.26-145.45 130.2m368.56-15.02c-34.14-34.15-81.31-55.27-133.42-55.27-52.1 0-99.28 21.12-133.43 55.27-34.14 34.14-55.26 81.31-55.26 133.42s21.12 99.28 55.26 133.43c34.15 34.14 81.32 55.26 133.42 55.26 52.12 0 99.29-21.12 133.43-55.26 34.14-34.15 55.27-81.32 55.27-133.44 0-52.1-21.12-99.27-55.27-133.41"/>
		</symbol>

		<!-- Other icons -->
		<!-- https://custicon.com/ , code hourglass ci-00855  -->
		<symbol id="icnSvgHourGlass" xmlns="http://www.w3.org/2000/svg" viewBox="3 1 13 19">
			<path d="M16 3.5V3c0-.392-.241-.733-.717-1.014-.344-.203-.821-.382-1.419-.531-1.172-.293-2.722-.454-4.364-.454s-3.192.161-4.364.454c-.598.149-1.075.328-1.419.531C3.241 2.267 3 2.608 3 3v.5a6.51 6.51 0 0 0 4 6.002v1.997a6.51 6.51 0 0 0-4 6.002v.5c0 .392.241.733.717 1.014.344.203.821.382 1.419.531C6.308 19.839 7.858 20 9.5 20s3.192-.161 4.364-.454c.598-.149 1.075-.328 1.419-.531.476-.281.717-.623.717-1.014v-.5a6.51 6.51 0 0 0-4-6.002V9.502A6.51 6.51 0 0 0 16 3.5M5.612 2.369C6.678 2.131 8.059 2 9.5 2s2.823.131 3.888.369c1.15.257 1.498.534 1.589.631-.091.097-.439.374-1.589.631C12.322 3.869 10.941 4 9.5 4s-2.823-.131-3.888-.369C4.462 3.374 4.114 3.097 4.023 3c.091-.097.439-.374 1.589-.631m5.721 9.944A5.51 5.51 0 0 1 15 17.5v.473c-.042.057-.324.37-1.612.657-1.066.238-2.447.369-3.888.369s-2.823-.131-3.888-.369c-1.287-.288-1.57-.6-1.612-.657V17.5a5.51 5.51 0 0 1 3.667-5.187.5.5 0 0 0 .333-.471V9.159a.5.5 0 0 0-.333-.471 5.51 5.51 0 0 1-3.624-4.506q.451.203 1.093.364C6.308 4.839 7.858 5 9.5 5s3.192-.161 4.364-.454a6.6 6.6 0 0 0 1.093-.364 5.51 5.51 0 0 1-3.624 4.506.5.5 0 0 0-.333.471v2.683a.5.5 0 0 0 .333.471"/>
			<path d="M13.667 16.529C11.405 15.73 10 13.803 10 11.5V8.475a5 5 0 0 0 1.723-.495.5.5 0 0 0-.445-.895c-.555.276-1.153.416-1.778.416s-1.223-.14-1.778-.416a.5.5 0 0 0-.445.895A4.9 4.9 0 0 0 9 8.475V11.5c0 2.302-1.405 4.229-3.667 5.029a.499.499 0 0 0 .058.959c.982.22 2.477.512 4.109.512s3.127-.292 4.109-.512a.5.5 0 0 0 .058-.959M9.5 17c-.877 0-1.701-.087-2.437-.205a6.4 6.4 0 0 0 1.711-1.575c.293-.391.536-.812.726-1.254.19.442.433.863.726 1.254a6.4 6.4 0 0 0 1.711 1.575c-.736.117-1.56.205-2.437.205"/>
		</symbol>
		<symbol id="icnSvgSpinWaiting" viewBox="24 24 52 52">
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.92s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(30 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.83s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(60 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.75s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(90 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.67s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(120 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.58s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(150 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.5s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(180 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.42s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(210 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.33s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(240 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.25s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(270 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.17s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(300 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.08s" repeatCount="indefinite"/>
			</rect>
			<rect x="47" y="24" rx="3" ry="6" width="6" height="12" transform="rotate(330 50 50)">
			  <animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="0s" repeatCount="indefinite"/>
			</rect>
		</symbol>

		<!-- SETTING icons -->
		<symbol id="icnSvgSetting" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.878">
			<path fill-rule="evenodd"
				d="M101.589,14.7l8.818,8.819c2.321,2.321,2.321,6.118,0,8.439l-7.101,7.101 c1.959,3.658,3.454,7.601,4.405,11.752h9.199c3.283,0,5.969,2.686,5.969,5.968V69.25c0,3.283-2.686,5.969-5.969,5.969h-10.039 c-1.231,4.063-2.992,7.896-5.204,11.418l6.512,6.51c2.321,2.323,2.321,6.12,0,8.44l-8.818,8.819c-2.321,2.32-6.119,2.32-8.439,0 l-7.102-7.102c-3.657,1.96-7.601,3.456-11.753,4.406v9.199c0,3.282-2.685,5.968-5.968,5.968H53.629 c-3.283,0-5.969-2.686-5.969-5.968v-10.039c-4.063-1.232-7.896-2.993-11.417-5.205l-6.511,6.512c-2.323,2.321-6.12,2.321-8.441,0 l-8.818-8.818c-2.321-2.321-2.321-6.118,0-8.439l7.102-7.102c-1.96-3.657-3.456-7.6-4.405-11.751H5.968 C2.686,72.067,0,69.382,0,66.099V53.628c0-3.283,2.686-5.968,5.968-5.968h10.039c1.232-4.063,2.993-7.896,5.204-11.418l-6.511-6.51 c-2.321-2.322-2.321-6.12,0-8.44l8.819-8.819c2.321-2.321,6.118-2.321,8.439,0l7.101,7.101c3.658-1.96,7.601-3.456,11.753-4.406 V5.969C50.812,2.686,53.498,0,56.78,0h12.471c3.282,0,5.968,2.686,5.968,5.969v10.036c4.064,1.231,7.898,2.992,11.422,5.204 l6.507-6.509C95.471,12.379,99.268,12.379,101.589,14.7L101.589,14.7z M61.44,36.92c13.54,0,24.519,10.98,24.519,24.519 c0,13.538-10.979,24.519-24.519,24.519c-13.539,0-24.519-10.98-24.519-24.519C36.921,47.9,47.901,36.92,61.44,36.92L61.44,36.92z" />
		</symbol>
		<symbol id="icnSvgFullTrashBin" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M322.62 254.95h-20.71v195.41h20.71V254.95zM111.53 2.02l105.89 36.64 3.26-9.41c.11-.32.23-.64.38-.94 3.69-9.25 13.28-14.76 23.08-13.35 2.56.37 4.75 1.19 7.16 2.03l60.97 21.1c.82.28 1.62.53 2.4.91 5.11 2.08 9.07 5.94 11.32 10.59 2.21 4.56 2.8 9.93 1.36 15.13-.17.61-.35 1.25-.55 1.83l-3.07 8.89 106.95 37.01c1.43.49 2.47.88 3.84 1.61 6.86 3.69 10.35 11.45 8.43 19.03-.21.82-.44 1.59-.72 2.38l-12.01 34.71c-1.67 4.85-6.97 7.41-11.81 5.74l-19.61-6.79a81.15 81.15 0 0 1 6.56 28.24c1.22.78 2.35 1.68 3.36 2.68 3.52 3.47 5.81 8.14 5.93 13.34.02 1.1-.11 2.21-.21 3.3L388.9 490.72c-.33 3.6-.93 6.8-2.75 10.18-3.52 6.55-10.03 11.1-18.14 11.1H117.06c-5.32 0-9.19-.47-13.67-3.53-5.28-3.61-8.74-9.7-9.35-16.46L68.66 215.9c-.08-.87-.16-1.82-.13-2.68.18-5.15 2.44-9.76 5.94-13.19 2.78-2.73 6.45-4.74 10.43-5.61-.19-.97-.3-1.96-.3-2.99v-66.36c0-8.26 6.76-15.02 15.02-15.02h78.92c8.25 0 15.01 6.76 15.01 15.02v22.45c12.39-10.17 28.24-16.28 45.52-16.28a71.52 71.52 0 0 1 32.54 7.79c4.18-3.5 8.71-6.6 13.54-9.22L79.45 58.63c-4.85-1.68-7.42-6.97-5.75-11.82l.07-.2 11.29-32.63C89.79.32 98.32-2.56 111.53 2.02zm143.75 252.93h-20.72v195.41h20.72V254.95zm-67.34 0h-20.71v195.41h20.71V254.95zm205.55-42.48H89.89c-1.99 0-2.94.34-2.75 2.45l25.11 273.2c.16 1.69.13 5.33 2.53 5.29h253.25c2.08 0 2.32-2.93 2.46-4.44l25.57-274.23c.16-1.77-.89-2.27-2.57-2.27zm-224.75-23.88h9.8v-52.32c0-5.98-4.9-10.87-10.88-10.87h-57.17c-5.98 0-10.87 4.89-10.87 10.87v52.32h69.12zm100.12 2.44H379.1c-2.52-15.25-11.22-28.4-23.44-36.82l-.15-.11-.23-.15-.38-.26-.38-.25-.02-.01-.37-.25-.39-.24-.26-.17-.13-.08-.4-.24-.39-.24-.11-.06-.29-.17-.4-.23-.36-.21-.04-.02-.4-.23-.41-.22-.41-.22-.41-.21-.41-.22-.06-.03-.35-.17-.42-.21-.32-.16-.09-.04-.42-.2-.43-.2-.16-.07-.26-.12-.43-.19-.42-.18-.01-.01-.42-.17-.71-.29-.16-.06-.84-.33-.02-.01-.12-.05-.32-.12-.44-.16-.4-.14-.04-.01-.45-.16-.44-.15-.24-.07-.21-.07-.45-.15-.45-.13-.06-.02-.39-.12-.45-.13-.35-.1-.11-.03-.45-.12-.46-.12-.18-.05-.28-.07-.46-.11-.46-.11h-.01l-.46-.1-.76-.17-.17-.03-.46-.09-.48-.09-.12-.03-.34-.06-.48-.08-.42-.07-.05-.01-.48-.07-.47-.07-.24-.04-.24-.03-.48-.06-.48-.05-.06-.01-.42-.05-.48-.05-.37-.03-.11-.01-.49-.04-.48-.04-.19-.01-.3-.02c-1.18-.08-2.37-.12-3.57-.12-27.51 0-50.44 19.73-55.12 46.67z" />
		</symbol>
		<symbol id="icnSvgTrashBin" xmlns="http://www.w3.org/2000/svg" viewBox="128 64 768 896">
			<path d="M384 384h64v384h-64zm192 0h64v384h-64z"/>
			<path d="M128 192v64h64v640a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V256h64v-64zm128 704V256h512v640zM384 64h256v64H384z"/>
		</symbol>
		<symbol id="icnSvgCheckDBsUpdate" xmlns="http://www.w3.org/2000/svg" viewBox="1.1 0 56 58.2">
			<path d="M44.1 32.201c-3.764 0-7.317 1.581-9.75 4.338a1.001 1.001 0 0 0 1.5 1.324c2.053-2.327 5.061-3.662 8.25-3.662 6.065 0 11 4.935 11 11s-4.935 11-11 11c-4.992 0-9.407-3.367-10.741-8H38.1v-2h-8v8h2v-3.664c2.093 4.531 6.781 7.664 12 7.664 7.168 0 13-5.832 13-13s-5.832-13-13-13M26.243 43.109a16.95 16.95 0 0 1 5.092-10.15q-1.28.073-2.628.111a84 84 0 0 1-5.22-.001c-7.341-.201-13.191-1.238-17.403-2.717C4.104 29.685 2.409 28.899 1.1 28v9.4c2.846 2.971 12.394 5.711 25 5.711zm-2.507-13.144q.487.014.982.023a79 79 0 0 0 2.765.001q.494-.01.982-.023l.349-.008c11.253-.359 19.648-2.915 22.286-5.668v-9.401C46.233 18.232 35.944 20 26.1 20s-20.133-1.768-25-5.111v9.4c2.638 2.754 11.033 5.31 22.286 5.668z"/><path d="M51.1 11.306V9a.9.9 0 0 0-.135-.458C49.843 4.241 41.215 0 26.1 0 11.023 0 2.404 4.22 1.247 8.51A.97.97 0 0 0 1.1 9v2.306C3.937 14.267 13.417 17 26.1 17s22.164-2.733 25-5.694M26.151 46.2H26.1c-12.346 0-20.866-2.29-25-5.201V49.2a.94.94 0 0 0 .117.451C2.398 54.546 12.964 58.2 26.1 58.2c2 0 3.93-.094 5.787-.255A16.95 16.95 0 0 1 26.151 46.2"/>
		</symbol>

		<symbol id="icnSvgHistory" xmlns="http://www.w3.org/2000/svg" viewBox="3 2 18 20">
			<path d="M19 10H5c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2M5 6h14v2H5zm2-4h10v2H7z"/>
		</symbol>
		<symbol id="icnSvgGUI" xmlns="http://www.w3.org/2000/svg" viewBox="2 4 28 24">
			<circle cx="20" cy="8" r="1"/>
			<circle cx="23" cy="8" r="1"/>
			<circle cx="26" cy="8" r="1"/>
			<path d="M28 4H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2m0 2v4H4V6ZM4 12h6v14H4Zm8 14V12h16v14Z"/><path style="fill:none" d="M0 0h32v32H0z"/>
		</symbol>
		<symbol id="icnSvgDatabaseConfig" xmlns="http://www.w3.org/2000/svg" viewBox="3 2 29.1 28.82"><ellipse cx="14" cy="8" rx="10" ry="5"/>
		<ellipse cx="14" cy="8" rx="11" ry="6"/>
		<path d="M14 24c-4.8 0-8.8-1.4-11-3.6V24c0 3.4 4.8 6 11 6 .9 0 1.8-.1 2.7-.2-1.5-1.5-2.4-3.6-2.7-5.8M3 12.4V16c0 3.4 4.8 6 11 6h.1c.2-2.4 1.4-4.6 3-6.2-1 .1-2 .2-3.1.2-4.8 0-8.8-1.4-11-3.6m28.7 8.5c-.1-.5-.7-.8-1.2-.7-.7.2-1.2 0-1.3-.2s0-.7.5-1.3c.4-.4.4-1 0-1.4q-1.5-1.5-3.6-2.1c-.5-.1-1.1.2-1.2.7-.2.7-.6 1-.9 1s-.6-.4-.9-1c-.2-.5-.7-.8-1.2-.7q-2.1.6-3.6 2.1c-.4.4-.4 1 0 1.4.5.5.6 1 .5 1.3-.1.2-.6.4-1.3.2-.5-.1-1.1.2-1.2.7Q16 21.95 16 23c0 1.05.1 1.4.3 2.1.1.5.7.8 1.2.7.7-.2 1.2 0 1.3.2s0 .7-.5 1.3c-.4.4-.4 1 0 1.4q1.5 1.5 3.6 2.1c.5.1 1.1-.2 1.2-.7.2-.7.6-1 .9-1s.6.4.9 1c.1.4.5.7 1 .7h.3q2.1-.6 3.6-2.1c.4-.4.4-1 0-1.4-.5-.5-.6-1-.5-1.3.1-.2.6-.4 1.3-.2.5.1 1.1-.2 1.2-.7q.3-1.05.3-2.1c0-1.05-.2-1.4-.4-2.1M24 26c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3"/>
		</symbol>
		<symbol id="icnSvgKeyboard" viewBox="3 3.7 26 25.31">
			<path d="M27 29.016H5a2 2 0 0 1-2-2v-13a2 2 0 0 1 2-2l1.058.006c0-1.634.497-2.694 1.492-3.807q1.492-1.668 3.702-1.668 1.049 0 2.323.354s1.847.614 3.129.614q2.936 0 4.001-2.574.5-1.238 1.017-1.238.742 0 .742.691 0 1.223-1.322 2.703-1.773 2.012-4.367 2.012c-1.343 0-3.644-.63-3.644-.63q-1.402-.339-1.998-.339-1.435 0-2.458 1.226c-1.023 1.226-1.023 1.54-1.023 2.669L27 12.016a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2m1-15a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v13a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1zm-7.997 7.011h6.018v1.981h-6.018zm1.985-3h4.021v1.981h-4.021zm2.019-3.011h2.003v2.044h-2.003zm-2.97 0h1.961v2.044h-1.961zm-2.029 3.011h1.981v1.981h-1.981zm-.983-3.011h2.002v2.044h-2.002zm-2.071 3.011h2.044v1.981h-2.044zm-.982-3.011h2.044v2.044h-2.044zm-2.97 0h2.023v2.044h-2.023zm-3.074 0h2.065v2.044H8.928zm-2.928 0h2.044v2.044H6zm6.018 4.993H6v-1.981h6.018zm-3.974 6.044H6v-2.044h2.044zm-2.033-5.026h4.021v1.981H6.011zm5.024 5.026H8.99v-2.044h2.045zm4.969-3.044h-2.045v-1.981h2.045zm-2.991 0h-2.044v-1.981h2.044zm1.995-3h-2.045v-1.981h2.045zm3.986 1.018v1.981h-1.981v-1.981zm1.013 5.026h-7.963v-2.044h7.963zm2.991 0h-2.045v-2.044h2.045zm2.99 0h-1.981v-2.044h1.981z"/>
		</symbol>
		<!-- from https://uxwing.com/wp-content/themes/uxwing/download/education-school/books-icon.svg -->
		<symbol id="icnSvgBookSets" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 99.45">
			<path d="M64.48.38H82.9c1.85 0 3.36 1.51 3.36 3.36v14.84H61.12V3.74c0-1.85 1.51-3.36 3.36-3.36m21.79 27.27v45.19H61.12V27.65zm0 54.27v13.8c0 1.85-1.51 3.36-3.36 3.36H64.48c-1.85 0-3.36-1.51-3.36-3.36v-13.8zM101.09.38h18.42c1.85 0 3.36 1.51 3.36 3.36v14.84H97.73V3.74c0-1.85 1.52-3.36 3.36-3.36m21.79 27.27v45.19H97.73V27.65zm0 54.27v13.8c0 1.85-1.51 3.36-3.36 3.36H101.1c-1.85 0-3.36-1.51-3.36-3.36v-13.8zM35.95.2l17.31 6.3c1.74.63 2.64 2.57 2.01 4.31L50.2 24.75l-23.63-8.6 5.07-13.94C32.28.47 34.22-.43 35.95.2M47.1 33.28 31.65 75.75l-23.63-8.6 15.45-42.46zm-18.55 51-4.72 12.96c-.63 1.74-2.57 2.64-4.31 2.01l-17.31-6.3C.47 92.32-.43 90.38.2 88.64l4.72-12.96z"/>
		</symbol>
		<!-- from https://svgicons.com/icon/51196/book-open-microphone-28-filled -->
		<!-- https://brandeps.com/icon-download/B/Book-open-microphone-icon-vector-01.svg -->
		<symbol id="icnSvgBooks" xmlns="http://www.w3.org/2000/svg" viewBox="102.4 153.6 870.4 819.2">
			<path d="M512 819.2c-23.3 31.1-60.5 51.2-102.4 51.2H179.2a76.8 76.8 0 0 1-76.8-76.8V230.4a76.8 76.8 0 0 1 76.8-76.8h230.4c41.9 0 79.1 20.1 102.4 51.2 23.3-31.1 60.5-51.2 102.4-51.2h230.4a76.8 76.8 0 0 1 76.8 76.8v358.4c0-41.9-20.1-79.1-51.2-102.4v-256a25.6 25.6 0 0 0-25.6-25.6H614.4a76.8 76.8 0 0 0-76.8 76.8v460.8c0 26.8 13.8 50.5 34.7 64.2 6.6 22.7 16.5 43.9 29.2 63.2a127.8 127.8 0 0 1-89.5-50.6M153.6 230.4v563.2a25.6 25.6 0 0 0 25.6 25.6h230.4a76.8 76.8 0 0 0 76.8-76.8V281.6a76.8 76.8 0 0 0-76.8-76.8H179.2a25.6 25.6 0 0 0-25.6 25.6M892.2 824a127.5 127.5 0 0 0 29.4-81.6 25.6 25.6 0 0 1 51.2 0 179.3 179.3 0 0 1-153.6 177.4v27.4a25.6 25.6 0 0 1-51.2 0v-27.4a179.8 179.8 0 0 1-136.3-100.6 178.5 178.5 0 0 1-17.3-76.8 25.6 25.6 0 0 1 51.2 0A127.5 127.5 0 0 0 695 824c23.4 28.3 58.9 46.4 98.5 46.4h.2c39.7 0 75.1-18.1 98.5-46.4M716.8 588.8a76.8 76.8 0 0 1 153.6 0v153.6a76.8 76.8 0 0 1-153.6 0z"/>
		</symbol>		

		<!-- History icons -->
		<!-- https://uxwing.com/sweeper-cleaning-icon/ -->
		<symbol id="icnSvgClearHistory" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 121.1">
			<path d="M62.89 56.03c1.11-.35 2.34-.25 3.72.37l10.4 7.87c2.26 1.71 4.24 3.78 2.73 6.9-.51 1.06-1.4 2.1-2.38 3.49l-.53.75c-1.97 2.8-2.61 2-5.71 1.83.56 13.37 1.75 27.82-2.64 40.88-.87 2.7-3.32 3.44-6.95 2.71l-6.1-2.03c4.11-6.14 6.16-13.85 6.44-22.89-3.46 8.58-6.8 16.96-10.68 20.86l-6.28-2.08c.61-3.05 1.05-5.43.35-6.9l-4.07 4.24-9.33-5.77c6.36-3.36 11.62-7.87 15.6-13.73-6.69 5.01-12.76 8.1-18.14 8.99-2.75.83-4.49.35-5.16-1.53-.48-1.34-.05-1.77.81-2.86 1.11-1.41 2.61-2.67 4.35-3.79-3.13 1.1-4.64.95-6.37 1.51-4.9 1.59-9.94-1.86-8.26-6.9 1.07-3.23 3.54-3.09 6.67-4.07l5.42-1.69c-5.19.28-10.32.45-15.02-.25-5.4-.8-5.31-.99-8.24-5.38-3.94-5.91-6.25-11.45 2.52-9.16 16.73 3.18 33.56 5.34 51.25-.98-.76-1.32-.9-2.57-.5-3.73.58-1.75 4.34-6.11 6.1-6.66M113.8 2.42 74.45 51.53c-4.71 6.68 3.2 11.91 8.39 5.64l39.2-49.27c3.08-6.04-2.91-11.06-8.24-5.48"/>
		</symbol>
		<symbol id="icnSvgHistoryForward" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.883 122.882">
			<path
				d="M61.441,0C44.475,0,29.115,6.877,17.996,17.996C6.877,29.115,0,44.475,0,61.441c0,16.966,6.877,32.326,17.996,43.445 c11.119,11.118,26.479,17.995,43.445,17.995c16.967,0,32.327-6.877,43.446-17.995c11.119-11.119,17.996-26.479,17.996-43.445 c0-16.967-6.877-32.327-17.996-43.445C93.768,6.877,78.408,0,61.441,0L61.441,0z M51.505,42.166 c-1.735-1.784-1.696-4.637,0.088-6.372c1.784-1.735,4.637-1.696,6.373,0.088l21.839,22.521l-3.23,3.142l3.244-3.146 c1.738,1.792,1.693,4.652-0.098,6.39c-0.053,0.05-0.105,0.099-0.158,0.146L57.966,87.017c-1.735,1.784-4.588,1.823-6.373,0.088 c-1.784-1.734-1.823-4.588-0.088-6.372l18.78-19.201L51.505,42.166L51.505,42.166z M24.386,24.386 C33.869,14.903,46.97,9.038,61.441,9.038c14.471,0,27.573,5.865,37.055,15.348c9.484,9.483,15.35,22.584,15.35,37.056 c0,14.471-5.865,27.572-15.35,37.055c-9.482,9.483-22.584,15.349-37.055,15.349c-14.471,0-27.572-5.865-37.055-15.349 C14.903,89.014,9.038,75.912,9.038,61.441C9.038,46.97,14.903,33.869,24.386,24.386L24.386,24.386z" />
		</symbol>
		<symbol id="icnSvgSquareLinkArrow" xmlns="http://www.w3.org/2000/svg" viewBox="300 150 424 724">
			<path
				d="M725.4 853.3H256C208.9 853.3 170.7 815.1 170.7 768V298.7C170.7 251.5 208.9 213.3 256 213.3H426.7V298.7H256V768H725.4V597.3H810.7V768C810.7 815.1 772.5 853.3 725.4 853.3ZM499.2 584.8L439.1 524.5 707.6 256H554.7V170.7H853.4V469.3H768V316.4L499.2 584.8Z" />
		</symbol>

		<!-- Icons for using in general chapter information item -->
		<symbol id="icnSvgMicrophone" xmlns="http://www.w3.org/2000/svg" viewBox="192 0 640 1024">
			<path
				d="M224 416a32 32 0 0 1 32 32v64a256 256 0 0 0 512 0v-64a32 32 0 0 1 64 0v64a320 320 0 0 1-288 318.4V960h192a32 32 0 0 1 0 64H288a32 32 0 0 1 0-64h192V830.4A320 320 0 0 1 192 512v-64a32 32 0 0 1 32-32" />
			<path
				d="M640 512a128 128 0 1 1-256 0V192a128 128 0 1 1 256 0zM512 0a192 192 0 0 0-192 192v320a192 192 0 0 0 384 0V192A192 192 0 0 0 512 0" />
		</symbol>
		<symbol id="icnSvgDuration" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512">
			<path d="M320 0c8 0 14.8 5.9 15.9 13.9l49.3 369.5 47-305.8c1.2-7.9 8-13.6 16-13.6s14.6 6 15.7 13.8l34.6 254L528.3 173c1.4-7.3 7.6-12.7 15-13s14.1 4.5 16.1 11.6L588.1 272H624c8.8 0 16 7.2 16 16s-7.2 16-16 16h-48c-7.1 0-13.4-4.7-15.4-11.6l-13.4-46.8-35.5 189.3c-1.4 7.7-8.3 13.2-16.1 13s-14.4-6.1-15.5-13.8L447 191.4l-47.2 307c-1.2 7.9-8 13.6-16 13.6s-14.6-6-15.7-13.9l-48.1-361-48.1 361c-1.1 7.9-7.7 13.8-15.7 13.9s-14.8-5.7-16-13.6l-47.2-307-33.1 242.8c-1.1 7.8-7.6 13.6-15.5 13.8s-14.7-5.3-16.1-13L92.8 245.6l-13.4 46.8c-2 6.9-8.2 11.6-15.4 11.6H16c-8.8 0-16-7.2-16-16s7.2-16 16-16h35.9l28.7-100.4c2-7.1 8.7-11.9 16.1-11.6s13.6 5.7 15 13l29.8 158.8 34.6-254c1.1-7.9 7.8-13.8 15.7-13.8s14.7 5.7 16 13.6l47.1 305.9 49.2-369.6C305.2 5.9 312 0 320 0"/>
		</symbol>
		<symbol id="icnSvgListenTime" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 115.34 122.88">
			<path
				d="M97.74 119.52a2 2 0 0 1-.68-.12V65.93a2 2 0 0 1 .68-.12c3.34 0 6.43 5 8.48 7l-.46-12.12c0-12.8-3.72-23.11-9.68-30.93a7.37 7.37 0 0 1-5.86-2.23l-.68-.7C80.91 18.29 69 14.44 57.24 14.66s-23.48 4.53-31.55 12.25l-.66.64a7.3 7.3 0 0 1-6.49 2.05c-6 7.84-9.75 18.21-9.75 31.14l-.46 13.89c2.25-2.71 6.34-8.66 10-8.82v53.71C10.52 119.36 4.91 107.05 3 101H0V60.74a57.33 57.33 0 0 1 12.83-36.17 7.35 7.35 0 0 1 1.8-7.36l1-.95C26.36 6 41.62.3 57 0s31.25 4.9 42.87 16.46l.91.93a7.33 7.33 0 0 1 1.74 7.2 57.34 57.34 0 0 1 12.81 36.13V101h-2.21c-1.89 6.14-7.54 18.57-15.39 18.57Zm-5.55 3.36h-9a3.48 3.48 0 0 1-3.48-3.47V65.65a3.49 3.49 0 0 1 3.48-3.48h9zm-69-60.71H33a3.5 3.5 0 0 1 3.48 3.48v53.76a3.49 3.49 0 0 1-3.48 3.47h-9.86V62.17Z" />
		</symbol>
		<symbol id="icnSvgCalendar" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 119.92 122.88">
			<path
				d="M108.68,122.88H11.24A11.28,11.28,0,0,1,0,111.64V22.55A11.28,11.28,0,0,1,11.24,11.31H21.61V25.14a12.35,12.35,0,0,0,4.67,9.61,14.55,14.55,0,0,0,18.31,0,12.35,12.35,0,0,0,4.67-9.61V11.31H70.2V25.14a12.35,12.35,0,0,0,4.67,9.61,14.55,14.55,0,0,0,18.31,0,12.35,12.35,0,0,0,4.67-9.61V11.31h10.83a11.3,11.3,0,0,1,11.24,11.24v89.09a11.27,11.27,0,0,1-11.24,11.24ZM83.58,56.77h16.1a2.07,2.07,0,0,1,2.06,2v13.4a2.07,2.07,0,0,1-2.06,2H83.58a2.06,2.06,0,0,1-2-2V58.82a2.05,2.05,0,0,1,2-2Zm-31.51,0H68.18a2.06,2.06,0,0,1,2,2v13.4a2.07,2.07,0,0,1-2,2H52.07a2.06,2.06,0,0,1-2-2V58.82a2.06,2.06,0,0,1,2-2Zm-31.84,0H36.34a2.06,2.06,0,0,1,2,2v13.4a2.07,2.07,0,0,1-2,2H20.23a2.06,2.06,0,0,1-2.05-2V58.82a2.05,2.05,0,0,1,2.05-2ZM83.58,85.26h16.1a2.07,2.07,0,0,1,2.06,2v13.4a2.06,2.06,0,0,1-2.06,2.05H83.58a2.06,2.06,0,0,1-2-2.05V87.31a2.06,2.06,0,0,1,2-2Zm-31.51,0H68.18a2.06,2.06,0,0,1,2,2v13.4a2.06,2.06,0,0,1-2,2.05H52.07a2.06,2.06,0,0,1-2-2.05V87.31a2.07,2.07,0,0,1,2-2Zm-31.84,0H36.34a2.06,2.06,0,0,1,2,2v13.4a2.06,2.06,0,0,1-2,2.05H20.23a2.06,2.06,0,0,1-2.05-2.05V87.31a2.06,2.06,0,0,1,2.05-2ZM78.6,4.45C78.6,2,81,0,84,0s5.43,2,5.43,4.45V25.14c0,2.46-2.42,4.45-5.43,4.45s-5.42-2-5.42-4.45V4.45ZM30,4.45C30,2,32.44,0,35.44,0s5.42,2,5.42,4.45V25.14c0,2.46-2.42,4.45-5.42,4.45S30,27.6,30,25.14V4.45ZM3.6,43.86v66.58a8.87,8.87,0,0,0,8.84,8.84h95a8.87,8.87,0,0,0,8.85-8.84V43.86Z" />
		</symbol>
		<symbol id="icnSvgChapterInfor" xmlns="http://www.w3.org/2000/svg" viewBox="204.8 102.4 614.4 819.2">
			<path
				d="M204.8 204.8v614.4a102.4 102.4 0 0 0 102.4 102.4h486.4a25.6 25.6 0 0 0 0-51.2H307.2a51.2 51.2 0 0 1-51.2-51.2h512a51.2 51.2 0 0 0 51.2-51.2V204.8a102.4 102.4 0 0 0-102.4-102.4H307.2a102.4 102.4 0 0 0-102.4 102.4m512-51.2a51.2 51.2 0 0 1 51.2 51.2V768H256V204.8a51.2 51.2 0 0 1 51.2-51.2zM550.4 294.4a38.4 38.4 0 1 0-76.8 0 38.4 38.4 0 0 0 76.8 0M537.6 640a25.6 25.6 0 0 1-51.2 0V435.2a25.6 25.6 0 0 1 51.2 0z" />
		</symbol>
		<symbol id="icnSvgChapGroupIcon" viewBox="1 1 13 14" xmlns="http://www.w3.org/2000/svg">
			<path d="M1.5 1h2v1H2v12h1.5v1h-2l-.5-.5v-13zm6 6h-2L5 6.5v-2l.5-.5h2l.5.5v2zM6 6h1V5H6zm7.5 1h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 6h2V4h-2zm-3.5 6h-2l-.5-.5v-2l.5-.5h2l.5.5v2zM6 11h1v-1H6zm7.5 2h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 12h2v-2h-2zm-1-2H8v1h2zm0-5H8v1h2z"/>
		</symbol>
		<symbol id="icnSvgMediaLinks" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 95.19">
			<path
				d="M11.7 0h6.19v2.07c15.49 3.54 17.26 11 8.28 22.7.95-11.63-.22-14.12-8.28-14.66v29.4a4 4 0 0 1 0 .47c0 3.82-4 7.61-8.95 8.47S0 46.9 0 43.07c0-5.21 7.16-9.74 11.7-8.14zM103 0h6.19v2.07c15.48 3.54 17.25 11 8.27 22.7 1-11.63-.22-14.12-8.27-14.66v29.87c0 3.82-4 7.61-9 8.47s-9-1.55-9-5.38c0-5.21 7.16-9.74 11.7-8.14V0ZM70.51 68.64a11.3 11.3 0 0 1 4.5.08V37.13l-33.43 9.59v37.3c0 5.82-6.42 10.06-11.57 11-6.39 1.1-11.58-2-11.58-7S23.65 78.18 30 77.08a13 13 0 0 1 6.49.42V32.34l43.54-9.91v50.88c.48 5.4-5 9.49-9.56 10.28-5.34.92-9.66-1.68-9.66-5.81s4.32-8.22 9.66-9.14Z" />
		</symbol>
		<symbol id="icnSvgSwitchChapterLinks" xmlns="http://www.w3.org/2000/svg" viewBox="64 64 896 896">
			<path
				d="M768 768v64h78.7A190.1 190.1 0 0 1 704 896a192.2 192.2 0 0 1-192-192h-64a255.5 255.5 0 0 0 448 168.5V960h64V768zm-64-320a257.3 257.3 0 0 0-192 87.5V448h-64v192h192v-64h-78.7A190.1 190.1 0 0 1 704 512a192.2 192.2 0 0 1 192 192h64a256.3 256.3 0 0 0-256-256" />
			<path
				d="M384 896H192V768h64v-64h-64V544h64v-64h-64V320h64v-64h-64V128h576v256h64V128a64 64 0 0 0-64-64H192a64 64 0 0 0-64 64v128H64v64h64v160H64v64h64v160H64v64h64v128a64 64 0 0 0 64 64h192Z" />
		</symbol>
		<!-- https://www.svgrepo.com/svg/142831/fast-forward-double-right-arrows -->
		<symbol id="icnSkipStart" xmlns="http://www.w3.org/2000/svg" viewBox="0 10.64 220.68 199.4">
		<polygon points="92.695,38.924 164.113,110.341 92.695,181.758 120.979,210.043 220.682,110.341 120.979,10.639 "/><polygon points="28.284,210.043 127.986,110.341 28.284,10.639 0,38.924 71.417,110.341 0,181.758 "/>
		</symbol>

		<!-- Icons for using in general book information item -->
		<!-- https://custicon.com/ , code cb-9566  -->
		<symbol id="icnSvgBookType" xmlns="http://www.w3.org/2000/svg" viewBox="64 256 896 512">
			<path d="M960 512 704 768l-45.2-45.2L869.5 512 658.8 301.2 704 256z"/>
			<path d="M512 704a31.9 31.9 0 0 1-22.6-9.4l-160-160a32 32 0 0 1 0-45.2l160-160a32 32 0 0 1 45.2 0l160 160a32 32 0 0 1 0 45.2l-160 160A31.9 31.9 0 0 1 512 704M397.2 512 512 626.8 626.8 512 512 397.2Z"/>
			<path d="m64 512 256-256 45.2 45.2L154.5 512l210.7 210.8L320 768z"/>
		</symbol>
		<!-- https://uxwing.com/pencil-icon/ -->
		<symbol id="icnSvgId" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 121.48 122.88">
			<path d="m96.84 2.22 22.42 22.42c2.96 2.96 2.96 7.8 0 10.76l-12.4 12.4-33.18-33.18 12.4-12.4c2.96-2.96 7.8-2.96 10.76 0M70.18 52.19v.01c.92.92 1.38 2.14 1.38 3.34s-.46 2.41-1.38 3.34v.01l-.01.01-30.08 30.09h-.01c-.26.26-.55.48-.84.67h-.01q-.45.285-.93.45c-1.66.58-3.59.2-4.91-1.12h-.01v-.01c-.26-.26-.48-.55-.67-.84v-.01q-.285-.45-.45-.93c-.58-1.66-.2-3.59 1.11-4.91v-.01l30.09-30.09h.01c.92-.92 2.14-1.38 3.34-1.38s2.41.46 3.34 1.38zm-24.7 56.92c-8.98 2.78-17.95 5.55-26.93 8.33-21.1 6.53-21.01 10.88-15.25-9.44l9.07-32-.03-.03L67.4 20.9l33.18 33.18-55.07 55.07zM18.03 81.66l21.79 21.79c-5.9 1.82-11.8 3.64-17.69 5.45-13.86 4.27-13.8 7.13-10.03-6.22z" style="fill-rule:evenodd"/>
		</symbol>
		<!-- https://uxwing.com/wp-content/themes/uxwing/download/web-app-development/stack-icon.svg -->
		<symbol id="icnSvgChapters" viewBox="0 0 122.88 111.96">
			<path d="M61.15 0 0 26.52l61.41 24.96 61.47-24.88zm61.73 57.12L95.46 45.31 62.73 58.56c-.88.36-1.83.33-2.65 0L27.27 45.22 0 57.05 61.41 82zM96.14 75.56 62.73 89.08c-.88.36-1.83.33-2.65 0L26.59 75.47 0 87.01l61.41 24.96 61.47-24.88z"/>
		</symbol>
		<symbol id="icnSvgRemainTime" xmlns="http://www.w3.org/2000/svg" viewBox="-0.42 0 1024.32 1024.2">
			<path
				d="M545 65.2a448 448 0 0 0-33-1.2V0a512 512 0 0 1 37.7 1.4zM673.2 94a448 448 0 0 0-63-19.1l14-62.5c24.5 5.5 48.6 12.8 72.1 21.9zm87.7 45.5a449 449 0 0 0-28.1-17.3l31.6-55.7a513.6 513.6 0 0 1 62.6 41.9l-39.4 50.4a448 448 0 0 0-26.7-19.3M878.3 254a447.4 447.4 0 0 0-41.8-50.9l46.3-44.2c17.3 18.2 33.3 37.8 47.8 58.3zm47.6 86.5a453 453 0 0 0-13.7-29.9l57.1-28.8a510.5 510.5 0 0 1 28.8 69.6l-60.8 20.1a450 450 0 0 0-11.4-31M959.8 501a447.4 447.4 0 0 0-6.4-65.6l63-10.9c4.3 24.7 6.8 49.8 7.5 74.9l-64 1.6zm-8.4 98.4c2.1-10.9 3.8-21.7 5.2-32.6l63.6 7.9a509 509 0 0 1-14.8 73.9l-61.7-17.1c2.9-10.6 5.5-21.2 7.7-32.1m-60.9 152.3c11.8-18.6 22.1-38 31.1-58.1l58.5 25.9c-10.2 23-22.1 45.2-35.5 66.4zm-61.7 77.1c7.8-7.8 15.3-15.9 22.4-24.2l48.5 41.8A517 517 0 0 1 874 874z" />
			<path d="M512 64a448 448 0 1 0 316.8 764.8L874 874A512.1 512.1 0 1 1 512 0z" />
			<path
				d="M480 192a32 32 0 0 1 32 32v333.4l207.9 118.8a32 32 0 0 1-31.8 55.6l-224-128A32 32 0 0 1 448 576V224a32 32 0 0 1 32-32" />
		</symbol>
		<!-- https://uxwing.com/writer-blogger-author-icon/ -->
		<symbol id="icnSvgMaleAuthor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 117.37 122.88">
			<path
				d="M78.08 115.36H6.11c-5.24-.4-6.5-4.17-6.02-8.52C2.96 81.2 31.72 88.62 43.28 78.21c5.76 16.96 29.85 17.59 35.26 0 3.18 2.87 9.48 4.58 15.85 6.08.32.08.65.15 1 .23-7.77 4.75-13.88 12.08-16.32 20.65-1 3.52-1.31 6.95-.99 10.19m31.43-26.51 7.04 5.43c.93.72 1.1 2.06.39 2.99l-1.83 2.29-10.42-8.04 1.83-2.29c.71-.92 2.06-1.09 2.99-.38m-7.59 28.62c-2.4 1.1-4.79 2.19-7.19 3.28-5.63 2.57-5.45 3.78-4.58-2.08l1.37-9.22-.01-.01 11.54-15.87 10.42 8.04-11.55 15.87zm-8.62-6.65 6.84 5.28c-1.58.72-3.15 1.44-4.72 2.15-3.7 1.68-3.58 2.48-3.01-1.37zM43.13 61.2c2.19 3.47 4.48 7.02 7.32 9.63 2.74 2.5 6.06 4.2 10.45 4.21 4.76.01 8.23-1.75 11.06-4.39 2.94-2.75 5.25-6.52 7.54-10.28l6.14-10.12c1.14-2.62 1.56-4.36 1.3-5.39-.16-.61-.83-.91-1.98-.96-.24-.01-.49-.01-.74-.01-.27.01-.56.03-.86.05-.17.01-.32 0-.47-.03-.54.03-1.11-.01-1.68-.09l2.1-9.31c-15.61 2.46-27.28-9.13-43.77-2.32l1.19 10.97c-.65.04-1.29.01-1.87-.07-9.47.31 2.4 15.14 4.27 18.11m43.95-20.09c1.51.46 2.48 1.42 2.88 2.97.44 1.72-.04 4.14-1.5 7.45-.03.06-.05.12-.09.18l-6.21 10.23c-2.4 3.94-4.82 7.9-8.07 10.93-3.36 3.15-7.5 5.24-13.16 5.22-5.28-.01-9.27-2.03-12.53-5.02-3.94-3.62-22.12-26.37-14-31.85.4-.26.84-.49 1.32-.67-.36-4.7-.48-10.63-.26-15.59.12-1.17.35-2.35.67-3.53 1.39-4.98 4.89-8.99 9.21-11.74 2.39-1.52 5-2.67 7.72-3.43 1.73-.49-1.47-6.03.31-6.2 8.65-.89 22.66 7.01 28.7 13.55 3.02 3.27 4.93 7.62 5.34 13.36z" />
		</symbol>		
		
		<!-- Toast icons -->
		<symbol id="svgIconToastInfor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<path fill-rule="evenodd"
				d="M61.44 0c33.926 0 61.44 27.514 61.44 61.44s-27.514 61.439-61.44 61.439C27.513 122.88 0 95.366 0 61.44S27.513 0 61.44 0m17.98 98.215H43.46v-6.053h6.757v-36.96H43.46v-4.816h16.808c4.245 0 8.422-.51 12.549-1.551v43.328h6.604v6.052zM63.859 21.078c2.785 0 4.975.805 6.571 2.396 1.579 1.59 2.377 3.771 2.377 6.581 0 2.848-1.358 5.381-4.093 7.601-2.751 2.22-5.941 3.338-9.577 3.338-2.733 0-4.905-.765-6.569-2.297-1.665-1.551-2.497-3.556-2.497-6.05 0-3.143 1.358-5.853 4.059-8.152q4.05-3.416 9.729-3.417" />
		</symbol>
		<symbol id="svgIconToastSuccess" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.881 122.88">
			<path fill-rule="evenodd"
				d="M61.44 0c33.933 0 61.441 27.507 61.441 61.439s-27.508 61.44-61.441 61.44C27.508 122.88 0 95.372 0 61.439S27.508 0 61.44 0M34.106 67.678l-.015-.014a3.87 3.87 0 0 1-1.256-2.669 3.86 3.86 0 0 1 .984-2.777l.029-.031a3.87 3.87 0 0 1 2.668-1.256 3.87 3.87 0 0 1 2.792.998l12.956 11.748 31.089-32.559a3.87 3.87 0 0 1 2.719-1.204 3.87 3.87 0 0 1 2.771 1.067v.001a3.87 3.87 0 0 1 1.205 2.718 3.87 3.87 0 0 1-1.068 2.773L55.279 81.769a1 1 0 0 1-.073.067 3.87 3.87 0 0 1-2.598 1.13 3.86 3.86 0 0 1-2.744-1L34.118 67.688z" />
		</symbol>
		<symbol id="svgIconToastWarning" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 463.43">
			<path fill-rule="evenodd"
				d="M189.46 44.02c34.26-58.66 99.16-58.77 133.24.12l.97 1.81 175.27 304.4c33.71 56.4-1.2 113.76-66.17 112.96v.12H73.53c-.9 0-1.78-.04-2.66-.11-58.34-.79-86.64-54.22-61.9-106.84.39-.85.82-1.67 1.28-2.46l-.04-.03 179.3-309.94zm50.32 302.4c4.26-4.13 9.35-6.19 14.45-6.56 3.4-.24 6.8.29 9.94 1.48 3.13 1.19 6.01 3.03 8.39 5.41 6.92 6.91 8.72 17.38 4.64 26.16-2.69 5.8-7.08 9.7-12.11 11.78-3.03 1.27-6.3 1.84-9.56 1.76-3.27-.08-6.49-.82-9.41-2.18-5.02-2.33-9.3-6.43-11.7-12.2-2.65-6.36-2.27-12.96.63-19.15 1.15-2.46 2.75-4.81 4.73-6.5m33.86-47.07c-.8 19.91-34.51 19.93-35.28-.01-3.41-34.1-12.13-110.53-11.85-142.58.28-9.87 8.47-15.72 18.94-17.95 3.23-.69 6.78-1.03 10.35-1.02 3.6.01 7.16.36 10.39 1.05 10.82 2.3 19.31 8.39 19.31 18.45l-.05 1z" />
		</symbol>
		<symbol id="svgIconToastError" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<path style="fill-rule:evenodd"
				d="M61.44 0A61.44 61.44 0 1 1 0 61.44 61.44 61.44 0 0 1 61.44 0m13.14 36.8c1.74-1.77 2.83-3.18 5-1l7 7.13c2.29 2.26 2.17 3.58 0 5.69L73.33 61.83l12.75 12.75c1.77 1.74 3.18 2.83 1 5l-7.13 7c-2.26 2.29-3.58 2.17-5.68 0L61.44 73.72 48.63 86.53c-2.1 2.15-3.42 2.27-5.68 0l-7.13-7c-2.2-2.15-.79-3.24 1-5l12.73-12.7-13.2-13.19c-2.15-2.11-2.27-3.43 0-5.69l7-7.13c2.15-2.2 3.24-.79 5 1l13.09 13.12z" />
		</symbol>
		<symbol id="svgIconToastPromise" xmlns="http://www.w3.org/2000/svg" viewBox="0.05 0.05 127.9 127.9">
			<path d="M38.52 33.37 21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z"></path>
			<path
				d="M67.642 24.324 67.649.05a63.6 63.6 0 0 1 38.31 15.627L88.778 32.86a39.5 39.5 0 0 0-21.142-8.528zM94.63 38.52l17.17-17.16a63.6 63.6 0 0 1 16.04 38.14h-24.3a39.5 39.5 0 0 0-8.92-20.98zm9.046 29.122 24.275.007a63.6 63.6 0 0 1-15.627 38.31L95.14 88.778a39.5 39.5 0 0 0 8.528-21.142zM89.48 94.63l17.16 17.17a63.6 63.6 0 0 1-38.14 16.04v-24.3a39.5 39.5 0 0 0 20.98-8.92zm-29.122 9.046-.007 24.275a63.6 63.6 0 0 1-38.31-15.627L39.222 95.14a39.5 39.5 0 0 0 21.142 8.528zM33.37 89.48 16.2 106.64A63.6 63.6 0 0 1 .16 68.5h24.3a39.5 39.5 0 0 0 8.92 20.98zm-9.046-29.122L.05 60.351a63.6 63.6 0 0 1 15.627-38.31L32.86 39.222a39.5 39.5 0 0 0-8.528 21.142z"
				style="opacity:0.6">
		</symbol>

		<symbol id="svgIconNoInternetConnection" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<!-- <path
				d="m101.68 32.93-68.76 68.75a49.29 49.29 0 0 0 77.83-40.24A49.3 49.3 0 0 0 108 45.15a48.9 48.9 0 0 0-6.32-12.22M24 93.5 93.49 24A49.31 49.31 0 0 0 24 93.5"
				style="fill:#fff" /> -->
			<path
				d="M30.29 52a3 3 0 0 1-4.29-.37 3 3 0 0 1 .34-4.24A59.3 59.3 0 0 1 43.27 37a48 48 0 0 1 36.4.31A61 61 0 0 1 96.46 47.9a1.3 1.3 0 0 1 .17.16 3 3 0 0 1 .27 4.07 1.5 1.5 0 0 1-.17.19 3 3 0 0 1-4.16.19A55.2 55.2 0 0 0 77.47 43a41.86 41.86 0 0 0-32.08-.27A53.4 53.4 0 0 0 30.29 52m31.15 24.09A6.59 6.59 0 1 1 56.77 78a6.62 6.62 0 0 1 4.67-1.93ZM50.05 72.5a3 3 0 0 1-4.16-.35 1.4 1.4 0 0 1-.16-.18 3 3 0 0 1 .43-4.07l.17-.14a27.6 27.6 0 0 1 7.33-4.33 21.7 21.7 0 0 1 7.84-1.52 21.4 21.4 0 0 1 7.8 1.47 27.1 27.1 0 0 1 7.34 4.36 3 3 0 0 1 .44 4.26 3 3 0 0 1-2 1.1 3.06 3.06 0 0 1-2.21-.66 21.3 21.3 0 0 0-5.62-3.37 15.12 15.12 0 0 0-11.47 0 22 22 0 0 0-5.7 3.41Zm-9.56-9.71-.15.13a3.06 3.06 0 0 1-2.08.67 3 3 0 0 1-2-1 1 1 0 0 1-.14-.15 3 3 0 0 1 .34-4.16 45.8 45.8 0 0 1 12.36-8 30.76 30.76 0 0 1 25.6.42 45.7 45.7 0 0 1 12.11 8.41l.08.07a3.1 3.1 0 0 1 .87 2 3 3 0 0 1-.82 2.15l-.07.08a3 3 0 0 1-2 .87 3 3 0 0 1-2.15-.81A40.1 40.1 0 0 0 72 56.28a24.75 24.75 0 0 0-21-.35 39.7 39.7 0 0 0-10.5 6.86Z" />
			<path
				d="M61.44 0A61.31 61.31 0 1 1 38 4.66 61.3 61.3 0 0 1 61.44 0m40.24 32.93-68.75 68.75A49.44 49.44 0 0 0 80.31 107 49.53 49.53 0 0 0 107 80.3a49 49 0 0 0 3.73-18.86 48.93 48.93 0 0 0-9.08-28.51ZM24 93.5 93.5 24A49.32 49.32 0 0 0 24 93.5"
				style="fill:#d92d27" />
		</symbol>

	</svg>
</body>

</html>