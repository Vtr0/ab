<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
	<title>@Chinhvtr Audio Books</title>
	<!-- https://cdn-icons-png.flaticon.com/512/8651/8651477.png
	 https://www.svgrepo.com/show/324118/education-technology-audio-electronics-book-sound-audio-book.svg
	
	<link rel="icon" type="image/x-icon" href="https://icooon-mono.com/i/icon_14868/icon_148680_256.png">
	
	https://www.svgrepo.com/download/483896/sherlock-holmes-1.svg
	  -->
	<link rel="icon" type="image/svg" href="https://www.svgrepo.com/download/235301/lotus.svg">
	
	<link rel="apple-touch-icon-precomposed" href="https://www.svgrepo.com/download/235301/lotus.svg" sizes="72x72">

	<!-- Root, common elements  type="text/css" -->
	<style>
		@charset "UTF-8";

		* {
			/* "SFU AmericanType",  */
			font-family: "SFU AmericanType", monospace, "Courier New";
			font-size: 19px;
			box-sizing: border-box;
			text-rendering: optimizeLegibility;
			-webkit-font-smoothing: antialiased;
		}

		body {
			/* Fun corner: change color of selBookGroup and elmSelBookTitles by the selected value of selBookGroup */
			--select-book-group-color: darkblue;
			--select-book-group-filter: invert(14%) sepia(49%) saturate(4923%) hue-rotate(236deg) brightness(81%) contrast(147%);			

			&:has(#selBookGroup > option:nth-of-type(2):checked) {
				--select-book-group-color: darkred;
				--select-book-group-filter: invert(6%) sepia(86%) saturate(6340%) hue-rotate(360deg) brightness(111%) contrast(108%);
			}

			&:has(#selBookGroup > option:nth-of-type(3):checked) {
				--select-book-group-color: darkgreen;
				--select-book-group-filter: invert(22%) sepia(99%) saturate(1440%) hue-rotate(95deg) brightness(90%) contrast(105%);
			}

			--book-micro-svg-bground: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='darkgreen' viewBox='102.4 153.6 870.4 819.2'%3E%3Cpath d='M512 819.2c-23.3 31.1-60.5 51.2-102.4 51.2H179.2a76.8 76.8 0 0 1-76.8-76.8V230.4a76.8 76.8 0 0 1 76.8-76.8h230.4c41.9 0 79.1 20.1 102.4 51.2 23.3-31.1 60.5-51.2 102.4-51.2h230.4a76.8 76.8 0 0 1 76.8 76.8v358.4c0-41.9-20.1-79.1-51.2-102.4v-256a25.6 25.6 0 0 0-25.6-25.6H614.4a76.8 76.8 0 0 0-76.8 76.8v460.8c0 26.8 13.8 50.5 34.7 64.2 6.6 22.7 16.5 43.9 29.2 63.2a127.8 127.8 0 0 1-89.5-50.6M153.6 230.4v563.2a25.6 25.6 0 0 0 25.6 25.6h230.4a76.8 76.8 0 0 0 76.8-76.8V281.6a76.8 76.8 0 0 0-76.8-76.8H179.2a25.6 25.6 0 0 0-25.6 25.6M892.2 824a127.5 127.5 0 0 0 29.4-81.6 25.6 25.6 0 0 1 51.2 0 179.3 179.3 0 0 1-153.6 177.4v27.4a25.6 25.6 0 0 1-51.2 0v-27.4a179.8 179.8 0 0 1-136.3-100.6 178.5 178.5 0 0 1-17.3-76.8 25.6 25.6 0 0 1 51.2 0A127.5 127.5 0 0 0 695 824c23.4 28.3 58.9 46.4 98.5 46.4h.2c39.7 0 75.1-18.1 98.5-46.4M716.8 588.8a76.8 76.8 0 0 1 153.6 0v153.6a76.8 76.8 0 0 1-153.6 0z'/%3E%3C/svg%3E");			
		}

		/* SETTING SOME VARIABLE TO CUSTOMIZE THE PAGE */
		:root {
			/* Font size of Chapter title (span) in Playlist item (li) */
			--playlist-item-title-font-size: 21px;
			--playlist-item-title-font-weight: 400;
			--button-hover-bground-color: #e5e7eb;
			--select-hover-bground-filter: invert(19%) sepia(33%) saturate(6688%) hue-rotate(278deg) brightness(91%) contrast(89%);
			/* the filter that shift color of backgound svg image of select boxes from Black to --button-hover-bground-color */
			--button-hover-border-color: #8d28a5;
			--button-border-style: 1px solid #bdbec0;
		}

		audio {
			width: 100%;
			display: none;
		}

		div[name="divContainer"] {
			/* Choose divContainer becauss this div is innermost element that contain both playPause button. Remove this if you don't want circle progress buttons */
			/* Following 3 vars are for icnSvgPlayProgress */
			--audio-playing-current-progress-percent: 383px;
			/* stroke-dashoffset to show effect of percentage of current playing */
			--audio-playing-current-progress-remained-color: #8f8f8f;
			/* remained color: #abef83 rgb(135, 243, 102)*/
			--audio-playing-current-progress-played-color: #21ff15;
			/* Progressed color #ff4015*/

			width: 100%;
			/* 100vw 1vw = 1% of viewport width. Default width of the page is all screen */
			text-align: center;
			margin: 5px auto;

			&>* {
				width: 100%;
				max-width: 100%;
			}

			&>div[name="divCtnTop"] {
				margin-bottom: -5px;
				/* in column mode: to push big Playing time closer to audio buttons */
			}
		}

		/* iphone, iPad has big screen dpi. See https://hover-pointer-media-query.glitch.me/ for pointer value for different device
Following are settings for Desktop screen. "pointer: coarse" is for iphone/iPad and android phone/tablet which defaultly is handled 
*/
		@media (pointer: fine) {
			:root {
				--playlist-item-title-font-size: 18px;
				--playlist-item-title-font-weight: 400;
			}

			* {
				font-size: 17px;
			}
		}

		/* see https://www.w3schools.com/css/css_rwd_mediaqueries.asp for different kind of screen like phone, tablet,.. */


		/* Introduce about Book or Chapter */
		p.bookChapIntro {
			columns: 3 300px;
			column-rule: 1px solid lightblue;
			column-gap: 30px;
			/* text-indent: 1em; */
			margin-top: 10px;
			padding-top: 5px;
			border-top: 1px solid lightblue;
			text-align: justify;

			&::first-letter{
				font-size: 3.5em;
				/* initial-letter: 3 5; */
				font-weight: bold;
				text-transform: uppercase;
				color: var(--select-book-group-color);
				/* float: left; */
				padding: 0px 3px;
				float: inline-start;
				line-height: 1;
				margin-inline-end: .25rem;
				margin-bottom: -.25em;
				margin-top: -.15em; 
			}

			&>.bookChapIntroImg {
				width: 100px;
				margin-right: 10px;
				float: left;
			}
		}

		/* Flex container for dispay div side by side */
		.flex-container {
			/* set default flex setting, which is for small device like iPhone */
			display: flex;
			flex-direction: column;
			gap: 5px 15px;
			/* Only show gap between flex items on row mode */
		}

		/* Big Audio control below book cover Img and history buttons */
		div[name="divCtnAudioControlExtraBig"] {
			display: none;
		}

		.flex-container>div,
		h2 {
			flex: auto;
			/*0 0 auto*/
		}

		/* flex item that has book cover will have flex-grow = 0, so that all extra space will go to Playlist element*/
		.flex-container>div:has(>div > #elmArtwork) {
			/* div that contain the artwork which can be book cover or chapter cover */
			flex: 0 0 auto;
			/*0 0 auto*/
			order: 2;
			/*so that in the column flex, the artwork will be after Playlist */
			max-width: 100%;
			/* In column mode, size of artwrok can reach to 100% */
		}

		/* This left side of playlist has multiple children, so set this to make nicer visibility */
		.flex-container>div:has(>div > #elmArtwork)>* {
			margin-bottom: 5px;
		}

		.flex-container #elmArtwork {
			/* In column mode, size of artwrok can reach to 100% */
			max-width: 100%;
			
			border: 1px solid bisque;
			border-radius: 30px 0px;
			box-shadow: #0007 2px 2px 10px;

			/* make the top-left and bottom-right round border */
			/* clip-path: xywh(0 0px 100% 100% round var(--workart-border-radius));
			margin-bottom: -3.5px; */
			
			/* selector for youtube SD poster, which for now identified by the file name 'hqdefault.jpg' */
			&[src*="i.ytimg.com"][src*="hqdefault.jpg"]{
				/* crop the top and bottom black stripes */
				clip-path: xywh(0 12.5% 100% 75% round var(--workart-border-radius));
				/* remove border on normal workart. Becaused of the 'clip-path', the border will be made by the background color of mother div */
				border: none;
				/* change the border-box of the image using margin */
				margin-top: -9.2%;
				margin-bottom: calc(-3px - 9.5%);
				transition: margin .5s;
			}
		}

		/* adding effect for #elmArtwork by styling the div that contains #elmArtwork */
		.flex-container div:has(> #elmArtwork[src*="i.ytimg.com"][src*="hqdefault.jpg"]){
			--workart-border-radius: 30px 0; /* border radius is the same with clip-path in #elmArtwork */
			border-radius: var(--workart-border-radius); 
			width: fit-content;

			/* padding and background-color to make the border for the inside #elmArtwork */
			padding: 1px;
			background-color: #f1b874;
			/* background: radial-gradient(closest-corner, #0000 69%, bisque 69%); */
			/* add shadow for the inside #elmArtwork */
			filter: drop-shadow(2px 2px 10px #0007);
			
			/* center the div */
			margin: 0 auto;			
		}

		.flex-container .noInternetImg {
			width: min(100%, 400px);
			margin-bottom: 15px !important;
		}

		.flex-container>div:last-child {
			flex-grow: 1;
		}

		.flex-container> :first-child {
			margin-right: 0px;
		}

		@media only screen and (min-width: 850px) {
			
			.flex-container {
				/* If screen is bigger, make flex to be row */
				flex-direction: row;
			}

			div[name="divContainer"]>div[name="divCtnTop"] {
				margin-bottom: 5px;
				/* in row mode,  */
			}

			/* Big Audio control below book cover Img and history buttons */
			div[name="divCtnAudioControlExtraBig"] {
				display: flex;
				/* This div has control-button-flex class, so set its display to flex */
			}

			/* .flex-container > :first-child {
		margin-right: 20px;
	}*/
			.flex-container>div:has(> div > #elmArtwork) {
				/* div that contain the artwork which can be book cover or chapter cover */
				order: 0;
				/*in the row flex, the artwork will be right side of Playlist */
				max-width: 40%;
				/* In row mode, size of artwrok cannot wider than 50% */
			}
		}

		@media only screen and (min-width: 1100px) {
			div[name="divContainer"] {
				/* text-align: center;
		margin: 5px auto; */
				width: 1100px;
				/* When screen is too wide, make the page only 1100px wide */
			}
		}

		.flex-button-container {
			display: flex;
			flex-flow: row wrap;
			justify-content: space-evenly;
		}

		/* DETAIL - SUMMARY css */

		details {
			max-width: 100%;
			margin-top: 3px;
			/* margin-bottom: 10px; */
			overflow: hidden;
			/* Keep this line to prevent an odd blue outline around the element in Safari. */
		}

		summary {
			display: inline-block;
			padding-top: 5px;
		}

		summary::-webkit-details-marker {
			display: none;
		}

		summary>span {
			/* position: relative;
	display: flex;
	align-items: flex-start; */
			text-align: center;
			cursor: pointer;
			/* padding-left: 1rem;
	background: #444;
	color: #fff;
	height: 4rem; */
		}

		/* Only decorate for the book title when width large enough */
		@media screen and (min-width: 800px){
			summary:has( > span[id="elmBookTitle"]){
				background: conic-gradient(from 12deg at 84% 40%, #efd9bd 115deg, #c2965e 0% 50%, #b1ceec 0% 295deg, #f2c079 0%);
				transform: skew(-25deg, 0);
				border-radius: 11px;
				box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.34);
				margin: 10px auto 5px;
				padding: 10px 8px;
				max-width: calc(100% - 40px);
				min-width: 60%;

				& > span{
					display: inline-block;
					transform: skew(25deg, 0);
				}
			}
		}

		summary>span::before {
			content: '';
			width: 0;
			height: 0;
			display: inline-block;
			border: 6px solid transparent;
			border-width: 6px 9px;
			border-left-color: red;
			/* these 7 css lines is to make ⏵triangle */
			margin-right: 5px;
			transform: translateY(-2px);
			transform-origin: 40% 50%;
			transition: rotate 300ms ease-out;
		}

		details[open]>summary>span::before {
			rotate: 90deg;
		}

		div.detailContent {/* details+ */
			box-sizing: border-box;

			max-width: 100%;
			max-height: 0px;
			overflow: hidden;
			transition: padding .1s ease, max-height 1s ease-out;
			/* , border 0ms 400ms linear; */
		}

		details+div.detailContent#elmChapterInfor {
			transition: max-height .5s ease-out;
			/* chapter infor really short, so if animation time too long, the animation seems not smooth */
		}

		details[open]+div.detailContent {
			/* Set a max-height value enough to show all the content */
			max-height: 5000px;			
			/* for a.srcPlaying item not to be cropped at bottom */
			padding: 3px 0px;
		}

		/*format summary marker (the small triagle) for Book and Chapter titles*/

		#elmBookTitle::before {
			border-left-color: darkblue;
		}

		#elmChapterTitle {
			text-align: center;
			font-size: 25px;
			color: red;
			font-weight: bold;
			/*padding-top: 5px;*/
			& *{font-size: inherit;}
			
		}

		#elmChapterInfor {
			margin-bottom: 5px;
			/* padding-bottom: 3px; */
		}

		#elmBookTitle {
			text-align: center;
			font-size: 23px;
			color: darkblue;
			font-weight: bold;
			text-wrap: pretty; /* balance this balance length of lines if title+eTitle is rendered into two lines */
		}
		@media (hover: hover) and (pointer: fine) {
			/* 'nowrap' and <wbr/> element at the title will auto break the english title down if title+eTitle is rendered into two lines. Unfortunately, it not work on iOS, so I have to use @media query to let it effeft for desktop only */
			#elmBookTitle {
				text-wrap: nowrap; 
			}
		}

		#elmBookInfo {
			text-align: justify;
			text-justify: inter-word;
			padding-left: 5px;
		}

		/* END OF DETAIL - SUMMARY css */
		#selBookGroup {
			background: transparent url(https://uxwing.com/wp-content/themes/uxwing/download/education-school/books-icon.svg) 50% 3px / 25px no-repeat !important;
			padding-top: 25px !important;
			text-indent: 0px;
			/* to make the [01] number at the center of button */
			padding-bottom: 4px;
			-moz-appearance: none;
			-webkit-appearance: none;
			appearance: none;
			font-size: 17px;
			text-align-last: center;
			color: #000;
			border: 2px solid black;
			/* var(--button-border-style); */
			filter: var(--select-book-group-filter);
			border-radius: 15%;
			cursor: pointer;
		}

		#selBookGroup:hover {
			filter: var(--select-hover-bground-filter);
			/* color: var(--button-hover-border-color);
	background-color: var(--button-hover-bground-color) !important; 
	*/
			-webkit-transition: background .2s ease;
			transition: background .2s ease;
		}

		#elmPlayingTime {
			flex-shrink: 0;
			/* Prevent playing time to be forced into two lines */
			text-align: center;
			font-weight: bold;
			color: green;
			margin-top: -3px;
			/* margin: auto 0px; */
			font-size: xx-large;

			/* Prevent user select the timer text when double click on it */
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none;

			/* class to blink #elmPlayingTime when audio is paused */
			&.paused{
				animation: timer-blink-kf 2s step-start .3s infinite;
			}
		}
		@keyframes timer-blink-kf{
			0% {
				opacity: 1;
			}
			50% {
				opacity: 0;
			}
			80% {
				opacity: 1;
			}
			100% {
				opacity: 1;
			}
		}

		div:has(> #elmPlayingTime) {
			/* the div container which is direct father of #elmPlayingTime */
			display: flex;
			align-items: center;
			justify-content: center;
			flex-shrink: 0;
			/* to prevent #elmPlayingTime being broken into two line when screen width shrink */
			font-size: xx-large;
			/* max-height: 1.6em; */
			/* so that in column mode, 9em below become the height */
			flex: 1 0 9em;
			/* fix the width so buttons on the right not have to be moved left/right when playinTime switch from Loading to current time */
			margin: 6px auto;
		}

		@media only screen and (min-width: 850px) {
			div:has(> #elmPlayingTime){
				/* format the border for the div that is direct mother of #elmPlayingTime and HourglassSpining */
				/* border: 2px dashed var(--select-book-group-color);
				border-radius: 1em; */

				--b: 2px;  /* border thickness */
				--s: 20px; /* size of the dashes */
				--c1: var(--select-book-group-color); /* #215A6D; */
				--c2: #dddd; /* #92C7A3; */

				position: relative;
				&::before {
					content:"";
					border-radius: 1em;
					position: absolute;
					inset: 0;
					padding: var(--b);
					background: 
					repeating-conic-gradient(var(--c1) 0 25%,var(--c2) 0 50%) 
					0 0/var(--s) var(--s) round;
					-webkit-mask:
					linear-gradient(#000 0 0) content-box,
					linear-gradient(#000 0 0);
					-webkit-mask-composite: xor;
							mask-composite: exclude;
					pointer-events: none;
				}
			}
		}

		@media only screen and (max-width: 850px) {
			/* When in column mode, flex-basic (9em) become the height of the div, so revoke it */
			div:has(> #elmPlayingTime) {
				flex: 0;
				border: none;
				/* margin: unset; */
			}
		}

		div[name="HourglassSpining"] {
			color: darkgreen;
			position: relative;
			/* to vertically center the Loading span */
			transform: translateX(-80px);
			/* to make spinning clock with the span seems to be centered*/
		}

		div[name="HourglassSpining"]>span {
			font-weight: bold;
			font-size: 2em; /* xx-large */
			/* Center vertically */
			position: absolute;
			top: 50%;
			transform: translate(0, -50%);
			margin-left: 10px;
		}

		#elmBookTotalDuration {
			color: darkgreen;
			margin: 5px 0px 5px 0px;

			&>span {
				font-size: x-large;
				font-weight: bold;
			}

			&>svg:first-of-type {
				color: darkgreen;
				font-size: 1.45em;
				margin: auto -4px -.35em 5px;
			}

			&>svg:last-of-type {
				color: darkgreen;
				font-size: 1.1em;
				margin: auto 4px -4px 8px;
			}
		}

		#elmSelBookTitles {
			max-width: 100%;
			margin: 2px auto;
			border-color: var(--select-book-group-color);
			border-width: 2px;
		}

		/* class to replace default spinner (little triangle at right side) of dropdown list */
		.dropdown-book-spinner {
			/* Hide default spninner */
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			/* SVG background image */
			background: var(--book-micro-svg-bground) right 0.2em center / 1.4em no-repeat;
			/* background-image: var(--book-micro-svg-bground);
			background-size: 1.4em;
			background-position: right 0.2em center;
			background-repeat: no-repeat; */
			border-color: #0000;
			line-height: 1.8em;
			padding-left: 5px;
			padding-right: 1.8em;
			border-radius: .4em;

			&:focus {
				border-width: 2.5px !important;
				outline: none;
				/* remove browser-added black outline when dropdown got focus */
			}

			/* Hide default spninner for IE */
			&::-ms-expand {
				display: none;
			}

		}

		#elmInnerMcFlexCtn>span>label::before {
			/* content: "🎙: "; 🗣 */
			content: url(https://uxwing.com/wp-content/themes/uxwing/download/peoples-avatars/speak-talk-voice-icon.svg);
			display: inline-block;
			width: 23px;
			margin: -1px 7px;
			transform: rotateY(180deg);
			color: red;
		}

		#elmInnerMcFlexCtn>span>label {
			font-size: var(--playlist-item-title-font-size);
			font-weight: bold;
			margin-right: 15px;
		}

		#elmInnerMcFlexCtn>span:first-of-type>label {
			color: darkred;
		}

		#elmInnerMcFlexCtn>span:nth-of-type(2)>label {
			color: darkblue;
		}

		#elmInnerMcFlexCtn>span:nth-of-type(3)>label {
			color: darkorchid;
		}

		/* General Setting fro some element types */
		fieldset{
			background-color: #f4f4e52b;
			border: 1px solid #bdbec0;
			border-radius: .4em;
			padding: .3em;
			max-width: 100%;
			/* Header of fieldset */
			& > legend{
				font-size: .875em;
				font-weight: 600;
				color: var(--select-book-group-color);
				text-align: left;
				margin-left: .5em;
				white-space: nowrap; /* on stupid iOS, legend somehow be compressed into multiple (>3) lines */
			}
		}
		p {
			margin: 5px 2px;
		}

		select,
		button {
			color: black;
			/*font-size: 18px;
	font-weight: bold;*/
		}

		a {
			&:link {
				text-decoration: none;
			}

			&:visited {
				text-decoration: none;
			}

			&:hover {
				/* color:darkred !important; */
				background-color: rgb(227, 232, 244);
				border: 1px solid #666;
				border-right-width: 5px;
				padding: 2px 5px 4px 3px;
				border-radius: 5px;
			}
		}

		/* dfn: used for book/book kit/book collection summary
		var element used for real listening time all over the page
		*/
		dfn, var {
			font-size: inherit;
			font-weight: inherit;
			font-style: normal;
			text-decoration: none;
		}

		input[type="radio"]:checked{
			accent-color: red;
		}

		.glowing-border {
        	animation: glow-keyframe 1s 1;
			/* animation-iteration-count: 1; infinite*/
        }
		@keyframes glow-keyframe {
            0% {
                box-shadow: 0 0 5px grey, 0 0 10px grey, 0 0 15px grey;
            }
            50% {
                box-shadow: 0 0 20px grey, 0 0 30px grey, 0 0 40px grey;
            }
            100% {
                box-shadow: 0 0 0px grey, 0 0 0px grey, 0 0 0px grey;
            }
        }
	</style>

	<!-- inlineList, inlineListInfor -->
	<style>
		/* Display inline list of information. inlineList for list of anchors, inlineListInfor for list of pieces of information */
		ul.inlineList,
		ul.inlineListInfor {
			display: inline;
			padding-inline-start: 2px;
		}

		ul.inlineList>li:not(:last-of-type)::after {
			content: ' ┋ ';
			/*∴ ┋*/
			color: darkred;
		}

		ul.inlineListInfor {
			padding-inline-start: 0px;
		}

		ul.inlineListInfor>li::before {
			content: '∴';
			padding-left: 10px;
			padding-right: 7px;
			color: darkgreen;
		}

		ul.inlineList>li,
		ul.inlineListInfor>li {
			display: inline;
			/* format the box for percentage of listened duration in compared with total duration */
			& > span#percentageListened{
				background: linear-gradient(90deg, rgba(139, 198, 236, 0.5) 0%, rgba(149, 153, 226, 0.5) 100%) 0px 0px / 50% 100% no-repeat;
				border: 1px solid #0fa8a8;
        		border-radius: 6px;
				padding: 0px 5px 2px 5px;
				font-size: .85em;
        		font-weight: 700;
				transition: background-size .3s;				
			}
		}

		ul.inlineList {
			counter-reset: anchor;
		}

		ul.inlineList>li>a[href].srcPlaying {
			border: 1px solid #730a50;
			border-left: 5px solid #730a50;
			color: darkblue;
			font-weight: 700;
			background-color: rgb(255 243 229);
			padding: 1px 5px 2px 0px;
			border-radius: 5px;

			&:hover {
				background-color: rgb(246 213 175);
			}
		}

		ul.inlineList>li>a[href].srcPlaying::before {
			/* content: counter(anchor) ". "; "⏵ "  ⧉ */
			background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 92.2 122.88' fill='%2300008b'%3E%3Cpath style='fill-rule:evenodd;clip-rule:evenodd' d='M92.2 60.97 0 122.88V0z'/%3E%3C/svg%3E");
			margin-left: 2px;
		}

		/* If there is only one link, no need for order number */
		ul.inlineList>li:only-of-type>a[href].srcPlaying::before {
			content: "";
			/* "⏵ "; */
		}

		ul.inlineList>li>a[href] {
			counter-increment: anchor;
			white-space: nowrap;
			/* &:hover::before{
		color: black;
		filter: invert(13%) sepia(47%) saturate(6568%) hue-rotate(7deg) brightness(81%) contrast(124%);
	} */
		}

		ul.inlineList>li>a[href]::before {
			content: "\2002" counter(anchor) ".";
			background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg fill='%230000EE' viewBox='300 150 424 724' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m725.4 853.3h-469.4c-47.1 0-85.3-38.2-85.3-85.3v-469.3c0-47.2 38.2-85.4 85.3-85.4h170.7v85.4h-170.7v469.3h469.4v-170.7h85.3v170.7c0 47.1-38.2 85.3-85.3 85.3zm-226.2-268.5-60.1-60.3 268.5-268.5h-152.9v-85.3h298.7v298.6h-85.4v-152.9l-268.8 268.4z'%3E%3C/path%3E%3C/svg%3E");
			background-position: 0px 50%;
			background-size: 13px 13px;
			background-repeat: no-repeat;
			padding-left: 16px;
			padding-right: 6px;
		}
		
		ul.inlineList>li>a.outsideLink[href]::before {
			/* content: counter(anchor) ". ";  */
			background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg fill='%230000EE' viewBox='150 120 724 724' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath d='m301.8 418.7-87.8 87.8a192 192 0 1 0 271.5 271.5l117-117a192 192 0 0 0-53-309l-37.5 37.5a64.1 64.1 0 0 0-9.9 12.7 128 128 0 0 1 55.1 213.6l-116.9 117a128 128 0 1 1-181.1-181.1l50.8-50.7a257.2 257.2 0 0 1-8.2-82.4z'/%3E %3Cpath d='m421.5 299a192 192 0 0 0 53 309l49.6-49.7a128 128 0 0 1-57.3-214.1l116.9-117a128 128 0 1 1 181.1 181.1l-50.8 50.7c7.2 26.9 9.9 54.7 8.2 82.4l87.8-87.8a192 192 0 1 0-271.5-271.6l-117 117z'/%3E %3C/svg%3E");
			/* 🔗 */
		}

		ul.inlineList>li>a:is([href*="youtube.com"], [href*="GetAudioYoutube"])::before{
			/* display: inline-block; */
			width: 35px; /* long enough to contains the icon */
			background: url('https://www.svgrepo.com/download/475700/youtube-color.svg') 0px center / 20px no-repeat !important;
			/* background-position: 0px 65%;
			background-size: 15px; */
		}
		ul.inlineList>li>a[href$=".pdf"]::before{
			background: url('https://uxwing.com/wp-content/themes/uxwing/download/file-and-folder-type/pdf-icon.svg')  0px center / 18px no-repeat;
			/* background-position: 0px 60%;
			background-size: 15px; */
		}
		ul.inlineList>li>a[href*="archive.org"]:not(.srcPlaying)::before{
			/* https://archive.org/offshoot_assets/assets/ia-logo-2c2c2c.03bd7e88c8814d63d0fc..svg */
			background: url('https://www.svgrepo.com/download/173820/historic-theatre.svg')  0px center / 18px no-repeat;
			/* background-position: 0px 60%;
			background-size: 15px; */
		}

		/* If there is only one link, no need for order number */
		ul.inlineList>li:only-of-type>a[href]::before {
			content: "";
			/*⚓ 🔗*/
		}

		svg.svg-img-infor {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			width: 1.1em;
			max-height: 1.4em;
			display: inline-block;
			color: #0fa8a8;
			fill: currentColor;
			font-size: inherit;
			margin-bottom: -.3em;
			margin-right: 5px;

			&:hover {
				color: #0d8707 !important;
			}
		}

		/* setting for svg that height bigger than width. We need some modification so that these svg looks not too small in compared with other square svg. Following are some modification for some special svg icon to make them equally-sized and vertical-middle with other svg icon and text */
		svg.svg-img-infor:has(use:is([href="#icnSvgListenTime"])) {
			font-size: .9em;
			margin-bottom: -.25em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgRemainTime"])) {
			font-size: 1.1em;
			margin-bottom: -.35em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgDuration"], [href="#icnSvgMediaLinks"])) {
			font-size: 1.15em;
			margin-bottom: -.35em; /* so that the svg stick to base-line */
		}
		svg.svg-img-infor:has(use:is([href="#icnSvgBooks"])) {
			font-size: 1.15em;
			margin-bottom: -.4em; /* so that the svg stick to base-line */
		}
	</style>

	<!-- STYLE FOR BUTTONS AND SELECT IN MAIN PAGE USING SVG -->
	<style>
		/* Audio control button using SVG */
		.control-button-flex {
			display: flex;
			flex-flow: row wrap;
			justify-content: center;
			align-items: center;
			gap: 8px;
			max-width: 100%;
			margin-bottom: 5px;
			background-color: transparent;
			/* #FBB040; */
		}

		.control-button-flex button,
		.svgButton {
			cursor: pointer;
			-webkit-appearance: button;
			appearance: button;
			background-color: transparent;
			background-image: none;
			text-transform: none;
			margin: 0px;
			padding: 4px 4px 1px 4px;
			border: var(--button-border-style);
			border-radius: 20%;
			color: inherit;
		}

		.control-button-flex button:hover,
		.svgButton:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color);

			/* Make the remainder circle and played circle of circle-progress button a bit darker */
			--audio-playing-current-progress-played-color: #0ee302;
			--audio-playing-current-progress-remained-color: #656565;

			-webkit-transition: background-color .2s ease;
			transition: background-color .2s ease;
		}

		svg.button-svg-img {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			width: 1.25em;
			height: 1.25em;
			display: inline-block;
			fill: currentColor;
			-webkit-flex-shrink: 0;
			-ms-flex-negative: 0;
			flex-shrink: 0;
			-webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
			transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
			font-size: inherit;
			margin: auto -2px;
		}

		.\!text-\[15px\] {
			font-size: 16px !important;
		}

		.\!text-\[20px\] {
			font-size: 20px !important;
		}

		.\!text-\[25px\] {
			font-size: 25px !important;
		}

		.\!text-\[28px\] {
			font-size: 28px !important;
		}

		.\!text-\[30px\] {
			font-size: 30px !important;
		}

		.\!text-\[35px\] {
			font-size: 35px !important;
		}

		.\!text-\[40px\] {
			font-size: 40px !important;
		}

		.\!text-\[50px\] {
			font-size: 50px !important;
		}

		.\!text-\[55px\] {
			font-size: 55px !important;
		}

		.\!text-\[80px\] {
			font-size: 80px !important;
		}

		.rotate-90 {
			transform: rotate(90deg);
		}

		.rotate-180 {
			transform: rotate(180deg);
		}

		.elm-hidden {
			/* This css for hiding element only and being used alot. SHOULD NOT touch this css, if in need, create other one */
			display: none !important;
		}

		.elm-disabled {
			cursor: not-allowed !important;
			pointer-events: none;
			color: gray !important;
			background-color: #ddd8d8 !important;
		}

		.animate-spin {
			animation: spin-keyframe 1s linear infinite
		}

		@keyframes spin-keyframe {
			from {
				transform: rotate(0deg);
			}

			to {
				transform: rotate(360deg);
			}
		}
	</style>

	<!--------------------- Audio Player - AP ---------------->
	<style>
		/* Player and control panel */
		.ap-container {
			max-width: 100%;
			background-color: #dfdbe5;
			/* #ddd */
			border: 1px solid darkcyan;
			border-radius: 8px;
			padding: 4px 0px;
		}

		.ap-panel {
			display: -webkit-box;
			display: -webkit-flex;
			display: -ms-flexbox;
			display: flex;
		}

		.ap-sub-panel {
			display: -webkit-box;
			display: -webkit-flex;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-flex: 0;
			/* 1 */
			-webkit-flex: 0;
			/* 1 */
			-ms-flex: 0;
			/* 1 */
			flex: 0;
			/* 1 */
			-webkit-box-pack: center;
			-webkit-justify-content: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-webkit-align-items: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.ap--track {
			-webkit-box-flex: 1;
			-webkit-flex: 1 0 auto;
			/* 1 40% */
			-ms-flex: 1 0 auto;
			/* 1 40% */
			flex: 1 0 auto;
			/* 1 40% */
			padding: 0 5px;
		}

		.ap--playback,
		.ap--settings {
			-webkit-box-flex: 0;
			/* 1 */
			-webkit-flex: 0;
			/* 1 */
			-ms-flex: 0;
			/* 1 */
			flex: 0;
			/* 1 */
		}

		.ap--settings>.ap-controls,
		.ap--playback>.ap-controls {
			-webkit-box-flex: 0;
			-webkit-flex: 0;
			/* 25% */
			-ms-flex: 0;
			/* 25% */
			flex: 0;
			/* 25% */
		}

		.ap--settings button,
		.ap--playback button {
			padding-left: 6px;
			/* On Ios, default padding is very wide (19px), so we need to fix this to save space of buttons for progress bar */
			padding-right: 6px;
		}

		/* Info section */
		.ap-info {
			width: 100%;
			position: relative;
			-webkit-align-self: flex-start;
			-ms-flex-item-align: start;
			align-self: flex-start;
			padding: 5px 0 0;
		}

		.ap-title-time{
			display: flex;
			flex-flow: row nowrap;
			align-items: flex-start;
			justify-content: space-between;
		}

		.ap-title {
			position: relative;
			padding-right: 10px;
			text-align: left;
			white-space: nowrap;
			text-overflow: ellipsis;
			overflow: hidden;
			font-size: 15px;
			/* width: 350px; */
			flex: 1 1 350px;
			min-width: 0px;
		}

		.ap-time {
			/* position: absolute;
			top: 5px;
			right: 0; */
			flex: 0 0 auto;
		}

		.ap-time * {
			font-size: 15px;
		}

		.ap-progress-container {
			padding: 5px 0 10px;
			cursor: pointer;
		}

		.ap-progress {
			position: relative;
			height: 5px;
			border-radius: 5px;
			background: #c4c4c4;
		}
		
		.ap-progress-preload-bar,
		.ap-progress-bar {
			position: absolute;
			left: 0;
			top: 0;
			bottom: 0;
			width: 0;
			border-radius: 5px 0 0 5px;
			transition: width .5s;
		}

		.ap-progress-preload-bar {
			background: #a6a6a6;
			z-index: 0;
		}

		.ap-progress-bar {
			background: #f50;
			/* #f50 steelblue*/
			
			z-index: 1;
		}

		.ap-progress-bar::after {
			position: absolute;
			top: 0;
			right: -5px;
			width: 12px;
			height: 12px;
			margin-top: -4px;
			content: '';
			border-radius: 6px;
			background: #f50;
			opacity: 0.3;
			-webkit-transition: opacity .3s ease;
			transition: opacity .3s ease;
		}

		.ap-progress-container:hover .ap-progress-bar::after {
			opacity: 1;
		}

		/* css to show the loading animation in .ap-progress-bar when audio is being loaded */
		/* .ap-progress-bar--loading {
			height: 4px;
			width: 100%;
			--c:repeating-linear-gradient(135deg,#6100ee 0 12px, #ffc260 0 20px) no-repeat;
			background: var(--c),var(--c),#d7b8fc;
			background-size: 20% 100%;
			animation: l16 4s infinite alternate;
			
			& > *{
				visibility: hidden;
			}
		}
		@keyframes l16 {
			0%   {background-position: -30% 0, -30% 0}
			66%  {background-position: 130% 0, -30% 0}
			100% {background-position: 130% 0, 130% 0}
		} */

		.ap-progress-bar--loading {
			--c: repeating-linear-gradient(135deg, var(--select-book-group-color, #6100ee) 0 12px, #bbb 0 20px) no-repeat;
			--w: 18%; /* width of moving shuttle */
			--b: .5px; /* border width */
			background: var(--c), #d7b8fc; /* #e1cbfc */
			background-size: var(--w) calc(100% - 2 * var(--b));
			/* background-position: 0px var(--b); */
			border: var(--b) solid #000;
			animation: l16 cubic-bezier(.5, 0, .5, 1) 2s infinite alternate;
			
			& > *{ /* temporarily hide all children */
				visibility: hidden;
			}
		}
		@keyframes l16 {
			0%   {background-position: calc(-5% - var(--w)) var(--b)}
			100% {background-position: calc(105% + var(--w)) var(--b)}
		}

		.ap-buffer-bar {
			width: 100%;
			height: 4px;
			border-radius: 4px;
			line-height: 5px;
			display: block;
		}

		/* Buttons */
		.ap-controls {
			position: relative;
			z-index: 2;
			display: block;
			height: 50px;
			cursor: pointer;
			-webkit-transition: background .2s ease;
			transition: background .2s ease;
			text-align: center;
			color: #222;
			border: 0;
			outline: 0;
			background: none;

			&:hover {
				background-color: #ccc;
			}
		}

		.ap-controls {
			cursor: pointer;
			appearance: button;
			-webkit-appearance: button;
			background-color: transparent;
			background-image: none;
			text-transform: none;
			margin: 0px;
			/* padding: 4px 4px 1px 4px;
	border: var(--button-border-style); */
			border-radius: 20%;
			color: inherit;
		}

		.ap-controls:hover,
		.svgButton:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color);

			/* Make the remainder circle and played circle of circle-progress button a bit darker */
			--audio-playing-current-progress-played-color: #0ee302;
			--audio-playing-current-progress-remained-color: #656565;
		}

		/* .ap-controls svg {
		fill: #333;
		}
		.ap-controls:hover svg {
		fill: #222;
		} */
		.ap-controls:active {
			background: rgba(0, 0, 0, .1);
		}

		.ap-volume-container {
			z-index: 3;
		}

		.ap-volume {
			position: absolute;
			right: 0;
			bottom: 50px;
			overflow: hidden;
			width: min(100%, 35px);
			/* 100% */
			height: 0;
			visibility: hidden;
			-webkit-transition: height .2s cubic-bezier(0.17, 0.72, 0.26, 1.23);
			transition: height .2s cubic-bezier(0.17, 0.72, 0.26, 1.23);
			background: #f2f2f2;
			border: 1px solid #ccc;
			border-bottom: 0;
		}

		.ap-volume-btn {
			display: block;
			text-align: center;
			width: 100%;
			padding-right: 9px !important;
		}

		.ap-volume-btn>svg>.ap--volume-off,
		.muted>svg>.ap--volume-on {
			display: none;
		}

		.muted>svg>.ap--volume-off {
			display: inline;
		}

		.ap-volume-container:hover {
			background: #ddd;
		}

		.ap-volume-container:hover .ap-volume {
			height: 120px;
			visibility: visible;
		}

		.ap-volume-progress {
			display: block;
			width: 4px;
			height: 100px;
			margin: 10px auto;
			background: rgba(0, 0, 0, .2);
			position: relative;
			border-radius: 3px;
		}

		.ap-volume-bar {
			position: absolute;
			left: 0;
			right: 0;
			bottom: 0;
			background: #f50;
			height: 50%;
			border-radius: 3px;
		}

		.ap-speed-container {
			display: flex;
			align-items: center;
			gap: 1px;
		}

		.ap-change-speed-buttons {
			display: flex;
			flex-flow: column wrap;
			justify-content: center;
			align-items: stretch;
			gap: 0px;
			/* max-width: 100%;
	margin-bottom: 5px; */
			background-color: transparent;
			/* #FBB040; */
		}

		.ap-change-speed-buttons>button {
			/* plus/minus speed buttons */
			border: none;
			background-color: transparent;
			padding: 0px 2px;
		}

		.ap-speed-option-select {
			background: transparent url(https://uxwing.com/wp-content/themes/uxwing/download/transportation-automotive/speed-test-icon.svg) 57% 3px / 30px no-repeat;
			padding-top: 30px;
			padding-bottom: 4px;
			-moz-appearance: none;
			-webkit-appearance: none;
			appearance: none;
			font-size: 15px;
			text-align-last: center;
			color: #000;
			border: none;
			border-radius: 8px;
			/* border:var(--button-border-style);
    border-radius: 15%; */
			cursor: pointer;

		}

		.ap-speed-option-select:hover {
			filter: var(--select-hover-bground-filter);
		}

		.ap-change-speed-buttons>button:hover {
			color: var(--button-hover-border-color);
			background-color: var(--button-hover-bground-color) !important;
		}

		.ap-active {
			background: rgba(0, 0, 0, .15);
			opacity: 1;
		}

		/* ------------HANDLING RESPONSIVE--------------- */
		@media(min-width:850px) {
			.ap-title {
				max-width: 330px;
			}
		}

		@media(min-width:950px) {
			.ap-title {
				max-width: 440px;
			}
		}

		@media(min-width:1050px) {
			.ap-title {
				max-width: 580px;
				/* Wide screen such as iPad Pro or desktop, make title wider */
			}
		}

		@media(max-width:850px) {
			.ap-title {
				max-width: 200px;
				/* visibility: hidden; */
				/* Hide title but keeps it there to take the space for progress bar display vertically center */
			}
		}

		/* @media(max-width:800px) {
  .ap-sub-panel > .ap-controls {
    -webkit-box-flex: 1;
    -webkit-flex: 1;
        -ms-flex: 1;
            flex: 1;
  }
} */

		@media(max-width:680px) {
			.ap-container {
				/* min-width: 400px; */
				width: 100%;
				height: auto;
				background-color: transparent;
				border: none;
			}

			.ap-panel {
				-webkit-flex-wrap: wrap;
				-ms-flex-wrap: wrap;
				flex-wrap: wrap;
				justify-content: space-evenly;
				height: auto;
			}

			.ap--track {
				margin-bottom: 10px;
				padding: 8px 10px;
				background-color: #ddd;
				/* #56AEFF #B1D4E0*/
				border-radius: 10px;
				-webkit-box-ordinal-group: 2;
				-webkit-order: 1;
				-ms-flex-order: 1;
				order: 1;
				-webkit-box-flex: 1;
				-webkit-flex: 1 1 100%;
				-ms-flex: 1 1 100%;
				flex: 1 1 100%;
			}

			.ap--playback {
				/* Only .ap--playback take extra space, .ap--settings keeps flex-grow=0 so take no extra space */
				-webkit-box-flex: 1;
				-webkit-flex: 1 1 70%;
				-ms-flex: 1 1 70%;
				flex: 1 1 70%;
				-webkit-box-ordinal-group: 3;
				-webkit-order: 2;
				-ms-flex-order: 2;
				order: 2;
			}

			.ap--settings {
				-webkit-box-ordinal-group: 4;
				-webkit-order: 3;
				-ms-flex-order: 3;
				order: 3;
			}

			.ap--playback>.ap-controls {
				-webkit-box-flex: 1;
				-webkit-flex: 1;
				/* 25% */
				-ms-flex: 1;
				/* 25% */
				flex: 1;
				/* 25% */
			}

			/* .ap-title,
			.ap-time {
				display: none;
			} */
		}

		/* @media(max-width:450px) {
  .ap-panel {
    flex-direction: row;
	justify-content: space-evenly;
	height: auto;
  }
} */
	</style>

	<!-- Format ol, li of Playlist and popup book group list-->
	<style>
		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) {
			max-height: 450px;
			list-style: none;
			overflow-y: auto;
			/*overlay*/
			overflow-x: hidden;
			/*list-style: decimal-leading-zero;*/
			padding-left: 40px;
			/* to reserve space for li::before which show chapter order UI */
			border: 1px solid #bdbec0;
			border-radius: 10px;
			margin: 0px; /* to prevent margin-block-start, margin-block-end default is 1em = 17px */
			/* format the size and color of the CSS background */
			/* --__s: 240px;
			--__c: #b5c7f520; */
		}

		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li {
			text-align: left;
			/* font-size: 16px; */
			color: #4F4F4F;
			position: relative;
			line-height: 21px;

			padding: 10px 0px 5px 7px;
			border-bottom: 1px solid #730a50c4;
			cursor: pointer;
			transition: color 0.4s;

			&:hover {
				background: linear-gradient(to right, rgba(255, 138, 0, 0.2), #fff) !important;
				/* background-color: #d8e08457; */
				transform: translate(0.5%, 0px);
				/* scale(1.05) translate(3%, 0px) */
				box-shadow: 2px 2px 15px 4px rgba(51, 51, 51, 0.18);

				&::before {
					background-color: #f1a25a38 !important;
				}
			}

			&::before {
				/* counter-increment: list-item; */
				content: counter(list-item);
				/* counter(list-item, decimal-leading-zero) to have leading 0 */
				color: black;
				font-size: var(--playlist-item-title-font-size);
				font-weight: 700;
				display: flex;
				height: 32px;
				width: 32px;
				border-radius: 50%;
				border: 1.5px solid #454545;
				background: #afafaf54;
				justify-content: center;
				align-items: center;
				position: absolute;
				top: 2px;
				left: -36px;
			}

			/* When the li ordernal number is too big (more than 2 digits), we need to make its font-size smaller so it fit inside the circle */
			&.threeDigitOrdernalNo::before {
				font-size: .9em;
			}
			&.fourDigitOrdernalNo::before {
				font-size: .8em;
			}

			&.beingPlay {
				/* mark that a chapter being played or a book set/kit just being drag in setting */
				background: linear-gradient(to right, rgba(156, 39, 176, 0.2), #fff0) !important;
				box-shadow: 2px 2px 15px 7px rgb(241 180 180 / 27%);

				&::before {
					border-color: #d52323;
					background: rgba(156, 39, 176, 0.25);
				}
			}

			/* Format the chapter titles in the list */
			&>span {
				color: #4F4F4F;
				font-size: var(--playlist-item-title-font-size);
				font-weight: var(--playlist-item-title-font-weight);
			}

			/* Format the duration wrap in <code> tag */
			&>code {
				font-size: 0.9em;
			}
			/* mark elements that will be right-align from item to item */
			& [data-rAlignGroup]{
				display: inline-block;
				text-align: right;
			}
		}

		/* customize for even li */
		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li:nth-of-type(even) {
			background: linear-gradient(to left, rgba(138, 138, 138, 0.2), #fff);

			&:before {
				border-color: #2378D5;
				background: #2378d547;
			}

			/* Format the chapter titles in the list */
			&>span {
				color: #2378D5;
			}
		}

		:is(ol#elmPlaylist, ol.lstBookTitlesSetting) li:first-of-type {
			border-top: 1px solid #730a50c4;
		}

		ol.lstBookTitlesSetting>li:has(> input[type="checkbox"]:not(:checked)) {

			/* li that has unchecked chkbox, paint it gray */
			&>span,
			&>code {
				color: #639858 !important;
			}

			&::before {
				color: #999 !important;
			}
		}

		/* Chapter group css */
		ol#elmPlaylist:has(section) {
			padding-left: 0px !important;
			/* default #elmPlaylist has no section, so its  padding-left: 40px to reserve space for li::before which show chapter order UI*/
		}

		ol#elmPlaylist>input[type=checkbox] {
			display: none;
		}

		ol#elmPlaylist>input[type=checkbox]+label+section {
			padding-left: 40px !important;
			/* to reserve space for li::before which show chapter order UI. Note that #elmPlaylist that has section set padding-left: 0px */
			max-height: 0;
			max-width: 0;
			transform: scaleY(1);
			opacity: 0;
			overflow: hidden;
			/* white-space:nowrap; */
			-webkit-transition: all .5s ease;
			-moz-transition: all .5s ease;
			-o-transition: all .5s ease;
			transition: all .5s ease;

			/* the label show the summary of current chapters group */
			&>label.chapter-group-summary {
				display: flex;
				align-items: center;
				justify-content: space-evenly;
				padding: 5px 0px;
				margin-left: -40px;
				/* to compensate padding-left: 40px of section */
				color: #f85012;
				pointer-events: none;
				/* save click event bubbling up to elmPlaylist's click handler */
				& > span > code{
					color: #043268;
				}
			}
		}

		ol#elmPlaylist>input[type=checkbox]:checked+label+section {
			max-height: 100%;
			max-width: 100%;
			transform: scaleY(1);
			opacity: 1;
		}

		/* label to define beginning of chapter group. This is for label when its previous sibling checkbox is CHECKED, meaning section expanded and is default style */
		ol#elmPlaylist>input[type=checkbox]+label {
			color: rgb(139, 0, 127);
			margin: 4px auto;
			margin-left: 2px;
			padding: 7px 0px 7px 5px;
			cursor: pointer;
			display: flex;
			/* to display label center horizontally and vertically */
			align-items: center;
			justify-content: center;

			&.is-sticky {
				/* This for sticky label */
				position: -webkit-sticky;
				/* for safari */
				position: sticky;
				z-index: 2;
				top: -0.1px;
				/* the hack for label being partly (0.1px) hidden, so IntersectionObserver triggers action (adding .stickyPinned class) when label being pinned (stickied) at the top */
				background-image: linear-gradient(to right, #e9d8c788 0%, #FFFFFF99 51%, #e9d8c788 100%);
				border: 1.5px solid rgb(144 42 136);
				border-radius: 5px;

			}

			&.stickyPinned {
				/* This is for label when being pinned */

				color: red;
				background-image: linear-gradient(to right, #b7d1e6e9 0%, #eef2f3dd 51%, #b7d1e6cc 100%) !important;
				/* linear-gradient(to right, #9284add1 0%, #fdfdfd 51%, #9284add1 100%) !important
		*/
				border-right-width: 5px !important;

				&::before {
					border-top-color: red;
					/* change color for small triangle */
					rotate: -180deg !important;
					transform: translate(0px, 4px);
				}
			}

			/* format differently for label that its next sibling section contain li chapter that is playing */
			&:has(+ section > li.beingPlay) {
				color: rgb(116 25 196);
				background-image: linear-gradient(to top left, #abb1f3bd, #ffffff2e 80%);
				font-weight: bold;

				&::before {
					border-top-color: rgb(116 25 196);
					/* change color for small triangle */
				}
			}

			/* underline animation effect class */
			&>span>code.underlineAnim {
				/* prepare for label hover effect */
				--bg-h: 2px;
				text-decoration: none;
				/* display: inline; */
				background-image: linear-gradient(to right, slateblue, grey);
				background-position: 0px calc(1em + 4px + var(--bg-h));
				background-repeat: no-repeat;
				background-size: 0% var(--bg-h);
				transition: background-size 0.5s ease-in-out;
				padding-bottom: 3px;
			}

			&:hover {
				color: darkcyan !important;

				/* text-transform: capitalize; uppercase */
				/* font-weight: bold; */
				&::before {
					border-top-color: darkcyan !important;
					/* change color for small triangle */
				}

				/* parent on hover: underline animation effect class */
				&>span>code.underlineAnim {
					/* change background width=100% to make the animation */
					background-size: 100% var(--bg-h);
					background-position-x: left;
				}
			}

			&::before {
				content: '';
				display: inline-block;
				width: 0;
				height: 0;
				border: 5px solid transparent;
				border-width: 10px 5px;
				border-top-color: rgb(139, 0, 127);
				/* these 7 css lines is to make ⏵ */
				margin-left: 4px;

				-webkit-transition: all .5s ease;
				-moz-transition: all .5s ease;
				-o-transition: all .5s ease;
				transition: all .5s ease;
				transform-origin: 25% 50%;
				transform: translate(-5px, calc(50% - 2px));
			}
		}

		@media (pointer: coarse) {

			/* for smart device has (pointer: coarse), the font-size set to 19px, so we need to change background-position so it not go off of the element and user cann't see it */
			ol#elmPlaylist>input[type=checkbox]+label>span>code.underlineAnim {
				--bg-h: 1.5px;
				background-position: 0px calc(1em - 1px);
			}
		}

		/* Customize for section collapsed  */
		ol#elmPlaylist>input[type=checkbox]:not(:checked)+label {
			background-image: linear-gradient(to bottom right, #fdfcfb00, #e2d1c3b3);
			border: 1px solid rgb(139, 0, 127);
			border-left: 5px solid rgb(139, 0, 127);
			border-radius: 5px;
			justify-content: space-between;
			/* to force the triangle in ::before to align left (looks like float:left) and label content align right */
			padding-right: 5px;

			&:has(+ section > li.beingPlay) {
				/* format differently for label that its next sibling section contain li chapter that is playing */
				background-image: linear-gradient(to bottom right, #abb1f3bd, #ffffff2e 80%);
			}

			&::before {
				rotate: -90deg;
				transform: translate(-3px, 4px);
			}
		}

		/* adding playing icon for beingPlay item */
		ol#elmPlaylist li.beingPlay::after {
			content: url('data:image/svg+xml,<svg fill="red" viewBox="0 0 10.5 7" xmlns="http://www.w3.org/2000/svg"><rect transform="translate(.5 6) rotate(180) translate(-.5 -6)" x="-.5" y="5" width="1.5" height="2"><animate attributeName="height" dur="1.2s" keyTimes="0;0.5;1" repeatCount="indefinite" values="2;7;2"/> </rect> <rect transform="translate(3.5 4.5) rotate(180) translate(-3.5 -4.5)" x="2.5" y="2" width="1.5" height="5"> <animate attributeName="height" dur="2.8s" keyTimes="0;0.4;0.8;1" repeatCount="indefinite" values="5;1;7;5"/> </rect> <rect transform="translate(6.5 3.5) rotate(180) translate(-6.5 -3.5)" x="5.5" width="1.5" height="7"> <animate attributeName="height" dur="1s" keyTimes="0;0.5;1" repeatCount="indefinite" values="7;0;7"/> </rect> <rect transform="translate(9.5 5) rotate(180) translate(-9.5 -5)" x="8.5" y="3" width="1.5" height="4"> <animate attributeName="height" dur="4.7s" keyTimes="0;0.5;1" repeatCount="indefinite" values="2;7;2"/> </rect> </svg>');
			width: 18px;
			/* height changes with width, that why scaleY below */
			transform: scaleY(1.3);
			display: block;
			position: absolute;
			right: 4px;
			bottom: 4px;
			/* vertically center the playing bars
			top: 50%;
			transform: translateY(-50%); */
		}

		ol#lstJsFileDataSetting {
			/* responsive on screen height */
			max-height: min(calc(80dvh - 160px), 600px) !important;
		}
		ol#lstJsFileDataSetting > li {
			padding: 3px 5px 0px 0px;
			counter-reset: bookKitListCounter;
			/* div contains the file/variable name and checkbox to load/not load the data file */
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile]){
				display: flex;
				flex-flow: row nowrap;
				justify-content: stretch;
				/* margin-right: 5px; */
				padding: 5px;
				border: 1px solid #ae7676;
				border-radius: 5px;

				--illustrated-bgrnd-color: #f5c7c7aa;
				background-image: linear-gradient(to right, transparent 30%, var(--illustrated-bgrnd-color) 100%), 
				repeating-linear-gradient(-40deg,#fffc 0 25px,#f4f4f4cc 0 50px);

				& > :first-child{ /* details element */
					flex-grow: 1;
					font-weight: bold;
					color: darkblue;
					margin-top: 0px; /* overwrite default */
					& > summary {padding-top: 0px} /* overwrite default */
					& > summary > span::before {
						transform: translateX(2px); /* Vertically centered the small triangle */
						border-left-color: darkblue /* overwrite default color of details small triagle */
					}
				}
				& > :last-child{
					flex-grow: 0;
					text-align: right; /* so checkbox would be align right */
					align-self: center;
				} 

				& + div.detailContent{
					padding: 3px 0px;
					text-align: justify;
					-moz-columns	: 2 330px;
					-webkit-columns	: 2 330px;
					columns			: 2 330px;
					/* -webkit-column-break-inside: avoid;
					page-break-inside: avoid;
					break-inside: avoid; */

					& > h2 {
						text-align: center;
						margin: 5px 0px;
						column-span: all;
					}
				}

				&:has(details[open])+div.detailContent{
					max-height: 2000px; /* Expand the content */
				}
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="0"]){ /* state-val==0 */
				border-color: #363636;
				--illustrated-bgrnd-color: #909090aa;
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="1"]){ /* state-val==1 */
				border-color: #653302;
				--illustrated-bgrnd-color: #f49b43aa;
			}
			& div:has( > span > input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile][data-state-val="2"]){ /* state-val==2 */
				border-color: #093a56;
				--illustrated-bgrnd-color: #95ceefaa;
			}
			
			& p.dbFileBookList{
				counter-reset: dbBookListCounter;
				counter-increment: bookKitListCounter;
				margin: 2px 0 0 0;
				&:not(:last-of-type){
					border-image: linear-gradient(to right, #c9b7e6, #af90a4) 1 / 0 0 1px 0;
					padding-bottom: 5px;
				}
				&:before {
					counter-increment: section;
					content: counter(bookKitListCounter, upper-roman) ". ";
					color: darkorchid;
					font-weight: bold;
				}
				& > code{
					counter-increment: dbBookListCounter;
					word-spacing: -0.15em;
					display: inline;
					&::before{
						content: " ∵\2005" counter(dbBookListCounter) ". ";
						color: darkorchid;
						font-size: .9em;
					}
					&:nth-of-type(odd){color: #9f5c28}
					&:nth-of-type(even){color: #272782}
					&:only-of-type::before{content: " ∴ "}
				}
			}

			& input[type="checkbox"][role="switch"][attr-chkbox-Data-jsFile] {
				&:checked + label::before {
					content: "Fresh Load";
				}

				&:not(:checked) + label::before {
					content: "No show";
				}

				/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
				&:indeterminate + label::before {
					content: "Cache Load";
				}
			}
		}

		/* fieldset in DBFile tab to show statistics for whole DBs and status of DB checking for update */
		fieldset:has( > div[name="DBStatistics"]){
			padding:1px;
			display: flex;
			flex-direction: column;
			justify-content: space-evenly;
			& > div[name="DBStatistics"] > dfn{
				font-size:.85em;
				font-weight:400;
			}
		}

		/*       ScrollBar         */
		.niceScrollBar{
			/* to prevent below document to scroll when content of setting scroll reach to top or bottom. See https://getcssscan.com/blog/prevent-page-scrolling-while-scrolling-div-element for more */
			&:not(ol#elmPlaylist){ /* not apply for elmPlaylist */
				overscroll-behavior: contain;
			}

			&::-webkit-scrollbar {
				width: 10px;
			}

			&::-webkit-scrollbar-track {
				border-radius: 8px;
				background-color: #e7e7e7;
				border: 1px solid #cacaca;
			}

			&::-webkit-scrollbar-thumb {
				border-radius: 8px;
				border: 3px solid transparent;
				background-clip: content-box;
				background-color: #a3b3bd; /* #d55959; */
			}
		}

		/* End of Playlist*/

		div[name="bookKitChkboxContainer"]{
			justify-content: space-evenly;
			max-height: 5em;
			overflow: hidden auto;
		}
		/* Class for changing UI of Book Sets when their parent's Book Kit is hover. See bookSetList() function for more
		For now, maximum two Book Kits having more than one Book Sets (for all group way), if there are more than such two book kit, we can add style for .bookKitNo2-Childs, .bookKitNo3-Childs, ...
		*/
		div[name="bookKitChkboxContainer"] > div[class^="bookKitNo"]{
		/* :is(.bookKitNo0, .bookKitNo1, .bookKitNo2, .bookKitNo3, .bookKitNo4) { */

			/*only to disable context menu on long press*/
			-webkit-tap-highlight-color: #0000;
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none;
		}

		.bookKitNo0:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo0:hover)+ol>li.bookKitNo0-Childs {
			background: linear-gradient(to right, rgb(0 123 255 / 20%), #fff) !important
		}
		.bookKitNo1:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo1:hover)+ol>li.bookKitNo1-Childs {
			background: linear-gradient(to right, rgb(255 226 0 / 20%), #fff) !important
		}
		.bookKitNo2:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo2:hover)+ol>li.bookKitNo2-Childs {
			background: linear-gradient(to right, #d34af933, #fff) !important
		}
		.bookKitNo3:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo3:hover)+ol>li.bookKitNo3-Childs {
			background: linear-gradient(to right, #f9884a33, #fff) !important
		}
		.bookKitNo4:hover>label,
		div[name="bookKitChkboxContainer"]:has(> .bookKitNo4:hover)+ol>li.bookKitNo4-Childs {
			background: linear-gradient(to right, #524af933, #fff) !important
		}
	</style>

	<!-- TOAST NOTIFICATION  -->
	<style>
		div[name="toastContainer"] {
			--toastify-toast-offset: 20px;
			--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));
			--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));
			--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));
			--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));

			position: fixed;
			display: flex;

			z-index: 999999;
			pointer-events: none;

			/* TOAST LOCATION */
			/* &[location='manual-Bottom-Left']{} */

			&[location='Bottom-Right'] {
				flex-direction: column-reverse;
				align-items: flex-end;
				/* right align */
				bottom: var(--toastify-toast-bottom);
				right: var(--toastify-toast-right);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-bottom: calc(var(--toastify-toast-bottom)/2);
						;
					}
				}
			}

			&[location='Top-Right'] {
				flex-direction: column;
				align-items: flex-end;
				/* right align */
				top: var(--toastify-toast-top);
				right: var(--toastify-toast-right);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-top: calc(var(--toastify-toast-top)/2);
						;
					}
				}
			}

			&[location='Bottom-Left'] {
				flex-direction: column-reverse;
				align-items: flex-start;
				/* right align */
				bottom: var(--toastify-toast-bottom);
				left: var(--toastify-toast-left);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-bottom: calc(var(--toastify-toast-bottom)/2);
						;
					}
				}
			}

			&[location='Top-Left'] {
				flex-direction: column;
				align-items: flex-start;
				/* right align */
				top: var(--toastify-toast-top);
				left: var(--toastify-toast-left);

				&>.toast-element {
					&+& {
						/* margin between adjacent Toast */
						margin-top: calc(var(--toastify-toast-top)/2);
					}
				}
			}
		}

		.toast-element {
			--toast-color-light-bgrnd: #eeed;
			--toast-color-dark-bgrnd: #333b;
			--toast-color-dark-text: #fff;

			--toast-color-info: #3498db;
			--toast-color-info-lightest: #aae3f6;
			/* #2f86eb */
			--toast-color-success: #07bc0c;
			--toast-color-success-lightest: #80d280;
			/* 47d864 */
			--toast-color-warning: #ffc021;
			--toast-color-warning-lightest: #ffdd80;
			/* f1c40f #00b894cc #fdcb6ecc*/
			--toast-color-error: #e74c3c;
			--toast-color-error-lightest: #fd9c9f;
			/* ff623d #bd3d53 */
			--toast-color-promise: #9542fa;
			--toast-color-promise-lightest: #b378fb;

			--toast-border-width: 1.5px;
			--progress-bar-height: calc(var(--toast-border-width) * 2);
			/* --toastify-color-progress-light: linear-gradient(90deg,#4cd964,#5ac8fa,#007aff,#34aadc,#5856d6,#ff2d55);
    		--toastify-color-progress-dark: #bb86fc; */

			/* Set a default minimum and maximum width */
			min-width: 200px;
			max-width: min(calc(100vw - 30px), 750px); /* so that the toast should not be too long */
			display: flex;
			position: relative;
			align-items: center;
			padding: 5px 10px;
			background-color: var(--toast-color-light-bgrnd);
			border: var(--toast-border-width) solid #666;
			border-left: 5px solid;
			border-radius: 5px;
			box-shadow: #666a 5px 5px 25px 0px;
			z-index: 13;
			pointer-events: auto;
			cursor: pointer;
			
			&.toast-manual {
				position: fixed;
				bottom: 0px;
				/* to prepare for transition */
				left: var(--toastify-toast-left);
			}

			&>.toast__icon {
				flex-grow: 0;
				padding: 4px 8px 0px 0px;
				user-select: none;
				display: inline-block;

				&>svg {
					width: 1.25em;
					height: 1.25em;
					fill: currentColor;
				}
			}

			&>.toast__msg {
				flex-grow: 1;
				font-size: 1.15rem;
				color: #eee;
				line-height: 1.5;
			}

			&>.toast-progress {
				position: absolute;
				/* to cover the bottom border of toast */
				bottom: calc(0px - var(--toast-border-width));
				left: -2px;
				width: calc(100% + 2px);
				height: var(--progress-bar-height);
				background-color: #4070f4;
			}
		}

		/* THEME */
		.toast-element.toast-dark-theme {
			background-color: var(--toast-color-dark-bgrnd);
			border-bottom: var(--progress-bar-height) solid black;

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast-progress {
				/* to cover the bottom border of toast */
				bottom: calc(0px - var(--progress-bar-height)) !important;
			}
		}

		.toast-element.toast-color-theme {
			border-color: var(--toast-color-dark-bgrnd) !important;

			&>.toast__icon {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
			}
		}

		.toast-element.toast-mono-theme {
			background-color: var(--toast-color-dark-bgrnd);			

			&>.toast__msg {
				color: var(--toast-color-dark-text) !important;
				/* vertical middle the message in case message has something taller than normal (like a svg picture). I don't use it because flex cause so much trouble when the message contains mix of text, svg and sometime <br> */
				/* display: flex;
				flex-wrap: wrap;
        		align-items: center; */
				/* to preserve whitespace  */
				white-space: pre-wrap;				

				/* instead of setting display: flex for the toast__msg, which can middle the svg with the text but cause so much issue. I just simply set margin-bottom for svg manually */
				& > svg{
					margin-bottom: -3px;
				}
			}

			&>.toast__icon {
				color: var(--toast-color-dark-text) !important;
			}

			&>.toast-progress {
				/* background: var(--toastify-color-progress-light) !important; */
				background-color: var(--toast-color-dark-text) !important;
			}
		}

		@media only screen and (max-width: 450px) {
			.toast-element {
				&>.toast__icon {
					padding: 2px 8px 0px 0px;

					&>svg {
						width: 1.15em;
						height: 1.15em;
					}
				}

				&>.toast__msg {
					font-size: 1rem;
					/* toast text a bit smaller on small screen */
				}
			}
		}

		/* TOAST TYPES */
		.toast-type--Promise {
			color: var(--toast-color-dark-bgrnd);
			border-color: var(--toast-color-promise);
			border-bottom: var(--toast-border-width) solid var(--toast-color-promise) !important;

			&>.toast__icon {
				color: var(--toast-color-dark-bgrnd);

				&>svg {
					width: 1.4em;
					height: 1.4em;
					animation: spin-keyframe 1s linear infinite;
					animation-timing-function: steps(12, jump-none);
				}
			}

			&>.toast__msg {
				color: var(--toast-color-dark-bgrnd);
			}

			&>.toast-progress {
				background-color: var(--toast-color-promise);
			}

			&.toast-dark-theme {
				color: var(--toast-color-dark-text);

				&>.toast__icon {
					color: var(--toast-color-dark-text);
				}
			}

			&.toast-color-theme {
				color: var(--toast-color-dark-text);
				background-color: color-mix(in srgb, var(--toast-color-promise), transparent 10%);

				&>.toast__icon {
					color: var(--toast-color-dark-text);
				}
			}
		}

		.toast-type--Infor {
			border-color: var(--toast-color-info);
			
			&>.toast__icon {
				color: var(--toast-color-info);
			}

			&>.toast__msg {
				color: #043268;
			}

			&>.toast-progress {
				background-color: var(--toast-color-info);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-info), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-info-lightest);
				}
			}
		}

		.toast-type--Success {
			/* background-color:#333c; */
			border-color: var(--toast-color-success);

			&>.toast__icon {
				color: var(--toast-color-success);
			}

			&>.toast__msg {
				color: #026516;
			}

			&>.toast-progress {
				background-color: var(--toast-color-success);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-success), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-success-lightest);
				}
			}
		}

		.toast-type--Warning {
			border-color: var(--toast-color-warning);

			&>.toast__icon {
				color: var(--toast-color-warning);
			}

			&>.toast__msg {
				color: #543d02;
			}

			&>.toast-progress {
				background-color: var(--toast-color-warning);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-warning), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-warning-lightest);
				}
			}
		}

		.toast-type--Error {
			border-color: var(--toast-color-error);

			&>.toast__icon {
				color: var(--toast-color-error);
			}

			&>.toast__msg {
				color: #8a1c04;
			}

			&>.toast-progress {
				background-color: var(--toast-color-error);
			}

			&.toast-color-theme{
				background-color: color-mix(in srgb, var(--toast-color-error), transparent 10%);
				& > .toast-progress{
					background-color: var(--toast-color-error-lightest);
				}
			}
		}

		/* keyframe for progress-bar counting-down animation */
		@keyframes progress-keyframe {
			100% {
				width: 0%;
			}
		}

		/* Set for manual mode only */
		@keyframes Toastify__slideManualIn {
			from {
				transform: translateX(calc(-100% - 32px));
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes Toastify__slideManualOut {
			from {
				transform: translateY(0);
			}

			to {
				/* bottom: calc(-100% - 10px) ;  */
				transform: translateY(calc(100vh + 100%));
			}
		}
		/* End of Set for manual mode only */
		
		/* Bounce animation */
		/* Bounce from/to Right */
		@keyframes Toastify__bounceInRight {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			from {
				opacity: 0;
				transform: translate3d(calc(100vw + 100px), 0, 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(-25px, 0, 0);
			}

			75% {
				transform: translate3d(10px, 0, 0);
			}

			90% {
				transform: translate3d(-5px, 0, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutRight {
			20% {
				opacity: 1;
				transform: translate3d(-20px, 0, 0);
			}

			to {
				opacity: 0;
				transform: translate3d(calc(100vw + 100px), 0, 0);
			}
		}

		/* Bounce from/to Left */
		@keyframes Toastify__bounceInLeft {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			0% {
				opacity: 0;
				transform: translate3d(calc(-100vw - 100px), 0, 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(25px, 0, 0);
			}

			75% {
				transform: translate3d(-10px, 0, 0);
			}

			90% {
				transform: translate3d(5px, 0, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutLeft {
			20% {
				opacity: 1;
				transform: translate3d(20px, 0, 0);
			}

			to {
				opacity: 0;
				transform: translate3d(calc(-100vw - 100px), 0, 0);
			}
		}

		/* Bounce from/to bottom */
		@keyframes Toastify__bounceInBottom {

			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			from {
				opacity: 0;
				transform: translate3d(0, calc(100vh + 100px), 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(0, -20px, 0);
			}

			75% {
				transform: translate3d(0, 10px, 0);
			}

			90% {
				transform: translate3d(0, -5px, 0);
			}

			to {
				transform: translate3d(0, 0, 0);
			}
		}

		@keyframes Toastify__bounceOutBottom {
			20% {
				transform: translate3d(0, calc(0 - 10px), 0);
			}

			40%,
			45% {
				opacity: 1;
				transform: translate3d(0, calc(0 + 20px), 0);
			}

			to {
				opacity: 0;
				transform: translate3d(0, calc(100vh + 100px), 0);
			}
		}

		/* Bounce from/to top */
		@keyframes Toastify__bounceInTop {
			from,
			60%,
			75%,
			90%,
			to {
				animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
			}

			0% {
				opacity: 0;
				transform: translate3d(0, calc(-100vh - 100px), 0);
			}

			60% {
				opacity: 1;
				transform: translate3d(0, 25px, 0);
			}

			75% {
				transform: translate3d(0, -10px, 0);
			}

			90% {
				transform: translate3d(0, 5px, 0);
			}

			to {
				transform: none;
			}
		}

		@keyframes Toastify__bounceOutTop {
			
			20% {
				transform: translate3d(0, calc(0 - 10px), 0);
			}
			40%, 45% {
				opacity: 1;
				transform: translate3d(0, calc(0 + 20px), 0);
			}
			to {
				opacity: 0;
				transform: translate3d(0, calc(-100vh - 100px), 0);
			}		
		}

		/* ——End of Bounce animation—— */

		/* Slide animation */
		/* Slide from/to Right */
		@keyframes Toastify__slideInRight {
			from {
				transform: translateX(calc(100% + 100px));
				opacity: 0;
			}

			to {
				transform: translateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutRight {
			0% {
				transform: translateX(0);
				opacity: 1;
			}
			100% {
				transform: translateX(calc(100% + 100px));
				opacity: 0;
			}
		}

		/* Slide from/to Left */
		@keyframes Toastify__slideInLeft {
			from {
				transform: translateX(-120vw);
				opacity: 0;
			}

			to {
				transform: translateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutLeft {
			0% {
				transform: translateX(0);
				opacity: 1;
			}
			100% {
				transform: translateX(-120vw);
				opacity: 0;
			}
		}

		/* Slide from/to Top */
		@keyframes Toastify__slideInTop {
			0% {
				transform: translateY(-50vh);
				opacity: 0;
			}
			100% {
				transform: translateY(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutTop {
			from {
				transform: translateY(0);
				opacity: 1;
			}

			to {
				transform: translateY(-100vh);
				opacity: 0;
			}
		}

		/* Slide from/to Bottom */
		@keyframes Toastify__slideInBottom {
			0% {
				transform: translateY( calc(100vh + 50px));
				opacity: 0;
			}
			100% {
				transform: translateY(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__slideOutBottom {
			from {
				transform: translateY(0);
			}

			to {
				opacity: 0;
				transform: translateY( calc(100vh + 50px));
			}
		}
		/* End of Slide animation */

		/* Elliptic Slide animation */
		/* Elliptic Slide from/to Right */
		@keyframes Toastify__ellipticInRight {
			0% {
				transform: translateX(800px) rotateY(-30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 0;
			}
			100% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: -1800px 50%;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutRight {
			0% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: -1800px 50%;
				opacity: 1;
			}
			100% {
				transform: translateX(1000px) rotateY(-30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Left */
		@keyframes Toastify__ellipticInLeft {
			0% {
			transform: translateX(-800px) rotateY(30deg) scale(0);
			transform-origin: -100% 50%;
			opacity: 0;
		}
		100% {
			transform: translateX(0) rotateY(0) scale(1);
			transform-origin: 1800px 50%;
			opacity: 1;
		}
		}
		@keyframes Toastify__ellipticOutLeft {
			0% {
				transform: translateX(0) rotateY(0) scale(1);
				transform-origin: 2000px 50%;
				opacity: 1;
			}
			100% {
				transform: translateX(-1000px) rotateY(30deg) scale(0);
				transform-origin: -100% 50%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Top */
		@keyframes Toastify__ellipticInTop {
			0% {
				transform: translateY(-600px) rotateX(-30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 0;
			}
			100% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% 1400px;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutTop {
			0% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% 1400px;
				opacity: 1;
			}
			100% {
				transform: translateY(-600px) rotateX(-30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 1;
			}
		}

		/* Elliptic Slide from/to Bottom */
		@keyframes Toastify__ellipticInBottom {
			0% {
				transform: translateY(600px) rotateX(30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 0;
			}
			100% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% -1400px;
				opacity: 1;
			}
		}
		@keyframes Toastify__ellipticOutBottom {
			0% {
				transform: translateY(0) rotateX(0) scale(1);
				transform-origin: 50% -1400px;
				opacity: 1;
			}
			100% {
				transform: translateY(600px) rotateX(30deg) scale(0);
				transform-origin: 50% 100%;
				opacity: 1;
			}
		}
		/* End of Elliptic Slide animation */

		/* FLIP animation */
		@keyframes Toastify__flipInHorz {
			0% {
				transform: rotateX(80deg);
				opacity: 0;
			}
			100% {
				transform: rotateX(0);
				opacity: 1;
			}
		}
		@keyframes Toastify__flipOutHorz {
			0% {
				transform: rotateX(0);
				opacity: 1;
			}
			100% {
				transform: rotateX(70deg);
				opacity: 0;
			}
		}

		@keyframes Toastify__flipInVert {
			0% {
				transform: rotate3d(1, 1, 0, -80deg);
				opacity: 0;
			}
			100% {
				transform: rotate3d(1, 1, 0, 0deg);
				opacity: 1;
			}
		}
		@keyframes Toastify__flipOutVert {
			0% {
				transform: rotate3d(1, 1, 0, 0deg);
				opacity: 1;
			}
			100% {
				transform: rotate3d(1, 1, 0, -70deg);
				opacity: 0;
			}
		}
		/* END OF FLIP animation */

		/* SLIT animation */
		@keyframes Toastify__slitInHorz {
			0% {
				transform: translateZ(-800px) rotateX(90deg);
				opacity: 0;
			}
			54% {
				transform: translateZ(-160px) rotateX(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(0) rotateX(0);
			}
		}
		@keyframes Toastify__slitOutHorz {
			0% {
				transform: translateZ(0) rotateX(0);
				opacity: 1;
			}
			54% {
				transform: translateZ(-160px) rotateX(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(-800px) rotateX(90deg);
				opacity: 0;
			}
		}

		@keyframes Toastify__slitInVert {
			0% {
				transform: translateZ(-800px) rotateY(90deg);
				opacity: 0;
			}
			54% {
				transform: translateZ(-160px) rotateY(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(0) rotateY(0);
			}
		}
		@keyframes Toastify__slitOutVert {
			0% {
				transform: translateZ(0) rotateY(0);
				opacity: 1;
			}
			54% {
				transform: translateZ(-160px) rotateY(87deg);
				opacity: 1;
			}
			100% {
				transform: translateZ(-800px) rotateY(90deg);
				opacity: 0;
			}
		}
		/* END OF SLIT animation */

		@keyframes Toastify__zoomIn {
			from {
				opacity: 0;
				transform: scale3d(0.3, 0.3, 0.3);
			}

			to {
				opacity: 1;
			}
		}
		@keyframes Toastify__zoomOut {
			from {
				opacity: 1;
			}

			to {
				opacity: 0;
				transform: scale3d(0.3, 0.3, 0.3);
			}
		}

		@keyframes Toastify__swirlIn {
			0% {
				transform: rotate(-540deg) scale(0);
				opacity: 0;
			}

			100% {
				transform: rotate(0) scale(1);
				opacity: 1;
			}
		}
		@keyframes Toastify__swirlOut {
			0% {
				transform: rotate(0) scale(1);
				opacity: 1;
			}

			100% {
				transform: rotate(-540deg) scale(0);
				opacity: 0;
			}
		}
	</style>

	<!-- small popup css -->
	<style>
		.havingShortPopup {
			display: inline-block;
			position: relative;
		}

		.havingShortPopup .shortPoup {
			visibility: hidden;
			/* to prevent jump2Chapter popup go outside of screen viewport */
			width: min(500px, calc(100vw - 40px));
			top: 100%;
			left: 50%;
			transform: translateX(var(--data-translateX, -50%));

			background-color: #656565;
			color: #fff;
			text-align: center;
			padding: 5px;
			border: 1px solid gray;
			border-radius: 6px;
			box-shadow: rgb(38, 57, 77) 0px 20px 30px -10px;

			/* Position the tooltip text - see examples below! */
			position: absolute;
			z-index: 5;
			/* must higher than chapter-group-label's z-index */

			opacity: 0;
			transition: opacity 1s;
		}

		.havingShortPopup .shortPoup::after {
			content: " ";
			position: absolute;
			bottom: 100%;
			/* At the top of the poup */
			left: var(--data-translateX-pseudo-after, calc(50% - 8px));
			/*  margin-left: -10px; */
			border-width: 8px;
			border-style: solid;
			border-color: transparent transparent #656565 transparent;
		}

		.havingShortPopup .shortPoupShow {
			visibility: visible !important;
			opacity: 1;
		}

		/* .havingShortPopup:not(:hover) .shortPoupShow{
	visibility: hidden !important;
	opacity: 1;
} */
		.shortPoup input:not([type="button"]) {
			width: 10em;
		}

		/* Remove Arrows/Spinners */
		/* Chrome, Safari, Edge, Opera */
		input::-webkit-outer-spin-button,
		input::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		/* Firefox */
		input[type=number] {
			appearance: textfield;
			-moz-appearance: textfield;
		}

		.shortPoup input+span {
			padding-right: 30px;
		}

		.shortPoup>* {
			margin-bottom: 5px;
		}

		.shortPoup>label {
			display: inline-block;
			/* for margin to work */
		}

		.shortPoup>label>b {
			font-weight: 400;
			color: #d0f399;
			font-size: 1.1em;
		}

		.shortPoup input:invalid+span.checkInputValidity::after {
			position: absolute;
			content: "✖";
			color: #ff7272;
			font-size: 1.2em;
			padding-left: 5px;
		}

		.shortPoup input:valid+span.checkInputValidity::after {
			position: absolute;
			content: "✓";
			color: #80f9f9;
			font-size: 1.15em;
			padding-left: 5px;
		}

		/* Sleep timer related elements */
		.havingShortPopup > button:has( + #sleepTimerDivPopup){
			&.sleepTimerActive{
				/* color: red !important; */
				animation: sleepTimerActive_colorChange 3s alternate infinite;
			}
		}
		@keyframes sleepTimerActive_colorChange{
			from, 40% {color: red}
			to {color: #c5a91e}
		}
		#elmSleepTimerCountDown{
			font-size: 1.3em;
			color: darkred; /* var(--select-book-group-color); */
			background: beige;
			border-radius: 5px;
    		padding: 0 5px;

			&.almostReachingEnd{
				animation: timer-blink-kf 2s step-start .3s infinite;
			}

			/* format for svg right before input box */
			svg:has( + &){
				color: darkred;
			}
		}

		/* .shortPoup .popupCloseButton {
			float: right;
			padding: 2px 4px;
			border: 1px solid gray;
			border-radius: 5px;
			background-color: #ddd;
		}

		.shortPoup .popupCloseButton:hover {
			background-color: #d2f3f3;
		}

		.shortPoup .popupCloseButton::before {
			content: '✕';
		} */

		/* Drag and Drop */
		.activeDragItem {
			/* transform: scaleY(1.2) translateY(-20px); */
			background-color: #666;
			box-shadow: rgba(181, 14, 14, 0.16) 0px 1px 4px, rgb(124, 76, 76) 0px 0px 0px 3px;
		}

		.draggingGhostElem {
			background-color: orange;
			position: absolute;
			opacity: 1 !important;
			border: 2px solid darkblue;
			pointer-events: none;
			list-style-type: none;
			& *{
				opacity: 1 !important;
				color: #000 !important;
				font-weight: bold;
			}

			/* to make the checkbof float right exactly as original li */
			&>input[type="checkbox"] {
				float: right;
				margin-right: 7px;
				font-size: 20px;
				border: 1px solid darkred !important;
			}
		}

		.activeDropItem {
			transform: translateX(50px) scaleX(1.2);
			background-color: #21ff1577 !important;
			box-shadow: rgba(0, 0, 0, 0.16) 0px 1px 4px, rgb(51, 51, 51) 0px 0px 0px 3px;
		}
	</style>

	<!-- SETTING MODAL POPUP -->
	<style>
		/* CSS nền hiển thị Modal */
		.modalPopup .modalPopupOverlay {
			position: fixed;
			top: 0px;
			left: 0px;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.7);
			z-index: 9;
			display: none;
		}

		/* CSS bảng nội dung Modal */
		.modalPopup .modalPopupContentWrapper {
			position: absolute;
			display: block;
			/* This line and next to fit wrapper height to the content */
			overflow: hidden;
			top: 0px; /* 50% */
			/* min(50%, 200px)Use 50% if you want the modal verically middle of screen */
			left: 50%;
			transform: translate(-50%, -50%) scale(0);
			background-color: #fff;
			/* DFDBE5 */
			width: min(80vw, 850px);
			z-index: 10;
			text-align: center;
			padding: 10px;
			box-sizing: border-box;
			border-radius: 20px;
			display: block;
			position: fixed;
			box-shadow: 0px 0px 10px #111;
			transition: all 300ms ease-in-out;
			
			/* format the color and the size for the CSS background set in .circus-background */
			--__s: 45px;
    		--__c: #a088b921;
		}

		@media (max-width: 700px) {
			.modalPopup .modalPopupContentWrapper {
				width: 95vw;
			}
		}

		/* CSS Header bao bọc title & nút tắt Modal */
		.modalPopup .modalHeader {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-top: -10px;
			/* margin-bottom: 10px; */
		}

		/* CSS tieu de của Modal */
		.modalPopupContent #elmHistoryWipeAll {
			display: flex;
			align-items: center;
			width: 34px;

			&+label::after {
				content: "Wipe out all saved data";
			}
		}

		.modalPopupContent #elmHistoryWipeAllButDataCfg+label::after {
			content: "Reset to new DBs cfg above";
		}

		.modalPopupContent #elmCheckDBFilesUpdate+label::after {
			content: "Check new DBs edition";
		}

		.modalPopupContent #chkShowHideAllHistChapDetails + label::after{
			content: "Show/Hide chapers infor";
		}
		.modalPopupContent #chkDisableCircleProgressButton {
			&:checked+label::before {
				content: "Show Play progress";
				color: var(--select-book-group-color);
			}

			&:not(:checked)+label::before {
				content: "Hide Play progress";
			}
		}

		.modalPopupContent #chkHideBufferBar {
			&:checked+label::before {
				content: "Show audio buffer bar";
				color: var(--select-book-group-color);
			}

			&:not(:checked)+label::before {
				content: "Hide audio buffer bar";
			}
		}

		@media (min-width: 800px) {
			.modalPopupContent #chkShowHideAllHistChapDetails + label::after{
				content: "Ẩn/Hiện chi tiết các chương sách";
			}
			.modalPopupContent #elmHistoryWipeAll+label::after {
				content: "Xóa toàn bộ thông tin đã lưu";
			}

			.modalPopupContent #elmHistoryWipeAllButDataCfg+label::after {
				content: "Nạp lại theo cấu hình CSDL mới";
			}

			.modalPopupContent #elmCheckDBFilesUpdate+label::after {
				content: "Kiểm tra phiên bản mới các CSDL";
			}

			.modalPopupContent #chkDisableCircleProgressButton {
				&:checked+label::before {
					content: "Hiện tiến trình trên nút Play";
				}

				&:not(:checked)+label::before {
					content: "Ẩn tiến trình trên nút Play";
				}
			}

			.modalPopupContent #chkHideBufferBar {
				&:checked+label::before {
					content: "Hiện thanh audio buffer";
				}

				&:not(:checked)+label::before {
					content: "Ẩn thanh audio buffer";
				}
			}

		}

		/* CSS nút tắt modal */
		.modalPopup .closeModal {
			position: absolute;
			right: 10px;
			top: 5px;
			width: 34px;
			height: 34px;
			text-align: center;
			padding: 2px;
			cursor: pointer;

			border-radius: 6px;
			background: #eee;
			border: 1px solid #aaa;

			&::before {
				content: ' ';
				background: transparent url("https://uxwing.com/wp-content/themes/uxwing/download/checkmark-cross/remove-icon.svg") 0px 0px / 30px 30px no-repeat !important;
				display: block;
				width: 30px;
				height: 30px;
				text-align: center;
			}

			&:hover {
				background: #ccc;

				&::before {
					filter: invert(14%) sepia(98%) saturate(7458%) hue-rotate(358deg) brightness(91%) contrast(122%);
					transition: filter 150ms ease-out;
				}
			}
		}

		.modalPopupContent .bounding-box {
			border: 1px solid gray;
			border-radius: 10px;
			background-color: #f0f8ff44;
			padding: 5px 0px 2px 0px;
			margin: 5px 0px;
		}

		/* This conflict with tooltip, so it has to be removed
	.modalPopupContent #chkShowBookKit + label{
		&:checked + label::after{
			content: "Book Kit view";
		}
		&:not(:checked) + label::after{
			content: "Book Set view";
		}
		
	}*/

		.modalPopup.activeModalPopup .modalPopupOverlay {
			display: block;
			backdrop-filter: blur(2px);
			-webkit-backdrop-filter: blur(2px);
		}

		/* CSS animation when Modal shown */
		.modalPopup.activeModalPopup .modalPopupContentWrapper {
			/* calc(50vh - 50%) Using dvh to better account for address-bar of iPhone */
			transform: translate(-50%, max(calc(25dvh - 25%), 1px) ) scale(1);
			/* remove the dark border added by browser when the div is forced to have focus in initSettingModal() */
			&:focus{outline: none;}
		}

		.modalPopupContent label[for="selPopupBookGroup"]{
			display: none;
		}
		.modalPopupContent #selPopupBookGroup {
			width: 90%;
			border-width: 2px;
			border-color: var(--select-book-group-color);
		}

		@media (min-width: 500px) {
			.modalPopupContent label[for="selPopupBookGroup"]{
				display: block;
			}
			.modalPopupContent #selPopupBookGroup {
				width: 20em;
			}
		}

		/* Format ol, li of popup book group list (mostly in setting modal). The others CSS are with ol#elmPlaylist */
		ol.lstBookTitlesSetting {
			/* to prevent margin-block-start, margin-block-end default is 1em = 17px */
			margin: 5px 0px !important;
			/* responsive on screen height */
			max-height: min(calc(80dvh - 100px), 600px) !important;			
		}

		/* Since there are multiple bookKit checkboxes, so make the height of #lstBookTitlesSetting (in Setting modal) shorter to prevent overflow */
		ol#lstBookTitlesSetting {
			/* responsive on screen height */
			max-height: min(calc(80dvh - 130px), 600px) !important;
		}

		ol.lstBookTitlesSetting>li>input[type="checkbox"] {
			float: right;
			margin-right: 7px;
			font-size: 20px;
			border: 1px solid darkred !important;
		}

		/* Format fancy checkbox */
		input[type="checkbox"][role="switch"] {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			position: relative;
			color: inherit;
			font-size: inherit;
			width: 2em;
			height: 1em;
			box-sizing: content-box;
			border: 1px solid;
			border-radius: 1em;
			vertical-align: text-bottom;
			margin: auto;

			&:checked:hover {
				background: color-mix(in srgb, #8bb9ee 60%, CanvasText 10%);
			}

			&:not(:checked):hover {
				background: color-mix(in srgb, GrayText 30%, CanvasText 10%);
			}

			/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
			&:indeterminate:hover {
				background: color-mix(in srgb, GrayText 30%, white 70%);
			}

			&::before {
				content: "";
				position: absolute;
				top: 50%;
				left: 0;
				transform: translate(0, -50%);
				box-sizing: border-box;
				width: 0.7em;
				height: 0.7em;
				margin: 0 0.15em;
				border: 1px solid;
				border-radius: 50%;
				background: currentcolor;
			}

			&:checked::before {
				left: 1em;
				background: #0d8707;
			}

			/* Put last after :checked and :not:checked to avoid UI mess-up when browser does not know the state of checkbok */
			&:indeterminate {
				background: transparent;

				&::before {
					border-radius: 20%;
					left: 0.5em;
					background: #b8b8b8;
					scale: 0.9;
					/* make it smaller so it looks same size as circle */
					transform: translate(0, calc(-50% - 0.05em));
				}
			}

			&:disabled {
				opacity: 0.4;
			}
		}

		[name="Toast-Setting"]{
			/* responsive on screen height */
			max-height: min(calc(90dvh - 130px), 600px) !important;
			overflow-y: auto;
		}

		/* Fancy radio buttons */
		.fancyRadioContainer {
			display: flex;
			-webkit-box-align: center;
			flex-wrap: wrap;
			align-items: center;
			justify-content: flex-start;
			/* space-evenly */
			gap: 5px;
			padding: 2px 4px 4px 10px;
			margin-bottom: 5px;

			&>input[type="radio"].fancyRadioHidden {
				margin-right: 8px;
				position: absolute;
				opacity: 0;
				z-index: -1;
			}
		}

		input[type="radio"].fancyRadioHidden+label.fancyRadioLabel {
			font-weight: 300;
			position: relative;
			z-index: 1;
			margin-right: 0.6em;
			padding-left: 1.6em;
			padding-right: 1em;
			line-height: 1.8;
			vertical-align: middle;
			cursor: pointer;
			color: #333;
			/* e91e63 */
			transition: all 0.25s ease 0s;

			&::before {
				content: " ";
				box-sizing: border-box;
				display: block;
				position: absolute;
				top: 0.3em;
				left: 0px;
				width: 1.2em;
				height: 1.2em;
				border: 2px solid rgb(233, 30, 99);
				border-radius: 1em;
				z-index: -1;
				transition: all 0.25s ease 0s;
			}

			&.fancyRadioLabelPurple::before {
				border-color: rgb(148, 30, 233);
			}

			&.fancyRadioLabelBlue::before {
				border-color: rgb(30, 30, 233);
			}

			&.fancyRadioLabelGold::before {
				border-color: rgb(212 122 17);
			}

			&.fancyRadioLabelRandomChoose{
				/* text-decoration: underline;
				border: 1px solid darkred;
        		border-radius: .5em; */

				&::after {
				content: " ";
				box-sizing: border-box;
				display: block;
				position: absolute;
				top: 0.5em;
				left: .2em;
				width: 0.8em;
				height: 0.8em;
				/* border: 2px solid darkorange; */
				background-color: #938f8f;
				border-radius: 50%;
				z-index: -1;
			}
			}
		}

		input[type="radio"].fancyRadioHidden:checked+label.fancyRadioLabel {
			padding-left: 1em;
			color: rgb(255, 255, 255);

			&::before {
				top: 1px; /* 0.15em */
				width: 100%;
				height: 1.8em;
				background: rgb(233, 30, 99);
			}

			&.fancyRadioLabelPurple::before {
				background: rgb(148, 30, 233);
			}

			&.fancyRadioLabelBlue::before {
				background: rgb(30, 30, 233);
			}

			&.fancyRadioLabelGold::before {
				background: rgb(212 122 17);
			}
		}

		.setting-elm-disabled {
			cursor: not-allowed;
			pointer-events: none;
			background-color: #ddd8d866;
			border-image: linear-gradient(to right, #743ad5, #d53a9d) 1 / 1.5px 0;
		}

		/* Hotkeys user-help using Grid-layout */
		div[name="hotkeysSettingWrapper"]{
			width: 100%;
			max-height: min(calc(100dvh - 70px), 780px) !important;
			overflow: hidden auto;
			
			& > div{ /* without this inner-wrapper div, the scroll-y will not work */
				display: block; /* at default small size, just make it simple block */
			}

			& > div > fieldset{
				display: grid;
				justify-items: start;
				align-items: center;
				grid-template-columns: [hotKey] min-content [description] 1fr;
				grid-auto-flow: row;
				grid-gap: .2em .5em;
				
				@media screen  and (min-width: 800px){
					/* for fieldset that has enough width, make the column displaying keys bigger so it is shown in one line */
					&.lanscape-content{
						grid-template-columns: [hotKey] auto [description] 1fr;
					}
				}

				/* &:not(:last-child){
					margin-bottom: 8px;
				}
 */
				&  *{
					font-size: .9em;
				}
						
				/* common guide spread two columns */
				& > span.commonGuide{
					grid-column: span 2;
					text-align: justify;
					line-height: 1.3;

					border: 1px solid gray;
					border-radius: 10px;
					background-color: #f0f8ff44;
					padding: 2px 5px;
				}
				/* samp - an item of grid contains hotkey code */
				& > samp  {
					grid-column: hotKey;
					grid-row: auto;
					justify-self: end; /* align right */
					align-self: center; /* center to avoid the div stretch */
					text-align: right;
				}
				
				/* hotkey description */
				& > label {
					grid-column: description;
					grid-row: auto;
					padding: .4em;
					border: 0;
					text-align: left;
				}

				/* hotkey decoration */
				& kbd/* :not(:has(> kbd)) */  {
					/* font-family: monospace; */
					background-color: #eee;
					border-radius: 3px;
					border: 1px solid #b4b4b4;
					box-shadow:
						0 1px 1px rgba(0, 0, 0, 0.2),
						0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
					color: #333;
					display: inline-block;
					margin-bottom: 3px;
					
					font-size: 0.95em;
					font-weight: 700;
					line-height: 1.2;
					padding: 2px 4px;

					white-space: nowrap; /* to avoid text is broken into lines */
					
					/* using different color for keys that having ignoreModifier=true in its shortcut */
					&.ignoreModifierKeys{
						color: var(--select-book-group-color);
					}
				}

				& > div[name="coryright"]{
					grid-column: span 2;
					text-align:left;
					display: flex;
					flex-flow: row nowrap;
					align-items: center;
					/* margin: -17px 0 -6px 0; */
					font-size: 1.1rem;
					& > [name="authorName"]{
						display: inline-block;
						line-height: 1.3em;
						height:1em;
						overflow: hidden;
						&::after {
							content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁\A🅑🅈 🄲🄷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🄷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🄸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🄽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🄷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🅅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🅃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🆃🅁\A🅑🅨 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷ🅨 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ 🅲🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ Ⓒ🅷🅸🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽ🅸🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾ🅽🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃ🅷🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽ🆅🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋ🆃🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋⓉ🆁\AⒷⓎ ⒸⒽⒾⓃⒽⓋⓉⓇ";
							font-size: 1rem;
							white-space: pre;
							display: inline-block;
							animation: l39-1 4.5s infinite steps(20) alternate, l39-2 3s infinite alternate;
						}
					}
				}
			}
		}
		@media (pointer: fine) {
			/* On desktop, change the height for the animation look right */
			div[name="authorName"]{
				line-height: 1.2em !important;
				height:1.2em !important;
			}
		}
		@keyframes l39-1 {
			100%{transform: translateY(-100%)}
		}
		@keyframes l39-2 {
			0% {
				color: #000;
			}
			20% {
				color: blue;
			}
			60% {
				color: red;
			}
			80%{
				color: green;
			} 
			100% {
				color: #000;
			}
		}
		/* @keyframes changeLetters {
			0% {
				color: #000;
				content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁" ;
			}
			20% {
				content: "🅑🅨 🅲🅷🅸🅽🅷🆅🆃🆁" ;
			}
			40% {
				color: red;
				content: "🄱🅈 🅲🅷🅸🅽🅷🆅🆃🆁" ;
			}
			60% {
				content: "🅑🅨 🄲🄷🄸🄽🄷🅅🅃🅁" ;
			}
			80%{
				color: green;
				content: "ⒷⓎ ⒸⒽⒾⓃⒽⓋⓉⓇ"
			} 
			100% {
				color: #000;
				content: "🄱🅈 🄲🄷🄸🄽🄷🅅🅃🅁";
			}
		} */
		
		/* for wider screen, applying grid layout to inner-wrapper div to make the effect of two column */
		@media (min-width: 800px) {
			div[name="hotkeysSettingWrapper"] > div{
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    			/* grid-auto-flow: row dense; */
				column-gap: 8px;
				align-items: baseline;

				/* the first fieldset is keyboard of search-dropdown, which is the longest one */
				/* & > fieldset:first-of-type{
					grid-row: span 4; 
					margin-bottom: 0px;
				} */
			}
		}
	</style>

	<!-- Tabs - group -->
	<style>
		/* Adpat from https://codepen.io/hluebbering/pen/PoaWLrw and https://jsbin.com/rebini/3/edit?css,output */
		.tabs-group {
			display: flex;
			flex-wrap: wrap;
			margin: 0px auto;
			width: 100%;

			/* Setting for tab headers */
			&>label {
				--active-tab-header-text-color: #222;
				--inactive-tab-header-text-color: #fff;
				--active-tab-header-bg-color: #93cef8; 
				--inactive-tab-header-bg-color: #699879;
				/* --active-tab-header-bg-color: #ccc;
				--inactive-tab-header-bg-color: #666; */

				--tab-header-border-color: #fff; /* #ebffd4 */
				--tab-header-border-width: 1px;

				/* the width and the skew degreen of pseudo ::after, ::before of this label element to make the curved -overlapping at left+right of tab header */
				--padd-width: .7em; /* changing this width to modify total tab header width */
				--pad-skew: 13deg;

				background: var(--inactive-tab-header-bg-color);
				color: var(--inactive-tab-header-text-color);				
				cursor: pointer;
				display:inline-block;
				position:relative;
				order: initial;

				margin:0 .3rem 0 calc(-4px + var(--padd-width));
				/* padding-right must be large enough so the ::after pseudo not overlap the header content (which is svg icon) */
				padding: .5rem calc(2px + var(--padd-width)/2) .1rem;
				
				border-radius:0.5rem 0.5rem 0 0; /* just to smooth the top edges */
				/* border-top: var(--tab-header-border-width) solid var(--tab-header-border-color); */

				&:first-of-type{
					/* first tab header need to align with left side of tab content */
					margin-left: calc(-1px + var(--padd-width)); /* 1px is tab content border width */
				}

				/* ::before and ::after make left/right curver borders */
				&::before, &::after{
					content:" ";
					position: absolute;
					top:0;
					bottom: 0; /* use this instead of height: 100%; */
					width: var(--padd-width);					
					background-color: inherit; 
					/* border-top: var(--tab-header-border-width) solid var(--tab-header-border-color); */
					z-index: -1; /* so that the curved side is below the tab header's svg icon */
				}
				&::before{
					border-radius: calc(2px + var(--padd-width)/2) 0 0 0;
					transform: skew(calc(0deg - var(--pad-skew)));
					border-left: var(--tab-header-border-width) solid var(--tab-header-border-color);
					left: calc(-2px - var(--padd-width)/2); /* give the LI border ~2px extrusion */
				}
				&::after{
					border-radius: 0 calc(2px + var(--padd-width)/2) 0 0;
					transform: skew(var(--pad-skew));
					right: calc(-2px - var(--padd-width)/2); /* give the LI border ~2px extrusion */
					border-right: var(--tab-header-border-width) solid var(--tab-header-border-color);
					z-index: 1; /* overlap next tab header element. Remove this, the overlap will be at the ::before */
				}

				/* Content of the label */
				& > code {
					position:relative;
					z-index:2; /* to make the svg icon above the label's pseudo :before and :after */

					& > svg{
						/* somehow, with the size of .8em or 1.1em, the svg is not cropped, but with the size of .9em or 1em, it is */
						font-size: 1.1em !important;
					}
				}

				/* speciffically customize to make the icnSvgKeyboard looks more vertically middle */
				&:has(use[href="#icnSvgKeyboard"]){
					padding-top: .35em;
				}
			}

			&>.tab-content {
				max-height: calc(100dvh - 60px);
				background: var(--active-tab-header-bg-color);
				display: none;
				flex-flow: column nowrap;
				flex-grow: 1;
				padding: 5px;
				width: 100%;

				/* so that all tab content elements is after all tab headers */
				order: 99;

				border: 1px solid #666;
				border-radius: 0px 10px 10px;
			}

			&>input[type="radio"] {
				display: none;
			}
		}

		/* a bit of fun, change the background color of tab header based on the book group ways */
		body:has(#selBookGroup > option:nth-of-type(2):checked) .tabs-group > label{
			--active-tab-header-bg-color: #c9c5f2; 
			--inactive-tab-header-bg-color: #945396;
		}		
		body:has(#selBookGroup > option:nth-of-type(3):checked) .tabs-group > label{
			--active-tab-header-bg-color: #ccc;
			--inactive-tab-header-bg-color: #666;
		}

		/* Setting tab header for active tab */
		.tabs-group>input[type="radio"]:checked+label {
			background: var(--active-tab-header-bg-color);
			color: var(--active-tab-header-text-color);

			/* overlap prev tab header element */
			&::before{ z-index: 1; }
			/* overlap next tab header */
			/* &::after{ z-index: 1; } */

			&+.tab-content {
				display: flex;
				flex-flow: column;
			}
		}

		/* @media (min-width: 10em) {
			.tabs-group>.tab-content {
				order: 99;
			}

			.tabs-group>label {
				order: 1;
				margin-right: 0.3rem;
				margin-top: 0;
				width: auto;
			}
		} */
	</style>
	
	<!-- CSS FOR LOADING PAGE -->
	<style>
		/* Adapt from https://css-loaders.com/, especially from 'The filling', 'The Continuous' category */
		#loadingPageWrapper {
			position: fixed;
			top: 0px;
			left: 0px;
			width: 100vw;
			height: 100vh;
			background: white;
			z-index: 15;
			opacity: 1;
			/* make fading-out effect when remove splash screen */
			transition: opacity .5s linear;

			&>div {
				/* height: 20px; */
				width: fit-content;
				position: absolute;
				top: 30%;
				/* top: 0;
				bottom: 0; */
				left: 0;
				right: 0;
				margin: 0px auto;
			}
		}

		/* The bar with a shuttle keep moving back&ford */
		.loader-bar-nonstop{
			width: 100%;
			height: 1.5rem;
			border-radius: 2rem;
			color: #514b82;
			border: .15rem solid;
			position: relative;
			overflow: hidden;
			
			&::before {
				content: "";
				position: absolute;
				margin: 2px;
				width: 14px;
				top: 0;
				bottom: 0;
				left: -20px;
				border-radius: inherit;
				background: currentColor;
				box-shadow: -10px 0 12px 3px currentColor;
				clip-path: polygon(0 5%, 100% 0,100% 100%,0 95%,-30px 50%);
				animation: l14 1s infinite linear;
			}
		}
		@keyframes l14 {
			0% {color: #514b82;}
			20% {color: #ef5d74;}
			40% {color: #f9a74b;}
			60% {color: #60beeb;}
			80% {color: #fbef5a;}
			100% {left: calc(100% + 20px);color: #514b82;}
		}

		/* The Loadin text with waves insides */
		.loading-text-loader {
			width: fit-content;
			font-size: 3em;
			line-height: 1.5;
			/* margin-top: -.3em; */
			/* font-family: system-ui,sans-serif; */
			font-weight: bold;
			/* text-transform: uppercase; */
			color: #0000;
			--wave-color: #008000aa;
			-webkit-text-stroke: 1px #000;
			-webkit-text-stroke-color: var(--select-book-group-color, #000);
			
			background:
				radial-gradient(1.13em at 50% 1.6em, var(--wave-color) 99%,#0000 101%) calc(50% - 1.6em) 0/3.2em 100% text,
				radial-gradient(1.13em at 50% -0.8em,#0000 99%, var(--wave-color) 101%) 50% .8em/3.2em 100% repeat-x  text;
			animation: l9 2s linear infinite;

			&::before {
				content: "Loading";
			}
		}		
		@keyframes l9 {
			to {background-position: calc(50% + 1.6em) 0,calc(50% + 3.2em) .8em}
		}
		
		.loading-text-splash-screen{
			font-size: 3.5em;
			/* text-transform: uppercase; */
			--wave-color: #000b;
			margin-top: -.25em;
			animation: l9 2s linear infinite, l10 2s linear alternate infinite;
		}
		@keyframes l10 {
			0% {-webkit-text-stroke-color: #514b82;}
			20% {-webkit-text-stroke-color: #ef5d74;}
			40% {-webkit-text-stroke-color: #f9a74b;}
			60% {-webkit-text-stroke-color: #60beeb;}
			80% {-webkit-text-stroke-color: #fbef5a;}
			100% {-webkit-text-strokecolor: #514b82;}
		}	

		.circus-background {
			/* Adapt from https://codepen.io/t_afif/pen/bGKKaPq https://freefrontend.com/css-background-patterns/*/
			--__s: 30px;
			--__c: #e2c9b921;
			--_l: #0000 46%, var(--__c) 47% 53%, #0000 54%;
			background: radial-gradient(100% 100% at 100% 100%, var(--_l)) var(--__s) var(--__s), radial-gradient(100% 100% at 0 0, var(--_l)) var(--__s) var(--__s), radial-gradient(100% 100%, #0000 22%, var(--__c) 23% 29%, #0000 30% 34%, var(--__c) 35% 41%, #0000 42%) transparent;
			background-size: calc(var(--__s)* 2) calc(var(--__s)* 2);
			/* background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 304 304' width='304' height='304'%3E%3Cpath fill='%239C92AC' fill-opacity='0.1' d='M44.1 224a5 5 0 1 1 0 2H0v-2h44.1zm160 48a5 5 0 1 1 0 2H82v-2h122.1zm57.8-46a5 5 0 1 1 0-2H304v2h-42.1zm0 16a5 5 0 1 1 0-2H304v2h-42.1zm6.2-114a5 5 0 1 1 0 2h-86.2a5 5 0 1 1 0-2h86.2zm-256-48a5 5 0 1 1 0 2H0v-2h12.1zm185.8 34a5 5 0 1 1 0-2h86.2a5 5 0 1 1 0 2h-86.2zM258 12.1a5 5 0 1 1-2 0V0h2v12.1zm-64 208a5 5 0 1 1-2 0v-54.2a5 5 0 1 1 2 0v54.2zm48-198.2V80h62v2h-64V21.9a5 5 0 1 1 2 0zm16 16V64h46v2h-48V37.9a5 5 0 1 1 2 0zm-128 96V208h16v12.1a5 5 0 1 1-2 0V210h-16v-76.1a5 5 0 1 1 2 0zm-5.9-21.9a5 5 0 1 1 0 2H114v48H85.9a5 5 0 1 1 0-2H112v-48h12.1zm-6.2 130a5 5 0 1 1 0-2H176v-74.1a5 5 0 1 1 2 0V242h-60.1zm-16-64a5 5 0 1 1 0-2H114v48h10.1a5 5 0 1 1 0 2H112v-48h-10.1zM66 284.1a5 5 0 1 1-2 0V274H50v30h-2v-32h18v12.1zM236.1 176a5 5 0 1 1 0 2H226v94h48v32h-2v-30h-48v-98h12.1zm25.8-30a5 5 0 1 1 0-2H274v44.1a5 5 0 1 1-2 0V146h-10.1zm-64 96a5 5 0 1 1 0-2H208v-80h16v-14h-42.1a5 5 0 1 1 0-2H226v18h-16v80h-12.1zm86.2-210a5 5 0 1 1 0 2H272V0h2v32h10.1zM98 101.9V146H53.9a5 5 0 1 1 0-2H96v-42.1a5 5 0 1 1 2 0zM53.9 34a5 5 0 1 1 0-2H80V0h2v34H53.9zm60.1 3.9V66H82v64H69.9a5 5 0 1 1 0-2H80V64h32V37.9a5 5 0 1 1 2 0zM101.9 82a5 5 0 1 1 0-2H128V37.9a5 5 0 1 1 2 0V82h-28.1zm16-64a5 5 0 1 1 0-2H146v44.1a5 5 0 1 1-2 0V18h-26.1zm102.2 270a5 5 0 1 1 0 2H98v14h-2v-16h124.1zM242 149.9V160h16v34h-16v62h48v48h-2v-46h-48v-66h16v-30h-16v-12.1a5 5 0 1 1 2 0zM53.9 18a5 5 0 1 1 0-2H64V2H48V0h18v18H53.9zm112 32a5 5 0 1 1 0-2H192V0h50v2h-48v48h-28.1zm-48-48a5 5 0 0 1-9.8-2h2.07a3 3 0 1 0 5.66 0H178v34h-18V21.9a5 5 0 1 1 2 0V32h14V2h-58.1zm0 96a5 5 0 1 1 0-2H137l32-32h39V21.9a5 5 0 1 1 2 0V66h-40.17l-32 32H117.9zm28.1 90.1a5 5 0 1 1-2 0v-76.51L175.59 80H224V21.9a5 5 0 1 1 2 0V82h-49.59L146 112.41v75.69zm16 32a5 5 0 1 1-2 0v-99.51L184.59 96H300.1a5 5 0 0 1 3.9-3.9v2.07a3 3 0 0 0 0 5.66v2.07a5 5 0 0 1-3.9-3.9H185.41L162 121.41v98.69zm-144-64a5 5 0 1 1-2 0v-3.51l48-48V48h32V0h2v50H66v55.41l-48 48v2.69zM50 53.9v43.51l-48 48V208h26.1a5 5 0 1 1 0 2H0v-65.41l48-48V53.9a5 5 0 1 1 2 0zm-16 16V89.41l-34 34v-2.82l32-32V69.9a5 5 0 1 1 2 0zM12.1 32a5 5 0 1 1 0 2H9.41L0 43.41V40.6L8.59 32h3.51zm265.8 18a5 5 0 1 1 0-2h18.69l7.41-7.41v2.82L297.41 50H277.9zm-16 160a5 5 0 1 1 0-2H288v-71.41l16-16v2.82l-14 14V210h-28.1zm-208 32a5 5 0 1 1 0-2H64v-22.59L40.59 194H21.9a5 5 0 1 1 0-2H41.41L66 216.59V242H53.9zm150.2 14a5 5 0 1 1 0 2H96v-56.6L56.6 162H37.9a5 5 0 1 1 0-2h19.5L98 200.6V256h106.1zm-150.2 2a5 5 0 1 1 0-2H80v-46.59L48.59 178H21.9a5 5 0 1 1 0-2H49.41L82 208.59V258H53.9zM34 39.8v1.61L9.41 66H0v-2h8.59L32 40.59V0h2v39.8zM2 300.1a5 5 0 0 1 3.9 3.9H3.83A3 3 0 0 0 0 302.17V256h18v48h-2v-46H2v42.1zM34 241v63h-2v-62H0v-2h34v1zM17 18H0v-2h16V0h2v18h-1zm273-2h14v2h-16V0h2v16zm-32 273v15h-2v-14h-14v14h-2v-16h18v1zM0 92.1A5.02 5.02 0 0 1 6 97a5 5 0 0 1-6 4.9v-2.07a3 3 0 1 0 0-5.66V92.1zM80 272h2v32h-2v-32zm37.9 32h-2.07a3 3 0 0 0-5.66 0h-2.07a5 5 0 0 1 9.8 0zM5.9 0A5.02 5.02 0 0 1 0 5.9V3.83A3 3 0 0 0 3.83 0H5.9zm294.2 0h2.07A3 3 0 0 0 304 3.83V5.9a5 5 0 0 1-3.9-5.9zm3.9 300.1v2.07a3 3 0 0 0-1.83 1.83h-2.07a5 5 0 0 1 3.9-3.9zM97 100a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-48 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 96a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-144a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM49 36a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM33 68a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 240a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm80-176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm112 176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 180a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 84a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6z'%3E%3C/path%3E%3C/svg%3E"); */
		}

		/* Adapt from https://css-pattern.com/ */
		.radial-background {
			/* https://codepen.io/t_afif/pen/YzaoqVV */
			/* --__s: 30px; 
			--__c: #cbb37d26;
			
			--_g: #0000 83%, var(--__c) 85% 99%,#0000 101%;
			background:
				radial-gradient(27% 29% at right ,var(--_g)) calc(var(--__s)/ 2) var(--__s),
				radial-gradient(27% 29% at left  ,var(--_g)) calc(var(--__s)/-2) var(--__s),
				radial-gradient(29% 27% at top   ,var(--_g)) 0 calc(var(--__s)/ 2),
				radial-gradient(29% 27% at bottom,var(--_g)) 0 calc(var(--__s)/-2)
				transparent;
			background-size: calc(2*var(--__s)) calc(2*var(--__s)); */

			/* --__s: 65px;
			--__c: #ecd0783d;
			--c2: #fff;
			
			--l1:#0000  48%,var(--__c) 0 52%,#0000 0;
			--l2:#0000 1.3%,var(--c2) 0 32%,#0000 0;
			background:
				linear-gradient(-45deg,var(--l2)),
				linear-gradient( 45deg,var(--l1)),
				linear-gradient( 45deg,var(--l2)) calc(var(--__s)/2) calc(var(--__s)/2),
				linear-gradient(-45deg,var(--l1)) var(--c2);
			background-size: calc(2*var(--__s)) var(--__s),var(--__s) var(--__s); */

			/* --__s: 50px;
			--__c: #b2cdd952;
			--c2: #fff;
			
			--_g: calc(2*var(--__s)) calc(2*var(--__s)) 
				radial-gradient(25% 25%,var(--__c) 99%,#0000 101%);
			background:
				0 var(--__s)/var(--_g),var(--__s) 0/var(--_g),
				radial-gradient(50% 50%,var(--c2) 97%,#0000)
				calc(var(--__s)/2) calc(var(--__s)/2)/var(--__s) var(--__s),
				linear-gradient(90deg,var(--__c) 50%,var(--c2) 0) 
				0 0/calc(2*var(--__s)); */

			--__s: 80px; /* control the size*/
			--c1: #fff;
			--__c: #f8994f20; /* #bfb35a33; */

			--_s: calc(2*var(--__s)) calc(2*var(--__s));
			--_g: 35.36% 35.36% at;
			--_c: #0000 66%,var(--__c) 68% 70%,#0000 72%;
			background:
				radial-gradient(var(--_g) 100% 25%,var(--_c)) var(--__s) var(--__s)/var(--_s),
				radial-gradient(var(--_g) 0    75%,var(--_c)) var(--__s) var(--__s)/var(--_s),
				radial-gradient(var(--_g) 100% 25%,var(--_c)) 0 0/var(--_s),
				radial-gradient(var(--_g) 0    75%,var(--_c)) 0 0/var(--_s),
				repeating-conic-gradient(var(--c1) 0 25%,#0000 0 50%) 0 0/var(--_s),
				radial-gradient(var(--_c)) 0 calc(var(--__s)/2)/var(--__s) var(--__s)
				var(--c1);
		}

		/* targeting smart device, the background color need to be a little darker, so its alpha channel value need to be a little bit higher */
		@media (pointer: coarse) and (hover: none){
			.circus-background{ --__c: #e2c9b938; }
			.radial-background {--__c: #f2a06040;}
			.sdd-chapterList-background {--__c: #a7677820;}
		}
	</style>

	<!-- CSS FOR TOOL TIP -->
	<style>
		/* Default tooltip setting (also ) */
		[data-tooltip] {
			--arrow-size: 5px;
			position: relative;
			/* z-index: 10; */

			/* Disable context menu on long press on touch screen */
			-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
			user-select: none;
			-webkit-user-select: none;
			-webkit-touch-callout: none
		}

		/* Positioning and visibility settings of the tooltip */
		[data-tooltip]::before,
		[data-tooltip]::after {
			position: absolute;
			visibility: hidden;
			opacity: 0;
			left: 50%;
			bottom: calc(100% - 5px + var(--arrow-size));
			pointer-events: none;
			transition: 0.2s;
			/* will-change: transform; */
			z-index: 12;
		}

		/* The actual tooltip with a dynamic width */
		[data-tooltip]:before {
			content: attr(data-tooltip);
			padding: 10px 18px;
			box-sizing: border-box;
			min-width: 60px;
			max-width: min(500px, calc(100vw - 30px));
			width: max-content;
			width: -moz-max-content;
			border-radius: 6px;
			font-size: 14px;
			background-color: rgba(59, 72, 80, 0.9);
			background-image: linear-gradient(30deg,
					rgba(59, 72, 80, 0.44),
					rgba(59, 68, 75, 0.44),
					rgba(60, 82, 88, 0.44));
			box-shadow: 0px 0px 14px rgba(0, 0, 0, 0.6);
			color: #fff;
			text-align: center;
			white-space: pre-wrap;
			font-weight: 400;
			transform: translate(var(--data-translateX, -50%), calc(0px - var(--arrow-size))) scale(0.5);
		}

		/* Tooltip arrow */
		[data-tooltip]:after {
			content: '';
			border-style: solid;
			border-width: var(--arrow-size) var(--arrow-size) 0px var(--arrow-size);
			/* CSS triangle */
			border-color: rgba(55, 64, 70, 0.9) transparent transparent transparent;
			transition-duration: 0s;
			/* If the mouse leaves the element, 
								  the transition effects for the 
								  tooltip arrow are "turned off" */
			transform-origin: top;
			/* Orientation setting for the
								  slide-down effect */
			transform: translateX(-50%) scaleY(0);
		}

		/* Tooltip becomes visible at hover */
		[data-tooltip]:hover:before,
		[data-tooltip]:hover:after {
			visibility: visible;
			opacity: 1;
		}

		/* Scales from 0.5 to 1 -> grow effect */
		[data-tooltip]:hover:before {
			transition-delay: 0.3s;
			/* transform: translate(-50%, calc(0px - var(--arrow-size))) scale(1); */
			transform: translate(var(--data-translateX, -50%), calc(0px - var(--arrow-size))) scale(1);
		}

		/* 
	  Arrow slide down effect only on mouseenter (NOT on mouseleave)
	*/
		[data-tooltip]:hover:after {
			transition-delay: 0.5s;
			/* Starting after the grow effect */
			transition-duration: 0.2s;
			transform: translateX(-50%) scaleY(1);
		}

		/* That's it for the basic tooltip, which set for TOP tooltip. Below are customization for left, right, bottom tooltips */

		/* LEFT */
		/* Tooltip + arrow */
		[data-tooltip-location="left"]:before,
		[data-tooltip-location="left"]:after {
			left: auto;
			right: calc(100% - 5px + var(--arrow-size));
			bottom: 50%;
		}

		/* Tooltip */
		[data-tooltip-location="left"]:before {
			transform: translate(calc(0px - var(--arrow-size)), 50%) scale(0.5);
		}

		[data-tooltip-location="left"]:hover:before {
			transform: translate(calc(0px - var(--arrow-size)), var(--data-translateY, 50%)) scale(1);
		}

		/* Arrow */
		[data-tooltip-location="left"]:after {
			border-width: var(--arrow-size) 0px var(--arrow-size) var(--arrow-size);
			border-color: transparent transparent transparent rgba(55, 64, 70, 0.9);
			transform-origin: left;
			transform: translateY(50%) scaleX(0);
		}

		[data-tooltip-location="left"]:hover:after {
			transform: translateY(50%) scaleX(1);
		}

		/* RIGHT */
		[data-tooltip-location="right"]:before,
		[data-tooltip-location="right"]:after {
			left: calc(100% - 5px + var(--arrow-size));
			bottom: 50%;
		}

		[data-tooltip-location="right"]:before {
			transform: translate(var(--arrow-size), 50%) scale(0.5);
		}

		[data-tooltip-location="right"]:hover:before {
			transform: translate(var(--arrow-size), var(--data-translateY, 50%)) scale(1);
		}

		[data-tooltip-location="right"]:after {
			border-width: var(--arrow-size) var(--arrow-size) var(--arrow-size) 0px;
			border-color: transparent rgba(55, 64, 70, 0.9) transparent transparent;
			transform-origin: right;
			transform: translateY(50%) scaleX(0);
		}

		[data-tooltip-location="right"]:hover:after {
			transform: translateY(50%) scaleX(1);
		}

		/* BOTTOM */
		[data-tooltip-location="bottom"]:before,
		[data-tooltip-location="bottom"]:after {
			top: calc(100% - 5px + var(--arrow-size));
			bottom: auto;
		}

		[data-tooltip-location="bottom"]:before {
			transform: translate(var(--data-translateX, -50%), var(--arrow-size)) scale(0.5);
		}

		[data-tooltip-location="bottom"]:hover:before {
			/* If there is no --data-translateX, then it will be translate -50% */
			transform: translate(var(--data-translateX, -50%), var(--arrow-size)) scale(1);
		}

		[data-tooltip-location="bottom"]:after {
			border-width: 0px var(--arrow-size) var(--arrow-size) var(--arrow-size);
			border-color: transparent transparent rgba(55, 64, 70, 0.9) transparent;
			transform-origin: bottom;
		}

		/* Hack for chapter infor tooltip not to be clipped. Because #elmChapterInfor has class .detailContent (which contains max-height for detail/summary to expand/collapse animation), thus its has property display:block, so tooltip contained in ::before pseudo of its <code> descendant being clipped by boudingRect of #elmChapterInfor. Can change #elmChapterInfor display to 'inline' for tooltip to fully shows up, but #elmChapterInfor cannot be collapsed anymore. So, I do this hack using padding */
		div[name='divCtnTop']>div:has(> details[name='chapterInforDetails']:not(:has([open])) + div.ap-container) {
			/* details collapsed */
			margin-top: 5px;
			/* come back to normal margin */
		}

		div[name='divCtnTop']>div:has(> details[name='chapterInforDetails'][open]) {

			/* details expanded */
			&>.detailContent {
				padding-bottom: 60px;
				/* make room for bottom tooltip*/
			}

			&+div.ap-container {
				margin-top: -60px;
				/* compensate the room of its presibling .detailContent */
			}
		}

		/* End of tooltip hack */
	</style>

	<!-- CSS FOR TREE VIEW -->
	<style>
		/* original idea https://codepen.io/axelaredz/pen/WNzPxb */
		div#ListeningHistoryWrapper{
			width: 100%;
			padding-top: 0px;
			max-height: min(calc(100dvh - 70px), 780px) !important;
			overflow: hidden auto;
			text-align: left;
		}
		.treeview {
			/* set the padding-left of all nested ul. This in turn define the location of li content and position of tree lines */
			--ul-padding-left: 20px;
			/* the distance from tree vertical line (which drawed by li::before) to the label content */
			--vertical-lines-indent: calc(var(--ul-padding-left) / 2); /* 20px;  */
			/* the top of tree horizontal line (which drawed by li::after) connecting the vertical line to the border of label content. Note that in li.chapter_li, I set '--horizon-lines-top:50%' for chapter_li only */
			--horizon-lines-top: 25px;
			/* the padding left and right of the li, this need to be used to calculate the horizontal line's width so it match the border of label content. Note: if you change this value, the small triagle of book li (li.parent_li) might not be centered with tree-lines */
			--li-padd-left: 5px;
			/* the padding top of the li */
			--li-padd-top: 5px;
						
			min-height:20px;
			padding:3px;
			margin-bottom: 0px !important;
			border-radius:4px;
			/* box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.5); */
			
			& ul{
				/* set the padding-left of all nested ul (except the outermost ul), so the vertical tree lines would match everything else */
				padding-left: var(--ul-padding-left);
			}
			/* set different padding, margin for outer-most ul */
			& > ul{
				/* The following 2 properties is used to overwrite the default padding (which usually is 1em 1em 1em 2.5em) and margin of ul, which is very wide */
				padding: 0 5px 0px 0;
				margin: 0px;

				/* set color for the label of outer-most li */
				&>li>label {color: #000 !important}
				/*remove the tree lines (both vertical and horizontal) of outer-most li*/
				&>li::before, &>li::after {
					border:0
				}
			}
		}
		
		@media screen and (max-width: 500px) {
			.treeview {
				/* make tree lines shorter on small screen such as iPhone */
				--ul-padding-left: 14px;
			}
		}

		/* common setting for all tree li, mostly for drawing tree lines */
		.treeview li {
			list-style-type:none;
			margin:0;
			padding:var(--li-padd-top) 0 0 var(--li-padd-left);
			position:relative;

			&::before, &::after {
				content:'';
				left:calc(0px - var(--vertical-lines-indent));
				position:absolute;
				right:auto
			}
			/* vertical tree line */
			&::before {
				border-left:1px solid #999;
				height:100%;
				top:0;
				width:1px
			}
			/* has to fix the height of vertical tree line of last li so it make a L corner, not be crossed as + */
			&:last-child::before {
				height: var(--horizon-lines-top)
			}

			/* horizontal tree line which connect vertical tree line to the label content */
			&::after {
				border-top:1px solid #999;
				height:var(--vertical-lines-indent);
				top: var(--horizon-lines-top);
				width: calc(var(--li-padd-left) + var(--vertical-lines-indent))
			}

			/* because li might contain sub-folder ul (which in turn contain li), so we don't put text directly into li, instead, we put in label element */
			& > label {
				border:1px solid #666;
				border-radius:5px;
				display:inline-block;
				padding:3px 8px;
				text-decoration:none;
				font-size: .9em;

				/* these setting NOT for outer-most li>label (the label has attribute [for="outer_listening_history"]) */
				&:not(.treeview  > ul > li > label) > *{
					font-size: inherit;
					/* so that no children of label would take mouse event */
					pointer-events: none;
				}
				& [data-rAlignGroup]{
					display: inline-block;

					&[data-rAlignGroup='listenedTime']{
						/* right-align the dropoff time to make a better-readable visual */
						text-align: right;
					}
				}
			}
			
			/* set different color for title and svg icon */
			&:nth-of-type(odd) > label > :is(span.histTitle, svg.svg-img-infor) {
                color: #272782;
            }
			&:nth-of-type(even) > label > :is(span.histTitle, svg.svg-img-infor) {
                color: #9f5c28;
            }
			/* &:nth-of-type(odd) > label{
				&, & * {
					color: #272782;
				}
			}
			&:nth-of-type(even) > label{
				&, & * {
                color: #9f5c28;
				}
            } */
		}
		

		/* li that contains the uncompleted-listening chapters for a book */
		li.chapter_li{
			/* This line can be removed. Its purpose is to make tree horizontal line for chapter li to be at the middle of the li element (this works because children of .chapter_li does not increase the height of .chapter_li element). This can't be applied to .parent_li because middle of .parent_li is middle of itselft AND its content (which is ul with a bunch of .chapter_li elements) */
			--horizon-lines-top: 50%;

			cursor: pointer;
			/* so the width of li does not 100% even the content is much narrower */
			width: fit-content;

			/* header of li that contains the last listening chapters for a book */
			&.last-playing-chapter > label{
				border:1.5px solid var(--select-book-group-color) !important;
				background: linear-gradient(to left, #ddd, #fff0);
				/* border-right-width: 3px !important; */ /* make a mark on right-side to highlight this chapter is last-playing-chapter. The left-side already has a dot drawed by ::before pseudo element */
			}

			&:hover > label{
				background:#ddd;
				border:1px solid #94a0b4;
				color:#000;			
			}
		}

		/* The little red dot (with little rectangle) marking the last-listening-chapter and little dot on last-listening-book */
		li.chapter_li.last-playing-chapter > label::before, li.parent_li.last-playing-book > label::after {
			/* note that this dot-size affect the function Setting.addListeningHistory() on how identify clicking on li.parent_li>label ::before pseudo to remove a book out of history */
			--dot-size: 6px; /* size of the dot */
			content: "";
			display: block;
			position: absolute;
			top: calc(var(--horizon-lines-top) - var(--dot-size)/2);
			left: calc(6px - var(--dot-size)/2); /* I got 6px by experiment, I still not sure where it come from, but it works perfectly. It might be [label padding-right (8px) + label border width (2px)]/2 */
			width: var(--dot-size);
			height: var(--dot-size);
			border-radius: 50%; /* make the small dot */
			background-color: #f00;
			z-index: 1;
		}
		/* little rectangle at the tail of chapter li. Need to add {li.chapter_li.last-playing-chapter > label::after} to right above CSS  */
		/* li.chapter_li.last-playing-chapter > label::after{
			left: unset;
			right: calc(0.5px - var(--dot-size)/2);
			border-radius: 0;
			top: var(--horizon-lines-top);
		} */
		/* different color for the dot of book li */
		li.parent_li.last-playing-book > label::after{
			background-color: #80f;
		}

		/* li that contain information for a book, this li should contains ul>li for chapters */
		.treeview li.parent_li{
			/* this is used to seperate book to book a bit wilder than chapter to chapter */
			&:has(> ul):not(.treeview > ul > li.parent_li){
				padding-top: calc(1.5*var(--li-padd-top));
				padding-bottom: calc(1.5*var(--li-padd-top));
			}

			&.last-playing-book{
				& > label{
					border:2px solid var(--select-book-group-color) !important;
					background: linear-gradient(to right, #ff8a0033, #fff0);					
				}

				/* li that contain the last listening chapters of current played book */
				& li.last-playing-chapter > label{
					background: linear-gradient(to right, #9c27b033, #fff0) !important;
				}
			}

			& >input[type=checkbox] {
				display: none;		
			}
			& >input[type=checkbox] + label {
				cursor:pointer;

				/* when hover on parent li (one that has ul>li), change UI of all of its children li */
				&:hover, &:hover+ul li > label  {
					background-color:#eee9;
					border:1px solid #333; /* #94a0b4 */
					color:#333;
					/* & * {color:#000;} */
				}

				/* change the color and the width of tree-lines belong to this group */
				&:hover +ul li::before, &:hover +ul li::after{
						border-width: 1.5px;
						border-color: var(--select-book-group-color);
					}

				/* make small-turnable triangle for the label, but not for the outer-most li label */
				&:not([for="outer_listening_history"])::before {
					--triangle-height: 8px;
					--triangle-width: 5px;
					content: '';
					display: inline-block;
					width: 0;
					height: 0;
					border: 5px solid transparent;
					border-width:var(--triangle-height) var(--triangle-width);
					border-top-color: #00588b;
					/* these 7 css lines is to make ⏵ */
					/* margin-left: 4px; */

					/* The next 4 lines is to position the small triangle at the intersection of vertical&horizontal tree lines */
					position: absolute;
					left: calc(var(--triangle-width)/2 + 0.5px - var(--li-padd-left)/2 - var(--vertical-lines-indent)); /* 0.5px is half of tree-line width */
					top: calc(var(--horizon-lines-top) - var(--triangle-height));
					z-index: 1; /* so that the triangle above horizontal line drawed by li::after */

					transition: all .5s ease;
					transform-origin: 25% 50%;
					transform: translate(-5px, calc(50% - 2px));
				}
				/* an square at the intersection connecting the vertical tree-line and the outer-most li's label */
				/* &[for="outer_listening_history"]::after {
					--dot-size: 6px;
					content: "";
					display: block;
					position: absolute;
					/* bottom: calc(0px - var(--dot-size)/2); * /
					left: calc(1px + var(--vertical-lines-indent) + var(--li-padd-left) - var(--dot-size)/2);
					width: var(--dot-size);
					height: var(--dot-size);
					background-color: #a96004;
					z-index: 1;
				} */
				&:hover::before{
					border-top-color: #8d1db9 !important;
				}
			}
			
			/* transition for li>label, li>ul when collapsing/expanding */
			& >input[type=checkbox]:not(:checked) + label{
				/* border: 1.5px solid #ba2ef5; */
				border-left-width: 4px !important; /* make the mark so that user know that this book is collapsed */
				&::before {
					border-top-color: red;
					rotate: -90deg;
					transform: translate(-3px, 3px);
				}
			}
			/* :not(:checked) */
			& >input[type=checkbox] + label + ul{
					/* use max-height to animated the collapse effect. "height: 0" not work with css transitions */
					max-height: 0;
					/* hide the scroll-bar so that the content is hidden when set max-height to 0 */
					overflow: hidden;
					/* max-width: 0; */
					/* opacity: 0; */
					transition: max-height 1s ease;
				}
			& >input[type=checkbox]:checked + label + ul {
				max-height: 5000px; /* 100%; */
				/* max-width: 100%; */
				/* opacity: 1; */
				
			}			
		}
	</style>

	<!-- CSS FOR SEARCH DROPDOWN -->
	<style>
	div[name="sdd-BookTitlesDropdown-container"] { /* Books list container */
	   position: relative;
	   width: min(800px, 95vw);
	   margin: 5px auto;
	}

	div[name="sdd-ChaptersListDropdown-container"] { /* Chapters list container */
	   margin-bottom: 5px;
	}

	/* the root div of the sdd  */
	.sdd-wrapper {
	   --color-black: hsl(0, 0%, 10%);
	   --color-darks: hsl(0, 0%, 20%);
	   --color-darkgreys: hsl(0, 0%, 50%);
	   --color-greys: hsl(0, 0%, 80%);
	   --color-light: hsl(0, 0%, 96%);
	   --color-white: hsl(0, 0%, 100%);
	   --color-blues: hsl(217, 91%, 60%);
	   --color-dark-blues: hsl(217, 91%, 40%); /* #4679cd; */
	   --color-dark-light_yellow: rgba(255, 138, 0, 0.2);
	   --shadow-small: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
		  0 1px 2px 0 rgba(0, 0, 0, 0.06);
	   --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
		  0 2px 4px -1px rgba(0, 0, 0, 0.06);
	   --shadow-large: 7px 8px 15px -3px rgba(0, 0, 0, 0.4), 2px 7px 6px -2px rgba(0, 0, 0, 0.2);
	   --shadow-bottom: 0px 3px 3px 0px #1115;
	   /* -20px 18px 10px -15px #1113, 20px 18px 10px -15px #1113; */
	   
	   position: relative;
	   width: 100%;
	   max-width: min(800px, 100%, 95vw);
	   margin: 0px auto;

	   & * {
		  padding: 0;
		  margin: 0;
		  box-sizing: border-box;
		  text-align: left;
	   }

	   /* this em contain the order of the option and opt-group */
		& em.item-order{
			display: inline-block;
			text-align: right;
			font-style: normal;
			color: darkgoldenrod;
			font-size: .9em;
			margin-right: 3px;
			/* background-color: gainsboro;
			padding: 1px 2px;
			border-radius: .25em; */
		}

		/* This class store item de-emphasize infor */
		& .item-slight-details{
			font-size:.875rem;
			color: var(--select-book-group-color);
		}
	}

	/* the control that always display, even when dropdown closed */
	.sdd-wrapper .sdd-controls {
	   position: relative;
	   /* font-family: inherit;
	   font-size: 1rem;
	   font-weight: 400; */
	   line-height: 1.2;
	   cursor: pointer;
	   user-select: none;
	   width: 100%;
	   height: auto;
	   padding: 0.4rem .5rem;
	   padding-right: 1.7em; /* so the text not overlap the background sized 1.5em */
	   border: 2px solid var(--select-book-group-color);
	   outline: none;
	   border-radius: 0.4rem;
	   color: var(--color-black);
	   background-clip: padding-box;
	   /* background-color: var(--color-white); */
	   box-shadow: var(--shadow-medium);
	   transition: all 0.3s ease-in-out;

	   background-image: var(--book-micro-svg-bground);
	   background-position: right 0.25em center;
	   background-repeat: no-repeat;
	   background-size: 1.5em;

	   /* make this Div just one line, its content may be truncated */
	   &.single-line{
		  white-space: nowrap;
		  /* Prevents line breaks */
		  overflow: hidden;
		  /* Hides overflow content */
		  text-overflow: ellipsis;
		  /* Adds ellipsis (...) for overflow text */
	   }
	}

	.sdd-wrapper .sdd-dropdown-wrapper {
	   position: absolute;
	   /* max-height: 0px; */
	   /* opacity: 0; */
	   top: 100%;
	   left: 0;
	   width: 100%;
	   z-index: 20;
	   /* padding-bottom: 2px; */
	   border-radius: 0.25rem;
	   border: 2px solid var(--color-greys);
	   background-color: var(--color-white);
	   box-shadow: var(--shadow-large);
	   /* transition: opacity .6s ease-in-out; */
	}

	/* This div has single role to be the bottom border of SDD, with the purpose to separate SDD with other background elements. Especialy, for SDD chapter list to be seperated from backgroung ol#elmPlaylist */
	
	.sdd-wrapper .sdd-dropdown-border-bottom-stripes {
		height: 5px;
		--__c: var(--select-book-group-color);
		background: linear-gradient(-45deg, var(--__c) 60%, transparent 60%, transparent 75%, var(--__c) 75%) 0px 0px /40px 20px;
		animation: sdd-dbb-stripes 2s linear infinite;
	}
	@keyframes sdd-dbb-stripes {
		from {
			background-position: 40px 0;
		}
		to {
			background-position: 0 0;
		}
	}

	/* Customized class for chapter-list SDD. This class will apply for SDD outermost container .sdd-wrapper. If we need to change the css for any component inside .sdd-wrapper, we specify the query-selector path for that component and put css for that component inside that path */
	.sdd-wrapper.sdd-wrapper-chapterList{
		/* customize the sdd-dropdown-content background */
		& .sdd-dropdown-wrapper .sdd-dropdown-content {
			--__s: 240px;
			--__c: #a7677816; /* #f5b5f029 */
			--__c2: transparent;

			--_g: #0000 54%,var(--__c) 54% 57%,#0000 57%; 
			background: 
				radial-gradient(farthest-side at -33.33% 50%,var(--_g)) 0 calc(var(--__s)/2),
				radial-gradient(farthest-side at 50% 133.33%,var(--_g)) calc(var(--__s)/2) 0,
				radial-gradient(farthest-side at 133.33% 50%,var(--_g)),
				radial-gradient(farthest-side at 50% -33.33%,var(--_g)),
				var(--__c2);
			background-size: calc(var(--__s)/4.667) var(--__s),var(--__s) calc(var(--__s)/4.667);

			& .sdd-dropdown-item:nth-of-type(odd){
				color: #7d1f21;
			}
		}		

		/* & .sdd-dropdown-wrapper .sdd-dropdown-item.is-selected::before{
			border-color: #797979;
		} */

		/* & .sdd-dropdown-wrapper .sdd-dropdown-item.is-active.is-selected{
			background: linear-gradient(25deg, var(--sdd-dropdown-item-color-light) 0%, #ccca 70%, var(--color-dark-light_yellow) -10%);
		} */

		/* customize the animation for .sdd-dropdown-border-bottom */

		/* adapt from #4 of https://css-loaders.com/infinity/ */
		/* .sdd-wrapper .sdd-dropdown-border-bottom-arrows {
			height: 5px;
			--__c: var(--select-book-group-color) 0 15px, #0000 0 20px;
			background: repeating-linear-gradient(135deg, var(--__c)) left top, repeating-linear-gradient(45deg, var(--__c)) left bottom;
			background-size: 200% 50%;
			background-repeat: no-repeat;
			animation: sdd-dbb-arrows 35s infinite linear;
		}
		@keyframes sdd-dbb-arrows {
			100% {background-position:top right,bottom right}
		} */

		/* Adapt from #2 of https://css-loaders.com/factory/ */
		& .sdd-dropdown-wrapper .sdd-dropdown-border-bottom {
			--__c: var(--select-book-group-color); /* main color of the dots */
			--__h: 8px; /* height of the div and the dots */
			--__s: 25px; /* the size of the block that each contains one dot */
			--__cw: 65%; /* clip-width: which set the width of the left side which contains square dots */
			
			animation: none; /* reset animation in case other class having animation */
			height: var(--__h);
			box-shadow: 0 2px 0 var(--__c); /* draw the bottom/top border, change to negative to draw top border, change to 0px to remove the border */
			background: linear-gradient(#0fa8a8 0 0) var(--__cw) 100%/3px 100% no-repeat, var(--color-light); /* draw the cross-bar */
			display: grid;
			&::before,
			&::after{
				content: "";
				grid-area: 1/1;
				background: repeating-linear-gradient(90deg, var(--__c) 0 calc(1.5*var(--__h)),#0000 0 100%) 0 0/var(--__s) 100%;
				clip-path: inset(0 calc(100% - var(--__cw)) 0 0);
				animation: sdd-dbb-sc .8s infinite linear;
			}
			&::before{
				background: radial-gradient(circle calc(var(--__h)/2) at calc(var(--__h)/2) 50%, color-mix(in hsl, var(--__c) 40%, #d3cf00) 99%,#0000) 0 0/var(--__s) 100%;
				clip-path: inset(0 0 0 var(--__cw));
			}
		}
	}
	@keyframes sdd-dbb-sc {
		100% {background-position: var(--__s) 0}
	}
	
	@media (pointer:fine) and (hover:hover) {
		/* on desktop screen, make the dots size a bit smaller */
		.sdd-wrapper .sdd-dropdown-border-bottom-factory {
			--__h: 6px;
			--__s: 20px;
		}
	}

	/* wrapper for searchbox and functional buttons */
	.sdd-wrapper .input-wrapper {
		position: relative;
		display: block grid;
		/* 1st column set to minmax(0px, 1fr) instead of 1fr to avoid 2nd column to be blowed out of container. Learn from https://css-tricks.com/preventing-a-grid-blowout/ */
		grid-template-columns: minmax(0px, 1fr) minmax(1rem, max-content);
		background-color: var(--color-light);
		border: 1px solid grey;
		border-radius: 5px;

		/* bottom box shadow */
		box-shadow: var(--shadow-bottom);
		
		div.sdd-control-buttons{
			display: block grid;
			grid-auto-flow: column dense;
			place-items: center end;
			/* display: flex;
			align-items: center;
			justify-content: flex-end; */
			margin: auto 5px;
			
			& > button {
				width: 1.4em;
				height: 1.4em;
				margin-left: 3px;
				appearance: none;
				border: none;
				background-color: transparent;
				
				cursor: pointer;
				color: var(--select-book-group-color);

				&:hover {
					/* color: var(--color-blues) !important;
					background-color: var(--color-greys); */
					border-color: var(--color-blues) !important;
				}
				&:active, &:focus{
					color: var(--color-dark-blues) /* !important */;
					border: 1px solid var(--color-greys);
					outline: none !important;
					box-shadow: none;
				}
				& > svg {
					color: inherit;
					fill: currentColor;
				}

				&.close-open-extra-title-button[extra-title-toggle]{
					color: red;
				}
			}

			& > button.clear-input-button {
				display: none; /* only show when sdd-search-box is valid */
			}
			& > button.close-open-groups-button{
				display: none; /* only show when sdd has optGroup */
			}

			/* button to choose the option between exact search and search with removed diacritics*/
			& > button.search-diacritics-option-button{
		
				display: block grid; /* to center the svg icon insides */
				place-items: center;
				
				padding: .15em;
				border: 2px solid var(--select-book-group-color);
				border-radius: .2em;
				color: darkmagenta;
				background-color: bisque;
				&.search-diacritics-exactSearch{ /* Exact search mode */
					/* border-width: 1px;
					border-color: #999; */
					color: #333;/* var(--select-book-group-color); */
					border-color: #666;
					background-color: unset;
					& > svg{
						filter: blur(.7px) drop-shadow(-1px -1px 4px var(--select-book-group-color)); /* grayscale(1) */
					}
				}
			}
		}
	}

	/* close/open groups button only show it dropdown having optgroup */
	.sdd-wrapper:has(div.sdd-dropdown-wrapper > div.sdd-dropdown-content > div.optgroup) .close-open-groups-button{
		display: block;
	}

	/* Search box */
	.sdd-wrapper .input-wrapper .sdd-search-box {
	   display: block;
	   /* flex: 1 1 auto; */
	   /* width: 100%; */
	   height: auto;
	   line-height: 1.8;
	   font-family: inherit;
	   font-size: 1.1rem !important; /* avoid page zooming when textbox got focus in iOs */
	   font-weight: 400;
	   
	   padding: .2rem 0 .1rem .8rem;
	   /* border-radius: 5px; */
	   caret-color: #d53498; /* var(--select-book-group-color) */
	   border: none;
	   outline: none;
	   color: var(--color-black);
	   background-clip: padding-box;
	   background-color: transparent; /*  var(--color-white); */

	   &:invalid {
		  &+div.sdd-control-buttons > button.clear-input-button {
			display: none;
		  }
	   }

	   &:valid {
		  /* border: 1px solid grey; */
		  &+div.sdd-control-buttons > button.clear-input-button{
			display: block grid;
			align-items: center;
		  }

		  /* Can use following complex css so that button only appear when textbox got focus
		  :is(&:focus, &:hover)+div.sdd-control-buttons > button.clear-input-button,
		  &+div.sdd-control-buttons > button.clear-input-button:is(:hover,:focus) {
			display: inline-block;
			color: darkgreen;
		  } */
	   }
	   
	}

	/* dropdown menu */
	.sdd-wrapper .sdd-dropdown-content {
		max-height: 0rem;
		overflow: hidden scroll;
		transition: max-height .5s ease-in-out;
		/* transition-property: height,max-height; */
		/* position: relative; */ /* so that .sdd-dropdown-status-bar would take this as its offsetParent and being positioned relative to this */
		counter-reset: dropdownItemCounter;

		--sdd-dropdown-item-color-light: color-mix(in srgb, var(--select-book-group-color) , transparent 70%);
		--sdd-dropdown-item-color-extra-light: color-mix(in srgb, var(--select-book-group-color) , transparent 82%);
		/* --sdd-dropdown-item-color-dark: color-mix(in srgb, var(--select-book-group-color) 60%, #181818 40%);
		--sdd-dropdown-item-color-selected: color-mix(in srgb, var(--color-blues) , transparent 40%); */

		&::-webkit-scrollbar {
			width: 5px;
			height: auto;
		}

		&::-webkit-scrollbar-thumb {
			border-radius: 0.25rem;
			background-color: var(--color-blues);
			box-shadow: var(--shadow-small);
		}

		& > .sdd-dropdown-status-bar{
			position: absolute;
			z-index: 5;
			/* display: block; */
			visibility: visible;
			opacity: 1;
			top: 2.65rem;
			right: .1em;
			text-align: center;
			
			background-color: #000a;
			color: white;
			padding: .5em .8em;
			border: 1.5px solid #000;
			border-radius: .5em;
			transition: all .5s ease-in-out;
			&.statusbar-hidden{
				opacity: 0;
				/* display: none; */
				visibility: hidden;
			}
			& > mark{ /* the number of result found */
				color: var(--select-book-group-color);
				font-weight: bold;
				padding: 0px 4px 2px;
			 }
		}
	}

	/* if add .hideOptionExtraTitle to .sdd-wrapper element, all .item-2nd-main-div element inside each dropdown option will be hidden */
	.sdd-wrapper.hideOptionExtraTitle .sdd-dropdown-item > .item-2nd-main-div{
		display: none;
	}
	/* dropdown option */
	.sdd-dropdown-content .sdd-dropdown-item {
		position: relative;
		font-family: inherit;
		font-size: 1rem;
		font-weight: normal;
		line-height: inherit;
		cursor: pointer;
		user-select: none;
		padding: .4rem .25rem .4rem 1.25rem;
		color: #5b0a72; /* var(--color-blues) */
		background-color: transparent; /* var(--color-white); */
		/*transition: all 0.2s ease-in-out;*/
		
		&:nth-of-type(even) {
			color: var(--color-black);
			background: linear-gradient(to left, rgba(138, 138, 138, 0.2), transparent);
		}
		counter-increment: dropdownItemCounter;
		
		/* div element that contain extra information such as Author, MC */
		& > .item-2nd-main-div{
			margin-top: 2px;
			font-size: .85em;
			color: #555;

			& span{
				font-size: inherit;
			}

			/* class to force statistics text to be left-aligned even they mostly has data-rAlignGroup attributes which defaultly align right */
			& span.forceTextLeft{
				& > var{
					text-align: left !important;
				}
			}
		}

		/* class to set style for chapter's foreign title, if it has one */
		& > .englishTitle{
			text-align:right;
			padding-right:0.7em;
		}

		&::after{ /* small number at right end of the option */
			content: counter(dropdownItemCounter);
			font-size: .7em;
			position: absolute;
			top: calc(50% - .5em);
        	right: 3px;			
		}
		&:only-of-type:after{
			content: "";
		}

		&.disabled {
			pointer-events: none;
			cursor: default !important;
			background: unset;
			color: var(--color-darkgreys);
			& *{
				color: inherit;
			}
		}

		&:not(:last-child) {
			border-bottom: 1px solid #8080805e;
		}

		& span.highlight {
			background: rgba(255, 237, 40, .4);
			border-radius: 1px;
			text-decoration: underline;
		}

		&.is-active,
		&.is-active:hover {
			/* color: var(--color-white); */
			/* --s: 15px;
			clip-path: polygon(0 0, 100% 0,100% 100%, 0 100% ,var(--s) 50% ); */

			background: linear-gradient(-165deg, transparent,  transparent 30%, var(--color-dark-light_yellow)); /* var(--color-dark-blues); */
			/* &  *{
				color: inherit;
			} */
			/* &::after{
				color: initial;
			} */
		}

		&.is-selected,
		&.is-selected:hover {
			/* color: initial; var(--color-black); */
			--s: 15px; /* control the shape */
			clip-path: polygon(0 0,calc(100% - var(--s)) 0,100% 50%, calc(100% - var(--s)) 100%,0 100%); /* ,var(--s) 50% */
			padding-right: calc(var(--s) );
  
			background: linear-gradient(25deg, transparent 0%, #ccca 70%, var(--sdd-dropdown-item-color-light) -10%); /* var(--color-blues); */
			&::before{
				/* using tick character */
				/* content: "✔";
				color: var(--sdd-dropdown-item-color-light);
				position: absolute;
				top: calc(50% - .75em);
				left: .25em; */

				/* drawed by css */
				content: "";
				position: absolute;
				top: calc(50% - 9px);
				left: .35em;
				transform: rotate(30deg);
				--tick-size: 6.5px;
				--tick-decor: 3.5px solid var(--sdd-dropdown-item-color-light);
				height: calc(2*var(--tick-size));
				width: var(--tick-size);				
				border-bottom: var(--tick-decor);
				border-right: var(--tick-decor);        
			}
			/* &  *{
				color: inherit !important;
			} */
		}

		/* option that both selected and active would have a bit different decoration */
		&.is-active.is-selected{
			background: linear-gradient(25deg, var(--color-dark-light_yellow) 0%, #ccca 70%, var(--sdd-dropdown-item-color-light) -10%);
			/* linear-gradient(to right, var(--color-blues), transparent); */
		}

		/* [data-rAlignGroup] to mark that elements need to right-align from option to option */
		& [data-rAlignGroup]{
			display: inline-block; /* so width property could take effect */
			text-align: right;
		}

		/* Thesse two svg class is to color the svg */
		& svg{
			color:var(--select-book-group-color);
			/* &.MaleAuthor{
				color:#4520ad;
			}

			&.Microphone{
				color:#272782;
			} */
		}		
	}

	/* class for subTitle to be applied to chapter subtitle, which can be found in SDD items, SDD representative control (the one remains when SDD collapsed) and in elmPlaylist items */
	.subTitle{
		font-size: .85em !important;
		& > i{
			color: #008333;
			font-size: inherit;
		}
		/* & *{
			font-size: inherit;
		} */
	}

	/* for SDD items, make the subTitle balance so that it has small chance to overlap with the ordinal number (which on the far right) of the item */
	.sdd-dropdown-content .subTitle{
		display: inline-block;
    	text-wrap: balance;
	}

	.sdd-controls .subTitle{
		/* font-size: .8em !important; */
		color: var(--select-book-group-color);		
	}	

	/* sdd item hover only when container has .allow-hover-on-item class */
	.sdd-dropdown-content.allow-hover-on-item .sdd-dropdown-item:hover {
		color: var(--color-black);
		background: linear-gradient(45deg, var(--color-greys) 60%, transparent);
		transition: all 0.2s ease-in-out;
	}

	/* dropdown option group */
	.sdd-dropdown-content .optgroup {
		border: 1.5px solid #cfcdcf;
		border-radius: 5px 5px 0 0 ;
		margin-top: 5px;
		/* padding-bottom: 2px; */
		counter-reset: dropdownItemCounter;
				
		&>input[type=checkbox] {
			display: none;
		}

		& input[type=checkbox]+.optgroup-header {
			max-width: 100%;
			display: block;
			/* display: flex;
			flex-flow: row wrap;
			align-items: center; */
			font-size: 1rem;
			font-weight: bold;
			/*.875rem;*/
			line-height: 1.5;
			background: white;
			color: #595b5d;
			border-bottom: 2px solid #c1c1c1;
			border-top: 1.5px solid #837d7dc9;
			cursor: pointer;
			padding: 3px .75rem;
			border-radius: 4px 4px 0 0;
			background-image: repeating-linear-gradient(45deg, var(--sdd-dropdown-item-color-extra-light)  0 15px, #d9dbe999 0 30px); /* #cbcfe999 */
			/* linear-gradient(to right, #d2ceca88 0%, #FFFFFF99 51%, #d2ceca88 100%); */
			box-shadow: var(--shadow-bottom);

			&.disabled {
				pointer-events: none;
				cursor: default !important;
				/* background-image: unset; */
				color: var(--color-darkgreys);

				& *{
					color: inherit !important;
				}
			}

			&::before {
				content: '';
				display: inline-block;
				width: 0;
				height: 0;
				border: 5px solid transparent;
				border-width: 10px 5px;
				border-top-color: rgb(17, 4, 112);
				/* these 7 css lines is to make ? */
				margin-left: 4px;

				-webkit-transition: all .5s ease;
				-moz-transition: all .5s ease;
				-o-transition: all .5s ease;
				transition: all .5s ease;
				transform-origin: 25% 50%;
				transform: translate(-5px, 50%);
			}

			& .item-slight-details{
				font-size:.875rem;
				color: var(--select-book-group-color);
			}
		}

		&:has(:is(.is-active, .is-selected)) input[type=checkbox]+.optgroup-header{
			background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, transparent 90%), 
			repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
			/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
		}
		/* If on desktop, make the optGroup header look a litte more colorful */
		@media (hover: hover) and (pointer: fine) {
			&:has(.is-active) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, transparent 90%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}

			&:has(.is-selected) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--sdd-dropdown-item-color-light) 51%, transparent 90%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}
			&:has(.is-active.is-selected) input[type=checkbox]+.optgroup-header{
				background-image: linear-gradient(to right, transparent 10%, var(--color-dark-light_yellow) 51%, var(--sdd-dropdown-item-color-light) 80%, transparent 100%), 
				repeating-linear-gradient(-45deg,#fffc 0 20px,#f4f4f4cc 0 40px)
				/* repeating-linear-gradient(-45deg, #a5b1ff99, #a5b1ff99 10px, #dbddee99 20px, #dbddee99 30px) */
			}
		}

		& input[type=checkbox]:not(:checked)+.optgroup-header {
			&::before {
				rotate: -90deg;
				transform: translate(-60%, 4px);               
			}
			
		}

		& input[type=checkbox]+.optgroup-header+section {
			/* hide the scroll-bar so that the content is hidden when set max-height to 0 */
			overflow: hidden;

			/* max-width: 0;
			max-height: 0;
			opacity: 0;
			transition: all .5s ease; */
			
			/* use max-height to animated the collapse effect. "height: 0" not work with css transitions */
			max-height: 0;
			transition: max-height .5s ease;
		}

		& input[type=checkbox]:checked+.optgroup-header+section {
			max-height: 5000px;			
			/* max-height: 100%;
			max-width: 100%;
			opacity: 1; */
		}

	}

	/* no result notification */
	.sdd-dropdown-content .no_results{
		padding: .5em 0px;
		color: var(--select-book-group-color); /* --color-dark-blues */
		text-align: center;
	}
 	</style>
</head>

<body onload="loadPage();" class="niceScrollBar">
	<!-- PAGES WAITS FOR MAIN PAGE TO BE FULLY LOADED-->
	<div id="loadingPageWrapper">
		<div>
			<div class='loader-bar-nonstop'></div>
			<div class='loading-text-loader loading-text-splash-screen'></div>			
		</div>
	</div>
	<!-- HTML MODAL POPUP -->
	<div class="modalPopup" id="modalSettingPopup">
		<div class="modalPopupOverlay" onclick="ssData.setting.closeSettingModal()"></div>
		<div class="modalPopupContentWrapper circus-background" tabindex="0">
			<!-- <div class="modalHeader"> </div> -->

			<div class="modalPopupContent">
				<div class="closeModal" onclick="ssData.setting.closeSettingModal()"></div>
				<div class="tabs-group">
					<!-- Tabs group Book Kit/Set setting -->
					<input type="radio" name="tabs-component" id="radioTabBookSetting" checked="checked">
					<label for="radioTabBookSetting"><code data-tooltip="Thiết đặt Book Kits / Book Sets. Có thể:&#xa;– Ẩn/Hiện sách trong danh sách các tựa sách ở trang chủ.&#xa;– Kéo thả để đảo thứ tự các sách.&#xa;– Có thể thực hiện độc lập cho từng 'Kiểu phân nhóm'.&#xa;– Một số thông tin về Book Set (bộ sách), Book Kit (kho sách) xem trong tooltip của checkbox 'Book Set/Kit View'" data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgBookSets"/></svg></code></label>
					<div class="tab-content">
						<div class="flex-button-container bounding-box">
							<div class="control-button-flex" style="padding-top: 2px;"><label
									for="selPopupBookGroup">Kiểu phân nhóm: </label><select id="selPopupBookGroup"
									class="dropdown-book-spinner" title="Những cách nhóm thứ tự các truyện"></select>
							</div>

							<span class="control-button-flex">
								<input id="chkShowBookKit" type="checkbox" class="!text-[25px]" role="switch"
									title="Danh sách hiển thị phía dưới là Book Kit hay Book Set">
								<label for="chkShowBookKit" data-tooltip="set in openSettingModal()"
									data-tooltip-location="bottom"
									style="color: var(--select-book-group-color); --data-translateX: -75%">Book Set
									view</label>
							</span>
						</div>

						<div name="bookTitlesSettingWrapper">
							<div name="bookKitChkboxContainer" class="control-button-flex"></div>
							<ol id="lstBookTitlesSetting" class="lstBookTitlesSetting niceScrollBar"></ol>
						</div>
					</div>

					<!-- Tabs group for Listening History -->
					<input type="radio" name="tabs-component" id="radioTabListenHistory">
					<label for="radioTabListenHistory"><code data-tooltip="Lịch sử các cuốn sách đã nghe.&#xa;– Thông tin về các cuốn sách đã nghe (gần nhất ở trên), các chương đang nghe dở cũng thời gian.&#xa;– Bấm vào tam giác nhỏ ở điểm giao các dòng kẻ, bên trái mục thông tin sách để xóa cuốn sách đó khỏi lịch sử nghe sách.&#xa;– Có thể dùng nút lệnh để xóa toàn bộ thông tin lịch sử nghe sách." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgHistory"/></svg></code></label>
					<div class="tab-content">
						<div id="ListeningHistoryWrapper" class="treeview niceScrollBar bounding-box"></div>
						
						<div class="flex-button-container bounding-box">
							<span class="control-button-flex">
								<input id="chkShowHideAllHistChapDetails" type="checkbox" class="!text-[25px]"
									checked="" role="switch">
								<label for="chkShowHideAllHistChapDetails"></label>
							</span>

							<span class="control-button-flex">
								<button id="elmHistoryClear" 
									data-tooltip="Xóa toàn bộ Lịch sử nghe sách" data-tooltip-location="top">
									<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
										<use href="#icnSvgClearHistory" />
									</svg>
								</button>
								<label for="elmHistoryClear">Xóa lịch sử nghe sách</label>
							</span>
						</div>
					</div>

					<!-- Tabs group for buttons and UI setting -->
					<input type="radio" name="tabs-component" id="radioTabUIOthers">
					<label for="radioTabUIOthers"><code data-tooltip="Thiết đặt giao diện (GUI).&#xa;– Chủ yếu thiết đặt cho Toast.&#xa;– Thiết đặt cho thanh tiến trình (Circle Progress) trên nút Play, thanh Buffer Bar.&#xa;– Một số nút lệnh xóa dữ liệu trang Web lưu nhằm nâng cao trải nghiệm người dùng." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgGUI"/></svg></code></label>
					<div class="tab-content">
						<div class="flex-button-container bounding-box">
							<span class="control-button-flex">
								<input id="chkDisableCircleProgressButton" type="checkbox" class="!text-[30px]"
									checked="" role="switch"
									title="Ẩn/Hiện tiến trình phát hình tròn bao quanh nút Play/Pause">
								<label for="chkDisableCircleProgressButton"></label>
							</span>
							<span class="control-button-flex">
								<input id="chkHideBufferBar" type="checkbox" class="!text-[30px]" checked=""
									role="switch"
									title="Ẩn/Hiện thanh tiến trình dữ liệu audio đã được tải về máy (buffer)">
								<label for="chkHideBufferBar"></label>
							</span>
						</div>

						<div name="Toast-Setting" class="niceScrollBar bounding-box"></div>

						<div class="flex-button-container bounding-box">
							<!-- <span class="control-button-flex">
								<button id="elmHistoryClear"
									data-tooltip="Xóa toàn bộ Lịch sử nghe sách" data-tooltip-location="top">
									<svg class="!text-[25px] button-svg-img" focusable="false" aria-hidden="true">
										<use href="#icnSvgClearHistory" />
									</svg>
								</button>
								<label for="elmHistoryClear">Xóa lịch sử nghe sách</label>
							</span> -->
	
							<span class="control-button-flex">
								<button onclick="historyCls.wipeAll(0);"
								data-tooltip="Xóa toàn bộ lịch sử thông tin trang Web đã ghi nhận. Nạp lại trang Web" id="elmHistoryWipeAll">
									<svg class="!text-[25px] button-svg-img" focusable="false" aria-hidden="true">
										<use href="#icnSvgFullTrashBin" />
									</svg>
								</button>
								<label for="elmHistoryWipeAll"></label>
							</span>
						</div>
					</div>

					<!-- Tabs group Database files & variables setting -->
					<input type="radio" name="tabs-component" id="radioTabJsFileDataSetting">
					<label for="radioTabJsFileDataSetting"><code data-tooltip="Thiết đặt Database file.&#xa;– Xem thông tin về các Book Kit, các sách của mỗi Book Kit trong từng file Database.&#xa;– Lựa chọn Database file để hiện các sách trong phiên làm việc tới.&#xa;– Kéo thả để đảo thứ tự nạp các Database (do đó thứ tự sách bị đảo theo, dù các thứ tự này có thể thay đổi lại trong tab Book Setting)" data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgDatabaseConfig"/></svg></code></label>
					<div class="tab-content">
						<div name="jsFileDataSettingWrapper" style="flex-grow: 1;">
							<ol id="lstJsFileDataSetting" class="lstBookTitlesSetting niceScrollBar"></ol>
						</div>
						<fieldset>
							<legend>Thống kê</legend>
							<div name="DBStatistics"></div>
						
							<div class="flex-button-container">
								<span class="control-button-flex">
									<button onclick="ssData.setting.handyCheckDBsEdition(true);"
									data-tooltip="Kiểm tra để tìm xem có phiên bản (edition) mới các file dữ liệu (Database- DB). Nếu có phiên bản mới của một file dữ liệu, bạn có thể cần phải khởi động lại app để cập nhật dữ liệu mới nhật." id="elmCheckDBFilesUpdate">
										<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
											<use href="#icnSvgCheckDBsUpdate" />
										</svg>
									</button>
									<label for="elmCheckDBFilesUpdate"></label>
								</span>
								<span class="control-button-flex">
									<button onclick="historyCls.wipeAll(1);"
									data-tooltip="Xóa toàn bộ lịch sử thông tin trang Web đã ghi nhận ngoài cấu hình file database chọn ở bảng phía trên. Nạp lại trang Web" id="elmHistoryWipeAllButDataCfg">
										<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
											<use href="#icnSvgTrashBin" />
										</svg>
									</button>
									<label for="elmHistoryWipeAllButDataCfg"></label>
								</span>
							</div>
						</fieldset>
					</div>

					<!-- Tabs group HotKeys setting -->
					<input type="radio" name="tabs-component" id="radioTabHotKeysSetting">
					<label for="radioTabHotKeysSetting"><code data-tooltip="Xem thông tin phím tắt điều khiển trang Web, bao gồm:&#xa;– Phím tắt cho Danh mục sách/chương (Search-Dropdown)&#xa;– Phím tắt điều khiển player (Audio–Player).&#xa;– Phím tắt chung của trang chủ.&#xa;– Phím tắt trong cửa số cấu hình này." data-tooltip-location="bottom"><svg class="button-svg-img"><use href="#icnSvgKeyboard"/></svg></code></label>
					<div class="tab-content">
						<div name="hotkeysSettingWrapper" class="niceScrollBar">
							
						</div>
					</div>

				</div>
			</div>
		</div>
	</div>
	<!-- end of html modal popup -->

	<!-- MAIN PAGE -->
	<div name="divContainer">
		<!-- Top part of the page, containing book select element and chapter title, audio element -->
		<div name="divCtnTop">
			<audio id="elmMyAudio" autoplay controls src=""></audio>

			<div>
				<!-- Searched Dropdown list of Book titles (Book kits, Book sets, Books)  -->
				<div name="sdd-BookTitlesDropdown-container"></div>

				<div id="elmDivMcRadioCtn">
					<p id="elmInnerMcFlexCtn" class="flex-button-container"></p>
				</div>
			</div>

			<div>
				<details open name="chapterInforDetails">
					<summary><span id="elmChapterTitle"></span></summary>
				</details>
				<div id="elmChapterInfor" class="detailContent"></div>
			</div>

			<div class="ap-container">
				<div class="ap-panel">
					<div class="ap-sub-panel ap--playback" name="divCtnAudioControlBottom"> <!-- control-button-flex -->
						<button class="ap-controls ap-reload-btn"
							data-tooltip="Nạp lại link truyện" data-tooltip-location="bottom"
							style="--data-translateX:-15px">
							<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgReload" />
							</svg>
						</button>

						<button class="ap-controls ap-prev-btn" title="Nghe chương trước">
							<svg class="!text-[30px] rotate-180 button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgSkipNext" />
							</svg>
						</button>
						<button class="ap-controls ap-rewind-btn" onclick="xAudio.currentTime -= 10;"
							title="Lùi lại 10 giây">
							<svg class="!text-[20px] rotate-180 button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgFastForward" />
							</svg>
						</button>
						<button class="ap-controls ap-play-pause-btn" title="Phát/Dừng truyện">
							<svg class="!text-[40px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgPlay" svg-icon-name="PlayPauseIcon" />
							</svg>
						</button>

						<button class="ap-controls ap-fastforward-btn" onclick="xAudio.currentTime += 10;"
							title="Tiến lên 10 giây">
							<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgFastForward" />
							</svg>
						</button>
						<button class="ap-controls ap-next-btn" title="Nghe chương sau">
							<svg class="!text-[30px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgSkipNext" />
							</svg>
						</button>
					</div>

					<div class="ap-sub-panel ap--track">
						<div class="ap-info">
							<div class="ap-title-time">
								<div class="ap-title"></div>
								<div class="ap-time">
									<span class="ap-time--remains">0:00 / 0:00</span>
								</div>
							</div>
							<div class="ap-progress-container">
								<div class="ap-progress">
									<div class="ap-progress-bar" style="width: 10%;"></div>
									<div class="ap-progress-preload-bar" style="width: 100%;"></div>
								</div>
							</div>
							<!-- buffered bar -->
							<canvas class="ap-buffer-bar"></canvas>
						</div>
					</div>
					<div class="ap-sub-panel ap--settings">

						<!-- Speed select box with increase/decrease buttons -->
						<div class="ap-controls ap-volume-container">
							<button class="ap-controls ap-volume-btn">
								<svg class="!text-[15px] button-svg-img" focusable="false" aria-hidden="true">
									<use href="#icnSvgVolumeOn" class="ap--volume-on" />
									<use href="#icnSvgVolumeOff" class="ap--volume-off" />
								</svg>
							</button>
							<div class="ap-volume">
								<div class="ap-volume-progress">
									<div class="ap-volume-bar" style="height: 70px;"></div>
								</div>
							</div>
						</div>

						<div class="ap-controls ap-speed-container">
							<span class="ap-change-speed-buttons">
								<button class="ap-speed-decrease-speed" title="Giảm tốc độ phát">
									<svg class="!text-[15px] button-svg-img" focusable="false" aria-hidden="true">
										<use href="#icnSvgMinusSign" />
									</svg>
								</button>
								<button class="ap-speed-increase-speed" title="Tăng tốc độ phát">
									<svg class="!text-[15px] button-svg-img" focusable="false" aria-hidden="true">
										<use href="#icnSvgPlusSign" />
									</svg>
								</button>
							</span>
							<select class="ap-speed-option-select" title="Chọn tốc độ phát"></select>
						</div>

					</div>
				</div>
			</div>
		</div>

		<div class="flex-container">
			<div>
				<div id="elmPlayingTime"></div>
				<div name='HourglassSpining'>
					<svg class="!text-[30px] button-svg-img animate-spin" focusable="false" aria-hidden="true">
						<use href="#icnSvgHourGlass" />
					</svg>
					<span class="loading-text-loader"></span>
				</div>
			</div>

			<div name="divCtnAudioControl" class="flex-button-container">
				<div class="control-button-flex" name="divOtherControlTop">
					<!-- <button class="ap-reload-btn" title="Nạp lại link truyện" data-tooltip="Nạp lại link truyện" style="height:41px; --data-translateX: -15%">
				<svg class="!text-[20px] button-svg-img" focusable="false" aria-hidden="true">
					<use href="#icnSvgReload"/>
				</svg>
			</button> -->
					
					<button onclick="utilityHandles.gotoPlayingChapter();" title="Đến chương đang phát"
						data-tooltip="Đến chương đang phát">
						<svg class="!text-[20px] button-svg-img rotate-90" focusable="false" aria-hidden="true">
							<use href="#icnSvgJump2PlayingChap" />
						</svg>
					</button>
					
					<!-- Sleep Timer button -->
					<div class="havingShortPopup">
						<button onclick="utilityHandles.showSleepTimerPopup();"
							data-tooltip="Hẹn giờ tắt Audio (nút sẽ chuyển sang màu đỏ).&#xa– Nhập 0 hoặc để trắng: Tắt hẹn giờ (nút hẹn giờ chuyển về màu đen).&#xa– Nhập -1 để audio tự tắt khi phát hết chương sách hiện tại.">
							<svg class="!text-[28px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgSleepTimer" />
							</svg>
						</button>
						<!-- popup to type in time to stop playing -->
						<div id="sleepTimerDivPopup" class="shortPoup SleepTimer">
							<label for="ipSleepTimer"></label>
							<datalist id="sleepTimersDatalist"></datalist>
							<input id="ipSleepTimer" placeholder="Hẹn giờ tắt" maxlength="10" list="sleepTimersDatalist" />
							<span class="checkInputValidity"></span>

						</div>
					</div>

					<!-- Seeking/Jumping to a specific time button -->
					<div class="havingShortPopup">
						<button onclick="utilityHandles.showSeekAudioDurationPopup();"
							data-tooltip="Chọn thời gian nghe">
							<svg class="!text-[28px] button-svg-img" focusable="false" aria-hidden="true">
								<use href="#icnSvgRunJumping" />
							</svg>
						</button>
						<!-- popup to type in duration to jump to -->
						<div id="seekDurationDivPopup" class="shortPoup">
							<label for="ipAudioDuration"></label>
							<input id="ipAudioDuration" type="text" inputmode="text" maxlength="10" pattern=""
								placeholder="Nhập thời gian">
							<span class="checkInputValidity"></span>
						</div>
					</div>

					<select id="selBookGroup" title="Đổi cách nhóm thứ tự các truyện"></select>

				</div>

				<!-- History buttons -->
				<div class="control-button-flex" name="divHistoryControlTop">
					<button onclick="ssData.setting.openSettingModal();">
						<svg class="!text-[30px] button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgSetting" />
						</svg>
					</button>
					<button id="elmHistoryGoBackward" onclick="historyCls.historyGo(-1);"
						title="Lịch sử nghe: Sách ngay trước" data-tooltip-location="bottom">
						<svg class="!text-[30px] rotate-180 button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgHistoryForward" />
						</svg>
					</button>
					<button id="elmHistoryGoForward" onclick="historyCls.historyGo(1);"
						title="Lịch sử nghe: Sách tiếp theo" data-tooltip-location="bottom">
						<svg class="!text-[30px] button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgHistoryForward" />
						</svg>
					</button>
				</div>

				<!-- Chapter group buttons -->
				<div class="control-button-flex" name="divChapterGroupControls">
					<!-- <button onclick="utilityHandles.gotoPlayingChapter();" title="Đến chương đang chạy" data-tooltip="Đến chương đang chạy" data-tooltip-location="bottom" >
				<svg class="!text-[20px] button-svg-img rotate-90" focusable="false" aria-hidden="true">
				<use href="#icnSvgJump2PlayingChap"/>
			</svg>
			</button> -->
					<span><input id="allChapGrpChkbox" type="checkbox" checked class="!text-[25px]" role="switch"
							title="Đóng/mở tất cả các chapter group">&emsp13;
						<label for="allChapGrpChkbox" data-tooltip="Đóng/mở tất cả các chapter group"
							data-tooltip-location="bottom">Nhóm chương</label>
					</span>
				</div>
			</div>

		</div>

		<div name="divCtnMiddle" class="flex-container">
			<div>
				<!-- chapter/book workart -->
				<div><img id="elmArtwork" /></div>

				<!-- No-Internet SVG image -->
				<svg class="noInternetImg elm-hidden" focusable="false" aria-hidden="true">
					<use href="#svgIconNoInternetConnection" />
				</svg>
				
				
				<!-- Sleep-Timer count-down text -->
				<div class="control-button-flex elm-hidden">
					<svg class="!text-[25px] button-svg-img" focusable="false" aria-hidden="true">
						<use href="#icnSvgSleepTimer" />
					</svg>
					<span id="elmSleepTimerCountDown">00:00</span>
				</div>

				<!-- Book Total duration -->
				<div id="elmBookTotalDuration" xrole="containing-tooltip">
					<svg class="svg-img-infor" style="margin-right:4px;" focusable="false" aria-hidden="true">
						<use href="#icnSvgDuration" />
					</svg>
					<span data-tooltip="Tổng thời gian cả cuốn sách">00:00:00</span>
					<svg class="svg-img-infor" focusable="false" aria-hidden="true">
						<use href="#icnSvgListenTime" />
					</svg>
					<span data-tooltip="Thời gian thực tế nghe cả cuốn sách với tốc độ phát hiện tại"
						role="listeningTime">00:00:00</span>
				</div>

				<!-- Big audio Play/Pause and other control button -->
				<div class="control-button-flex" style="color: #29689e;" name="divCtnAudioControlExtraBig">
					</button>
					<button onclick="xAudio.currentTime -= 20;" class="ap-rewind-btn" title="Lùi lại 20 giây">
						<svg class="!text-[50px] rotate-180 button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>

					<button title="Phát/Dừng truyện">
						<svg class="!text-[80px] button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgPlay" svg-icon-name="PlayPauseIcon" />
						</svg>
					</button> <!-- icnSvgPlayProgress -->

					<button onclick="xAudio.currentTime += 20;" class="ap-fastforward-btn" title="Tiến lên 20 giây">
						<svg class="!text-[50px] button-svg-img" focusable="false" aria-hidden="true">
							<use href="#icnSvgFastForward" />
						</svg>
					</button>

				</div>
			</div>

			<div name="elmPlaylistCtn">
				<!-- Searched Dropdown list of chapters list -->
				<div name="sdd-ChaptersListDropdown-container"></div>

				<ol id="elmPlaylist" class="radial-background niceScrollBar"></ol>
			</div>
		</div>
		<div name="divCtnBottom">
			<!-- ontoggle run only one time -->
			<details
				ontoggle="if(this.open) setTimeout(_ => reposTooltips(document.getElementById('elmBookInfo')), 500); this.removeAttribute('ontoggle') ">
				<summary><span id="elmBookTitle"></span></summary>
			</details>
			<div id="elmBookInfo" class="detailContent"></div>
		</div>
	</div>

	<!-- <script src="config.js"></script>
	<script src="data.js?v=1.112"></script>
	 -->
	
	
	<!-- Script that deal with loading js script files that contains page configuration and database, then loadPage() -->
	<script>
	"use strict";
		/* Class deal with DB files being loaded as js script elements */
		class DBFiles{

			/** Enum to define the loadMode of script file, especially for DB file  */
			static LMODE = Object.freeze({
				/* @value 0: Database file would not be loaded */		
				noShow: 0,
				/* @value 1: Database file is freshly-loaded, meaning even the file has been loaded before and being stored in browser's cache, the cache will be ignore and the page will load file from server */
				freshLoad: 1,
				/* @value 2: Database file is cache-loaded. If the file has been cached by browser before, the page will use that cache version of file for better performance and save bandwidth */
				cacheLoad:2
				/* @value -1 : called from Setting.addJsDatabaseFileReport() to load information of a database that was not choosen for showing when page load (its loadMode in xDBFilesCfg == 0). This loadMode is treated as loadMode=2 */
				//,tempLoad: -1
				/* for some DB that currently has loadMode = noShow(0) but it has new edition, we temporarily change it loadMode to delayFresh(-2), so that when completing reload (fresh) new edition of that DB, we would know to change its loadMode back to noShow */
				//,delayFresh: -2
			});

			/** LoadJS: class to load multiple js libraries and return a promise or an array of promise
			* @adapt_from https://github.com/MiguelCastillo/load-js/tree/master. See that github for usage and options, although I has renamed some flag name to to descibe more correcly their functionality, also I added some new @atttributes to meet my needs for this app (see @CUSTOMIZED_PROPERTIES section below).
			See _DEFAULT_OPTIONS in exec() function for the default value for all flags

			* @ORIGINAL_PROPERTIES
				@property type: @defaults to 'text/javascript'.
				@property async: @defaults to false.
				@property charset: @defaults to utf-8.
				@property id: no default value. If id is not set, loadJs will hash the script url (without parameters - string after '?') and make it to be the script id
				@property url: Location of the script to load. Required if no text is provided.
				@property text: Script code to execute. Required if no url is provided.

				@flag cacheEnable {@defaults to true} (I rename from original name 'cache'): flag to determine if item with ID or URL is to be cached. if this flag set to false, its promise will not be update the the loadJs internal cache
				@flag allowExternal {@defaults to true}: flag to handle situations when the DOM already has a script element with the same ID or URL as what loadJS is being told to load. By default, loadJs will ignore the script with similar url (same without parameter) that not loaded by loadJs. If set to false, loadJS will use script elements that already exist in the DOM. To turn off this behavior, set allowExternal to false. 
				@flag debug {@defaults to false}: flag to show debug message.

			* @CUSTOMIZED_PROPERTIES 
				@flag allowReload {@defaults to false}: the flag to tell loadJs to overload the old js file (which also had been loaded by loadJs). I use for config.js to detect if there is new database version or on Setting.addJsDatabaseFileReport(). Let see a case when loadJS has loaded a js file, e.g 'data_0.js', now that file is loaded again (also by loadJS), if this flag is missing or false, we can't load again the same file. This is different from @property allowExternal is that  allowExternal compared with js script NOT loaded by loadJS (might be a markup that was hard-coded or dynamiclly loaded by other agency )
				@flag freshLoad {@defaults to false}: the flag to tell if the script should be fresh-load (=true) or got from cache (false or missing), if applicable. 
					@note that when freshLoad = true, @flag allowReload is also set to true. Also, there is a @property urlVersion is attached to script element which store the lastest version of script url, which can be used to update back in function which invoked loadJS
				@flag removeMarkup {@defaults to true}: the flag to tell if the script mark-up should be delete out of DOM or keep it in the DOM (false). Even of markup being removed out of DOM, its data still being kept in window variables, so we still being able to process script data

				@attribute extAttr {@defaults to empty json {} }. extAttr will keep all @properties that user want to attach to script element for later usage:
					@attribute fileNo: store the ordernal number of current database file, which act as an Id to identify a Database File
					@attribute jsDBName: name of database file, also the name of database variable inside that file (they must be the same). For now, each file should have only one data variable, such as data_0.js has only one const json-like object 'data_0'
					@attribute loadMode: the mode to load the Database file. See LMODE for detail information of each type of loadMode
						
					@note See createScript() for the handy, customized property that added to script element like id, jsDBName, loadMode, urlVersion, watermark, type, charset
			* @USAGE
					@way 1: loadJS("https://code.jquery.com/jquery-2.2.1.js")
					 .then(function() {});
					@way 2: loadJS(["https://code.jquery.com/jquery-2.2.1.js", "https://unpkg.com/react@15.3.1/dist/react.min.js"])
					 .then(function() {}); 
					@way 3: loadJS({
							url: "data_1.js?v=3333",
							freshLoad: true,
							extAttr: {
								fileNo: 1,
								jsDBName: 'data_1', 
								allowReload: true,
								loadMode: -1
							}
						})
						.then(_ => {})
						See Setting.addJsDatabaseFileReport() for one example of usage that customize for this App
					@way 4: loadJS([{
					 		url: "data_1.js?v=3333",
							removeMarkup: false,
							extAttr: {
								fileNo: 1,
								jsDBName: 'data_1', 
								allowReload: true,
								loadMode: -1
							}
						}, {
							async: true,
							url: "https://unpkg.com/react@15.3.1/dist/react.min.js"
						}])
						.then(_ => {})
					@otherway : can use loadJS to load script code instead of url as above ways
			* @RETURN
				 * if @items is one item, it will return the script element directly
				 * if @items is array of items, it will return the array of result json which has one of following formats:
				 * 	- success: {status: 'fulfilled', value: ...the script element...}
				 * 	- failed:  {status: 'rejected', reason: ...the script element...}
			*/
			static loadJS = (function createLoadJS() {
				var _loadJsInternalCache = {}; //store scrips promise that being loaded by Loadjs
				var head = document.getElementsByTagName("head")[0] || document.documentElement;
				const _WATERMARK = "Chinhvtr";

				/* HELPER FUNCTIONS */
				/** get script THAT NOT LOADED by LoadJS */
				/* function getScriptById(id) {
					var script = id && document.getElementById(id);

					if (script && script.watermark !== _WATERMARK) {
						console.warn("load-js: duplicate script with id:", id);
						return script;
					}
				}
				
				function getScriptByUrl(url) {
					var script = url && document.querySelector("script[src='" + url + "']");

					if (script && script.watermark !== _WATERMARK) {
						console.warn("load-js: duplicate script with url:", url);
						return script;
					}
				} */

				/** get script that NOT loaded by LoadJS 
				 * @param url {string}: the url or the id of scipt
				 * @param byUrlOrId {boolean}:
				 * 		@value true (default): search script by url without param (string after '?')
				 * 		@value false: search by id
				 * @return
				 * 	- the first found script element if found
				 * 	- null if not found
				*/
				function getExternalScript(url, byUrlOrId = true) {
					if(!url) return null;

					if(byUrlOrId) url = url.split("?")[0];
					const _queryStr = byUrlOrId? "script[src^='" + url + "']" : "script[id='" + url + "']";

					const _scripts = document.querySelectorAll(_queryStr);
					let _foundScript = null;

					_scripts.forEach(_script => {
						if (!_foundScript && _script.watermark !== _WATERMARK) {
							console.warn("loadJS: found external script (one that not loaded by loadJs) with " + (byUrlOrId?"url":"id") + ":", url);
							_foundScript =_script;
						}
					});

					return _foundScript;					
				}

				/** simple hash function to hash any string to 7-chars string, this used to create an (nearly) unique id for the script. For now, I use String.prototype.hashCode */
				/* function simpleHash(str) {
					let hash = 0
					for (let i = 0; i < str.length; i++) {
						hash = ((hash << 5) - hash + str.charCodeAt(i)) | 0
					}
					return (hash >>> 0).toString(36)
				} */

				/** append script text (set in options.text) in the case that options.url is missing. Because options.text contain the js code already, so script should be loaded immediately without any delay, meaning no need to handle the async state of the script 
				 * @param head: the document.head element
				 * @param script: the script element that created by createScript() but not yet append to the DOM
				*/
				function appendScriptByText(head, script) {
					head.appendChild(script);
					return Promise.resolve(script);
				}

				/** append script by url (speified in options.url), so we use Promise to handle async state of script load 
				 * @param head: the document.head element
				 * @param script: the script element that created by createScript() but not yet append to the DOM
				*/
				function appendScriptByUrl(head, script) {
					return new Promise(function(resolve, reject) {
					// Handle Script loading
					var done = false;

					// Attach handlers for all browsers.
					//
					// References:
					// http://stackoverflow.com/questions/4845762/onload-handler-for-script-tag-in-internet-explorer
					// http://stevesouders.com/efws/script-onload.php
					// https://www.html5rocks.com/en/tutorials/speed/script-loading/
					//
					script.onload = script.onreadystatechange = function() {
						if (!done && (!script.readyState || script.readyState === "loaded" || script.readyState === "complete")) {
						done = true;

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;
						resolve(script);
						}
					};

					script.onerror = reject;

					head.appendChild(script);
					});
				}

				/* IMPORTAN FUNCTIONS */

				/** function to create script and attached properties, attributes to script element for later processing when script file is loaded or failed-loading. Note that for now, the script has not been appended to the DOM
				 * @param option: json of all attributes that need to config the script element and some other atttribute added to elements for using later. See https://github.com/MiguelCastillo/load-js/tree/master for list of default attribute like type, async, charset, id, url, text, cache (I renamed to 'cacheEnable'), debug
				 * ADDED: jsDBName, loadMode, allowReload, urlVersion
				 * @return the script element
				 */
				function createScriptElem(options) {
					var script = document.createElement("script");
					/* some built-in attribute of a script element, see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script for the full list */
					script.charset = options.charset || "utf-8";
					script.type = options.type || "text/javascript";
					script.async = !!options.async; //default false
					//in exec() we already create an options.id if user not clearly specify it
					script.id = options.id; 
					//script.id = (options.id || options.url).split("?")[0]; //without param of url if there any

					/* customized attribute to meet user extra need */
					//attach all extra/extented attributes that user need to attach to script for later handy usage
					script.extAttr = options.extAttr || {};
					//attach a watermark to know that the script is loaded by loadJs or not
					script.watermark = _WATERMARK;
					//adding timestamp for ease of debugging when loadJS internal cache hit
					script.timestamp = (new Date()).toLocaleString();

					/* Using version paramet '?v={version_number}' to force the browser to re-load and script file (mostly through file url) */
					const _DEF_VERSION = Math.round(performance.now()); //101;
					let _dbUrl = options.url;
					const _versReg = _dbUrl.match(/v\=(\d+)/);
					if(_versReg){
						let _version = parseInt(_versReg[1]);
						if(isNaN(_version)) _version = _DEF_VERSION;
						// freshLoad = true, we need to re-load the script even there is old version in the cache. For the specific case of this page when loading DB stored in script file, we do fresh-load only when loadMode == 1 (and we need to specify freshLoad attribute when invoking loadJs). Other mode loadMode= -1 (called from addJsDatabaseFileReport()) or =2, using cache if applicable
						// We archive fresh-load by changing the version so the js file load will ignore browser's cache.
						if(options.freshLoad)  _dbUrl = _dbUrl.replace(_versReg[0], "v=" + (++_version));
					}
					else _dbUrl += (_dbUrl.indexOf("?")>-1? "": "?") + "v=" + _DEF_VERSION; //assign a initial version number
					
					//save new versionning into urlVersion of script element, so later in loadPage, we can update the new version into xDBFilesCfg.toLoad[index].dbUrl. Note that I don't want to use script.src since it is absolute address while script.urlVersion is relative address (shorter)
					script.urlVersion = options.url = _dbUrl;

					if (options.url) { script.src = options.url; }
					if (options.text) { script.text = options.text; }
					return script;
				}

				/** function to create script and append it to the DOM. Note that this function only support for one script only. This function also handle some situation like duplicate load by loadJs or duplicate with hard-coded markup.
				 * @param option: config for the single script to be load
				 * @return a promise wrapping the script
				 */
				function exec(options) {
					// if user only invokde loadJS with a string as parameter like loadJS('https://code.jquery.com/jquery-2.2.1.js'), consider as loading by url

					/* Create default value for options attributes when missing */
					if (typeof options === "string") {
						options = {
							url: options
						};
					}

					//default flags if not otherwise specify differently when invoking loadJS()
					const _DEFAULT_OPTIONS = {
						cacheEnable: true, //update script to the loadJs internal cache
						allowExternal: false, //ignore the external having same url script (after removing parameter if any), if any
						allowReload: false, //not allow reload if this script has been loaded before by loadJs
						freshLoad: false, //using the browser cache if any
						removeMarkup: true, //remove markkup out of DOM when done loading script
						debug: false
					}
					options = Object.assign({}, _DEFAULT_OPTIONS, options);

					// if freshload, meaning loading new version of the script without using browser caches or loadJS internal cache, so we must set allowReload = true
					if(options.freshLoad) options.allowReload = true;

					// if user not specify an id for script, we make one from its url without param
					let _scriptId = options.id || (options.url.split('?')[0]).hashCode(); // make an id from url if option.id is not explicitly specified
					options.id = _scriptId; //update back the maybe-new id to the option

					// cache here just to avoid same js files being loaded twice in the SAME session, with requirement both are loaded by loadJS
					let _cachedScriptEntry = _loadJsInternalCache[_scriptId]; //see if script already in loadJS cache

					if (_cachedScriptEntry) {
						if (!!options.debug) {
							console.warn("loadJS: Script hit - this script has been loaded by loadJS in current page session. id:", _scriptId, "; url:", options.url);
						}
						//if options.allowReload = true: return script Promise right away without reloading it
						if(!options.allowReload)
							return _cachedScriptEntry;
					}
					//check allowExternal only when no _cachedScriptEntry because when there is _cachedScriptEntry, allowExternal is checked when the first time this script is loaded by loadJS
					else if (options.allowExternal) {
						// not found script in the cache AND options.allowExternal = true or missing, we need to look in the DOM to see if there any script (of cource, not loaded by loadJS). In case found, use that script without having loadJs reloaded that script

						let el = getExternalScript(options.url) ;//getScriptById(options.id) || getScriptByUrl(options.url);

						// found an external script with similar url (but not loaded by loadJs)
						if (el) {
							// Promise.resolve(el) is the same with 'new Promise( (resolve, reject) => resolve(el) )'
							let promise = Promise.resolve(el);
							//store external script promise into cache
							if (_scriptId) { _loadJsInternalCache[_scriptId] = promise; }
							return promise;
						}
					}					

					if (!options.url && !options.text) {
						throw new Error("load-js: must provide a url or text to load");
					}

					// depding on the type of script (code or url), we need different function to append the script and handle async nature of the script to the DOM
					const _scriptElem = createScriptElem(options);
					var pendingPromise = (options.url ? appendScriptByUrl : appendScriptByText)(head, _scriptElem);

					//if options.removeMarkup is true of missing, remove the script markup in document.head, so if other inspect the code would not see the script had been loaded to the page which could cause confusing for them when inspecting the code.
					if(options.removeMarkup !== false)
						//finally is to do performing cleanup/finalizing after the previous operations are complete (doesn't matter successfull to failed).
						pendingPromise.finally(_ => {
							_scriptElem.remove();
						});

					//if cacheEnable is not explicitly set to false, save this script inside _loadJsInternalCache for later check of duplication
					if (_scriptId && options.cacheEnable !== false) { _loadJsInternalCache[_scriptId] = pendingPromise; }

					return pendingPromise;
				}

				/** load one script or array of script 
				 * @param items is one item or array of items. Each item can be a string which contains url of the script or a json. If item is an json, the json is actually the option which has attributes as described in wrapper loadJS comments above
				 * 
				 * @return
				 * if @items is one item, it will return the script element directly
				 * if @items is array of items, it will return the array of result json which has one of following formats:
				 * 		success: {status: 'fulfilled', value: ...the script element...}
				 * 		failed:  {status: 'rejected', reason: ...the script element...}
				 * See createScript() for the handy, customized property that added to script element like id, jsDBName, loadMode, urlVersion, watermark, type, charset
				*/
				return function load(items) {
					return items instanceof Array ? Promise.allSettled(items.map(exec)) : exec(items);
				}
			})();

			/** Function to deploy data inside DB js file into the page, that is to load the Book Kit variables inside each Database file named {_jsDBName} into a collection {ssData.jsDBFiles} along with database file _loadMode */
			static deployDB(_jsDBName, _loadMode) {
				const bookKitVars = []; //store the names of attributes (each actually is book Kit variable) of the current data variable (like data_0)
				this.name = _jsDBName; //store data variable names inside the variable content
				for (const key of Object.getOwnPropertyNames(this)) {
					//console.log(key);
					if (key.match(/\_Data$/) && (typeof this[key] == 'object')) {
						//console.log(key + ":" + (typeof this[key]));
						bookKitVars.push(key);
					}
				}

				// new item of ssData.jsDBFiles for _jsDBName
				const _newJsDBFile = { dbName: this.name, dbs : bookKitVars, loadMode: _loadMode};
				// find index of current item in ssData.jsDBFiles having dbName == _jsDBName
				const _jsDBFileIdx = ssData.jsDBFiles.findIndex(_dbFile => _dbFile.dbName == _jsDBName );

				if(_jsDBFileIdx == -1)
					// not found, just push it in
					ssData.jsDBFiles.push(_newJsDBFile);
				else
					//found, replace old item with new one
					ssData.jsDBFiles.splice(_jsDBFileIdx, 1, _newJsDBFile);
			}

			/** Compare {edt} attribute (edition) from xDBFilesCfg.toLoad[index].edt with _DEFAULT_CFG.cDBFilesEdt.edt[index] to see if there is later version of any of data_{index} DB files. If there is, UPDATE edt IMMEDIATELY.
			 * @param _ivkFrom: invoked from, mostly for controlling the message
			 * 		@value 0: invoked from loadPage()
			 * 		@value 1: invoked from Setting.handyCheckDBsEdition()
			 * 		@note: for now, this param is redundant and is not usable
			 * @return 
			 * 		@value null is there is no new update on any DB files
					@value an json: see the 'return' directive at the very end of function for detailed information
			*/
			static checkDBFilesEdition(_ivkFrom){
				const _DEF_DB_EDITION = 100; //initial edition of any DBFile
				
				//array store DB dbName (like 'data_0', 'data_1') that has new edition that is to be fresh load (load ignoring browser'cache).
				let _DBsHasNewEdition = [];
				
				//the counter to count the number of DBs that has NO edt attributes before. This only happen when there is no xDBFilesCfg in local storage (which only the case when the page is loaded very firs time OR local storage has been completely wiped-out)
				let _DBsLoadedVeryFirstTimeCounter = 0;

				xDBFilesCfg.toLoad.forEach((_dbItem, i) => {
					
					let _latestDbEdition = _DEF_DB_EDITION;
					//Check Edition of a DB files, if it is smaller than the lastest (in _DEFAULT_CFG.cDBFilesEdt.edt array)
					if(_DEFAULT_CFG?.cDBFilesEdt?.edt ?? false){
						_latestDbEdition = i < _DEFAULT_CFG.cDBFilesEdt.edt.length ? _DEFAULT_CFG.cDBFilesEdt.edt[i] :  _DEF_DB_EDITION;
					}

					//if current edition of inspected DBItem is not set yet (when page runs clean - meaning cache and localStore of last session is all wiped out) OR not the lastest (need update)
					if(!_dbItem.hasOwnProperty("edt") || _dbItem.edt <  _latestDbEdition) {
						//store DBs already cached but has later edition
						if(!_dbItem.hasOwnProperty("edt")) _DBsLoadedVeryFirstTimeCounter++;

						//Important: update the edition number IMMEDIATELY and DIRECTLY into xDBFilesCfg.toLoad[index].edt
						_dbItem.edt =  _latestDbEdition;

						//store dbName of DB having new edition
						_DBsHasNewEdition.push(_dbItem.dbName);
					}
				});				

				return _DBsHasNewEdition.length > 0 ? 
					{	// array contains dbName of all DB having new edition
						DBsHasNewEdition: _DBsHasNewEdition,
						// true if all DB having new edition is actually has no .edt before (meaning page is loaded very first time of just being fully wiped out all its localStorage)
						noDBsBefore: _DBsLoadedVeryFirstTimeCounter == _DBsHasNewEdition.length
					} : 
					//if there is no DBs having new edition, return null
					null;
			}

			/** Function to download and load-up all DB script file, update its version into xDBFilesCfg.toLoad[index].dbUrl. Doing some extra work by the callbacks _promiseCB, _allSettleCB
			 * @param _ivkFrom: invoked from, used for doing some extra work depending on where this function is invoked from, and for controlling the toast message
			 * 		@value 0: invoked from loadPage()
			 * 		@value 1: invoked from ssData.setting.handyCheckDBsEdition
			 * @param _promiseCB {function} the callback function when EACH script promise suceed
			 * @param _allSettleCB {function} the callback function when ALL scripts promise are settled (does not matter successfully or not)
			 * @return 
			 * 		@value array of dbName of all DBs having new edition
			*/
			static importDBfromFiles(_ivkFrom, _promiseCB, _allSettleCB){
				//make an alias for xDBFilesCfg.toLoad
				let toLoadArr = xDBFilesCfg.toLoad;

				//check if there is new DB files updated, mark those DBs has new edition or has no cache with loadMode = 1 (fresh Load) so that DBFiles.loadJS will do the rest to load latest version of those new DB files. Note that this function could override loadMode for some DB files on check failCount above
				// this array store list of DB files that has newer editions. If none has or fail to load 'config.js', it is null. See return in DBFiles.checkDBFilesEdition for the format of returned value
				let _newEditionDBs = DBFiles.checkDBFilesEdition(0);

				let _DBsHasNewEdition = [];
				//notify user about DBs having new edition
				if(_newEditionDBs){
					/** the function to create notification message to user of the detail of new DBs 
					 * @param _DBarray the array of DBs file_no that need to create message, such as [0, 1, 3]
					*/
					const _newDBNotifyMsg = (_DBarray) => {
						let _msg = '';
						if(_DBarray.length > 0)
							_msg = (_msg==''?'': '<br>') + `${_DBarray.length > 1?"Các ":""}CSDL ${ _DBarray.map(t => "<mark style='color:red;font-weight:bold'>"+t+"</mark>").join(", ") } có phiên bản mới`;
						return _msg;
					}

					let _msg = '';

					//empty function, this function is used as toast callback when user manually check new edition (when page is running), then it found a shown DB (loadMode = 1,2) having new edition, so when the toast is timed-out, this callback will be invoked to ask user to refesh the page to get new DB updated
					let _toastCallback = _ => {};

					//get the list of all DBs having new edition
					_DBsHasNewEdition = _newEditionDBs.DBsHasNewEdition;

					//_newEditionDBs.noDBsBefore = true when all DBs (in xDBFilesCfg.toLoad) load into page not yet has 'edt' attribute, meaning this might be the very first time page is loaded or xState was completely wiped-out
					if(_newEditionDBs.noDBsBefore){
						if(_ivkFrom==0 )
						_msg = 'Sử dụng app lần đầu tiên hoặc dữ liệu lưu của các phiên làm việc trước của app đã bị xóa sạch!';
					}
					else{
						//get all DBs has new edition but is set to be hidden
						const _DBloadHide = _DBsHasNewEdition.filter(_dbName => 
							toLoadArr.find(_dbItem => _dbItem.dbName == _dbName).loadMode == DBFiles.LMODE.noShow
						);

						//get all DBs has new edition and is set to be shown
						const _DBloadShow = _DBsHasNewEdition.filter(_dbName => !_DBloadHide.includes(_dbName)
						);

						// show toast for DBs having new edition and also set to be shown
						if(_DBloadShow.length > 0){
							let _localMsg = _newDBNotifyMsg(_DBloadShow);
							if(_localMsg != '')
								_msg += _localMsg + ', đã được App tự động ' + (_ivkFrom == 0? 'cập nhật.' : 'tải xuống (Dữ liệu mới chỉ cập nhật khi nạp lại trang Web.).');
						}

						// show toast for DBs having new edition but set to be hidden
						if(_DBloadHide.length > 0){
							let _localMsg = _newDBNotifyMsg(_DBloadHide);
							if(_localMsg != '')
								_msg += (_msg == ''? '': '<br>') + _localMsg + ', đã được App tự động cập nhật nhưng đang ở chế độ ẩn.';
						}

						//set toast callback when is invoked from Setting.handyCheckDBsEdition()
						if(_DBloadHide.length < _DBsHasNewEdition.length && _ivkFrom == 1)
						_toastCallback = _ => {
								if(confirm("CSDL có phiên bản mới. Cần nạp lại trang Web để cập nhật dữ liệu mới.\n\n Sẽ chỉ mất vài giây. Bạn có muốn nạp lại trang Web ngay bây giờ?"))
								//Force a hard reload to clear the cache if supported by the browser
									window.location.reload(true);
							}
					}

					if(toast && _ivkFrom == 1)
						toast.showToast(_msg, toast.ToastType.Infor, {duration: 1.5e4, cbEnd: _toastCallback}); 
					else
						//since Toast object has not been loaded, so we put it into delayedNotification
						ssData.delayedNotification.push({msg: _msg, option: {duration: 1.5e4}});
				}
				
				//function to check if a DB has new edition
				const _newDBcheck = _dbItem => {
					if(_DBsHasNewEdition.length == 0) return false;
					return Boolean( _DBsHasNewEdition.find(_dbName => _dbItem.dbName == _dbName) );
				}
				//function to filter all DBs that need to download
				const _filterFnc = _dbItem => {
					//const _newDBcheck = _dbName => 
					if(_ivkFrom == 0){
						/* call from loadPage(), we need to load all DB that match one of following condition:
						 a) cacheLoad (2) or freshLoad (1)
						 b) all DB (even in noShow(0) mode) but has new edition. Some DB of this condition might already be in condition a) */
						return _dbItem.loadMode != DBFiles.LMODE.noShow || _newDBcheck(_dbItem);
					}
					else {
						// call from Setting.handyCheckDBsEdition(), just load the DB has new edition
						return _newDBcheck(_dbItem);
					}
				}
				//store array of script url and its option to load into loadJs
				//loadMode: 0 - No Show. 1- Fresh load, No Cache. 2-load, using cache if applicable.
				let _jsDataFiles = toLoadArr.filter( _dbItem => _filterFnc(_dbItem) ) //filter item to be loaded (has loadMode 1 or 2)
				.map( _dbItem =>  ({
					url: _dbItem.dbUrl,
					//removeMarkup: since we don't set value for this flag, its default value would be true, meaning the script markup would be removed out of DOM after being loaded (sucess or fail), so other would not see any markup in the DOM for those config.js and data_*.js files
					//allowReload: true, //removed because when freshLoad = true, allowReload also set to true
					freshLoad: _dbItem.loadMode == DBFiles.LMODE.freshLoad || _newDBcheck(_dbItem), //script should ignore browser's cache if its loadMode is freshLoad or it has new edition (does not matter what its loadMode is)
					//see DBFiles.loadJS for explanation of some properties of extAttr
					extAttr: {
						//fileNo: _dbItem.fileNo, // this actually can derived from jsDBName below
						jsDBName: _dbItem.dbName, 
						loadMode: _dbItem.loadMode //this property actually not use
					} 
				})
				); //map into format of options for loadJS()

				DBFiles.loadJS(_jsDataFiles)
				.then((_res) => {
					_res.forEach(_prom => {
						// for success loaded db file: add data to data collected variable ssData.jsDBFiles
						if(_prom.status === "fulfilled"){
							// because of Promise.allSettled in loadJS, so _prom.value point to script elements created inside createLoadJS
							const _scriptElm = _prom.value;
							const _extAttr = _scriptElm.extAttr;
							const _jsDBName = _extAttr.jsDBName; //something like 'data_0'

							//xDBFilesCfg.toLoad corresponding with current script
							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							
							//this should never happen
							if(!_dbFileCfgItm) return console.log('importDBfromFiles(): somehow there is a database script element that not found in xDBFilesCfg.toLoad');

							//reset failCount
							_dbFileCfgItm.failCount = 0;

							// If flag freshLoad is set to true (when loadMode=1), loadJS.exec() will change version number in script url. So, we need to update dbUrl accordingly, so next time load the page, the page would use the right version from the browser's cache (because the browser's cache only keep the last version of script)
							_dbFileCfgItm.dbUrl = _scriptElm.urlVersion;

							//if DB file having loadMode == DBFiles.LMODE.noShow then clean its data since those data would not be shown in books list
							if( _dbFileCfgItm.loadMode == DBFiles.LMODE.noShow ){

								// for more control on clearing unneccessary data, I defer the clearing job to _promiseCB callback
								//delete the global variable for data that set hidden to save memory
								//window[_jsDBName] = undefined;
							}
							else{
								// if fresh-load, then change loadMode to cache-load for next session
								if(_dbFileCfgItm.loadMode == DBFiles.LMODE.freshLoad) {
									_dbFileCfgItm.loadMode = DBFiles.LMODE.cacheLoad;
									console.warn(`importDBfromFiles(): Database file ${_dbFileCfgItm.dbUrl} has change loadMode from 1 to 2 (Load from Browser's Cache on next session)`);
								}
							}

							if('function' == typeof _promiseCB){
								// load DB into ssData.jsDBFiles (so books inside that DB would be show in this session) if it is not in no-show mode (loadMode !=0)
								if (_ivkFrom == 0) _promiseCB(_scriptElm);
								//DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _extAttr.loadMode);
							
								// for now Setting.handyCheckDBsEdition has set no function for this callback
								if (_ivkFrom == 1) _promiseCB(_scriptElm);
							}
						}
						// for failed loaded db file: 
						else if(_prom.status === "rejected"){
							/* most likely the database file not exist */

							//_prom.reason.target point to script elements created inside createLoadJS
							const _scriptElm = _prom.reason.target;
							const _jsDBName = _scriptElm.extAttr.jsDBName;

							//mark loadMode of failly-loaded database file to be 'No Show' and increase failCount
							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							if(_dbFileCfgItm){
								_dbFileCfgItm.loadMode = DBFiles.LMODE.noShow;
								if(typeof _dbFileCfgItm.failCount == 'number')_dbFileCfgItm.failCount++; else _dbFileCfgItm.failCount = 1;
								console.log(`Database file ${_dbFileCfgItm.dbUrl} has change loadMode to 0 (No show on next session)`);
							}
						}
					});

					if('function' == typeof _allSettleCB) _allSettleCB();

					
				})
				return _DBsHasNewEdition;
			}			
		}

		/* Function is called at the very beginning when page is load. It does:
		- restore xState from localStorage, which along others page states from last sesson, it also contains which database files would be loaded, with which loadMode
		- load the Databases file with the loadMode stored in xState
		- call init() function
		 */
		function loadPage(){
			//note that since "config.js" has no suffix "?v=", so it is treated as loadMode = 1 because it will be added suffixe ?v={performance.noe()}
			//{url: "config.js", removeMarkup: false}
			DBFiles.loadJS( "config.js" ).then((_ret) => {
				/* STEP B: Lấy lại xState, xDBFilesCfg lưu trong Storage từ phiên trước; This have been moved to init() */
				function getFromStorage(_storageName){ //wrap function to restore json variable from localStorage
					let resState = localStorage.getItem(_storageName);
					if (resState != null) {
						try {
							resState = JSON.parse(resState);
						} catch (e) { resState = null }
					}
					return resState;
				}

				/* I. Initiate some important environment variables */
				xState = getFromStorage('xState') ?? structuredClone(_DEFAULT_CFG.xState); //restore xState from localStorage
				//this to add some attributes that add might just be added while xState has been initialized quite a go
				xState = Object.assign({},_DEFAULT_CFG.xState, xState);

				// initialize history object if somehow it is not yet existed
				if(!xState.hasOwnProperty("history")) xState.history = structuredClone(_DEFAULT_CFG.xState.history);
				//this line is used to update new property 'books' of xState.history. TODO: This is redundant if user wipeout all localStorage data, and cann be moved after someimt
				xState.history = Object.assign({},_DEFAULT_CFG.xState.history, xState.history);

				xDBFilesCfg = getFromStorage('xDBFilesCfg') ?? structuredClone(_DEFAULT_CFG.xDBFilesCfg); //restore xDBFilesCfg from localStorage
				
				//initiate empty xState.toastCfg 
				if(!xState.hasOwnProperty("toastCfg")) xState.toastCfg={};

				//this to add some attributes that add might just be added while xState has been initialized quite a go
				xDBFilesCfg = Object.assign({},_DEFAULT_CFG.xDBFilesCfg, xDBFilesCfg);

				//initiate last checked time
				ssData.lastDBCheck = Date.now();

				//initiate delayedNotification storage for delayed (postponed) notification to user (especially when toast object has not created like when invoking from this loadPage() function)
				if(!ssData.hasOwnProperty("delayedNotification")) ssData.delayedNotification = [];

				//_DEFAULT_CFG.xDBFilesCfg looks like {"len":3,"toLoad":null};
				//in case new database just being added, the len in the cfg changes
				//for now, I fix number of databases on _DEFAULT_CFG.xDBFilesCfg.len
				xDBFilesCfg.len = _DEFAULT_CFG.xDBFilesCfg.len; //Math.max( (xDBFilesCfg.len ?? 3), _DEFAULT_CFG.xDBFilesCfg.len);
				
				/* II.A. Prepairing xDBFilesCfg.toLoad array before actually loading the DBs and book data inside them */
				//initiate xDBFilesCfg.toLoad array if it not yet exist (this only happen when page loaded for very first time or local storge was been completely wiped out)
				if(!(xDBFilesCfg.toLoad instanceof Array))  xDBFilesCfg.toLoad = [];
				let toLoadArr = xDBFilesCfg.toLoad; //don't swap this line and above

				/* II. load the DB files */
				const _DEF_LOADMODE = DBFiles.LMODE.cacheLoad;  //default loadMode is load, use cache
				// fill in items that localStorage's xDBFilesCfg does not have. This might happens when new database files being added to the page
				const _DB_MAX_FAILCOUNT = 10; //maximum fail count for an DB files before it is put into 'No Show' mode				

				const _DB_FILE_REFIX = "data_";
				//standard, initial database file information based on the len in config
				let _toLoadArrTemp = [...Array(xDBFilesCfg.len).keys()].map(i => {
					return {fileNo: i, //order number of Database file, act as an Id to identify a Database File
						dbName: `${_DB_FILE_REFIX}${i}`,  //name of Database variable inside file
						dbUrl: `${_DB_FILE_REFIX}${i}.js`, //Database file url
						loadMode: _DEF_LOADMODE, //default: database to be cache loaded
						failCount: 0} //count the number of fail when load this database
				});

				//if current cached has more number of databases than the config setting, remove them out of toLoadArr
				if(_toLoadArrTemp.length < toLoadArr.length){
					let _removedDBs = "";
					for(let i=_toLoadArrTemp.length; i<toLoadArr.length; i++)
					_removedDBs += "<mark>" + toLoadArr[i].dbName + "</mark>";
					ssData.delayedNotification.push({msg: "Database " + _removedDBs + " bị loại khỏi app.", option: {duration: 1e4}});
					//naive way to remove the database out of toLoadArr. Only work correctly if databases are in order like data_0, data_1, data_2, data_3,...
					toLoadArr.length = _toLoadArrTemp.length;
				}
				//add database to toLoadArr if there any new database in _toLoadArrTemp (which made from the config setting)
				const _pageLoadedFirstTime = toLoadArr.length == 0;
				for(let i=0; i<_toLoadArrTemp.length; i++) {
					const _toLoadItemTmp = _toLoadArrTemp[i];
					if( !toLoadArr.find(_item => _item.fileNo == _toLoadItemTmp.fileNo) ) {
						toLoadArr.push(_toLoadItemTmp);
						//only notify of new DBs if this it not the very first time the page is loaded (so there is no cache for DBs yet)
						if(!_pageLoadedFirstTime) ssData.delayedNotification.push({msg: "Có database <mark>" + _toLoadItemTmp.dbName + "</mark> mới được thêm vào app.", option: {duration: 1e4}});
					}
				}
				
				// if all data files having loadMode = 0 (no load) then mark the data_0 loadMode = 2 so there is at least one database to be loaded
				if(toLoadArr.every(_lm => _lm.loadMode == DBFiles.LMODE.noShow)){
					toLoadArr.find(_lm => _lm.fileNo == 0).loadMode = _DEF_LOADMODE; //load, use cache
				}

				//for item that has too many times fail when loading, just mark it to 'No show' so the page won't bother load it, except when its loadMode == 1 (forcing fresh load)
				toLoadArr.forEach((_dbItem, i) => {
					//mark no show if failCOunt > 10
					if(_dbItem.loadMode == DBFiles.LMODE.cacheLoad && _dbItem.failCount > _DB_MAX_FAILCOUNT) _dbItem.loadMode = DBFiles.LMODE.noShow;
				});

				ssData.jsDBFiles = []; //initialize jsFiles for deployDB() to put data into

				/* II.B downloading DBs from js script files and loading book data into the page */

				/** function to be invoked as a callback for importDBfromFiles() each time a script promise successfully loaded 
				 * @param _scriptElem {promise} the script promise that wrap script element
				*/
				const _promiseCB = _scriptElm => {
					const _extAttr = _scriptElm.extAttr;
					const _jsDBName = _extAttr.jsDBName; //something like 'data_0'
					//xDBFilesCfg.toLoad corresponding with current script
					const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);

					//note that the case loadMode==noShow (0), importDBfromFiles() has taken care to delete the global variable for data that set hidden to save memory. Here, we only do the deploy data inside database that set to be shown: cacheLoad(2), freshLoad(1)
					if(_dbFileCfgItm.loadMode > 0)
						DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _extAttr.loadMode);
					else
						window[_jsDBName] = undefined;
				}
				//now, actually download the DB script file and deploy data inside (if DB is not in hidden mode), then run the init()
				DBFiles.importDBfromFiles(
					//mark that invoke from loadPage()
					0, 
					//callback function which will be invoked each time a DB script file is loaded succesfully
					_promiseCB,
					//callback function which is invoked when all DBs has been loaded (each might be sucessful or failed)
					init
				);
			})
			.catch(err => {
				console.error(err);
				alert("Không nạp được file config.js, trang Web không thể hoạt động.");
			});
		}
	</script>

	<!-- SMALL, HANDY NON-UI FUNCTIONS -beauty -->
	<script>
		"use strict";
		String.prototype.toProperCase = function () {
			return this.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
		};
		String.prototype.hashCode = function () {
			let hash = 0;
			if (this.length === 0) return hash;
			for (let i = 0; i < this.length; i++) {
				hash = ((hash << 5) - hash + this.charCodeAt(i)) | 0
			}
			return (hash >>> 0).toString(36)
		}
		/* Simple, small, useful functions */
		/* padding some char before a text 
			n: the number of text to be padded
			width: number of char to pad
			z: char to pad
		*/
		const pad = (n, width, z) => String(n+ '').padStart(width, z || '0'); // '0009'

		//make braket that enclose something store in let m
		const makeBrk = (m) => (m ? "[" + m + "]" : "" );
		//convert integer number to upper-roman form
		const int2Roman = (num) => {
			const romanValues = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
			let roman = '';
			for (let key in romanValues) {
				while (num >= romanValues[key]) {
					roman += key;
					num -= romanValues[key];
				}
			}
			return roman;
		}
		
		/* make inline svg from sprite embeded at the end of HTML
			_spriteName {string}: id of svg sprite stored in <symbol> element
			_options	{Json}, may have following attributes
				class	{string}: list of class	names
				style	{string}: inline style that customize UI of a paticular icon
				title	{string}: tooltip for current icon
		*/
		const makeSvgFromSprite = (_spriteName, _options) => {
			let _class = "", _inlineStyle = "", _title = "";
			if (_options) {
				if (_options.class) _class = `class="${_options.class}"`;
				if (_options.style) _inlineStyle = `style="${_options.style}"`;
				//if(_options.title) _title = `title="${_options.title}"`; //for now, svg not support title, so ignore this for now
			}
			return `<svg ${_class} ${_inlineStyle} ${_title} focusable="false" aria-hidden="true">
			<use href="#${_spriteName}"/>
		</svg>`;
		}
		//extract host name from an url
		/* const getHostName = (url) => {
			if (!url) return "";
			let regRet = url.match(/(\w+)\.\w{2,}(\/|\?|$)/); 
			return (Array.isArray(regRet) && regRet[1].toProperCase()) || "Link";
		}; */
		/* extract host name from an url using URL API which support by most of modern browser. This version work better than the above regEx version */
		const getHostName = (url) => {
			if (!url.trim()) return "";
			//using URL API to extract the hostname
			let domain = (new URL(url));
			//break hostname into parts
			let names = domain.hostname.split(".");
			names.splice(-1, 1); //remove the last part of hostname because it commonly is domain extension like net, com, gov, vn, us,..

			//for double extension like .com.vn, .net.au or .edu.uk, we need to get previous part of hostname
			if(names.length === 0) return 'Link'
			else{
				let hName = 'Link';
				if(['com','net','org','gov','edu','info'].includes(names.at(-1)) ) 
				hName = names.at(-2) ?? 'Link'
				else 
				hName = names.at(-1);
				//map the hostname with something shorter or more meaningful
				const _NamesMap = {
					'phatphapungdung' : 'PPƯD',
					'phapthihoi': 'PhápThíHội',
					'dieuphapam': 'DPA', //DiệuPhápÂm
					'tinhtong': 'PhápHành',
					'theravada': 'Theravāda',
					'thuvienanime': 'Tóm tắt',
					'audioaz': 'AudioAZ',

					'youtube': 'YT',
					'dropboxusercontent': 'Dropbox',
					'googleapis': 'Google'
				};

				return _NamesMap[hName] ?? hName.toProperCase();
			}
		};

		//format number with comma delimeter
		const commaNum = x => x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, "."); //x.toLocaleString(); 
		//convert duration string (such as '34:09', '01:05:28' to second in number
		const toSeconds = (str) => {
			if (!str) return 0;
			let t = str.split(':').map(n => { return isNaN(parseInt(n)) ? 0 : parseInt(n) });
			return t.reduce((r, elem) => r * 60 + elem, 0);
		}
		//convert total number of second to duration string format: HH:mm:ss, HH will be left out if HH=0
		/* const toHhMmSs = (sec) => {
			if (isNaN(sec)) return "00:00";
			
			sec = sec << 0; //make sec to be integer
			let h = (sec / 3600) << 0; sec = sec % 3600;
			let m = (sec / 60) << 0;
			let s = sec % 60;
			return (h ? commaNum(h) + ":" : "") + pad(m, 2) + ":" + pad(s, 2);
		} */

		/** convert second to a human-readable format
		 * @param sec {number}: the amount of seconds to be formatted
		 * @param _verbose (optional)
		 * 		- missing or 0: format to HHHH:Mm:ss
		 * 		- 1: format to DD Ngày, HH:Mm:ss
		 * 		- 2: format to DD Ngày, HH Giờ, MM Phút, SS Giây
		 */
		const toHhMmSs = (sec, _verbose = 0) => {
			if (isNaN(sec)) return "00:00";

			sec = sec << 0; //make sec to be integer
			if (sec < 0) sec = -sec;
			if(_verbose < 2) {
				//convert second to Mm:Ss  no matter what
				const toMmSs = sec => pad(~~(sec / 60) % 60, 2) + ":" + pad(sec  % 60, 2);
				const mmss = sec % 3600;
				if(_verbose == 0) //HHHH:Mm:ss
					return (sec >= 3600? commaNum(~~(sec / 3_600)) +":" : "") + toMmSs(mmss);

				if(_verbose == 1){ //DD Ngày, HH:Mm:ss
					const d = ~~(sec / 86_400), h = ~~(sec / 3_600) % 24;

					return [d === 0? "" : commaNum(d) +  " ngày ⅋ ", // 🙵 ＆ ⅋ &
						h > 0? h +":" : "",
						toMmSs(mmss)].join("");
				}
			}

			if(_verbose == 2) //DD Ngày, HH Giờ, MM Phút, SS Giây
				return Object.entries({
					"ngày": ~~(sec / 86_400),
					"giờ":  ~~(sec / 3_600) % 24,
					"phút": ~~(sec / 60) % 60,
					"giây": sec  % 60
				})
					.filter(val => val[1] !== 0)
					.map(([key, val]) => `${val} ${key}`)
					.join(', ');			
		};

		//get param from Url string
		function getUrlVars() {
			let vars = {};
			let parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi,
				function (m, key, value) {
					vars[key] = value;
				});
			return vars;
		}

	</script>

	<!-- TOAST + SMALL FUNCTIONS THAT EFFECT UI -->
	<script>
		"use strict";
		/* Helper prototype for any HTML element that:
			- if attr is string - which is an element's attribute (e.g 'height'), it return Element.style[{that attribute}]
			- if attr is json (e.g {'height': 100px, 'font-size':17px} ), it will set the assigned value for an attribute
		*/
		Element.prototype.css = function (attr) {
			if (typeof attr === 'string') {
				return getComputedStyle(this, '')[attr];
			}
			else if (typeof attr === 'object') {
				for (let name in attr) {
					if (this.style[name] !== undefined) {
						this.style[name] = attr[name];
					}
				}
			}
		};

		/* Prototype for Audio element to get/set attribute */
		Element.prototype.attr = function (attrName, attrVal) {
			if (attrVal === undefined)
				return this.getAttribute("attr-" + attrName) || this.getAttribute(attrName);
			else {
				this.setAttribute("attr-" + attrName, attrVal);
			}
		}

		/* Set the state checked, indeterminate or unchecked for a textbox
			_chkBox {HTML element} : the checkbox to set state
			_state {interger}: 	0 : unchecked
								1 : checked
								2 : indeterminate
		*/
		function setChkboxState(_chkBox, _state) {
			if (_state === 0) {
				_chkBox.indeterminate = false; //to avoid UI mess-up when browser does not know the state of checkbok
				_chkBox.checked = false;
			}
			else if (_state === 1) {
				_chkBox.indeterminate = false; //to avoid UI mess-up when browser does not know the state of checkbok
				_chkBox.checked = true;
			}
			else _chkBox.indeterminate = true;
			_chkBox.dataset.stateVal = _state;
		}

		/* Change audio source for chapter that has multiple audio links
			_justReload {boolean} :
				TRUE: If failed, just trying audio.load() to reload audio src, skip step 3 of tryingLoadAudio()
				FALSE: if failed again after audio.load(), try other url src if there are multiple url src for this chapter
		*/
		let changeAudioSrc = (_justReload) => {
			let _currBook = xAudio.getAttribute("attr-Book");
			let _currChap = parseInt(xAudio.getAttribute("attr-Chap"));
			//chapDataUrl is an array (if it is not, it has been converted to array in changeChap() function) 
			// the ChangeSrc button only show up when chapDataUrl has at least two items
			let chapDataUrl = ssData.bookData.findBookFromId(_currBook).parts[_currChap - 1].url;

			let elmMp3Links = document.getElementById("elmMp3Links");

			//find current playing items
			let cSrcIdx = -1, _audioSrc = "";
			let _allMediaAnchors = elmMp3Links.querySelectorAll("li[role='audioSrc']> a");
			//find current playing source
			_allMediaAnchors.forEach((_anchor, _i) => {
				if (_anchor.classList.contains("srcPlaying")) cSrcIdx = _i
			});

			//cSrcIdx==-1: this is the case when this function is being called from changeChap(), so there has no .srcPlaying anchor yet
			if (cSrcIdx == -1) {
				cSrcIdx = parseInt(xState.history.books[_currBook]["urlLine"]); //the index of item in chapData.url that should be played
				if (isNaN(cSrcIdx)) { cSrcIdx = xState.history.books[_currBook]["urlLine"] = 0 }
				if (chapDataUrl.length <= cSrcIdx) cSrcIdx = 0;
			}
			//cSrcIdx > -1: this is the case when this function is being invoked from ChangeSrc button, when there is already one .srcPlaying anchor which set by invocation from changeChap()
			else {
				//switch to next url line
				cSrcIdx = (cSrcIdx + 1) % chapDataUrl.length;
				//update new urlLine for next chapter in this book to select mp3 source to play
				xState.history.books[_currBook]["urlLine"] = cSrcIdx;
			}

			//trying load audio src WITHOUT/WITH fail-safe to play other url line if current url line failed
			ssData.audioPlayer.loadSrc(chapDataUrl[cSrcIdx], _justReload ?? false);

			//each time a mp3 url is played (by change chapter or by Change Src button), we need to change the appearance of mp3 link accordingly
			(function changePlayingMp3Style(cSrcIdx) {

				//format mp3 links that is played by audio element
				let elmMp3Links = document.getElementById("elmMp3Links");
				elmMp3Links.querySelectorAll("a.srcPlaying").forEach(_ => { _.classList.remove("srcPlaying") });
				let _newMp3Anchor = elmMp3Links.querySelector("li[role='audioSrc']:nth-of-type(" + (cSrcIdx + 1) + ") > a");
				if (_newMp3Anchor) {
					let _mp3Link = _newMp3Anchor.getAttribute("href");
					let _linkHash = _mp3Link.hashCode();
					_newMp3Anchor.setAttribute("hash-code", _linkHash);
					_newMp3Anchor.classList.add("srcPlaying");
					//get file-size if possible
					if (!_newMp3Anchor.classList.contains("gotFileSize"))
						utilityHandles.getFileSize(_mp3Link, _msg => {
							// check if the current a.srcPlaying's link has the same hashCode with that of the one to request for file-size
							if (!_msg.success || document.querySelector("#elmMp3Links a.srcPlaying")?.getAttribute("hash-code") != _linkHash) return;
							_newMp3Anchor.innerHTML += ` ${_msg.msg}`;
							//mark that file size has achived, don't load again next time
							_newMp3Anchor.classList.add("gotFileSize");
						});
				};
			})(cSrcIdx);
		}


		/** Toast class to show multiple toasts at a time 
			@config toastConfig {JSON}: setting for toast, including:
				mode {integer}, location {string}: 		the Toast them mode, also define location of the toast
				theme {integer}, themeName {string}: 	define theme light(0) or dark(1)
				animMode {integer}, animName {string}:	define the type of animation, which is bounce(0), slide(1), flip(2), zoom(3)
				animDir{integer}, animDirName {string}:	For 'bounce' and 'slide' animation, this param define the animation direction, depend on the location of toast. E.g, location at "Bottom-Right", there will be two animMode which is in/out of Bottom and in/out of Right
			Example of one toastConfig
				{
					"mode": 3, "location": "Bottom-Left",
					"theme": 1, "themeName": "toast-dark-theme",
					"animMode": 0, "animName": "bounce",
					"animDir": 0, "animDirName": "Bottom"
				}
			
			This Toast object support callback when a toast about to vanish (because of timeout has reached to the end Or user click on the toast to vanish it). Example
				- toast.showToast("Tesst callback", toast.ToastType.Error, {duration: 1.5e4, cbEnd: _ => {console.log('Callback End')} } );
				- ssData.delayedNotification.push({msg: "Tesst callback", option: {duration: 1.5e4, cbEnd: _ => {console.log('Callback End')} }}); toast.showDelayedToast();
				TODO: need to add callback support for ChainToast and promise toast
		*/
		let Toast = function ToastObj() {
			/* For manual mode, we need to calculte location of new Toast so that it can be in-between shown Toasts if there is a gap which big enough */
			function locateToastManually(toastElem) {
				const BOTTOM_START = 20, TOAST_GAP = 10; //Toast bottom start and gap between Toasts
				//find the bottom, so new Toast not overlap old ones that has not been removed
				toastElem.setAttribute("newToastAdded", ""); //this attribute help to know this is newly added Toast
				let _toastElems = document.querySelectorAll(".toast-element:not([newToastAdded])"); //get all Toasts except the new added one
				toastElem.removeAttribute("newToastAdded"); //remove this attribute for the next added Toast (if any)

				// array store CSS bottom property and dimension of all currently displaying Toasts. The first item here is the fake element to shorten the code below. rect.top of this first element make the effect as css setting: 'bottom: {BOTTOM_START}px' from bottom of screen
				let _allToastSizes = [{ cssBottom: BOTTOM_START - TOAST_GAP, txt: "Dummy Marking Toast", rect: { top: window.innerHeight - BOTTOM_START + TOAST_GAP, height: 0 } }];
				_toastElems.forEach(_elm => {
					// cssBottom: =style.bottom property, measured from bottom of screen. 
					// rect: dimension of element, all measured from top-left of screen
					// txt: content of the Toast, for debugging only, can be removed
					_allToastSizes.push({ cssBottom: parseInt(_elm.style.bottom), txt: _elm.innerText, rect: _elm.getBoundingClientRect() });
				});

				//sort in ascending order of {cssBottom} buttom property, meaning the Toast element from bottom to up
				_allToastSizes = _allToastSizes.sort((a, b) => a.cssBottom - b.cssBottom);
				let _thisCSSBottom = BOTTOM_START; // the css bottom need to be calculated for new Toast
				let _currHeight = toastElem.getBoundingClientRect().height; //height of current Toast

				//func to calculate bottom property of Toast[i]'s next Toast should be
				let calNextBottom = i => {
					return _allToastSizes[i].cssBottom + _allToastSizes[i].rect.height + TOAST_GAP;
				}

				if (_allToastSizes.length > 1) { //beside fake element, this mean if there is at least one Toast still shown
					// go from screen's bottom up to find if there any space that can display the new Toast
					for (let i = 1; i < _allToastSizes.length; i++) {

						let _prevTop = _allToastSizes[i - 1].rect.top;
						let _nextBottom = _allToastSizes[i].rect.bottom;
						//console.log(`${_prevTop - _nextBottom} : ${_currHeight}`);

						if (_prevTop - _nextBottom > _currHeight + TOAST_GAP) {
							//found a gap which large enough to place new Toast, then this Toast would locate within this gap, right above of Toast[i-1]
							_thisCSSBottom = calNextBottom(i - 1);
							break;
						}

						//if reach to last Toast without found any larg-enough gap, make new Toast right above the last one
						if (i == _allToastSizes.length - 1) _thisCSSBottom = calNextBottom(i);
					}

				}
				// make bottom change to Toast element
				toastElem.style.bottom = _thisCSSBottom + "px";
			}

			// fun-purposed function utilizing internal variable to count the number of Toast
			function toastCounter() {
				return toastCounter.count++;
			};
			toastCounter.count = 0; //this simulate internal variable that keeps through multiple toast request

			let toastConfig = null;
			function getToastConfig(){return toastConfig};

			//Cannot use Object.freeze for toastChoices because animDirs attribute need to add to this object depending on modes and animation types
			const toastChoices = {
				modes: ["manual-Bottom-Left", "Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"],
				modes_weighted: [1, 2, 2, 2, 20], //wwighted for modes when randomly choose
				themes: ["toast-light-theme", "toast-dark-theme", "toast-color-theme", "toast-mono-theme"],
				themes_weighted: [1, 1, 1, 8], //wwighted for themes when randomly choose
				animations: ["bounce--m", "slide--m", "elliptic--m", "zoom", "flip--i", "swirl", "slit--i"],
				/** From name of animation (such as 'bounce--m' or 'slit-i') to generate possible animation direction. See inside function for more detail
					@param _animName {string}: the name of animation
						- animation with suffix '--m' (moving): the toast will move from outside of screen into viewport following x or y axis
						- animation with suffix '--i' (in-place): the toast will twisted in-place in vertical or horizontal
					@param _location {string}: the name of location of Toast container, which define possible direction for animation with --m
				@return: { anim: (name of animation), dir: (array of possible directions or null), animTimeFnc: animation time function }
				*/
				posssibleAnimDirs : function(_animName, _location){
					let _regEx = _animName.match(/\-\-([mi]+)/);
					let _animTimeFnc = ["ease-out", "ease-in"];
					if( _animName.match(/^(bounce|zoom|flip)/) ) _animTimeFnc = ["cubic-bezier(.68,-0.55,.4,1.6)", "cubic-bezier(.68,-0.55,.26,1.35)"];

					//note that _animName must be lower-case
					if(!_regEx) return {anim: _animName, dir: null, animTimeFnc: _animTimeFnc};

					_animName = _animName.replace(_regEx[0],""); //remove the --mi trailing
					
					
					if(_regEx[1] == 'm'){
						let _sides = _location?_location.split("-").slice(-2) : [];
						_sides = _sides.map(_side => _side.toProperCase()); //change direction to proper-case
						//if(_sides.length == 2){ toastChoices["animDirs"] = _sides; }
						return {anim: _animName, dir: _sides.length == 2? _sides: null, animTimeFnc: _animTimeFnc};
					}

					if(_regEx[1] == 'i'){
						return {anim: _animName, dir: ["Horz","Vert"], animTimeFnc: _animTimeFnc};
					}
				}
			};

			/** Adapt from https://trekhleb.medium.com/weighted-random-in-javascript-4748ab3a1500
			 * Picks the random item based on its weight.
			 * The items with higher weight will be picked more often (with a higher probability).
			 *
			 * For example:
			 * - items = ['banana', 'orange', 'apple']
			 * - weights = [0, 0.2, 0.8]
			 * - weightedRandom(items, weights) in 80% of cases will return 'apple', in 20% of cases will return
			 * 'orange' and it will never return 'banana' (because probability of picking the banana is 0%)
			 *
			 * @param {any[]} items
			 * @param {number[]} weights
			 * @returns {{item: any, index: number}}
			 */
			/* eslint-disable consistent-return */
			function weightedRandom(items, weights) {
			if (items.length !== weights.length) {
				throw new Error('Items and weights must be of the same size');
			}

			if (!items.length) {
				throw new Error('Items must not be empty');
			}

			// Preparing the cumulative weights array.
			// For example:
			// - weights = [1, 4, 3]
			// - cumulativeWeights = [1, 5, 8]
			const cumulativeWeights = [];
			for (let i = 0; i < weights.length; i += 1) {
				cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0);
			}

			// Getting the random number in a range of [0...sum(weights)]
			// For example:
			// - weights = [1, 4, 3]
			// - maxCumulativeWeight = 8
			// - range for the random number is [0...8]
			const maxCumulativeWeight = cumulativeWeights[cumulativeWeights.length - 1];
			const randomNumber = maxCumulativeWeight * Math.random();

			// Picking the random item based on its weight.
			// The items with higher weight will be picked more often.
			for (let itemIndex = 0; itemIndex < items.length; itemIndex += 1) {
				if (cumulativeWeights[itemIndex] >= randomNumber) {
				return {
					item: items[itemIndex],
					index: itemIndex,
				};
				}
			}
			}
			/* Function to make random configuration for Toast */
			function setToastMode() {
				function getChoice(_choiceName, _testChoice){
					let _choiceArrayName = _choiceName + "s";
					let _choiceIdx = _testChoice ?? xState.toastCfg?.[_choiceName] ?? -1;
					//if no specific choice, choose randomly
					if(_choiceIdx == -1)
						//if current choice has weight, choose randomly based on weight
						if(toastChoices.hasOwnProperty(_choiceArrayName + "_weighted"))
							_choiceIdx = weightedRandom(toastChoices[_choiceArrayName], toastChoices[_choiceArrayName + "_weighted"]).index;
						else
							//otherwise, just choose pure-randomly
							_choiceIdx = Math.floor(Math.random() * toastChoices[_choiceArrayName].length);
					return [_choiceIdx, toastChoices[_choiceArrayName][_choiceIdx]];
				}

				/* Choose theme light or dark for this session 
				toastTheme  = 0: light theme "toast-light-theme"
							= 1: dark theme	"toast-dark-theme"
				*/
				const [_theme, _themeName] = getChoice("theme");

				/* get random value between 0 and 1 to decide Toast mode for current page session.
				toastMode   = 0:   manual mode, on left side. "manual-Bottom-Left"
							= 1-4: auto mode on Bottom/Top-Right/Left side: "Bottom-Right", "Top-Right", "Bottom-Left", "Top-Left"
					For 4 Auto-mode, the name of the mode IS the location of toast Container
				*/
				const [_mode, _containerLocation] = getChoice("mode");

				/* Animation mode, one of "bounce", "slide", "flip", "zoom", "swirl", "diagFlip" */
				let [_animMode, _animName] = getChoice("animation");

				//update toast
				toastConfig = { 'mode': _mode, 'location': _containerLocation, 'theme': _theme, 'themeName': _themeName, 'animMode': _animMode };

				let _toastContainer = document.querySelector(`[name="toastContainer"][location="${_containerLocation}"]`);
				if(!_toastContainer){ //create if it is not existed yet
					_toastContainer = document.createElement("DIV");
					_toastContainer.setAttribute("name", "toastContainer");
					document.body.appendChild(_toastContainer);
				}
				_toastContainer.setAttribute("location", _containerLocation);
				
				// Default dir value for animation having no direction such as zoom, flip, swirl, ... 
				let [_animDir, _animDirName] = [-1, ""];
				let _possAnimDirs = toastChoices.posssibleAnimDirs(_animName, _containerLocation);
				_animName = _possAnimDirs.anim;
				let _animTimeFnc = _possAnimDirs.animTimeFnc;

				/* for bounce and slide only: direction of animation, depend on location of the toast elements */				
				// if there are animation possible directions
				if(_possAnimDirs.dir !== null){
					toastChoices["animDirs"] = _possAnimDirs.dir;
					[_animDir, _animDirName] = getChoice("animDir");
				}
				
				// unique animation for Toast manual mode, because other mode messes the toast bottom, hence the locateToastManually() does not work correctly
				if (_mode == 0) {
					[_animName, _animDir, _animDirName] = ["slideManual", -1, ""];
					_animTimeFnc[1] = "cubic-bezier(.68,-0.55,.26,1.35)";
				}
				
				toastConfig['animName'] = _animName;
				toastConfig['animDir'] = _animDir;
				toastConfig['animDirName'] = _animDirName;
				toastConfig['animTimeFnc'] = _animTimeFnc;
				
				//return toastConfig;
				//console.log(toastConfig);
			}
			setToastMode();

			// a local variable, if is set to TRUE, the next Toast request will be depressed the Toast from showing
			let depressToastFlag = false;
			/* get/set depressToastFlag. When user call depressToast(true), the next toast will be depressed */
			function depressToast(flag){
				if(flag == undefined) return depressToastFlag
				else depressToastFlag = flag;
			}

			// enum of Types of Toast allowed. Using Object.freeze to prevent this being changed, which make toastChoices to be an enum
			const ToastType = Object.freeze({
				Infor: "Infor",
				Success: "Success",
				Warning: "Warning",
				Error: "Error",
				Promise: "Promise"
			});

			/* Check if current Toast is one of 4 basic types "Infor", "Success", "Warning", "Error" */
			function isBasicType(_toastType) {
				return !(_toastType == ToastType.Promise);
			}

			/* set default duration before being removed for each Toast type */
			function defaultDuration(_toastType) {
				let _defaulDur = 2000;
				switch (_toastType) {
					case ToastType.Success:
						_defaulDur = 2000;
						break;
					case ToastType.Infor:
						_defaulDur = 3000;
						break;
					case ToastType.Warning:
						_defaulDur = 4000;
						break;
					case ToastType.Error:
					case ToastType.Promise:
						_defaulDur = 5000;
						break;
					default:
						_defaulDur = 2000;
				}
				return _defaulDur;
			}

			const DEBUG = false; //set true to debug, the toast not disapeared

			/**	Create new toast element or (for toast created in Promise type only) update its content
				@param _msg {string, required}: message to show
				@param _toastType (optional): value of Toast.ToastType enum. Default Toast.ToastType.Infor
				@param _showDuration {integer, optional}: duration (in ms) the toast appear. See defaultDuration() above for default duration for each ToastType
				@param options {json}
					@property oldToastElem {HTMLElement}: the toast has created at last phase. If this is undefined, this is in-phase where we need to create toast element and add to DOM
					@property duration {integer}: duration to show the toast before it disappear, duration only have effect on out-phase to wait the time before removing Toast out of DOM
					@property persistance {boolean}: true then this Toast would not be wiped out by basic dismissAll() function (see that function for more)
					@property out {boolean}: specify this is at out-phase
					@property cbEnd {function}: callback function that if is spedified, will be invoked when the toast end and about to vanish
			 */
			function makeToast(_msg, _toastType, options) {
				
				_toastType = _toastType ?? ToastType.Infor;
				//console.log("Toast No: " + toastCounter() );
				let _duration = Math.max(options?.duration ?? 0, defaultDuration(_toastType)); //at least Default duration for each Toast type
				_duration += 2000;
				const _PERSISTANCE = options?.persistance ?? false;

				//constant to mark if current is in/out phase, maybe none or both of it
				const _inPhase = options?.in ?? (options?.oldToastElem ? false : true);
				const _outPhase = options?.out ?? isBasicType(_toastType); //if not specify, this is out phase if toast type is one of first 4 basic type 

				//make phase: create the new Toast element.  update phase: use the toastElem has create before to update content
				let toastElem = _inPhase ? document.createElement('div') : options?.oldToastElem;
				/* if(!toastElem) {
						console.log("Toast is null because both options.in = false and options.oldToastElem = undefined");
						return;
				} */

				if (_inPhase) { //make phase
					toastElem.setAttribute("toast-no", toastCounter()); //just for fun
					if(_PERSISTANCE) toastElem.setAttribute("isPersistance", true);
					toastElem.classList.add(toastConfig.themeName);
				}
				else { //update or out phase
					//search and remove old toast-type
					toastElem.classList.forEach(_cls => {
						if (_cls.indexOf("toast-type--") > -1) toastElem.classList.remove(_cls)
					});
					//in case toastElem has been removed by click on the toast
					if (!document.contains(toastElem)) {
						console.log("Toast has been removed");
						return;
					}
				}

				//add class to define toast basic css, type customized css and theme light/dark
				toastElem.classList.add("toast-element", `toast-type--${_toastType}`);
				toastElem.innerHTML = `
				<div class="toast__icon">${makeSvgFromSprite("svgIconToast" + _toastType)}</div>
				<div class="toast__msg">${_msg}</div>
				<div class="toast-progress"></div>
                `;

				//set in & out animation for toast 
				const ANIM_IN_DUR = 500, ANIM_OUT_DUR = 500;
				let _delay = _duration - ANIM_IN_DUR - ANIM_OUT_DUR;
				//console.log(`Toastify__${toastConfig.animName}In${toastConfig.animDirName}`);
				const _IN_ANIMATE = `Toastify__${toastConfig.animName}In${toastConfig.animDirName} ${ANIM_IN_DUR}ms ${toastConfig.animTimeFnc[0]}`,
				_OUT_ANIMATE_CLICK = `Toastify__${toastConfig.animName}Out${toastConfig.animDirName} ${ANIM_OUT_DUR}ms ${toastConfig.animTimeFnc[1]} forwards`,
				_OUT_ANIMATE = _OUT_ANIMATE_CLICK.replace(' forwards', ` ${_delay}ms forwards`); //in and out animation 
				//linear ease-in
				//console.log(_OUT_ANIMATE_CLICK);

				if (toastConfig.mode == 0) { //manual mode, locate on left-bottom
					toastElem.classList.add("toast-manual");
					_inPhase && document.body.appendChild(toastElem);
					if (_inPhase) locateToastManually(toastElem);
				}
				else { //auto mode, locate at right-bottom
					toastElem.classList.add("toast-auto");
					_inPhase && document.querySelector(`[name="toastContainer"][location="${toastConfig.location}"]`).appendChild(toastElem);
				}

				let _animationStr = "";
				if (_inPhase) { //making in-animation for in-phase
					_animationStr = _IN_ANIMATE; //in make phase, always show in-animation
				}
				if (_outPhase) { //making in-animation for out-phase
					//make phase with one of first 4 ToastType, meaning this is just normal notification toast, then both animations are shown
					if (!DEBUG) _animationStr += (_animationStr == "" ? "" : ", ") + _OUT_ANIMATE;
				}
				if (_animationStr) toastElem.style.animation = _animationStr;

				//handle on click to Toast to remove it, add right when toast element is created and add to DOM at in-phase
				if (_inPhase)
					toastElem.addEventListener("click", (evt) => {
						// add out-effect animation
						toastElem.getAnimations().forEach(_anim => { _anim.finish(); }); //finish old animations if any
						toastElem.style.animation = _OUT_ANIMATE_CLICK;
						let _newAnmations = toastElem.getAnimations();
						if (Array.isArray(_newAnmations) && _newAnmations.length > 0) _newAnmations[0].play(); // run animation right-away

						//wait animation to finish then remove the toastElem
						setTimeout(function () {
							//invoke the 'end' callback if there is any
							options.cbEnd && options.cbEnd();

							//remove toastElem out of DOM and out of memory
							if(toastElem) toastElem.remove(); 
							toastElem = null; 
						}, ANIM_OUT_DUR + 50);

						//this is important. This is to avoid the click event bubbling up, some place above in DOM might catch it and works improperly (such as closeIfClickedOutside in Search-Dropdown class)
						evt.stopPropagation();
					});

				let _progressBar = toastElem.querySelector(".toast-progress");
				_progressBar.classList.toggle('elm-hidden', !_outPhase);
				if (_outPhase && !DEBUG) { //remove toast Element out of DOM at out-phase
					// start couting-down progress-bar (at starting of and) only when at out-phase
					_progressBar.style.animation = `progress-keyframe ${_delay}ms linear forwards`;

					// set duration to remove Toast
					const autoRemoveTO = setTimeout(function () {
						//remove toast element out of DOM 
						toastElem.remove(); 
						//clean the toastElem variable (I don't know if this is right way to do that)
						toastElem = null; 
						//invoke the 'end' callback if there is any
						options.cbEnd && options.cbEnd();
					}, _duration);
					toastElem.addEventListener("click", () => {
						// stop and clear the timeOut above
						clearTimeout(autoRemoveTO);
					});
				}

				//return toastElem for ChainToasts, promise function
				if (_inPhase && !_outPhase) return toastElem;
			}

			/* Function to remove all living toast 
				@param isExtensiveWipe {boolean}: 
					- false or missing: only wipe out basic toasts which wasn't created with option.persistance = true (those toast do not have attribute {isPersistance})
					-true: wipe all toasts, no matter its {isPersistance} attribute
			*/
			function dismissAll(isExtensiveWipe) {
				document.querySelectorAll(`.toast-element${isExtensiveWipe?"":":not([isPersistance])"}`).forEach(_toastElem => _toastElem.click());
			}
			/** Showing Basic Toast message, which has only single message
				@param msg {string}: the message to show
				@param toastType {enumerate}: define the background color of the toast. Has to be a value of enum Toast.ToastType. Default is Toast.ToastType.Infor
				duration {integet}: number of millisecond the toast appear before being removed. Default: depend on ToastType, set in makeToast()
				@param options {json}. See the makeToast() function for full list of options attribute
					@property duration: toast duration
					@property persistance: true if this toast not be wiped out by basic dismissAll()

			*/
			function showBasicToast(msg, toastType, options) {

				if (depressToastFlag) { //if the Toast not allow to show
					depressToastFlag = false; //turn back the flag
					return;
				}

				// There is no Toast when pages is hidden
				if (document.hidden) return;
				
				// make and show the Toast
				makeToast(msg, toastType, { duration: options?.duration ?? 2000, persistance: options?.persistance ?? false, out: true, cbEnd: options?.cbEnd });
			}
			/** Showing Delayed Toast message, which has only single message. Show the delayed message which usually from loadPage() when toast object has not been initialized. See the makeToast() function for full list of options attribute
			*/
			function showDelayedToast() {

				//delayed message stored in ssData.delayedNotification
				if (!ssData.delayedNotification || ssData.delayedNotification.length === 0) { //if there is no delayed message
					return;
				}
				ssData.delayedNotification.forEach(_msg => {
					showBasicToast(_msg.msg, ToastType.Infor, { duration: _msg.option.duration, persistance: true, cbEnd: _msg.option.cbEnd })
				});
				//clear all delayed Notification
				ssData.delayedNotification.length = 0;
			}

			/* Chained toast class which handle multiple message on the same toast element. The incoming messages can be shown on-the-fly (using showNextToast) until the last one is called using checkoutToast()
			Different from promise() method wich also support to show multiple messages
			*/
			class ChainToasts {
				_localToastElem = null;
				/* constructor and show the initial message, remember the Toast element
					@param options {json}
						- persistance: true if this toast not be wiped out by basic dismissAll()
				 */
				constructor(msg, toastType, options) {
					if (depressToastFlag) { //if the Toast not allow to show
						depressToastFlag = false; //turn back the flag
						this._localToastElem = null;
						return ;
					}

					// There is no Toast when pages is hidden
					if (document.hidden) {
						this._localToastElem = null;
						return ;
					}

					this._localToastElem = makeToast(msg, toastType ?? ToastType.Promise, {persistance: options?.persistance ?? false});
				}

				// show the next Toast message, but this should not be the last one			
				showNextToast(msg, toastType) {
					// if somehow this chain has been checkouted before by the call chainToasts.checkoutToast()
					if (!this._localToastElem || !document.contains(this._localToastElem)) return;

					makeToast(msg, toastType ?? ToastType.Promise, { oldToastElem: this._localToastElem, in: false, out: false });
				}

				// show the last Toast message and counting down to remove Toast element out of DOM
				checkoutToast(msg, toastType) {
					// if somehow this chain has been checkouted before
					if (!this._localToastElem || !document.contains(this._localToastElem)) return;

					makeToast(msg, toastType ?? ToastType.Success, { oldToastElem: this._localToastElem, in: false, out: true });
					//console.log(this);
					this._localToastElem = null; //delete variable
				}
			}

			/* toast.promise let pre-define messages for each state of promise. And this will show pre-defined message corresonding with .then or .catch of the promise
			Usage see: 
				toast.promise( fetchPromise,
				{
					pending: 'Đang lấy dữ liệu dung lượng file',
					success: 'Đã lấy được dữ liệu dung lượng file 👌',
					error: 'Không lấy được dữ liệu dung lượng file 🤯'
					persistance: false
						Set true if this toast not be wiped out by basic dismissAll()
				})
			*/
			function promise(_promise, options) {
				let toastElem = makeToast(options.pending, ToastType.Promise, { persistance: options?.persistance ?? false, out: false });
				_promise.then(_ => {
					document.contains(toastElem) && makeToast(options.success, ToastType.Success, { oldToastElem: toastElem, in: false, out: true })
				}
				)
					.catch(_err => {
						document.contains(toastElem) && makeToast(makeBrk(_err.message) + " " + options.error, ToastType.Error, { oldToastElem: toastElem, in: false, out: true })
					}
					);
			}

			/* Public enum, class and method */
			return {
				depressToast: depressToast,
				ToastType: ToastType, //enum of all toast type
				toastChoices: toastChoices, //json
				getToastConfig: getToastConfig, //this for debug only, can be removed
				setToastMode : setToastMode,
				showToast: showBasicToast,
				showDelayedToast: showDelayedToast,
				ChainToasts: ChainToasts, //class
				promise: promise,
				dismissAll: dismissAll
			}
		}

		/* This function for debug Toast only. Can be removed */
		/* function testToast() {
			const functionThatReturnPromise = new Promise((resolve, reject) => {
				setTimeout(resolve, 2000);
			});

			//create ChainToasts object
			let chainToast = new toast.ChainToasts("Promise is pending");
			functionThatReturnPromise.then(_ => {
				chainToast.showNextToast("Done with 2s wait, now wait 1s more"); //, toast.ToastType.Infor
				return new Promise((resolve, reject) => { // (*)
					setTimeout(resolve, 1000);
					//throw new Error("Test error");
				});
			})
				.then(_ => {
					chainToast.checkoutToast("Promise resolved 👌", toast.ToastType.Success);
					chainToast = null;
				})
				.catch(err => {
					chainToast.checkoutToast("Promise rejected 🤯" + err, toast.ToastType.Error);
				})

			return;
			toast.promise(
				functionThatReturnPromise,
				{
					pending: 'Promise is pending',
					success: 'Promise resolved 👌',
					error: 'Promise rejected 🤯'
				}
			)
		} */

		/* Re-calculate location of ::before pseudo which contain the tooltip 
			parentElem {HTML element}: the element that contains all the descendant element who has tooltip (has attribute data-tooltip)
			options {JSON}: might contain some property
				- container {HTMLElement}: HTML element that tooltip is not allowed to go off its edges. If missing, the default container is top-level div which contains almost all of the page div.[name="divContainer"]
				- selfElem {HTMLElement}: re-position tooltip for this selfElem itself. 
				- fixSmallPopup: fix location for small popup (see UtilityHandles class). If this set to true, selfElem has to set to button that trigger the popup. parentElem set to null
		*/
		function reposTooltips(parentElem, options) {

			let _container = options?.container ?? document.querySelector('[name="divContainer"]');
			let _containerPos = _container.getBoundingClientRect();
			/* Calculate left,right for element {_ttElem} having top/bottom tooltip */
			function calculateTooltipPos(_ttElem) {
				
				let _ttPos = _ttElem.getBoundingClientRect();
				//the element currently invisible (maybe just because its parent invisible), so any calculation is pointless
				if(_ttPos.width == 0) return;

				let fixSmallPopup = options?.fixSmallPopup ?? false;
				//fixSmallPopup to fix location for smallPopup. Otherwise, set for tooltip
				let _ttBeforePos = !fixSmallPopup ? getComputedStyle(_ttElem, '::before') : _ttElem.nextElementSibling.getBoundingClientRect();

				let _ttLocation = _ttElem.getAttribute("data-tooltip-location");
				if (["left", "right", "bottom"].indexOf(_ttLocation) === -1) _ttLocation = "top";

				if (_ttLocation == "top" || _ttLocation == "bottom" || fixSmallPopup) {
					/* //left, right of ::before calculted in the distance from parent
					let _ttBeforeLeft = parseFloat(_ttBeforePos.getPropertyValue("left"));
					let _ttBeforeRight = parseFloat(_ttBeforePos.getPropertyValue("right")); */

					let _ttBeforeWidth = (!fixSmallPopup) ? parseFloat(_ttBeforePos.getPropertyValue("Width")) : _ttBeforePos.width;

					/* Because ::before and ::after was initially set in CSS left:50%, so before all translate, the initial left (before all translate() action) of ::before is (_ttPos.left + _ttPos.width/2) */
					let _ttBeforeInitalLeft = _ttPos.left + _ttPos.width / 2;
					/* if translateX(-50%), then the right, left of ::before changes to (_ttBeforeLeft ± _ttBeforeWidth/2) */
					let _ttBeforeTX50Left = _ttBeforeInitalLeft - _ttBeforeWidth / 2;
					let _ttBeforeTX50Right = _ttBeforeInitalLeft + _ttBeforeWidth / 2;

					// check to see if tooltip goes off on left/right side of container when set 'transform: translateX(-50%)' for it. In the case of going off, calculate --data-translateX which is number of poxel need to move left (if <0) or right(if>0) from initial position (also this overides translateX(-50%)) so that tooltip is positioned inside
					let _elemToFix = (!fixSmallPopup) ? _ttElem : _ttElem.nextElementSibling;
					//with fixSmallPopup, need more property to set for pseudo ::afterm which is a pointing-up triangle
					if (fixSmallPopup) _elemToFix.style.setProperty("--data-translateX-pseudo-after", `${_ttPos.left + _ttPos.width / 2 - 19}px`); //19px is get from trial&error
					if (_ttBeforeTX50Left < _containerPos.left) { //the left side of tooltip go off
						_elemToFix.style.setProperty("--data-translateX", `-${_ttBeforeInitalLeft - _containerPos.left - 5}px`);
					}
					else if (_ttBeforeTX50Right > _containerPos.right) { //the right side of tooltip go off
						_elemToFix.style.setProperty("--data-translateX", `-${_ttBeforeInitalLeft + _ttBeforeWidth - _containerPos.right + 5}px`);
					}
					else { // if it already fit in, remove this style in case it was set last time page resize
						_elemToFix.style.removeProperty("--data-translateX");
						_elemToFix.style.removeProperty("--data-translateX-pseudo-after");
					}
				}
			}
			if (parentElem)
				parentElem.querySelectorAll("[data-tooltip]").forEach(_ttElem => {
					calculateTooltipPos(_ttElem);
				})
			if (options?.selfElem)
				calculateTooltipPos(options.selfElem);
		}

		/* Re-position tooltip for element that hard-code in the page HTML, some element adaptively created by js is not the concern here */
		function reposAllTooltips() {
			/* I. Re-postion for all hard-coded elements having tooltips */
			//adjust tooltip for buttons in extra audio controls
			reposTooltips(document.querySelector('[name="divCtnAudioControl"]'));

			//tooltip for bif total playing time
			reposTooltips(document.getElementById("elmBookTotalDuration"));

			document.querySelectorAll(".havingShortPopup > button").forEach(_elem => reposTooltips(null, { selfElem: _elem, fixSmallPopup: true }));
			//reposTooltips(document.querySelector('[name="divChapterGroupControls"]') );

			/*	TODO: Each time History Back/Forward buttons is click, its tooltip content changes, so might need to re-position for those button to update the changes
			*/

			/* I. Re-postion for all added-by-js elements having tooltips */
			//re-position tooltip for Book Infor svg icons
			reposTooltips(document.getElementById("elmBookInfo"));

			//re-position tooltip for Chapter Infor svg icons
			reposTooltips(document.getElementById("elmChapterInfor"));

			//re-calculate location for Book Kit/Set view checkbox in modalSetting
			//reposTooltips(document.querySelector(".modalPopupContent > :first-child"), {container: document.querySelector(".modalPopupContentWrapper") });
		}
	</script>

	<!-- ***** BIG FUNCTIONS THAT DEAL WITH BOOK DATA, GROUP/CATEGORY ***** -->
	<script>
		"use strict";
		
		/* IMPORTANT FUNCTION to prepare books/chapters data (and related data such as bookKitInfor, xBookGrp, xData) for the page to be built-on. It also create, populate and handle event for ssData.sddBookTitlesList, ssData.sddChaptersList and selBookGrp */
		function BookData() {
			const xBookGrp = ssData.xBookGrp; //abbreviate for xBookGrp
			//ssData.xData = [];
			let xData = ssData.xData; //abbreviate for xData

			/** 
			 *  Useful function using outside
			 */
			/* Function to find the book from xData by bookId */
			const findBookFromId = (bookId) => {
				const _bIdx = ssData.bIds.indexOf(bookId);
				return bookId == -1? null : ssData.xData[_bIdx];
			};

			const statisticsHTML = (_statsData, _forceTextLeft = false) => {
				const _class = _forceTextLeft ? "class='forceTextLeft'" : "";
				return `<span ${_class}>${makeSvgFromSprite("icnSvgChapters",{class:"svg-img-infor"})}<var data-rAlignGroup="chapsCount">${_statsData.chaptersCount}</var>
					${makeSvgFromSprite("icnSvgDuration",{class:"svg-img-infor"})}<var data-rAlignGroup="bDuration">${toHhMmSs(_statsData.totalDur)}</var>
					${makeSvgFromSprite("icnSvgListenTime",{class:"svg-img-infor"})}<var data-rAlignGroup="bListenTime" style="font-size:inherit" attr-duration="${_statsData.totalDur}">${toHhMmSs(_statsData.totalDur / xState.speed)}</var></span>`;
			}
			/* Based on the order of each book set, calculate the rank for each book kit (which actually the rank of avarage order of all book sets belong to a book kit) and save these information in ssData.bookKitInfor. This information will be used to sort bookKits in Setting modal in 'Book Kit view' mode */
			function calculateBookKitRank(_grpLine) {
				let _bookGrps = xBookGrp[_grpLine].grp;
				//grpRanks store rank (order) of each book kit for each group line that user re-arrange
				const bookKitInfor = ssData.bookKitInfor;
				for (let i = 0; i < bookKitInfor.length; i++) {
					let bkInforItemRank = bookKitInfor[i].grpRanks;
					if (!bkInforItemRank || !Array.isArray(bkInforItemRank))
						bookKitInfor[i].grpRanks = new Array(xBookGrp.length).fill(-1); //if not yet created, create new one with all -1
				}

				let _tempRank = bookKitInfor.map(_it => { return { bkId: _it.bkIdx, count: 0, rank: 0 } });
				for (let i = 0; i < _bookGrps.length; i++) {
					let _bkFather = _bookGrps[i].bookKit;
					/* if(_bkFather == undefined){
						// This is the case meta.bookGrp has group config but no book belong to
						toast.showToast(`The group named '${_bookGrps[i].label}', gId='${_bookGrps[i].gId}' in meta.bookGrp has no book belong to. FIXED IT NOWW`, toast.ToastType.Error, {duration:6e4, persistance: true});
						//create some dummy data for the other part of page could work
						_bookGrps[i].bookKit = -1;
						_bookGrps[i].books = [];
						continue;
					} */
					_tempRank[_bkFather].count++;
					_tempRank[_bkFather].rank += i;
				}
				// get the avarage rank of all book sets for each book kit
				_tempRank.forEach( _it => _it.rank = (_it.rank / _it.count).toFixed(2) );
				_tempRank.sort((a, b) => a.rank - b.rank); //sort ranks

				//update rank for the book kit
				for (let i = 0; i < _tempRank.length; i++) {
					let _tempItem = _tempRank[i];
					bookKitInfor[_tempItem.bkId].grpRanks[_grpLine] = { bsCount: _tempItem.count, rank: i, bsHidden: 0 }; //bsCount = book-set count, count number of book sets. bsHidden: book set hidden, count the number of hidden book set(s)
				}
				/* III. Update something more...? */
			}

			/** 
			 *  Main functions of BOOKDATA
			 */

			/* Prepare, collect, update all data (see each step for more detail) for page to work.
			Because of storage and performance reason, some data is store separatedly (such as book group/category is stored in xBookGrp variable, but its configuration like visible/hidden, their display order is stored in xState.grpCfg) and need to gather back to some app variable for the app to work correctly
			This is called one time on init() */
			function prepareData() {
				/* STEP A: unite (shallow copy - of course) all book information (which seperated for the easy of code management) into single variable and update some purposedly missing properties*/
				
				//Merge all single database (each of them is one item in ssData.dbRawData) into big one (xData, xBookGrp) and get the start index of each of after being merged.
				let _idx = 0, _xData = [];
				//Variable {dataSize} is used to built ssData.bookKitInfor and get bookKit father id for each bookSet in xBookGrp 
				let dataSize = [{ idx: 0, name: "", eName: "" }];
				//iterate through each DB file having loadMode cacheLoad(2) or freshLoad(1)
				ssData.jsDBFiles.filter(_dbFile => _dbFile.loadMode > 0).forEach(_dbFile => {
					const _dbFileName = _dbFile.dbName; //the name of DB file also the name of DB variable that file contain, such as data_0 (without '.js' extension)

					//iterate through each bookKit inside DB variable (each DB file has only one DB variable with the same name, such as data_0)
					_dbFile.dbs.forEach(_db => {
						const _CnstData = window[_dbFileName][_db]; //the bookKit data, such as lotr_Data
						if(!_CnstData) return;
						// merge all definition for group book of each book kit into xBookGrp variable
						for (let i = 0; i < xBookGrp.length; i++) {
							xBookGrp[i].grp = xBookGrp[i].grp.concat(_CnstData.meta.bookGrp[i]);
						}

						//add information for the bookKit and the DB variable that contain each book
						_CnstData.books.forEach((_book, i) => _book.dbPath = {file: _dbFileName, bookKit: _db, idx: i});

						// merge all the books information to xData variable
						_xData = _xData.concat(_CnstData.books);
						// return the start index and the name of current book kit in xData
						_idx += _CnstData.books.length;
						dataSize.push( {idx: _idx, name: _CnstData.meta.name, eName: _CnstData.meta.eName} );
					})
				});
				ssData.xData = _xData; //store in session data for extensive use later
				//put books Ids into an array for quick search later 
				ssData.bIds = ssData.xData.map(_book => _book.bookId);
				// appoint the minimum size of a chapter group (which in Vietnamese is Tập) 
				ssData._MIN_TAP_SIZE = 5;

				/* STEP B: restore xSate from localStorage of last session. This has been moved to loadPage() */
				
				/* STEP C: This step to find id of each book and put it in the correspoding group and sub-group for each of the group way defined in const xBookGrp. 
				By the same time, create ssData.bookKitInfor variable
				*/

				/* STEP C1: Group 0 is so much different from the other two group ways, so it need to treat differently 
				By the same time, create ssData.bookKitInfor variable
				*/
				let bookGrpWay = 0; //this special categorization always at index 0
				//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
				let _bookGrpItems = xBookGrp[bookGrpWay].grp;

				let bkInfor = []; //based on xBooGrp[0] to create array of book Kit information
				for (let i = 0; i < _xData.length; i++) {
					let _grpIds = _xData[i].grp[bookGrpWay].split("$"); //in the form "SH.A1$1" or "HP.TAP7$4"
					let _bookGrpItm = _bookGrpItems.find(m => m.gId == "$" + _grpIds[1]); //find the item of _bookGrpItems that has gId is something like $1, $4
					if(!_bookGrpItm){ //if not found because of database error
						toast.showToast(`Book '${_xData[i].title}' has wrong group config at line '${bookGrpWay}'. Group '${_grpIds[1]}' in '${_xData[i].grp[bookGrpWay]}' not found on meta.bookGrp`, toast.ToastType.Error, {duration: 6e4, persistance: true});
						continue;
						//this handle the case that Books has a 'grp' config that meta.bookGrp does not have. The case meta.bookGrp has group config but no book belong to is handled in setting.calculateBookKitRank
					}

					if (!_bookGrpItm.books) _bookGrpItm.books = []; //create array that will store books of this categories, e.g, $1 will store 4 novel (Tieu thuyet) A1->A4 of Sherlock Holmes

					let _bkIdx = dataSize.findIndex((_currVar, _idx) => { return _idx == dataSize.length - 1 ? _currVar.idx >= i : _currVar.idx <= i && dataSize[_idx + 1].idx > i }); //find index of book kit
					//create information for each Book Kit
					if (_bkIdx > -1 && !bkInfor[_bkIdx]) bkInfor[_bkIdx] = { bkIdx: _bkIdx, startIdx: dataSize[_bkIdx].idx, endIdx: dataSize[_bkIdx + 1].idx - 1, label: dataSize[_bkIdx + 1].name };

					if (!_bookGrpItm.hasOwnProperty("bookKit")) _bookGrpItm.bookKit = _bkIdx; //update Book Kit for current Book set. 

					let _bookItem = _bookGrpItm.books.find(m => m.gbId == _grpIds[0]);
					if (_bookItem == undefined) { //if there is no data for this book yet?
						_bookItem = {};
						_bookGrpItm.books.push(_bookItem); //create new item for xBookGrp[0].grp
						_bookItem.gbId = _grpIds[0]; //group book id, part of grp[0]. E.g, grp[0]="SH.A1$1", then gbId="SH.A1"
						//_bookItem.bookId = _xData[i].bookId; //hard-coded 8 chars Book Id
						_bookItem.bName = _xData[i].title; //eTitle
						_bookItem.mc = _xData[i].mc; //mc and year are extra infor to quickly build book item for elmSelBookTitles
						_bookItem.year = _xData[i].year;
						_bookItem.bList = [_xData[i].bookId]; //list of bookId of xData items that is the same book but different MC
					}
					else {
						_bookItem.bList.push(_xData[i].bookId); //just add bookId of this item to book List
					}
				}
				ssData["bookKitInfor"] = bkInfor; //done building ssData.bookKitInfor

				/* STEP C2: Collect group information for grpWay 1,2,.. (other than 0) */
				for (bookGrpWay = 1; bookGrpWay < xBookGrp.length; bookGrpWay++) {
					//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
					let _bookGrpItems = xBookGrp[bookGrpWay].grp;

					for (let i = 0; i < _xData.length; i++) {
						let _grpIds = _xData[i].grp[bookGrpWay]; //in the form "SH.VTC-TT" or "SH.A1"
						let _bookGrpItm = _bookGrpItems.find(m => m.gId == _grpIds); //find the item of _bookGrpItems that has gId is something like "SH.VTC-TT" or "SH.A1"
						if(!_bookGrpItm){ //if not found because of database error
							toast.showToast(`Book '${_xData[i].title}' has wrong group config at line '${bookGrpWay}'. Group '${_xData[i].grp[bookGrpWay]}' not found on meta.bookGrp`, toast.ToastType.Error, {duration: 6e4, persistance: true});
							continue;
						}
					
						if (!_bookGrpItm.books) _bookGrpItm.books = []; //create array that will store books of this categories, e.g, $1 will store 4 novel (Tieu thuyet) A1->A4 of Sherlock Holmes

						let _bkIdx = dataSize.findIndex((_currVar, _idx) => { return _idx == dataSize.length - 1 ? _currVar.idx >= i : _currVar.idx <= i && dataSize[_idx + 1].idx > i }); //find index of book kit
						if (!_bookGrpItm.hasOwnProperty("bookKit")) _bookGrpItm.bookKit = _bkIdx; //update Book Kit for current Book set.		

						let _bookID = _xData[i].bookId;
						let _bookItem = _bookGrpItm.books.find(m => m.bookId == _bookID);
						if (_bookItem == undefined) { //if there is no data for this book yet?
							_bookItem = {};
							_bookGrpItm.books.push(_bookItem); //create new item for xBookGrp[bookGrpWay].grp
							_bookItem.gbId = _bookID; //group book id, currently is stt
							_bookItem.bookId = _xData[i].bookId; //hard-coded 8 chars Book Id
							_bookItem.bName = _xData[i].title; //eTitle;
							_bookItem.mc = _xData[i].mc;
							_bookItem.year = _xData[i].year;
							_bookItem.bList = [_bookID]; //list of bookId of xData items that is the same book but different MC
						}
						else
							_bookItem.bList.push(_xData[i].bookId); //just bookId stt of this item to book List
					}
				}

				/* STEP D: collect all configuration like visible/hidden, their display order is stored in xState.grpCfg to xBookGrp variable */
				if (!xState.grpCfg) xState.grpCfg = {};
				for (let i = 0; i < xBookGrp.length; i++) {
					/* D1. create xState.grpCfg if it has not yet created*/
					if (xState.grpCfg[i] == undefined) {
						xState.grpCfg[i] = { grpLine: i, grpWay: xBookGrp[i].grpWay, grp: [] };
						let _bookGrpItems = xBookGrp[i].grp;
						for (let j = 0; j < _bookGrpItems.length; j++) {
							xState.grpCfg[i].grp.push({ gId: _bookGrpItems[j].gId, label: _bookGrpItems[j].label, bHidden: false });
						}
					}
					/* D2. Update the a) order and b) hidden state of each book set 
					xState.grpCfg (store the order and shown/hidden states for each book set by each group way) has been updated immediately when user click a checkbox or drag&drop an item in Setting.
					Important: Guarantee the integrity between xBookGrp and xState.grpCfg; xBookGrp and the real book in xData
					*/
					else{
						let _bookGrpItems = xBookGrp[i].grp;
						let _xStateCfgs = xState.grpCfg[i].grp;
						if (!Array.isArray(_xStateCfgs) || _xStateCfgs.length == 0) return; //there is no setting for this group line yet

						//temp array store user-setting order for each xBookGrp gId, which will be used for sorting xBookGrp. Also it contains bHidden infor from xState
						let _tmpArrSorted = {}; 
						_xStateCfgs.forEach((_itm, _idx) => _tmpArrSorted[_itm.gId] = [_idx, !!_itm.bHidden, false]); 
						// item of _tmpArrSorted array: array having 3 items: 0--the order of the book, 1--hidden state of the book, 2---flag to mark if this _tmpArrSorted is updated in step D2.1, one that still false after step D2.1 is the redundant item in xState (item in _xStateCfgs but _bookGrpItems does not have)

						/* D2.1 update the xBookGrp's hidden state from xState and add information of newly-added book in xBookGrp that xState not yet had */
						_bookGrpItems.forEach(_itm => {
							if(_tmpArrSorted[_itm.gId]){
								_itm.bHidden = _tmpArrSorted[_itm.gId][1];
								_tmpArrSorted[_itm.gId][2] = true; //mark that this item already updated to xBookGrp
							}
							else{
								// This is the case that xBookGrp has some just-added books that xState does not have in last session. Use MAX_SAFE_INTEGER as fallback value for the order of newly-added book set
								_tmpArrSorted[_itm.gId] = [Number.MAX_SAFE_INTEGER, false];
								//add the newly-added book infor into xState
								_xStateCfgs.push({ gId: _itm.gId, label: _itm.label, bHidden: false });
							}
						});

						/* D2.2: This is the case meta.bookGrp has group config but no book belong to. So we need to remove any orphan item of _bookGrpItems that don't have any book (because that group item might have a typo in gId or other reasons) */
						for(let i= _bookGrpItems.length-1; i>=0; i--)  {
							let _itm = _bookGrpItems[i];
							// grp that don't have any book would have no chance to add the bookKit at step C, so bookKit==undefined
							if(_itm.bookKit == undefined){
								const _errMsg = `The group named '${_itm.label}', gId='${_itm.gId}' in meta.bookGrp has no book belong to. FIXED IT NOWW`;
								_bookGrpItems.splice(i, 1); //remove it out of xBookGrp
								console.error(_errMsg);
								toast.showToast(_errMsg, toast.ToastType.Error, {duration: 6e4, persistance: true});
								
							}
						};

						/* D2.3: remove any item in _xStateCfgs that _bookGrpItems don't have (because that item's book just been removed out of xData) */
						const _removedItems = []; //temp array to store index of _xStateCfgs that to be removed
						for(const  _key in _tmpArrSorted){
							let _tmp = _tmpArrSorted[_key];
							if(!_tmp[2]) _removedItems.push(_tmp[0]); //_xStateCfgs.splice(_tmp[0], 1); //remove
						};
						_removedItems.sort((a,b) => b-a); //sort the index decreasingly
						_removedItems.forEach(_idx => _xStateCfgs.splice(_idx, 1))  //remove

						/* D2.4 sort _bookGrpItems to update the xBookGrp's book ORDER from xState */
						_bookGrpItems.sort((_a, _b) => {
							return _tmpArrSorted[_a.gId][0] - _tmpArrSorted[_b.gId][0];
						});
						
					}
				}
				
				/* E. Calculate Book Kit rank to update to ssData.bookKitInfor */
				for (let i = 0; i < xBookGrp.length; i++) {
					calculateBookKitRank(i);
				}
			
				/* F. calculate book statistics for all books */
				//ssData.allBooksSummary = BookData.prototype.booksStatistics( ssData.xData );
			}

			/*** THIS FUNCTION  FOR grpLine==0 (which in fact 2 level grouping "Book Set > Book > MC" ) 
			 * Adding and grouping books titles to sddBookTitlesList dropdown list for special case (case 0) where books are group in categories, each book may have different MC (e.g, Tay Du Ky, Sherlock Holmes) or different Authors (Buddha sermon) who will be listed into radio buttons.
			Each item of book select box is just represent for real book items in xData array, the real books lies in radios buttons of elmDivMcRadioCtn element
				@hiddenparam bookGrpWay: the order to put the title. For now, this function and next function only serves for bookGrpWay===0  (see xBookGrp, xSate.grpLine, xData.grp), so this parameter is missed
				@param _currBookId: bookId of the current playing book. There is a case that book is playing belong to group that is hidden by user (in setting class). In that case, This parameter is used to show the group and only current book (which is a bit different from user-setting) so that user has smooth experience when listning
				@param _repopulateSDD: true if need to re-populate sddBookTitlesList and then populate radio buttons with popuBooks2RadioButtons(), then finally load the book having bookId = {_currBookId}
					-false: just do the last two work without re-populating sddBookTitlesList
			*/
			function popuGrpBookTitles(_currBookId, _repopulateSDD = false) {
				/** function to generate setting for loading book sets and group of book sets (book kits) into SDD 
				 * @return the full setting for populating sddBookTitlesList SDD. This full setting includes commonn setting, render, callback function and most importantly including data
				*/
				function genGrpBookSddSetting(){
					const bookGrpWay = 0; //this special categorization always at index 0

					//special array that contains books in categories, each book may actually contains some items of xData which are actually the same book, but different MC
					let _bookGrpItems = xBookGrp[bookGrpWay].grp;

					let gStt = 1, kStt = 1; //stt of group and Book Kit
					let sddOptionData=[], sddOptGroup = [];
					for (let j = 0; j < _bookGrpItems.length; j++) {
						let bookGrpItem = _bookGrpItems[j];

						let hideThisGrp = bookGrpItem.bHidden;
						if (hideThisGrp) { //if user wants to hide this group 
							let _idx = -1;
							// search to find if this group contains the current playing book
							bookGrpItem.books.forEach(_bItem => {
								_idx = Math.max(_idx, _bItem.bList.indexOf(_currBookId))
							});
							if (_idx === -1) continue; //stop with this group, go with next one
						}

						//count number of books of this book kit. Note that bookGrpItem.books.length is number of book sets
						const _booksCount = bookGrpItem.books.reduce((bCount, _book) => bCount += _book.bList.length, 0);
						
						sddOptGroup.push( {stt: kStt, gId: bookGrpItem.gId, 
							label: `${int2Roman(kStt++)}. ${bookGrpItem.label}`,
							//disabled: bookGrpItem.gId == "$11", 
							subLabel: `${makeSvgFromSprite("icnSvgBookSets",{class:"svg-img-infor", style:"color:inherit"})}${bookGrpItem.books.length}${_booksCount > bookGrpItem.books.length?" " + makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor", style:"color:inherit"}) + _booksCount : ""}`, attr: {
								"attr-gId": bookGrpItem.gId
							}
						});

						for (let i = 0; i < bookGrpItem.books.length; i++) {
							let _book = bookGrpItem.books[i];

							//if user hides this group, and this book in this group not the current playing book
							if (hideThisGrp && _book.bList.indexOf(_currBookId) === -1) continue;

							//collect Author and MC name from each of book having {stt} stored in _book.bList, into a object looks like: { "author": [ "J. R. R. Tolkien" ], "mc": [ "Mạnh Tuấn", "Rin Mabuko" ] }
							const _propCollect = _book.bList.reduce((_tmpArr, _bookId) => {
								const _aBook = findBookFromId(_bookId);
								const _addProp = propName => {
									if(_tmpArr[propName].indexOf(_aBook[propName])==-1) _tmpArr[propName].push(_aBook[propName])
								}
								_addProp("author"); _addProp("mc");
								return _tmpArr
							}, {author:[], mc: []} );
							
							const _bookKitStatistics = BookData.prototype.booksStatistics(
								_book.bList.map( _bookId => ssData.bookData.findBookFromId(_bookId) )
							);

							//create option
							sddOptionData.push({stt: gStt++, gId: bookGrpItem.gId,
								value: _book.gbId, 
								label: _book.bName,//`${hideThisGrp ? "⚡ " : ""}${addSpace(makeBrk(_book.year))}${_book.bName}`,
								bookSetCount: _book.bList.length,
								year: _book.year,
								author: _propCollect.author,
								mc: _propCollect.mc,
								disabled: hideThisGrp,
								bkStatistics: _bookKitStatistics, //book Kit statistics
								attr: {
									"attr-book-array": JSON.stringify(_book.bList),
									"attr-gId": bookGrpItem.gId
								}
							});
						}
					}

					const addSpace = (str) => { //function to add " " to end of non-empty string
						if(str.trim()) return str.trim() + "&emsp13;"
						else return "";
					}
					//short function to generate svg icon for each author/mc of the author/mc array
					const listProp2Html = (propArray, _iconName) => {
						return propArray.map(prop => `${makeSvgFromSprite("icnSvg" + _iconName,{class:"svg-img-infor " + _iconName})}${prop}`).join(" ");
					}

					//create and return setting for sddBookTitlesList
					return {
						displayOneLine: false,
						maxHeight: 500,
						diacriticsFilterMode: xState?.bookTitlesDiacriticsSearch ?? true,
						//makeSelectKey: "Shift",
						searchBoxPlaceholder: "Tìm trong {_items_length} bộ sách ...",
						options: sddOptionData,
						optgroups: sddOptGroup,
						render: {
							//function to render the option. Below, data-rAlignGroup attribute to mark that element would be right-align vertically across all options (from book to book)
							option: function (data, escape) {
								return `<div class="item-main-div">${data.disabled?"⚡&emsp13;" : ""}<span class="item-slight-details">${addSpace(makeBrk(data.year))}</span><span>${escape(data.label)}</span>${data.bookSetCount > 1 ? " " + makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor"}) + data.bookSetCount: ""}</div>
								<div class="item-2nd-main-div">
									${statisticsHTML(data.bkStatistics, true)}

									<span>${listProp2Html(data.author, "MaleAuthor")}</span>.
									<span>${listProp2Html(data.mc, "Microphone")}</span>
								</div>`;
							},
							select_option: function (option, escape) {
								return option.firstChild.innerHTML; //textContent;
							},
							//function to render the group option label
							optgroup_header: function (data, escape) {
								return `${escape(data.label)}&emsp13;<span class="item-slight-details">${data.subLabel}</span>`;
							},
							'no_results': () => {
								return 'Không tìm thấy bộ sách nào';
							}
						},
						callbacks: {
							//callback function to be invoked when onChange event fire (a new item is selected)
							onChange: function (selectedItem) {
								//console.log(`onChange event: ${selectedItem.value}`);
								popuBooks2RadioButtons(selectedItem.value);
							},
							//callback function to update state of SDD search mode (removed diacritics or exact search)
							diacriticsFilterModeOnChanged: function(newDiacriticsSearchVal){
								xState.bookTitlesDiacriticsSearch = newDiacriticsSearchVal;
							}
						}
					};
				}

				/** popuBooks2RadioButtons: Making radio buttons for each MC voicing a specific book for special case where xState.grpLine =0
					@param _groupId: Id of current group, which look like "SH.A1" 
					@param _bookId: the bookID value used to mark radio button that present current book (something like "ebebb619"). This param is included only on showBookCateory() function to pinpont the current book. The onchange event of sddBookTitlesList will based on the bookLine to know which radio button should be checked when change the book category.
				*/
				function popuBooks2RadioButtons(_groupId, _bookId) {
					let elmInnerMcFlexCtn = document.getElementById("elmInnerMcFlexCtn");
					//console.log("popuBooks2RadioButtons: " + _bookId);

					elmInnerMcFlexCtn.innerHTML = ""; //clear radios button list

					//find item having value == catValue
					const _foundItem = ssData.sddBookTitlesList.items.find(item => item.value == _groupId);
					if(!_foundItem) return console.warn("popuBooks2RadioButtons: not found the item");

					//extract the book list of this book group
					let _bookIdsLst = JSON.parse(_foundItem.getAttribute("attr-book-array"));
					
					if (!_bookId) {
						if (xState.bookLine == undefined) xState.bookLine = 0; //default bookLine is 0
						_bookId = _bookIdsLst[ xState.bookLine >= _bookIdsLst.length ? 0 : xState.bookLine ]; //update to use bookLine
					}

					//Choose the attribute to show as the label of radio box. For most of the book, the same book should have different MC. Except for Budda Sutra, the same Sutra may be sermonized by different preachers
					const _booksLst = _bookIdsLst.map(_book_Id => findBookFromId(_book_Id));
					
					const _uniqueAuthArray = [...new Set(_booksLst.map(_book => _book.author))]; //trim the duplicate
					const _fieldName = _uniqueAuthArray.length === _booksLst.length? "author" : "mc";
					const _inputIdPrefix = "SpeakerMC_book_";
					let _innerH = [];
					for (let i = 0; i < _bookIdsLst.length; i++) {
						const _book_Id = _bookIdsLst[i];
						_innerH.push(`<span><input type="radio" name="SpeakerMC" id="${_inputIdPrefix}${_book_Id}" bookId="${_book_Id}" data-bookLine="${i}"><label for="${_inputIdPrefix}${_book_Id}">${_booksLst[i][_fieldName]}</label></span>`); //${_stt==bStt?"checked":""} 
					}
					elmInnerMcFlexCtn.innerHTML = _innerH.join("");

					//show the radio container if there are more than 1 radio buttons, otherwise hide it
					document.getElementById("elmDivMcRadioCtn").style.display = _bookIdsLst.length > 1 ? "block" : "none";

					//set click event handler for just-added radio buttons using event delegation.
					if(!elmInnerMcFlexCtn.hasAttribute("eventDelegation")){
						elmInnerMcFlexCtn.setAttribute("eventDelegation", true); //mark that event delegation handler already been set
						elmInnerMcFlexCtn.addEventListener("click", function(evt){
							const _target = evt.target;
							//if click on SpeakerMC radio butotn
							if(_target.tagName == "INPUT" && _target.type == "radio" && _target.getAttribute("name") == "SpeakerMC"){
								const _book_id = _target.getAttribute("bookId"); //.match(/\d+/)[0]; //this is book Id value
								
								const _currBook = xAudio.getAttribute("attr-book");
								if (_currBook && _currBook == _book_id) return; //if current radio button is selected, do nothing
								
								changeBook(_book_id);
								//only update book line if there are more than one lines
								if(this.querySelectorAll('input[type="radio"][name="SpeakerMC"]').length > 1) 
									xState.bookLine = parseInt(_target.dataset.bookline);
							}
							evt.stopPropagation(); //stop bublling up the click event, so higher level element (such as Document) of DOM might catch and work improperly
						});
					}

					let _radioButton2Select = elmInnerMcFlexCtn.querySelector(`input[id='${_inputIdPrefix}${_bookId}']`);
					if (!_radioButton2Select) _radioButton2Select = elmInnerMcFlexCtn.querySelector(`input[id='${_inputIdPrefix}${_bookIdsLst[0]}']`);
					_radioButton2Select.click();
				};
			
				/** Function to find groupId which contains the book having _bookId
				 * @param _bookId {8-chars-long string}: the id of the book need to find
				 * @return the group id of the book {_bookId} if found
				 * 	if not found, retuen group id of the very first book in the book list
				 */
				function findGroupIdForBook(_bookId) {
					/* find the groupId from bookId */
					const _findGroupId = (_bookId) => {
						let _foundGrpId = null; //store group ID if found
						//has to use Array.prototype.some() so we can jump all the way out of the nested loops by 'return true' immediately when found groupId
						xBookGrp[0].grp.some(_bookKitItem => { //each _bookKitItem is a bookKit. e.g: LOTR
							return _bookKitItem.books.some(_bookSetItem => { //each _bookSetItem is a bookSet which can be a singgle book or a book group (e.g, LOTR1 has two books read by two MC)
								//for each group, looking in the bList to see if it contains the _bookId
								if(_bookSetItem.bList.includes(_bookId)) {
									//found bookSet containing _bookId
									_foundGrpId = _bookSetItem.gbId; 
									return true; //must return TRUE to stop searching
								}
							});
						});
						//return groupId; null if not found
						return _foundGrpId; 
					}
					let _groupId = _findGroupId(_bookId);

					//if somehow _bookId not belong to any group, choose the first book
					if(!_groupId) {
						_bookId = ssData.xData[0].bookId; //select the first book to be new _bookId
						_groupId = _findGroupId(_bookId);
					}
					return _groupId;
				}

				/* MAIN: Starting populate SDD or Just change the book set */
				//get groupId (book set Id) for the book set that contains _currBookId book.
				const _groupId = findGroupIdForBook(_currBookId);

				if(_repopulateSDD){
					// get the setting including both setting and data
					const _bookListSetting = genGrpBookSddSetting();
					//load the sddBookTitlesList. By the same time select the book set that contains current _bookId, this in-turn will invoke ssData.sddBookTitlesList.callbacks.onChange() function, which invoke popuBooks2RadioButtons(_groupId)
					ssData.sddBookTitlesList.loadDropdown(_bookListSetting, ssData.sddChaptersList.LOAD_MODE_ENUM.All, _groupId);
				}
				else{
					// change to the new book set which contains the book having bookId = _bookId
					ssData.sddBookTitlesList.value = _groupId;
					// Even above assignment does not invoked onChange() callback, but we should not call ssData.sddBookTitlesList.onchange() since this just invoke popuBooks2RadioButtons one more redundant time.
				}

				//populate radio buttons if there are more than one books in this book set
				//NOTE that in ssData.sddBookTitlesList.loadDropdown few line above, function popuBooks2RadioButtons(_groupId) is invoked one time with one parameter, this invoke again with two parameters
				popuBooks2RadioButtons(_groupId, _currBookId);
			}			

			/*** THIS FUNCTION FOR grpLine > 0 (=1 or 2) which is just one level grouping "MC > Book" or "Book > MC". 
				adding and grouping books titles to dropdown list 
				@param _bookId {8-chars-string}: the book Id
				@param _bookGrpWay {1 or 2}: the order to put the title. For now, there are two type of order, see xBookGrp, xSate.grpLine, xData.grp
			***/
			function popuBookTitles(_bookId, _bookGrpWay) {
				if (_bookGrpWay == 0) { return; } //this should never happen, it have been taken care of at init() and selBookGroup.onchange() function, so that this function only work with bookGrpWay =1 or larger

				//hide the radio-buttons container which display the options for different Author or MC of the same book title
				document.getElementById("elmDivMcRadioCtn").style.display = "none";

				let xGrpLbl = xBookGrp[_bookGrpWay].grp, gStt = 1, kStt = 1;
				let sddOptionData=[], sddOptGroup = [];

				for (let j = 0; j < xGrpLbl.length; j++) {
					let bookGrpItem = xGrpLbl[j].books;

					let hideThisGrp = xGrpLbl[j].bHidden;
					let _idx = -1;
					if (hideThisGrp) { //if user wants to hide this group 
						// search to find if this group contains the current playing book (having stt = _currBook)
						bookGrpItem.forEach((_bItem, _idex) => {
							if (_bItem.gbId == _bookId) _idx = _idex
						});
						if (_idx === -1) continue; //stop with this group, go with next one
					}

					// add information for optGroup to setting
					sddOptGroup.push( {stt: kStt, gId: xGrpLbl[j].gId, 
						label: `${int2Roman(kStt++)}. ${xGrpLbl[j].label}`, 
						subLabel: `${bookGrpItem.length}`
					});

					for (let i = 0; i < bookGrpItem.length; i++) {
						if (hideThisGrp && _idx != i) continue; //if user want to hide the group, and book in index i is not current book

						/* let bIndex = bookGrpItem[i].gbId - 1; //book Index in xData is book Stt - 1
						let _xData = ssData.xData;
						 */
						//create option
						const _book = findBookFromId(bookGrpItem[i].bookId); // _xData[bIndex];
						//calculate book statistics if it not yet generated
						if(!_book.hasOwnProperty("statistics"))
							BookData.prototype.bookStatistics(_book);
						//add options setting data for sddBookTitlesList
						sddOptionData.push({stt: gStt++, 
							gId: xGrpLbl[j].gId,
							value: _book.bookId, 
							label: _book.title,
							year: _book.year,
							author: _book.author,
							mc: _book.mc,
							bStatistics: _book.statistics,
							disabled: hideThisGrp
						});
					}
				}

				const addSpace = (str) => { //function to add " " to end of non-empty string
					if(str.trim()) return str.trim() + "&emsp13;"
					else return "";
				}

				//create setting for sddBookTitlesList
				const _bookListSetting = {
					displayOneLine: false,
					diacriticsFilterMode: xState?.bookTitlesDiacriticsSearch ?? true,
					//makeSelectKey: "Ctrl",
					searchBoxPlaceholder: "Tìm trong {_items_length} quyển sách ...",
					options: sddOptionData,
					optgroups: sddOptGroup,
					render: {
						//function to render the option
						option: function (data, escape) {
							return `<div class="item-main-div">${data.disabled?"⚡&emsp13;" : ""}<span class="item-slight-details">${addSpace(makeBrk(data.year))}</span><span>${escape(data.label)}${data.bStatistics.chapGroupsCount? " " + makeSvgFromSprite("icnSvgChapGroupIcon",{class:"svg-img-infor"}) + data.bStatistics.chapGroupsCount:""}</span></div>
							<div class="item-2nd-main-div">
								${statisticsHTML(data.bStatistics, true)}
								
								<span>${makeSvgFromSprite("icnSvgMaleAuthor",{class:"svg-img-infor MaleAuthor"})}${data.author}</span>
								<span>${makeSvgFromSprite("icnSvgMicrophone",{class:"svg-img-infor Microphone"})}${data.mc}</span>
							</div>`;
							//return `<span>${escape(data.label)}</span>`;
						},
						//function to render the selected option to representative DIV
						select_option: function (option, escape) {
							return option.firstChild.innerHTML; // textContent;
						},
						//function to render the optGroup
						optgroup_header: function (data, escape) {
							return `<span>${escape(data.label)}</span>&emsp13;<span class="item-slight-details">${makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor", style:"color:inherit"})}${escape(data.subLabel)}</span>`;
						},
						'no_results': () => {
							return 'Không tìm thấy quyển sách nào';
						}
					},
					callbacks: {
						//callback function to be invoked when onChange event fire (a new item is selected)
						onChange: function (selectedItem) {
							//console.log(`onChange event: ${selectedItem.value}`);
							changeBook(selectedItem.value);
						},
						//callback function to update state of SDD search mode (removed diacritics or exact search)
						diacriticsFilterModeOnChanged: function(newDiacriticsSearchVal){
							xState.bookTitlesDiacriticsSearch = newDiacriticsSearchVal;
						}
					}
				};

				//load the sddBookTitlesList
				ssData.sddBookTitlesList.loadDropdown(_bookListSetting, ssData.sddBookTitlesList.LOAD_MODE_ENUM.All, _bookId);

				//ssData.sddBookTitlesList.value = _bookId; //restore the last book to be selected
				//ssData.sddBookTitlesList.onchange(); //make change. Note that onchange() is an alias of onChange(), but require no param
			}

			/** Short function to select the current book (WITHOUT re-populating Book list) for different case of Group Way (grpLine) 
			 * @param _bookId {8-chars-string}: the book Id
			 * @param _bookGrpWay {0 or 1 or 2}: the groupWay to group or sort books, which is 0 1 2
			*/
			function goGetBook(_bookId, _bookGrpWay) {
				if (_bookGrpWay == undefined) _bookGrpWay = xState.grpLine;
				if (_bookGrpWay == 0) {
					// WITHOUT re-populating the sddBookTitlesList for grpWay = 0, it just populates the radio-buttons (if they are more than one) and load the current book
					popuGrpBookTitles(_bookId, false);
				}
				else {
					//popuBookTitles(_bookId, _catLine);
					ssData.sddBookTitlesList.value = _bookId; //restore the last book to be selected
					ssData.sddBookTitlesList.onchange(); //make change. Note that onchange() is an alias of onChange()
				}
			}

			//populate the list which show the name of three way (3 _bookGrpWay) to group books, the select element look like a button having icon being a shelf of standing books
			let selBookGroup = document.getElementById("selBookGroup");
			(function populate_selBookGroup() {
				let _defGrpLabels = xBookGrp.map(_ => { return _.grpWay }); //get list of group name
				selBookGroup.innerHTML = "";// .options.length = 0; //clear the combobox
				for (let i = 0; i < _defGrpLabels.length; i++) {
					let opt = document.createElement('option');
					opt.value = i;
					opt.innerHTML = makeBrk(pad(i + 1, 2)) + " " + _defGrpLabels[i]; //"&nbsp;" + 
					selBookGroup.appendChild(opt);
				}
			})();

			//selBookGroup.addEventListener('change', selBookGroup_onchange, true);
			/* function to handle change the way to group book titles. Note that this function just change appearance of book list box, it does NOT touch to chapter and what is currently playing
			 */
			selBookGroup.onchange = () => {
				//I. save new grpLine to xState
				const newGrpIdx = xState.grpLine = parseInt(selBookGroup.value);

				/* II. Main job: Make the changing-chains */
				let _currBookId = xAudio.getAttribute("attr-Book"); //get the current book

				//_currBook can be null or undefined when page first loaded, which is called from bookDataInitial -> selBookGroup.onchange()
				if(!_currBookId) _currBookId = xState["lb"]; //xState["lb"] has been checked valid and (re)set in bookDataInitial

				//show/hide corresponding radio-buttons container element
				if (newGrpIdx == 0) { //for grpLine 0
					//populate the sddBookTitlesList for grpWay = 0, populate the radio-buttons (if they are more than one) and load the current book
					popuGrpBookTitles(_currBookId, true);					
				}
				else { //for grpLine 1 & 2
					//populate the sddBookTitlesList and load the current book for grpWay = 1 or 2
					popuBookTitles(_currBookId, newGrpIdx);
				}

				// Notify user
				toast.showToast(xBookGrp[newGrpIdx].grpWay, null, {persistance: true});

				/* III. Resize selBookGroup width with the content of selected item */
				let _sel = document.createElement('select');
				_sel.css({ "font-size": selBookGroup.css("font-size") }); //make font size the same as the main select
				_sel.innerHTML = "<option>" + pad(newGrpIdx + 1, 2) + "</option>"; //&nbsp;
				document.body.appendChild(_sel);
				selBookGroup.style.width = (_sel.offsetWidth - 2) + "px";
				_sel.remove();

				/* IV. Update spinner svg icon (which is a book with small micro) of sddBookTitlesList to match the new color */
				let oldBgrndImg = window.getComputedStyle(document.body).getPropertyValue('--book-micro-svg-bground');
				let oldBgrndColor = oldBgrndImg.match(/fill=\'([^\']+)\'/); //.match(/fill\%3D\%22([^\%]+)\%22/); //search for fill property in background image
				if (!oldBgrndColor) return; //not found, out
				oldBgrndColor = oldBgrndColor[1]; //svg icon old color
				let bdrColor = window.getComputedStyle(document.body).getPropertyValue('--select-book-group-color').replace("#", "%23"); //get border color of sddBookTitlesList
				document.body.style.setProperty('--book-micro-svg-bground', oldBgrndImg.replace(oldBgrndColor, bdrColor)); //make svg icon has same color with border

				/* V. Glowing the BooksList element so user know the changes */
				//if(ssData.sddBookTitlesList) SddDropdown.prototype.glowingElem(ssData.sddBookTitlesList.displayElement)
				if(ssData.sddBookTitlesList) ssData.sddBookTitlesList.glowing();
			}

			//Initialize book Data, populate and assign	event handler for following listbox: sddBookTitles, sddChapters and selBookGroup. This is invoked one time in init when creating bookData obj
			prepareData(); //collect all data to xData and xBookGrp

			/** 
			 *  BookData prototype functions
			 */

			/* Create real media links, cover image, original (outside) url,... for parts that have wildcart. For now, there are two kinds of wildcart:
			- book wildcart: the setting is set in "wc" attribute of the books. See data-beautify.js for the format of this setting
			- chapter wildcart: the setting is set in a chapter and effect consecutive chapters untils there is other setting in a sub-sequent chapter or a terminate-setting with wc.url=[], wc.img="". You need to check the code below for more.
			Note: These information is not created from beginning for all books, it is only being created each time a book is open inside changeBook() function.
			In future, if there is anything else can be wild-cart, this function need to be update to handle those wildcart things
			*/
			BookData.prototype.generateWCLinks = function(_bookId){
				/* function to check if a str is a full url */
				const isUrl = str => {
					if(!str) return false;
					return str.match(/^https?\:\/\//)
				};

				/* Function to generate data from wild-cart for wild-cart that set in chapter. Note that this function is invoked ONLY when in book metadata does not have attribute "wc" 
				FORMAT INFORMATION: Format of CHAPTER "wc" setting in database
					"wc": {
						"url": [
							{
								"urlLine": 0, //urlLine, there may be multiple urlLine 1,2,3,..
								"startNum": 0, //the number which is the start for auto-increasing-number replacement into the position of wildCartStr <*~~*>
								"nd": -1, //number of digits: define the length of auto-number, 0 will be padding to auto-number. E.g, nd=2, startNum = 1, so <*~~*> will be replaced with "01"
								"wcSrc": "...<*~~*>.mp3" //wild-cart source, the source must contain wildCartStr <*~~*> for replacement
							},
							{
								Other urlLine. Must have "urlLine" property. If "wcSrc" of any urlLine is set to "", null, or undefined. It will terminate that url line
							}
						],
						"img": "...", //src for workart img replacement. "img" may not contain wildCartStr <*~~*>, in that cases, all subsequent chapters would have the same workart img until a chapter has new setting for this "img" attribute
						
						"oUrl": "...<*~~*>" //outside link. Similar to "img", but this must contain wildCartStr <*~~*>. Extra infor: If a chapter (not this wc.img, wc.oUrl setting) has "img" attribute () but doesn't have "oUrl", when doing replacement, app will use value of "img" of that chapter
					}
				NOTE: wild-cart for title is NOT set in "wc" setting, it is rather set in chapter.tit attribute itself (because title changes much more frequently than url, img or oUrl)
				*/
				const chapterWildCart = function(bData){
					//if (!bData.wc || bData.wcDone) return; //if not wildcart specified, or already creating real links from wildcart, then do nothing
					let bParts = bData.parts;
					
					const wildCartStr = ssData.wildCartStr;

					/* Generate tittle from Wildcart */
					let _subsetWC = null, _subsetCounter = 0;
					let _wcLen = 1;
					for (let i = 0; i < bParts.length; i++) {
						if(bParts[i].tit == undefined) {
							//if _subsetWC was set by previous chapter, use the wild-cart
							if(_subsetWC && _subsetCounter)
							bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
						}
						// first chapter of the group that contains wild-cart
						else if(bParts[i].tit.includes(wildCartStr)){
							_subsetWC = bParts[i].tit; //set the wild-cart string for continuously subsequent chapters
							if(bParts[i].hasOwnProperty('titStartNum'))_subsetCounter = Number(bParts[i].titStartNum);
							else _subsetCounter = 1; //title always start with 1
							bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
						}
						else{
							/* // normal chapter, clear all the wild-cart identifier
							_subsetWC = null;
							_subsetCounter = 0; */

							// for normal chapter, keep the old _subsetWC and keep increasing _subsetCounter in case after some chapters that specify titles, there are bunch of undefined titles behind. So we don't need to re-defind wildcart titles for those undefined-title chapter
							_subsetCounter++;
						}
						
					}

					//create real audio links from wildcart
					let _wcLinks = []; //contains setting for current urlLine
					//_wcLen = _wc.length;
					let _wcImg = "", _wc_oUrl = "";
					for (let i = 0; i < bParts.length; i++) {
						const chapData = bParts[i];

						/* 1. make urls from wild-cart */

						//1a. if this chapter contains url setting for some adjacent chapters, update the setting
						if(chapData.wc && chapData.wc.hasOwnProperty("url")){ 
							const _wcUrls = chapData.wc.url;

							// a setting wc.url=[] in a chapter mark that chapter is the end of the last wc.url setting
							if(_wcUrls.length == 0) _wcLinks=[]
							else
							//update new setting for each urlLine. Note that the urlLine in old setting that new setting does not have will be kept for using
							_wcUrls.forEach(_jUrl => {
								//find the old setting for current urlLine from old _wcLinks
								const _oldIdx = _wcLinks.findIndex(_w => _w.urlLine === _jUrl.urlLine);
								//remove the old setting
								if(_oldIdx > -1) _wcLinks.splice(_oldIdx, 1);

								// wcUrl that has no wcSrc or wcSrc is set to "" or null is the one that mark the terminate of that urlLine.
								// Note that if this {urlLine} is not the last line, if we don't push this null wild-cart to _wcLinks array and 'chapData.url === undefined' (see few line of code below), when initiate 'chapData.url = Array(_wcLinks.length).fill("")', the _wcLinks[j].urlLine (in the wild-cart) and the index of item in chapData.url array would be miss-matched
								if(!_jUrl.wcSrc) _jUrl.wcSrc = null;

								//add new setting (or replace the old one which was spliced out)
								_wcLinks.push(_jUrl); 
								// startNum store the number that add to wild-cart in auto-wilcard links
								if(!_jUrl.hasOwnProperty("startNum")) _jUrl.startNum = 1; //default start from 1								
							});
						}

						//1b. generate url for each chapter from wild-cart
						//if there is _wcLinks empty, there nothing to wild-cart
						if(Object.keys(_wcLinks).length > 0) {

							// if url is missing, meaning its is array of empty string
							if(chapData.url === undefined) chapData.url = Array(_wcLinks.length).fill("");
							//first of all, convert url to array it is not
							if (!Array.isArray(bParts[i].url)) chapData.url = [chapData.url];
							let _chapUrls = chapData.url;

							for (let j = 0; j < _wcLinks.length; j++) {
								let urlLine = _wcLinks[j].urlLine;
								_wcLinks[j].startNum++; //increase startNum for each chapter, no matter how its url would be wild-carted

								// of the line {urlLine} if wild-cart link is null and chapter url for that line is not full url, we have no way to construct full url for this line, so make it null, so that at the end of this code block, we removed it out of url array
								if(!_wcLinks[j].wcSrc && !isUrl(_chapUrls[urlLine])) {
									_chapUrls[urlLine] = null;
									continue;
								}

								// Case 1: if link is null, there is no link, just remove it out of url array
								if (_chapUrls[urlLine] == null) {
									//because sometime null url is at index 0, so we need to  remove them from this later to avoid messing the array
									continue;
								}

								//Case 2: if the link is empty string, using stt (chapter index + 1) to fill in wild-cart
								if (_chapUrls[urlLine] == "") {
									_chapUrls[urlLine] = _wcLinks[j].wcSrc.replaceAll(wildCartStr, pad(_wcLinks[j].startNum - 1, _wcLinks[j].nd)); //note that chaper link most of the time start from 1 (not 0)
									continue;
								}

								//Case 3: if url is not empty, but not the full url link
								if (!isUrl(_chapUrls[urlLine])) {
									// use current url to fill in the wild-cart to get full link
									_chapUrls[urlLine] = _wcLinks[j].wcSrc.replaceAll(wildCartStr, _chapUrls[urlLine]);
									//console.log(_chapUrls[urlLine]);
								}

								//Case 4: if url is full url link, do nothing
							}

							//remove null link. Because splice() function change the index of array, so we go from back to beginning
							for (let j = _wcLinks.length - 1; j >= 0; j--) {
								let urlLine = _wcLinks[j].urlLine;
								if (_chapUrls[urlLine] == null) {
									//if null, meaning this chapter of this line does not have real link
									_chapUrls.splice(urlLine, 1); //remove this from array since there's no link for this line
								}
							}
						}
						
						/* 2. update the outside URl */
						//if this chapter has setting for oUrl, update it
						if(chapData.wc && chapData.wc.hasOwnProperty("oUrl"))
							_wc_oUrl = chapData.wc.oUrl;
						//only making wild-cart generator when _wc_oUrl is actual url
						if(_wc_oUrl && isUrl(_wc_oUrl)) {
							let _rplcUrl = chapData.oUrl || chapData.img; //take img if there is no oUrl for replacement
							if(_rplcUrl) chapData.oUrl = _wc_oUrl.replace(wildCartStr, _rplcUrl);
						}

						/* 3. update the cover image */
						//if this chapter has setting for img, update it
						if(chapData.wc && chapData.wc.hasOwnProperty("img"))
							_wcImg = chapData.wc.img;

						//a setting wc.img ="" or not full url mark this chapter is the end of last setting of old wc.img wildcart
						if(_wcImg && isUrl(_wcImg)) {

							//img wild-cart does not has any wild-cart
							if(_wcImg.indexOf(wildCartStr) === -1 ){
								if(!isUrl(chapData.img)) chapData.img = _wcImg;
							}
							else {
								//no img link at all (chapData.img == undefined, null, "") then there nothing todo. OR if img is full link, keep it that way.
								if (chapData.img && !isUrl(chapData.img)) {
									let _tmpSrc = _wcImg.replace(wildCartStr, chapData.img);
									//if it is youtube image, use high res, 16:9 thumbnail but might not always exist, so we need the error handler on cover image element which is on elmArtwork.onload()
									if(_tmpSrc.match(/ytimg\.com\/vi/)){
										//if there is youtubeId in img property, use this YoutubeId to make a mp3 link
										if(!chapData.hasOwnProperty("url")) chapData.url = []
										else if(!Array.isArray(chapData.url)) chapData.url = [chapData.url];

										const _convertedLink = `https://ph.tinhtong.vn/Home/GetAudioYoutube/${chapData.img}`;
										if(!chapData.url.includes(_convertedLink)) chapData.url.push(_convertedLink);

										//update img property to full url
										chapData.img = _tmpSrc.replace(/([^\/])+$/, "hq720.jpg");
									}
									else chapData.img = _tmpSrc;
								}
							}
						}
					}
				}

				/* Function to generate data from wild-cart set in Book Metadata 
				FORMAT INFORMATION: Format of BOOK "wc" in database is very much similar to CHAPTER "wc" setting (see comments of chapterWildCart function above) except that for now urlLine doesn't have startNum attribute
				*/
				const bookWildCart = function(bData){
					
					const wildCartStr = ssData.wildCartStr;
					let bParts = bData.parts;

					//create titles from wildcart set for all chapters of this book
					if (bData.wc.tit) {
						let _wc = bData.wc.tit;
						let _wcLen = 1; //(bParts.length + "").length;
						for (let i = 0; i < bParts.length; i++) {
							if(bParts[i].tit == undefined) bParts[i].tit = _wc.replaceAll(wildCartStr, pad(i + 1, _wcLen)) + (i == bParts.length-1? " (Hết)" :"");
						}
					}
					else {
						// Some book (especially buddha sutra), there are some group of continuous chapter having same name (because they are belong to same part of the book), we can wild-cart this sub-group of chapter
						let _subsetWC = null, _subsetCounter = 0;
						let _wcLen = 1;
						for (let i = 0; i < bParts.length; i++) {
							if(bParts[i].tit == undefined) {
								//if _subsetWC was set by previous chapter, use the wild-cart
								if(_subsetWC && _subsetCounter)
								bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
							}
							// first chapter of the group that contains wild-cart
							else if(bParts[i].tit.includes(wildCartStr)){
								_subsetWC = bParts[i].tit; //set the wild-cart string for continuously subsequent chapters
								_subsetCounter = 1; //title always start with 1
								bParts[i].tit = _subsetWC.replaceAll(wildCartStr, pad(_subsetCounter++, _wcLen));
							}
							else{
								// normal chapter, clear all the wild-cart identifier
								_subsetWC = null;
								_subsetCounter = 0;
							}
							
						}
					}

					//create real audio links from wildcart
					if (bData.wc.url) {
						let _wc = bData.wc.url;
						let _wcLen = _wc.length;
						for (let i = 0; i < bParts.length; i++) {
							// if url is missing, meaning its is array of empty string
							if(bParts[i].url === undefined) bParts[i].url = Array(_wcLen).fill("");
							//first of all, convert url to array it is not
							if (!Array.isArray(bParts[i].url)) bParts[i].url = [bParts[i].url];
							let _chapUrls = bParts[i].url;

							for (let j = 0; j < _wc.length; j++) {
								let urlLine = _wc[j].urlLine;

								// Case 1: if link is null, there is no link, just remove it out of url array
								if (_chapUrls[urlLine] == null) {
									//because sometime null url is at index 0, so we need to  remove them from this later to avoid messing the array
									continue;
								}

								//Case 2: if the link is empty string, using stt (chapter index + 1) to fill in wild-cart
								if (_chapUrls[urlLine] == "") {
									_chapUrls[urlLine] = _wc[j].wcSrc.replaceAll(wildCartStr, pad(i + 1, _wc[j].nd)); //note that chaper link most of the time start from 1 (not 0)
									continue;
								}

								//Case 3: if url is not empty, but not the full url link
								if (!isUrl(_chapUrls[urlLine])) {
									// use current url to fill in the wild-cart to get full link
									_chapUrls[urlLine] = _wc[j].wcSrc.replaceAll(wildCartStr, _chapUrls[urlLine]);
									//console.log(_chapUrls[urlLine]);
								}

								//Case 4: if url is full url link, do nothing
							}

							//remove null link. Because splice() function change the index of array, so we go from back to beginning
							for (let j = _wc.length - 1; j >= 0; j--) {
								let urlLine = _wc[j].urlLine;
								if (_chapUrls[urlLine] == null) {
									//if null, meaning this chapter of this line does not have real link
									_chapUrls.splice(urlLine, 1); //remove this from array since there's no link for this line
								}
							}
						}
					}

					//create real outer original links (usually youtube) from wildcart. For youtube link, the yt ID mostly got from bParts[i].img (because most of the case, img and oUrl has the same YT Id). So, this snippet has to be put before the snipet that update the img property (right below)
					if (bData.wc.oUrl) {
						let _wc2 = bData.wc.oUrl;
						for (let i = 0; i < bParts.length; i++) {
							let _rplcUrl = bParts[i].oUrl || bParts[i].img; //take img if there is no oUrl for replacement

							if (_rplcUrl == undefined) continue;

							//if oUrl not the full url and not empty
							if (_rplcUrl !== "" && !isUrl(_rplcUrl))
								bParts[i].oUrl = _wc2.replace(wildCartStr, _rplcUrl);
						}
					}

					//create real chapter cover from wildcart
					if (bData.wc.img) {
						let _wc1 = bData.wc.img;
						for (let i = 0; i < bParts.length; i++) {
							if (bParts[i].img == undefined) continue; //no img link at all
							// if img is full link, keep it that way
							if (isUrl(bParts[i].img)) continue;

							if (bParts[i].img != "") {
								let _tmpSrc = _wc1.replace(wildCartStr, bParts[i].img);
								//if it is youtube image, use high res, 16:9 thumbnail but might not always exist, so we need the error handler on cover image element which is on elmArtwork.onload()
								if(_tmpSrc.match(/ytimg\.com\/vi/)){
									//if there is youtubeId in img property, use this YoutubeId to make a mp3 link
									if(!bParts[i].hasOwnProperty("url")) bParts[i].url = []
										else if(!Array.isArray(bParts[i].url)) bParts[i].url = [bParts[i].url];
										const _convertedLink = `https://ph.tinhtong.vn/Home/GetAudioYoutube/${bParts[i].img}`;
										if(!bParts[i].url.includes(_convertedLink)) bParts[i].url.push(_convertedLink);

									//update img property to full url
									bParts[i].img = _tmpSrc.replace(/([^\/])+$/, "hq720.jpg");
								}
								else bParts[i].img = _tmpSrc;
							}
						}
					}
				}

				let bData = findBookFromId(_bookId); //bData contains all information for current book
				if (bData.wcDone) return; //if not wildcart specified, or already creating real links from wildcart, then do nothing
				bData.wcDone = true; //mark that Wildcart already done

				//create tap attribute for book that has "autoTap"
				if(bData.hasOwnProperty("autoTap") && !bData.hasOwnProperty("tap")){
					const _TapSize = parseInt(bData["autoTap"]);
					//const _MIN_TAP_SIZE = 5; //this has been moved to ssData
					if(isNaN(_TapSize) || _TapSize < ssData._MIN_TAP_SIZE) _TapSize = ssData._MIN_TAP_SIZE;
					let _tapArray = [], _datLen = bData.parts.length, _from = 1, _grp = 1;
					while(_from < _datLen){
						let _to = Math.min( _from + _TapSize - 1, _datLen);
						//if very last group has too little books, merges it to previous one
						if(_datLen-_to > 0 && _datLen-_to < Math.floor(_TapSize/2)) _to = _datLen;
						_tapArray.push({"label": `Nhóm ${int2Roman(_grp++)}: Chương ${_from} đến chương ${_to}`, "f": _from, "t": _to});
						_from = _to + 1;
					}
					bData.tap = _tapArray;
				}								

				//only invoke chapterWildCart if book has no attribute "wc"
				if (!bData.wc) return chapterWildCart(bData)
				else bookWildCart(bData);
			}
			
			/** Handy function to calculate the total duration for a book from a chapter number to the end of the book. If calculate for the whole book, result will be saved into statistics attribute book data. Next time calculate for whole book again, the result will get from book data without re-calculating.
			 * @param bData {jSon, string}: if bData type is string, it is bookId. Otherwise, it is json data of the whole book
			 * @param fromChap: the chapter number, which is its index in the chapter list PLUS 1, that the summation start to the end of the book
			 * @return {totalDur: total duration, chaptersCount: number of chapters being counted} 
			 * also, add statistics attribute into book data with the same format.
			 */
			BookData.prototype.bookStatistics = (bData, fromChap) => {
				
				if(typeof bData == "string") bData = findBookFromId(bData);
				if(!bData) return {totalDur: 0,chaptersCount: 0} ;
				fromChap = fromChap ?? 1; //if fromChap not specified, start from very first chapter

				let totalDuration = 0, chapterGroupCount = 0;
				//if calculate for whole book and it is calulated before whose result saved in bData.totalDur, use that saved result without re-calculating
				if(fromChap === 1 && bData.hasOwnProperty("statistics")){
					totalDuration = bData.statistics.totalDur;
				}
				else
					//calculte total Duration
					for (let i = fromChap; i <= bData.parts.length; i++) {
						totalDuration += toSeconds(bData.parts[i-1].dur); 
					}

				//if calculate for whole book, save the result in book metadata for next use
				if(fromChap === 1 && !bData.hasOwnProperty("statistics")){
					const _chapsCount = bData.parts.length;
					bData.statistics = {totalDur: totalDuration, chaptersCount: _chapsCount};
					if(bData.hasOwnProperty("tap") && Array.isArray(bData.tap)) bData.statistics.chapGroupsCount = bData.tap.length
					else if(bData.hasOwnProperty("autoTap")){
						//this calculation has to match the heuristic to generate chapters groups in BookData.prototype.generateWCLinks()
						const _TapSize = parseInt(bData["autoTap"]);
						if(isNaN(_TapSize) || _TapSize < ssData._MIN_TAP_SIZE) _TapSize = ssData._MIN_TAP_SIZE;
						bData.statistics.chapGroupsCount = Math.floor(_chapsCount/_TapSize) + (_chapsCount % _TapSize >= ssData._MIN_TAP_SIZE? 1 : 0);
					}
				}

				return {totalDur: totalDuration, chaptersCount: bData.statistics.chaptersCount - fromChap + 1};
			}

			/** Handy function to get statistics for a collection of books. By the same time, it will calculate the total duration for each book at add that value to "totalDur" attribute of its data
			 * @param books {array}: array of book data (which should be subset of ssData.xData)
			 * @return {totalDur: total duration, booksCount: number of books, chaptersCount: number of chapters insides} 
			 */
			BookData.prototype.booksStatistics = (books) => {
				return books.reduce((_accumulator, _book) => {
					_accumulator.booksCount++;

					//Calculate book statistics for _book and stored it in statistics attribute. Note that if statistics calculated before, it will not be calculated again
					const _bSummary = BookData.prototype.bookStatistics(_book);

					//update chapter counts
					_accumulator.chapGroupsCount += _book.statistics.chapGroupsCount ?? 0; //some books do not have chapter group, don't have chapGroupsCount property
					//update chapter counts
					_accumulator.chaptersCount += _book.statistics.chaptersCount;
					//update totalDur to _book data if it not yet existed
					_accumulator.totalDur += _book.statistics.totalDur;

					return _accumulator;
				}, {totalDur: 0, booksCount: 0, chaptersCount: 0, chapGroupsCount: 0} );
			}

			/* Handy function to create unique book Id, which I personally use when making database */
			BookData.prototype.makeUniqueId = _ => {
				const rand = Math.random().toString(16).substr(2, 8);
				//check if it is really unique
				if(ssData.bIds.indexOf(rand) ==-1 ) return rand;

				//return Math.round(Date.now()).toString(36);
			}

			/* Function to check if there is any duplicate in bookId */
			BookData.prototype.checkDuplicateBookId = _ => {
				const duplicates = ssData.bIds.filter((item, index) => ssData.bIds.indexOf(item) !== index);
				if(duplicates.length == 0) toast.showToast("Không có bookId bị trùng")
				else{
					toast.showToast("Có bookId bị trùng. Xem trong cửa số Console về các mã bị trùng.", toast.ToastType.Error);
					console.log(duplicates);
				}
			}
			
			/** 
			 *  Public methods
			 */
			return {
				goGetBook: goGetBook, //function to show a book by specified its stt.
				findBookFromId: findBookFromId, //function to find a book by its bookId
				//generateWCLinks: generateWCLinks //function to generate full information from wildcart
				calculateBookKitRank : calculateBookKitRank
			};
		} //END OF BookDATA CLASS
	</script>

	<!-- MAIN SCRIPT HANDLING THE PAGE -->
	<script>
		"use strict";
		// declare two state variables that would be saved in local-Storage for next session
		let xState = null, xDBFilesCfg = null;

		//session variables that extensively uses, so I don't put them into ssData as other variables and data (see ssData). Instead I make them global variables for shorter code
		let xAudio = document.getElementById("elmMyAudio"); //audio element
		let elmPlaylist = document.getElementById("elmPlaylist"); //Chapter Playlist
		let toast = null; //instance of Toast class that notifies all kinds of toast
		
		function init() {
			/* Initiate obserers (IntersectionObserver, MutationObserver, ResizeObserver) to watch for UI changes, see each observer for more detail */
			function webAPIinit() {
				// initialize playlistObserver to watch for chapter-group-label to pinned at top. For this to work, the label style need to set 'top:-0.1px' (top need less than 0 so when scroll to top, the label got hidden a bit)
				ssData.playlistObserver = new IntersectionObserver((entries, observer) => {
					//can do entries.forEach() to go thorugh all target, but it is not necessary because except fisrt time
					let entry = entries[0];
					// condition 'entry.boundingClientRect.top <= entry.rootBounds.top' is ONLY able to catch the case label enter the top. 
					entry.target.classList.toggle("stickyPinned", (entry.intersectionRatio < 1 && entry.boundingClientRect.top <= entry.rootBounds.top));
					//console.log("IntersectionObserver: " + entry.target.getAttribute("for") + ". " + entry.intersectionRatio );

					/* let _targetlId = entry.target.getAttribute("for"); //or any attribute to identify {target}
					if(entry.isIntersecting){ //from lowerer {entry.intersectionRatio} go through {threshold} to higher one, meaning the {target} just got fully appeared inside the {root}
						//the following code might work only at the case that height of {root} is at least 10% higher than height of {target}.
						if ( (entry.boundingClientRect.top - entry.rootBounds.top)/entry.boundingClientRect.height < 0.05) //if {target} top just go down less than 5% of its height
							console.log(_targetlId + ": leave the top [scroll down]");
						else if ((entry.rootBounds.bottom - entry.boundingClientRect.bottom)/entry.boundingClientRect.height < 0.05) //if {target} bottom just go up less than 5% of its height
							console.log(_targetlId + ": leave the bottom  [scroll up]");
					}
					else //from higher {entry.intersectionRatio} go through {threshold} to lower one, meaning the {target} just got partly hidden by the {root}
					{
						if(entry.boundingClientRect.top <= entry.rootBounds.top) 
							console.log(_targetlId + ": enter the top  [scroll up]");
						else if(entry.boundingClientRect.bottom >= entry.rootBounds.bottom) 
							console.log(_targetlId + ": enter the bottom  [scroll down]");
					} */

				},
					// rootMargin seems has no effect. If we want handle for last label in&out bottom of {root}, change 'threshold: [0.9, 1]'
					{ threshold: [1], root: elmPlaylist, rootMargin: "0px 0px -25px 0px" }
				);

				// MutationObserver object to detect when a new element having tooltip added to page, so js can locate them properly to make it inside the page
				//initiate Tooltip MutationObserver for adjsuting tooltip location
				ssData.ttMutationObserver = new MutationObserver((mutationList, observer) => {
					for (const mutation of mutationList) {
						if (mutation.type === "childList") {
							//console.log(mutation);
							for (const addedNode of mutation.addedNodes) {
								//console.log(addedNode);
								if (addedNode instanceof HTMLElement && addedNode.getAttribute("xrole") === "containing-tooltip") {
									//console.log(addedNode);
									reposTooltips(addedNode);
									observer.disconnect(); //job done, unhook the watching element
								}
							}
						}
						else if (mutation.type === "attributes") {
							//console.log(`The ${mutation.attributeName} attribute was modified.`);
							// console.log(mutation);
							const target = mutation.target;
							// div[name="divOtherControlTop"] which contains checkbox to expand/collapse all chapter-group and check if it is shown (its class .elm-hidden has been removed)
							if (target.getAttribute("name") == "divChapterGroupControls" && !target.classList.contains("elm-hidden"))
								reposTooltips(target);

							// for label[for="allChapGrpChkbox"], #elmHistoryGoBackward, #elmHistoryGoForward buttons when thier tooltip content changes
							if (target.hasAttribute("data-tooltip")) {
								//console.log(target);
								reposTooltips(null, { selfElem: target });
							}
							observer.disconnect(); //job done, unhook the watching element
						}
					}
				});

				/* div[name="divContainer"] has changed its sizes 2 or 3 rounds until page completely rendered, comprises of:
					- 1st round: temp width, temp height. This round is missed in some cases.
					- 2nd round: stable width, temp height
					- 3nd round: stable width, stable height
				So, we utilize ResizeObserver to watch for the last time size-changed to update tooltip location, for any case, after only 2nd round the width got stable */
				let _resizeCount = 0;
				let _mainContentContainer = document.querySelector('[name="divContainer"]');
				let resizeObserver = new ResizeObserver((entries, observer) => {
					//for (let entry of entries) { console.log(entry); }
					_resizeCount++;
					if (_resizeCount == 2) { //at 2nd round
						reposAllTooltips();
						observer.unobserve(_mainContentContainer); //unhook
						observer = null; //remove ResizeObserver object
					}
				});
				resizeObserver.observe(_mainContentContainer);
			}
			webAPIinit(); //init observers to watch for UI changes

			function pageEventHandlers(){
				/* Handle event when page is navigated away, the browser window is minimized, a browser tab is currently in the background, or a system element such as a task switcher obscures the page, task-switching on mobile platforms,... */
				document.addEventListener("visibilitychange", () => {
					if (document.hidden) { //or document.visibilityState=="hidden"
						saveState2Disk();
					} else {
						// Do something when the page got into user's view again
						//saveState();
						//if audio is playing, timeUpdate event will be invoked, so no need to raise it
						ssData.audioPlayer && ssData.audioPlayer.updateTime(true); //update with repaint heavy UI update immediately
					}
				});

				/* keydown event provide short-cut keys for some frequently used functions 
				NOTE: audio hotkeys function created in AudioPlayer class also handles the document's keydown event
				*/
				const pageKeyDown = (evt) => {
					//evt && console.log(evt.code);
					/** hotkey format (see SddDropdown.prototype.runHotkey for more details) */
					//full list of hotkeys with callback functions
					const hotkeyOptions = [

						// Z, ControlRight: open Books List dropdown
						{task: "global_openBooksList", kCode: ["KeyZ", "ControlRight"], desc: "Mở danh sách các tựa sách.", callback: () => {
							ssData.sddBookTitlesList.toggle();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},

						// A, ShiftRight: open Chapters List dropdown
						{task: "global_openChaptersList", kCode: ["KeyA", "ShiftRight"], desc: "Mở danh sách các chương sách.", callback: () => {
							ssData.sddChaptersList.toggle();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},

						// S, Tab: switch mp3 audio sources for current chapter
						{task: "global_switchAudioSource", kCode: ["Tab", "KeyL"], desc: "Đổi phát chương bằng link dự phòng.", callback: () => {
							const _switchSrcBtn = document.querySelector(".switchChapterAudioSrc");
							if(_switchSrcBtn) _switchSrcBtn.click();
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Home: scroll to current playing chapter
						{task: "global_scrollToPlayingChapter", kCode: ["Home"], desc: "Cuộn tới chương đang được phát.", callback: () => {
							utilityHandles.gotoPlayingChapter();
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// J: seeking to an audio time to play
						{task: "global_openSeeking2Time", kCode: ["KeyJ"], desc: "Chọn thời gian phát (Seeking).", callback: utilityHandles.showSeekAudioDurationPopup},

						// S: set sleep timer
						{task: "global_openSleepTimer", kCode: ["KeyS"], desc: "Hẹn giờ tắt.", callback: utilityHandles.showSleepTimerPopup},

						// N: expand or collapse all group chapters
						{task: "global_OpenCloseAllGroupChapters", kCode: ["KeyN"], desc: "Đóng/mở tất cả các nhóm chương.", callback: _ => {
							document.getElementById("allChapGrpChkbox").click()
						}},

						// G: change book Group way
						{task: "global_switchBookGrpWay", kCode: ["KeyG"], desc: "Đổi cách nhóm thứ tự sách.", callback: () => {
							const _selBookGroup = document.querySelector("#selBookGroup");
							if(_selBookGroup) {
								_selBookGroup.value = ( Number(_selBookGroup.value) + 1 ) % _selBookGroup.length;
								_selBookGroup.onchange();
							}
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Q: open Setting modal
						{task: "global_openSettingModal", kCode: ["KeyC", "KeyQ"], desc: "Mở hộp thoại cấu hình.", callback: () => {
							ssData.setting.openSettingModal();
							
							evt.preventDefault();
							evt.stopPropagation();
						}},

						// Shift + PageDown: next book in History List
						{task: "global_historyGoForward", kCode: ["Shift+PageDown"], desc: "Phát quyển sách tiếp theo trong lịch sử nghe.", callback: () => {
							const _elmHistoryGoBtn = document.getElementById("elmHistoryGoForward");
							if(evt.shiftKey && !_elmHistoryGoBtn.classList.contains("elm-disabled"))
								_elmHistoryGoBtn.click()
							}
						}, //PgDown for next chapter  of current book
						// Shift + PageUp: previous book in History List
						{task: "global_historyGoBackward", kCode: ["Shift+PageUp"], desc: "Phát quyển sách ngay trước trong lịch sử nghe.", callback: () => {
							const _elmHistoryGoBtn = document.getElementById("elmHistoryGoBackward");
							if(evt.shiftKey && !_elmHistoryGoBtn.classList.contains("elm-disabled"))
								_elmHistoryGoBtn.click()
							}
						},  //PgUp for previous chapter of current book

						// Alt + PageDown: next book in History List
						{task: "global_bookListNext", kCode: ["Alt+PageDown"], desc: "Phát quyển sách tiếp theo trong danh mục.", callback: () => {
								if(evt.altKey){
									const _nextBook = ssData.sddBookTitlesList.nextItem();
									if(_nextBook)
										// if next book exist, make the change
										ssData.sddBookTitlesList.onchange()
									else
										//not, notify user
										toast.showToast("Đã là quyển sách cuối cùng rồi!", toast.ToastType.Warning);	
								}
							}
						}, //PgDown for next chapter  of current book
						// Alt + PageUp: previous book in History List
						{task: "global_bookListPrev", kCode: ["Alt+PageUp"], desc: "Phát quyển sách ngay trước trong danh mục.", callback: () => {
								if(evt.altKey){
									const _prevBook = ssData.sddBookTitlesList.prevItem();
									if(_prevBook)
										// if previous book exist, make the change
										ssData.sddBookTitlesList.onchange()
									else
										//not, notify user
										toast.showToast("Đã là quyển sách đầu tiên rồi!", toast.ToastType.Warning);
								}
							}
						},  //PgUp for previous chapter of current book
					];

					// if this function run without {evt} parameter, it just save the hotkeys List into ssData.hotKeys.mainPage to notify to user
					if(!evt && !ssData?.hotKeys?.mainPage){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.mainPage){
							ssData.hotKeys.mainPage = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return;
					}

					/* //find if the key just press in the list of supported shortcuts
					const hotkeyOpts = hotkeyOptions.filter(keyItem => keyItem.kCode.indexOf(evt.code)>-1);
					//if found, do the corresponding job
					hotkeyOpts.forEach(hotkeyOpt => hotkeyOpt.callback()); */

					//search if a key just press matched any key specify above, then take the corresponding action (stopPropagation and preventDefault)
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions);
					
				};
				pageKeyDown(); //to get the list of hotKey and saved in ssData.hotKeys.mainPage
				document.addEventListener("keydown", pageKeyDown); 

				// extra event listeners for better behaviour
				/* document.addEventListener('blur' và 'focus', (event) => {
					saveState2Disk();
				}, false); */
				window.addEventListener('focus', (event) => {
					saveState2Disk();
					
					//check for DB files update
					if(!ssData.hasOwnProperty("lastDBCheck") || (Date.now() - ssData.lastDBCheck > 1000 * _DEFAULT_CFG.cDBFilesEdt.checkEdtDelay)){
						//check if there is any DB files having new edition, download them. Among them, if there is a DB file that its loadMode currently set to cacheLoad or freshLoad, ask user to reload the page to update the new data inside those DB
						ssData.setting.handyCheckDBsEdition(false);					
					}
				}, false);
				window.addEventListener('blur', (event) => {
					saveState2Disk();
				}, false);

				/* Loading page:waiting for main page to be fully loaded */
				/* document.onreadystatechange = function () {
					if (document.readyState === "complete") document.querySelector("#loadingPageWrapper").remove();
					return;

					if (document.readyState !== "complete") {
						document.querySelector("body").style.visibility = "hidden";
						document.querySelector("#loadingPageWrapper").style.visibility = "visible";
					} else {
						document.querySelector("#loadingPageWrapper").style.display = "none";
						document.querySelector("body").style.visibility = "visible";
					}
				}; */

				window.addEventListener('resize', function (event) {
					//re-position for pre-hard-coded elements
					reposAllTooltips();

					/*	TODO: reload the book so the chapter-group-label got its height recalculted */
				}, true);

			}
			pageEventHandlers(); //add event handler for the main page

			//initialize toast object
			toast = Toast();
			toast.showDelayedToast(); //show any delayed message that loadPage might have but haven't got toast object yet to notify to user

			//initial AudioPlayer object to take care of audio playing and corresponding UI
			let _spd = xState.speed ?? 1.4; 
			_spd = !isNaN(parseFloat(_spd)) ? parseFloat(_spd) : 1.4; //my default speed
			let _volume = xState.volume ?? 1;
			_volume = !isNaN(parseFloat(_volume)) ? parseFloat(_volume) : 1; //default audio volume
			_volume = Math.max( Math.min(_volume, 1), 0); //volume should be from 0 to 1

			ssData.audioPlayer = AudioPlayer({ speed: _spd, volume: _volume, muted: !!xState.muted }); //init object for audio player

			//initialize Books List search-dropdown
			ssData.sddBookTitlesList = new SddDropdown('[name="sdd-BookTitlesDropdown-container"]');
			//initialize Chapters List search-dropdown
			ssData.sddChaptersList = new SddDropdown('[name="sdd-ChaptersListDropdown-container"]');
			
			//initialize book data, state data (xState) saved in localStorage and load most recently playing book + chapter of last session
			ssData.bookData = BookData(); // instance of BookData class which purely deal with  books and chapters Data
			(function bookDataInitial() { //populate select elements  and load the book
				
				
				/* const _bookdefault = Math.floor(Math.random() * ssData.bIds.length); //0 //the book that would be load when page is load in very first time in user's device
				let _lastBook = ssData.xData[_bookdefault].bookId; //default to load the first book
				if (typeof xState["lb"] != "undefined") {
					_lastBook = xState["lb"];

					//in case last book not exists
					if(!ssData.bookData.findBookFromId(_lastBook)) {
						//clean the history and get the most recent book that still exists
						let _last_existed_book = historyCls.prototype.getAdjHist(0);
						//if found, make that book to be the last-book, the one will be loaded when page initializes
						if(_last_existed_book) _lastBook = _last_existed_book.bookId;
					}
				}
				//set the last-book in xState if it is not yet exist or the last-book was removed (because the database file containing it was removed)
				xState["lb"] = _lastBook; */

				//clean xState.history in case there are some books are not existed anymore
				historyCls.cleanHist();

				//set grpLine if it is not yet exist
				if (xState.grpLine == undefined) xState.grpLine = 0;
				
				const selBookGroup = document.getElementById("selBookGroup");
				// show category/group/ books for current group line
				selBookGroup.value = xState.grpLine;

				/* Load the most recently read book */
				//selBookGroup.onchange() will do the rest. It invokes a stack of calls like this: [popuGrpBookTitles() or popuBookTitles()]--> ssData.sddBookTitlesList.onchange() --> changeBook() --> changeChap()
				selBookGroup.onchange();

			})(); //self-invoked function to load the last-book
		
			ssData.setting = Setting(); //instance of Setting class that handle the Setting modal diaglog			
		
			//remove splash screen
			const _loadingPageWrapper = document.querySelector("#loadingPageWrapper");
			//make the effect of splash-screen fading-out
			_loadingPageWrapper.style.opacity = 0;
			setTimeout(_ => _loadingPageWrapper.remove(), 500);

			//Handling event for children of elmPlaylist, namely: li chapter item, chapter-group-label using event-delegation technique on bubbling event: click
			elmPlaylist.addEventListener("click", _elmPlaylistClickDelegation);
			function _elmPlaylistClickDelegation(evt) {
				let _target = evt.target;
				//console.log(_target);

				// user click on chapter-group-label which fire on-click to checkbox right before it
				if (_target.tagName === "INPUT" && _target.getAttribute("id").startsWith("chapGrpChkbox_")) {
					utilityHandles.chapGrpChkboxClick(_target)
				}
				else {
					// in case user click on a child of chapter li item
					let _liChapItem = _target.closest("li[attr-stt]");
					if (_liChapItem) { //if indeed click on li or its child
						let _chapStt = parseInt(_liChapItem.getAttribute("attr-stt"));
						if (!isNaN(_chapStt)) changeChap(_chapStt); //change to chapter
					}
				}
			}

			document.addEventListener("dblclick", evt => {
				let _target = evt.target;
				
				//seeking when user double click on workart
				if(_target.getAttribute("id")==='elmArtwork'){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 20;
					else xAudio.currentTime -= 20;
				}

				//seeking when user double click on the div that contain the playing time
				if (_target.tagName === "DIV" && _target.contains(elmPlayingTime) ){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 15;
					else xAudio.currentTime -= 15;
				}

				//seeking when double click on plain, empty (part that does not have any element) part of the body on the left and right
				if(_target === document.body){
					if(evt.offsetX > _target.offsetWidth / 2)
						xAudio.currentTime += 30;
					else xAudio.currentTime -= 30;
				}

				evt.stopPropagation();
			});

			/*  - fail-safe when high-res youtube image not available
				- align the height of elmPlaylist with the cover image on the left if it is too long
			*/
			const _elmArtwork = document.getElementById("elmArtwork");
			_elmArtwork.onload = async (_event) => {
				let elmArtwork = _event.target;
				// when a youtube thumbnail not exist, youtube will return a fallback image whose size is 120x90 so onerror event on elmArtwork will never be fired. This small trick is a way to know that an thumbnail not exist, so we replace another existed one.
				if (elmArtwork.naturalWidth === 120) {
					elmArtwork.src = elmArtwork.src.replace(/([^\/])+$/, "hqdefault.jpg"); //can use mqdefault.jpg with lower resolution but it is 16:9 thumbnail. Both of this thumbnail is guranteed to be existed

					//update new artwork to notification center
					utilityHandles.updateNCWorkart();

					return;
				}

				//fix the size of elmArrtwork depending on  the ratio of width and height of source image
				const _nRatio = elmArtwork.naturalWidth / elmArtwork.naturalHeight;
				const _elmWidth = _nRatio > 1.3? 450 : ( _nRatio > 1 ? 400 : (_nRatio > .8 ? 350 : 300) );
				elmArtwork.style.width = _elmWidth + "px";

				//align the height of elmPlaylist with the cover image on the left if it is too long
				let _leftSideHeight = 0;
				for (let _elm of elmArtwork.closest('[name="divCtnMiddle"]').firstElementChild.children) {
					if (_elm.tagName === 'svg')
						//note that no-wifi svg does not have offsetHeight
						_leftSideHeight += _elm.getBoundingClientRect().height
					else
						_leftSideHeight += _elm.offsetHeight;
				}
				const chapterListHeight = ssData.sddChaptersList.displayElement.getBoundingClientRect().height;
				elmPlaylist.style["max-height"] = Math.max(_leftSideHeight + 10 - chapterListHeight, 450) + "px";
			}
			_elmArtwork.onerror = evt => {
				//reload the image if it got error for the reason lost internet last time it got loaded
				let _retryCount = _elmArtwork.getAttribute("reload-Count");
				_retryCount = parseInt(_retryCount);
				if(isNaN(_retryCount)) _retryCount = 0;
				//update "reload-Count" with value increased by 1
				_elmArtwork.setAttribute("reload-Count", ++_retryCount);

				if (navigator.onLine){
					//allow trying reload 3 times
					if (_retryCount < 3)
						_elmArtwork.src = _elmArtwork.src + "?" + performance.now().toFixed(0);
					else _elmArtwork.src = "default.jpg"; //"https://th.bing.com/th/id/OIG1.umQWEGl8_HY7m9Mm76ww";
				}
				else{
					//show cover img or sprite svg image of No Internet depending on state of internet connection
					utilityHandles.showNoInternet();
				}
			}

			/* Handle event for allChapGrpChkbox, so if it is changed, all chapters group collapse/expand accordingly */
			document.getElementById("allChapGrpChkbox").onclick = evt => {
				let _chkExpandChapterGrp = evt.target;
				let _allChapChkbox = elmPlaylist.querySelectorAll("input[id^='chapGrpChkbox']");
				let _isChecked = _chkExpandChapterGrp.checked;
				_allChapChkbox.forEach(_chkBox => {
					_chkBox.checked = _isChecked;
					//utilityHandles.chapGrpChkboxClick(_chkBox); // to save checkbox state into xState
				});

				let _bookxState = xState.history.books[xAudio.getAttribute("attr-book")];

				//scroll elmPlaylist
				if (_isChecked) {
					//wait 500 second for expand/collapse animation to finish, then scroll to chapter being played
					setTimeout(_ => { elmPlaylist.querySelector("li.beingPlay").scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'end' }); }, 500);
					_bookxState.chapGrpCollapse = []; //meaning no group is collapsed
				}
				else {
					//scroll to top, so sticky label not overlap each others
					elmPlaylist.scrollTo({ top: 0, left: 0, behavior: "smooth" });
					_bookxState.chapGrpCollapse = [...Array(_allChapChkbox.length).keys()]; //fill with array from 0 to _allChapChkbox-1, meaning all groups are collapsed 
				}
				//because scroll too fast, so IntersectionObserver object might not catch some chapter-group-lables being pinned at top of elmPlaylist, thanks to scrollTo, they are now moved down but still keep .stickyPinned class. So, we might need to go through all label and remove .stickyPinned from all label that below elmPlaylist top. utilityHandles.chapGrpChkboxClick() on the a label will take care of that, it also fix the tooltip content & location of allChapGrpChkbox checkbox's label
				let _allChapGrpLabel = elmPlaylist.querySelectorAll("input[type='checkbox']:has( + label.is-sticky)");
				utilityHandles.chapGrpChkboxClick(_allChapGrpLabel[0]);
			}
		}

		/* user changes to other books
			bookValue: value of selected item of elmSelBookTitles, not selected index in the elmSelBookTitles element, which in fact is stt of book in ssData.xData
		 */
		function changeBook(bookValue) {
			//bookValue = parseInt(bookValue);

			//if still the same book, then do nothing. This happens sometimes, for example when close the User-Setting windows, Page will updates all the setting changes, and finally re-load book+chapter
			if (xAudio.getAttribute("attr-Book") == bookValue) return;

			// observe the _elmChapterInfor element, so when its newly added children and desendant rendered, adjust tooltips position
			ssData.ttMutationObserver.observe(document.getElementById("elmBookInfo"), { childList: true, subtree: true });
			// obsever if div[name="divOtherControlTop"] which contains checkbox to expand/collapse all chapter-group be show-up or hidden
			ssData.ttMutationObserver.observe(document.querySelector('[name="divChapterGroupControls"]'), { attributes: true, attributeFilter: ["class"] });

			historyCls.addToHistory(bookValue); //add new book to History if it was not hostory back/forward

			//update state
			xState["lb"] = bookValue;
			//if not yet available, make a new JSON for this book
			if (typeof xState.history.books[bookValue] == "undefined") xState.history.books[bookValue] = { "urlLine": 0 }; //urlLine remember the url link index should be played for all chapter this book if each chapter has multiple mp3 links

			let bData = ssData.bookData.findBookFromId(bookValue); // [bookValue - 1]; //bData contains all information for current book

			// Create real media links, cover image, original (outside) url,..., generate chaps groups from autoTap attribute for parts that have wildcart
			BookData.prototype.generateWCLinks(bookValue);

			let strOrgLink = "<div style='margin-left: 10px;text-align:left;'>Nguồn: <ul class='inlineList'>";
			if (Array.isArray(bData.ssrc)) {
				let i = 1;
				bData.ssrc.forEach(s => { strOrgLink += "<li><a target='_blank' href='" + s + "'>" + (getHostName(s)) + "</a></li>" });
			}
			else
				strOrgLink += `<li><a target='_blank' href='${bData.ssrc}'>${getHostName(bData.ssrc)}</a></li>`; //
			strOrgLink += "</ul></div>";

			let totalDuration = BookData.prototype.bookStatistics(bData).totalDur;
			//for (let i = 1; i <= bData.parts.length; i++) { totalDuration += toSeconds(bData.parts[i - 1].dur); }

			//update the total duration of the Book
			const _elmBookTotalDuration = document.getElementById("elmBookTotalDuration");
			elmBookTotalDuration.querySelector("span:first-of-type").innerHTML = toHhMmSs(totalDuration);
			const _elmBookRealListening = elmBookTotalDuration.querySelector("span:last-of-type");
			_elmBookRealListening.setAttribute("attr-duration", totalDuration);
			_elmBookRealListening.innerHTML = toHhMmSs(totalDuration / xAudio.playbackRate);

			/* Update book infor to detail elem at the bottom of page */
			document.getElementById("elmBookTitle").innerHTML = bData.title + (bData.eTitle && bData.eTitle != bData.title ? " <wbr/>(" + bData.eTitle + ")" : ""); /* <wbr> and css style '#elmBookTitle{text-wrap: nowrap}' can auto-break the line after <wbr/> into new line if the whole title is more than 1 line. However, for now this seem not work in Safary */
			
			/** function to make general information of the books and put in bunch of li elements */
			function makeLiGeneralInfor() {
				/** function to generate svg icon along with tooltip and css style for each type of information
				* @param _type: inforType, see the code for details
				*/
				let makeSvgStr = _type => {
					let _iconTitle = ["Mã sách", "Số chương", "Tác giả", "Năm xuất bản", "Thể loại", "Người đọc", "Thời gian còn lại của sách", "Thời gian nghe còn lại thực tế của sách (theo tốc độ phát)", "Số nhóm chương"];
					let _iconNames = ["icnSvgFeather", "icnSvgChapters", "icnSvgMaleAuthor", "icnSvgCalendar", "icnSvgBookType", "icnSvgMicrophone", "icnSvgRemainTime", "icnSvgListenTime", "icnSvgChapGroupIcon"];
					let _inlineStyle = "", _class = "svg-img-infor";

					//real Listening time icon
					if (_type == 7) _inlineStyle = "width: 1.2em;";
					/* if (_type == 6 || _type == 7) //make these two time icons a bit bigger
						_class += " svg-img-infor-13"; */
					return `<code style="display: inline-block" data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom">${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}</code>`; //
				}

				return `<ul class='inlineListInfor' style='padding-inline-start: 0px;'>
					<li>${makeSvgStr(0)}<span style='user-select: auto;-webkit-user-select: auto;' data-tooltip="${bData.dbPath.file}.${bData.dbPath.bookKit}[${bData.dbPath.idx+1}]\n[${bData.grp}]" data-tooltip-location="bottom">${bData.bookId}</span>.</li>
					${bData.tap? "<li>" + makeSvgStr(8) + "<span>" + bData.tap.length + "</span></li>" : ""}
					<li>${makeSvgStr(1)}<span>${bData.parts.length} chương.</span></li>
					<li>${makeSvgStr(6)}<span>${toHhMmSs(totalDuration)}</span>&ensp;${makeSvgStr(7)}<span attr-duration="${totalDuration}" role="listeningTime">${toHhMmSs(totalDuration / xAudio.playbackRate)}</span></li>
					<li>${makeSvgStr(2)}<span>${bData.author}</span></li>`
							+ (bData.year ? `<li>${makeSvgStr(3)}<span>${bData.year}</span></li>` : "")
							+ `<li>${makeSvgStr(4)}<span>${bData.type}</span></li>
					<li>${makeSvgStr(5)}<span}>${bData.mc}</span></li>
				</ul>`;
			}

			document.getElementById("elmBookInfo").innerHTML = `${strOrgLink}
			<div xrole="containing-tooltip">${makeLiGeneralInfor()}
			<p id="elmBookGioithieu" class="bookChapIntro">${bData.intro}</p>
			</div>`;

			/** function to format the subtitle, for now, it italic the number (which usually be the chapter number of text book) 
			 * @param subTit {string, undefined} the sub title
			 * @param _for {boolean}
			 * 		@value true: create html code for option of ssData.sddChaptersList
			 * 		@value false: create html code for li element of ol#elmPlaylist
			 * @example convert '80: Thái Dương thủ; 81: Ám giới; 82: Tần trong Tần Mục' into '<i>80</i>: Thái Dương thủ; <i>81</i>: Ám giới'
			*/
			const formatSubTit = (subTit, _for) => {
				if(!subTit) return "";
				subTit = subTit.replace(/(\d+):/g, "<i>$1</i>:");
				return _for ? 
					"<div class='item-2nd-main-div subTitle'>" + subTit + "</div>" :
					"<br/><span class='subTitle'>" + subTit + "</span>";
			}

			/* Create the Playlist which includes books' chapters */
			let _makeLiItem = (i) => {
				let _track = document.createElement('li');
				
				//set attribute data-rAlignGroup for right-align
				_track.innerHTML = `<code data-rAlignGroup='chapDuration'>${makeBrk(bData.parts[i - 1].dur)}</code> <span>${bData.parts[i - 1].tit}</span>${formatSubTit(bData.parts[i - 1].sTit, false)}`;
				if( i >= 100) _track.classList.add(i > 999? "fourDigitOrdernalNo": "threeDigitOrdernalNo");
				_track.setAttribute("attr-stt", i);

				return _track;
			}
			
			elmPlaylist.innerHTML = ""; //clear the Playlist
			let sddOptionData=[], sddOptGroup = null;
			if (bData.tap) {	//Neu sach co nhieu tap
				let _divChapterGroupControls = document.querySelector('[name="divChapterGroupControls"]');
				_divChapterGroupControls.classList.remove("elm-hidden"); //show control buttons for chapter groups
				//reposTooltips(_divChapterGroupControls); // need to re-pos tooltip for elems that just show up

				let _bookxState = xState.history.books[bookValue];
				if (!_bookxState.chapGrpCollapse) _bookxState.chapGrpCollapse = []; //initialize chapGrpCollapse array for this book if it is not existed

				let j = 0, liGroup = null;
				let _groupTotalDur = 0;

				sddOptGroup = [];
				for (let i = 1; i <= bData.parts.length; i++) {
					if (bData.tap[j].f == i) {//start new group
						let _chapGrpChkbox = document.createElement('input');
						_groupTotalDur = 0;
						_chapGrpChkbox.type = "checkbox";
						_chapGrpChkbox.checked = _bookxState.chapGrpCollapse.indexOf(j) > -1 ? false : true; //last time this group is collapsed or expanded
						_chapGrpChkbox.id = "chapGrpChkbox_" + j;
						_chapGrpChkbox.setAttribute("attr-grpNo", j);

						//Make label for group of chapters
						let _lbl = document.createElement('label');
						_lbl.htmlFor = "chapGrpChkbox_" + j;
						_lbl.style.fontWeight = "bold"; //make it bold to calculate maximum height of all labels
						_lbl.innerHTML = `<span style="display:block"><code class="underlineAnim">${bData.tap[j].label}</code></span>`;
						_lbl.classList.add("is-sticky");
						elmPlaylist.appendChild(_chapGrpChkbox);
						elmPlaylist.appendChild(_lbl);

						liGroup = document.createElement('section');
					}

					//add options setting data  for sddChaptersList
					sddOptionData.push({stt: i, gId: j,
						value: i, 
						label: bData.parts[i - 1].tit,
						dur: makeBrk(bData.parts[i - 1].dur),
						sTit: bData.parts[i - 1].sTit,
						eTit: bData.parts[i - 1].eTit,
						attr: {"attr-stt": i}
					});

					//Add li item to playlist
					liGroup.appendChild(_makeLiItem(i));
					_groupTotalDur += toSeconds(bData.parts[i - 1].dur);

					if (bData.tap[j].t == i || i == bData.parts.length) {//end of current option group
						if (j < bData.tap.length - 1 && bData.tap[j].t != bData.tap[j + 1].f - 1) {
							//Create dummy group for items that not belong to any group
							let _lbl = document.createElement('label');
							_lbl.innerHTML = "Orphan chapters";
							elmPlaylist.appendChild(_lbl);
						}

						//adding label to display chapter group summary
						let grpSummary = document.createElement('label');
						grpSummary.classList.add("chapter-group-summary");
						let _chapCount = bData.tap[j].t - bData.tap[j].f + 1;
						grpSummary.innerHTML = `<span>Số chương: <code>${_chapCount}</code>.</span><span>Thời lượng: <code>${toHhMmSs(_groupTotalDur)}</code> / <code attr-duration="${_groupTotalDur}">${toHhMmSs(_groupTotalDur / xAudio.playbackRate )}</code></span>`;
						liGroup.prepend(grpSummary); //add to top

						elmPlaylist.appendChild(liGroup);
						//right align duration of all chapter in this section
						SddDropdown.prototype.rightAlignElems(liGroup, "li");

						// add information for optGroup to setting
						sddOptGroup.push( {stt: j+1, gId: j, 
							label: `${int2Roman(j+1)}. ${bData.tap[j].label}`, 
							extraInfor: [_chapCount, toHhMmSs(_groupTotalDur)],
							attr: {"attr-grpNo": j}
						});

						j++; //prepare for new option group
					}
				}

				// update tooltip for label of allChapGrpChkbox checkbox
				ssData.ttMutationObserver.observe(document.querySelector('label[for="allChapGrpChkbox"]'), { attributes: true, attributeFilter: ["data-tooltip"] });
				utilityHandles.updateAllChapGrpChkboxUI(); //update allChapGrpChkbox UI when all done

				/* make all group label same height so that when scroll up/down, the down sticky label would stay fit above the up group label*/
				let _chapGroupLabels = elmPlaylist.querySelectorAll("input[type='checkbox'] + label");
				// wait for all labels to be rendered to find biggest height of all group labels
				setTimeout( () => {
					let _maxLabelHeight = 0;
					_chapGroupLabels.forEach(_lbl => {
						_maxLabelHeight = Math.max(_maxLabelHeight, _lbl.getBoundingClientRect().height);
						_lbl.style.fontWeight = null; //reset fontWeight that set before
					})

					_chapGroupLabels.forEach(_lbl => {
						_lbl.style.height = _maxLabelHeight + "px"; //make all label same height so when they are pinned to gether, they will fit above (and below) each other
					});
				}, 500);

				// stops watching all of old target elements, empty array of IntersectionObserverEntry (if any) for visibility changes.
				ssData.playlistObserver.disconnect();
				// observe new chapter-group-labels
				_chapGroupLabels.forEach(_lbl => { ssData.playlistObserver.observe(_lbl) });
			}
			else {// cho sach chi co 1 tap
				sddOptGroup = null;
				document.querySelector('[name="divChapterGroupControls"]').classList.add("elm-hidden"); //hide controls for chapter group
				for (let i = 1; i <= bData.parts.length; i++) {
					//add li to playlist
					elmPlaylist.appendChild(_makeLiItem(i));

					//add options setting data  for sddChaptersList
					sddOptionData.push({stt: i, 
						value: i, 
						label: bData.parts[i - 1].tit,
						dur: makeBrk(bData.parts[i - 1].dur),
						sTit: bData.parts[i - 1].sTit,
						eTit: bData.parts[i - 1].eTit,
						attr: {"attr-stt": i}
					});
				}
				//right align duration of all chapters
				SddDropdown.prototype.rightAlignElems(elmPlaylist, "li");
			}//.replace(/(\d+):/g, "<i>$1</i>:")

			//create setting for sddBookTitlesList
			const chapterListSetting = {
				displayOneLine: false,
				diacriticsFilterMode: xState?.chapterListDiacriticsSearch ?? true,
				//decorate background for SDDDropdownContent and SDD-dropdown-border-bottom, we specify customized class for whole .sdd-wrapper container
				customizedCssClass: "sdd-wrapper-chapterList",
				searchBoxPlaceholder: "Tìm trong {_items_length} chương sách ...",
				//rightAlignInEachOptGroup: false, //force right-align for items in whole SDD (not by optGroup as sddBookTitlesList)
				
				render: {
					//function to render the option
					option: function (data, escape) {
						return `<div class="item-main-div"><code class="item-slight-details" data-rAlignGroup="chapterDuration">${escape(data.dur)}</code>&emsp13;<span>${data.label}</span></div>
						${formatSubTit(data.sTit, true)}` +
						`${data.eTit? "<div class='item-2nd-main-div englishTitle'>" + data.eTit + "</div>" : ""}`;
					},
					//function to render the selected option to representative DIV
					select_option: function (option, escape) {
						return option.firstChild.innerHTML; // textContent;
					},
					//function to render the optGroup
					optgroup_header: function (data, escape) {
						return `<span>${escape(data.label)}</span>&emsp13;<span class="item-slight-details">[${escape(data.extraInfor[0])} chương / ${escape(data.extraInfor[1])}]</span>`;
					},
					'no_results': () => {
						return 'Không tìm thấy chương sách nào';
					}
				},
				callbacks: {
					//callback function to be invoked when onChange event fire (a new item is selected)
					onChange: function (selectedItem) {
						//console.log(`onChange event: ${selectedItem.value}`);
						changeChap(selectedItem.value);
					},
					//callback function to update state of SDD search mode (removed diacritics or exact search)
					diacriticsFilterModeOnChanged: function(newDiacriticsSearchVal){
						xState.chapterListDiacriticsSearch = newDiacriticsSearchVal;
					}
				}
			};

			// Tìm xem chương mở gần đây nhất của cuốn sách
			let lastChap = 1;
			if (typeof xState.history.books[bookValue]["lc"] != "undefined") lastChap = parseInt(xState.history.books[bookValue]["lc"]);
			//we need attr-PrevBook to save playing time before changing to other book
			xAudio.setAttribute("attr-PrevBook", xAudio.getAttribute("attr-Book") ?? "");
			xAudio.setAttribute("attr-Book", bookValue); //save book id to xAudio attribute
			
			//if this is the very first time load sddChaptersList because elmPlaylist not yet had Attribute "attr-Length", then we load the setting. So next time when playing new book, we just need to load the Data only
			if( !elmPlaylist.hasAttribute("attr-Length") )
				ssData.sddChaptersList.loadDropdown(chapterListSetting, ssData.sddChaptersList.LOAD_MODE_ENUM.SettingLoadOnly);		

			elmPlaylist.setAttribute("attr-Length", bData.parts.length); //save the number of li children

			// load/reload the sddChaptersList Data for the new book
			ssData.sddChaptersList.loadDropdown({
				options: sddOptionData,
				optgroups: sddOptGroup}, ssData.sddChaptersList.LOAD_MODE_ENUM.DataLoadOnly, ''+ lastChap);//callbacks.onChange() take value to set selected item, so we have to convert to string if lastChap is integer

			//changeChap(lastChap);
		}

		/* Function to take care of playing other chapter including preparing information for new chapter, load new source for audio,...
		newChap: stt of new chapter, can be text or number
		*/
		function changeChap(newChap) {
			//remember the last position that audio was played before new book/chapter attributes are updated to xAudio
			saveAudioCurrentTime();

			let bData = ssData.bookData.findBookFromId( xAudio.getAttribute("attr-Book") ) ; //bData contains all information for current book

			//Check the validity of variable newChap
			if (newChap == undefined) return;
			newChap = parseInt(newChap);
			if (isNaN(newChap)) return;

			let chapLength = parseInt(elmPlaylist.getAttribute("attr-Length"));
			if (isNaN(chapLength)) chapLength = elmPlaylist.querySelectorAll("li").length;

			//if play the chapter that is currently playing, do nothing
			let _liNewChap = elmPlaylist.querySelector(`li[attr-stt="${newChap}"]`);
			if (_liNewChap?.classList.contains("beingPlay")) { 
				//utilityHandles.updateNCWorkart(); //this does not seem to reload the Notification Center, but load the workart one more time
				//if item stt newChap having beingPlay class, meaning newChap is playing, then do nothing
				return; 
			} 

			if (newChap < 1 || newChap > chapLength) {
				toast.showToast("Không tìm thấy chương truyện có số thứ tự " + newChap, toast.ToastType.Warning);
				return;
			}

			//update sddChaptersList selected Item
			ssData.sddChaptersList.value = newChap;

			// dismiss all Toasts that might be belong to old chapter (if user switch chapter too fast)
			toast.dismissAll();

			//change selected appearance in Playlist
			let _lastTrack = elmPlaylist.querySelector("li.beingPlay");
			_lastTrack && _lastTrack.classList.remove("beingPlay");
			_liNewChap.classList.add("beingPlay");
			utilityHandles.gotoPlayingChapter(); //open section if it is currently collapsed and scroll into playing chapter

			(function () { //to enable/disable the preivous/next chapter button depending on the location of chapter to be the first or the last one
				/* _elmSkipPrev = document.querySelector(".ap-prev-btn");
				if(newChap == 1) _elmSkipPrev.classList.add("elm-disabled")
				else _elmSkipPrev.classList.remove("elm-disabled"); */

				let _elmSkipNext = document.querySelector(".ap-next-btn");
				if (newChap == chapLength) _elmSkipNext.classList.add("elm-disabled")
				else _elmSkipNext.classList.remove("elm-disabled");
			})();

			//check done, save newChap attribute to element
			elmPlaylist.setAttribute("attr-Value", newChap); //remember stt of current played 
			//remember the current Book and current Chapter for later use when needed
			xAudio.setAttribute("attr-Chap", newChap);

			let elmChapterTitle = document.getElementById("elmChapterTitle");
			let chapData = bData.parts[newChap - 1]; //information for new selected chapter of current book

			/* add html code to format the title. Check Lỗ Ban and Tiên hiệp novel */
			const _formatTit = tit => {
				tit = tit.replace(/\s+/g," ");
				//adding break for some place marked with " - ", not " – " (long alt+151 em-dash; alt+150 en-dash)
				tit = tit.replaceAll(" - ", "<br/>");

				//Following separate char ('[\:\–\.\-]') can be replaced by '\b.'

				//format for text looks like '1-Thôn nhỏ bên núi' (without 'Hồi|Chương|Phần|Tập' preceding)
				// /((?<!Hồi|Chương|Phần|Tập)\s+\d+\s*[\:\-])/g
				tit = tit.replaceAll(/((?<!Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*[\:\–\.\-])/gi, "<b style='color:#1566bf'>$1</b>");

				//format for text looks like 'Hồi 1.1', 'Chương 2 -5' (two numbers)
				tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+(?:\s*[\:\–\.\-]\s*\d+))/gi, "<b style='color:#c09618'>$1</b>");

				//format for text looks like 'Chương 1: ', 'Tập 1 -' (single number) without matching a part of two numbers like 'Chương 19 – ' of 'Chương 19 – 23'
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\s*[\:\-\.\-]?\s*(?!\d+)))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:[\:\–\.\-\s]+(?!\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\s*[\:\–\.\-]+(?!\s*\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+(?:[\s\:\–\.\-]\s*(?!\d)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+((?!\s*[\:\–\.\-]\s*\d+)|$))/gi
				// /((?:Hồi|Chương|Phần|Tập)\s+\d+\s*(?:[\:\–\.\-](?!\s*\d+)|(?![\:\–\.\-])|$))/gi
				// /((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*(?:[\:\–\.\-\(](?!\s*\d+)|$))/gi
				tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập|Quyển|Phẩm|Bài)\s+\d+\s*(?=[\:\–\.\-\(](?!\s*\d+)|$))/gi, "<b style='color:green'>$1</b>");

				/* tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập)\s+\d+\s*[\:\-])/g, "<b style='color:darkred'>$1</b>"); //–
				tit = tit.replaceAll(/((?:Hồi|Chương|Phần|Tập)\s+\d+(?:\.\d+)?[\:\s](?![\-\–]\s*\d+))/g, "<b style='color:green'>$1</b>"); */
				return tit;
			}

			document.querySelector(".ap-title").innerHTML = chapData.tit; //small track title right above progress bar
			elmChapterTitle.innerHTML = "<span style='color:darkblue;'>" + pad(newChap, 2) + "/" + pad(bData.parts.length, 2) + ".</span> " + _formatTit(chapData.tit) + (chapData.sTit? "<span style='font-size:.85em'> ⸺ " + _formatTit(" " + chapData.sTit) + "<span>" : "" ) ; //〰︎〰︎ —	〰
			//https://perishablepress.com/all-the-hyphens-dashes/

			// calculate total remaining duration, note that this is displayed in book Infor and used to calculte percentage right below
			const remainDuration = BookData.prototype.bookStatistics(bData, newChap).totalDur;
			const _listenedDur = bData.statistics.totalDur - remainDuration;
			// calculte percentage of all chapters (from chapter 1 to chapter right before current chapter) has been listen in compared with the whole book
			const _listenedPercent = ( (1 - remainDuration / bData.statistics.totalDur)*100 ).toFixed(1);

			let tit = elmChapterTitle.innerText;
			/* inforType 0:🎧 1:🕓 2:📆 3:🎤 4: cId
				5: tooltip for Media 6: tooltip for switch mp3 links button
			*/
			let makeSvgStr = (_type, _tooltip) => {
				let _iconTitle = ["Thời lượng", "Thời gian nghe thực tế", "Năm xuất bản", "Người đọc", "Id của chương truyện", "Link trực tiếp chương truyện", "Đổi nghe link tiếp theo"];
				let _iconNames = ["icnSvgDuration", "icnSvgListenTime", "icnSvgCalendar", "icnSvgMicrophone", "icnSvgFeather", "icnSvgMediaLinks", ""];
				let _inlineStyle = "", _class = "svg-img-infor";
				/* if (_type == 1) {
					_inlineStyle = "font-size:1.5em;margin-bottom: -.4em";
				}
				//for small icon, need to zoom it a bit so it looks equally to other icon
				if (_type == 1 || _type == 5) _class += " svg-img-infor-13"; */

				//icon for percentage of listened duration in compared with total duration				

				if (!_iconNames[_type]) return ` data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom"` // style="--data-translateX: -20%"
				else
					return `<code data-tooltip="${_iconTitle[_type]}" data-tooltip-location="bottom">${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}</code>`;
			}
			//Adding infor for the chapter
			let strBookInfo = "";
			strBookInfo += `${chapData.eTit ? "Tên gốc: <i>" + chapData.eTit + "</i><br>" : ""}`;
			strBookInfo += `<span xrole='containing-tooltip'><ul class='inlineListInfor'>
				${chapData.dur ? "<li>" + makeSvgStr(0) + "<span>" + chapData.dur + "</span> " + makeSvgStr(1) + "<span attr-duration='" + toSeconds(chapData.dur) + "' role='listeningTime'>" + toHhMmSs(toSeconds(chapData.dur) / xAudio.playbackRate) + "</span></li>" : ""}
				<li><span id='percentageListened' style='background-size: ${_listenedPercent}% 100%;' data-listened-duration='${_listenedDur}' data-book-dur='${bData.statistics.totalDur}' data-listened-percent='${_listenedPercent}' data-tooltip='Phần trăm tổng thời lượng đã nghe [${ toHhMmSs(_listenedDur)}]&#xaso với cả cuốn sách [${ toHhMmSs(bData.statistics.totalDur)}]' data-tooltip-location='bottom'>${_listenedPercent}%</span></li> 
				${chapData.year || bData.year ? "<li>" + makeSvgStr(2) + "<span>" + (chapData.year || bData.year) + "</span></li>" : ""} 
				${bData.mc ? "<li>" + makeSvgStr(3) + "<span>" + bData.mc + "</span></li>" : ""} 
				${(chapData.cId) ? "<li>" + makeSvgStr(4) + "<span>" + chapData.cId + "</span></li>" : ""}`; //!bData.grp[2].split(".").pop().match(/[A-F]/) && 

			//set direct Link for audio
			let strLink = "<li><span  id='elmMp3Links'>" + makeSvgStr(5) + "Media: ";
			if (!Array.isArray(chapData.url)) {
				chapData.url = [chapData.url]; //if not array, convert to array for simpler code below
			}
			//if having multiple audio sources, list all of them and show Switch src button
			if (chapData.url.length > 1)
				strLink += `<button class='svgButton switchChapterAudioSrc' style='padding: 1px 5px 0px 5px;' onclick='changeAudioSrc(false);' ${makeSvgStr(6)}><svg class='button-svg-img' style='font-size:15px' focusable='false' aria-hidden='true'><use href='#icnSvgSwitchChapterLinks'/></svg></button>&nbsp;`;

			//add audio url for playing
			strLink += "<ul class='inlineList'>";
			for (let i = 1; i <= chapData.url.length; i++)
				if (chapData.url[i - 1]) //in case url is empty or null or even undefined
					strLink += `<li role='audioSrc'><a target='_blank' href='${chapData.url[i - 1]}'>${getHostName(chapData.url[i - 1])}</a></li>`;

			//adding outside url (reference url, cannot be used as audio src)
			strLink += (chapData.oUrl ? `<li><a class='outsideLink' target='_blank' href='${chapData.oUrl}'>${getHostName(chapData.oUrl)}</a></li>` : "");
			strLink += "</ul><span></li>"; //closing tags

			let _chapInfor = "";
			if (chapData.infor)
				_chapInfor = ` ∴ <details ${window.chapInforDetailsOpen ? "open" : ""} ontoggle="window.chapInforDetailsOpen = this.open;" style="display: inline-block;margin-bottom: -5px;"><summary style="padding-top: 0px;cursor:pointer;">${makeSvgFromSprite("icnSvgChapterInfor", { class: "svg-img-infor", style: "" })}</summary></details><div class="detailContent"><p class="bookChapIntro" style="font-size: .8em;">${chapData.infor}</p></div>`;

			let _elmChapterInfor = document.getElementById("elmChapterInfor");
			// observe the _elmChapterInfor element, so when its newly added children and desendant rendered, adjust tooltips position
			ssData.ttMutationObserver.observe(_elmChapterInfor, { childList: true, subtree: true });
			//Show chapter information on the page	
			_elmChapterInfor.innerHTML = strBookInfo + strLink + "</ul></span>" + _chapInfor;

			//update chapter/book cover
			let elmArtwork = document.getElementById("elmArtwork");
			//elmArtwork.title = tit;
			//store the number of time trying reload the image when error loading image
			elmArtwork.setAttribute("reload-Count", 0);

			//size of image is now moved to elmArtwork.onload()
			if (chapData.img) { //if there is a chapter cover
				//update Chapter cover if there any
				elmArtwork.src = chapData.img;
				//elmArtwork.style.width = "450px";
			}
			else {
				elmArtwork.src = bData.cover;
				//elmArtwork.style.width = "300px";
			}

			//show cover img or sprite svg image of No Internet depending on state of internet connection
			utilityHandles.showNoInternet();

			// update total remaining duration, note that this is displayed in book Infor
			let _elmRealRemainListening = document.getElementById("elmBookInfo").querySelector("[attr-duration]");
			
			_elmRealRemainListening.parentElement.querySelector("span:first-of-type").innerText = `${toHhMmSs(remainDuration)} (${bData.parts.length - newChap + 1} chương)`; //first span is total duration
			//const _elmRealRemainListening = _totalRemainDurElem.querySelector("span:last-of-type");
			_elmRealRemainListening.setAttribute("attr-duration", remainDuration);
			_elmRealRemainListening.innerText = toHhMmSs(remainDuration / xAudio.playbackRate); //last span is real listenning time

			document.title = xAudio.title = tit;

			// set infor shown on notification center
			if ('mediaSession' in navigator) {
				navigator.mediaSession.metadata = new MediaMetadata({
					title: makeBrk(chapData.dur) + " " + tit,
					artist: bData.author,
					album: bData.title,
					artwork: [
						{ src: elmArtwork.src, sizes: '512x512', type: 'image/png' }
					]
				});
				/* navigator.mediaSession.setActionHandler on "previoustrack", "nexttrack","play", "pause", "seekbackward", "seekforward" is set on Auio Player */
			}

			//trying load audio src with fail-safe to play other url line if current url line failed
			changeAudioSrc(false);

			// update audio source and playing new chapter
			let _bookValue = xAudio.getAttribute("attr-Book");
			// Lưu chương mở gần đây nhất của cuốn sách
			xState.history.books[_bookValue]["lc"] = newChap;
			//Lưu xSate vào local Storage
			localStorage.setItem('xState', JSON.stringify(xState));

			//Jump to last audio played position
			(function gotoLastPosition() {
				let _bookValue = xAudio.getAttribute("attr-Book");
				let bSt = xState.history.books[_bookValue];
				if (!bSt) return;
				let cSt = parseFloat(bSt[parseInt(xAudio.getAttribute("attr-chap"))]);
				//if don't have that last-position, then we use skipStart set in chapter infor, If there is no skipStart in chap setting, use skipStart of book infor. If there is still no skipStart, then start from beginning
				cSt = !isNaN(cSt)? cSt: ( chapData?.skipStart ?? (bData?.skipStart ?? 0) );
				if (cSt) xAudio.currentTime = cSt;
			})();
		}

		//function to save position of current (of most recently, depend on cases) playing audio
		let saveAudioCurrentTime = () => {
			//get last book + chapter that is or was playing
			let _lB = xAudio.getAttribute("attr-Prevbook"); //_lB has to got from attr-Prevbook to handle the case changing book, the bookStt to save to xState belongs to previous book, not current book
			let _lC = xAudio.getAttribute("attr-chap");

			xAudio.setAttribute("attr-Prevbook", xAudio.getAttribute("attr-book")); //so if next chapter (of same book) play, _lB point to correct book
			if (_lB && _lC) { //note that, when the first chapter of first book playing, _lB="" and _lC should be null
				let currTime = xAudio.currentTime << 0; //get the integer
				if (currTime + 5 > xAudio.duration) {
					//if playing very close to end of video, then make it play from beginning next time
					delete xState.history.books[_lB][_lC];
				}
				else //save the position 
					xState.history.books[_lB][_lC] = currTime;
			}
		}

		// Save and recorded state to Local Disk
		function saveState2Disk() {
			saveAudioCurrentTime();
			//Lưu xSate vào Local Storage
			localStorage.setItem('xState', JSON.stringify(xState));
			localStorage.setItem('xDBFilesCfg', JSON.stringify(xDBFilesCfg));
		}

	</script>

	<!-- SMALL CLASSES -->
	<script>
		"use strict";
		/* Class contains handler for utility buttons and some other task. I wrap it in a class for easier to track source code */
		class utilityHandles {
			/* Handle small popup for button functions Seek to a duration time for audio to play */
			static showSleepTimerPopup() {
				//the popup
				let _popupDiv = document.getElementById("sleepTimerDivPopup");
				//the button on main page that when click on it, the popup show-up
				let _btnShowPopup = _popupDiv.previousElementSibling; 
				//the textbox to type in the sleep timer
				let _ipSleepTimer = document.getElementById("ipSleepTimer");
				//datalist that _ipSleepTimer bind to
				const _sleepTimersDatalist = document.getElementById("sleepTimersDatalist");

				// the div that contains the span displaying count down sleep timer text (below workart)
				const _stCountdownCtn = document.querySelector('div:has( > #elmSleepTimerCountDown)');
				// the span that contains count down sleep timer text
				const _stCountdownSpan = document.getElementById("elmSleepTimerCountDown");

				//can take 'h', '-', ':' as the hour delimiter
				const _pattern = /^\d+(\s+phút|\s*[hHgG\.\-\:]\s*\d*)?$/;

				_ipSleepTimer.setAttribute("pattern", _pattern.source); //pattern to check valid
				_popupDiv.querySelector("label[for]").innerHTML = "Nhập thời gian dừng phát truyện theo định dạng: <b>HH[<i>delimiter</i>]mm</b> (ví dụ: <b>1h20</b> = 1 giờ 20 phút), <b>mm</b> (ví dụ: <b>45</b> = 45 phút).<br/>Trong đó <b>HH</b> là số giờ, <b>mm</b> là số phút;  <b>[<i>delimiter</i>]</b> có thể là một trong các kí tự <b>H</b>, <b>h</b>, <b>G</b>, <b>g</b>, <b>.</b>, <b>-</b>, <b>:</b>";			
				
				 //show the popup and put focus on the textbox
				_popupDiv.classList.add("shortPoupShow");
				_ipSleepTimer.focus({ focusVisible: true, preventScroll: false });

				if (!_ipSleepTimer.onkeyup) { //check this, so these event defined only one time

					/** function convert back and ford from time to time string
					 * @time {string, number}
					 * if number, it conver time to time string. E.g: 60 -> '1h', 75 -> '1h15'
					 * if string, it conver time string to time (number). E.g: '1h' -> 60, '1h15' -> 75, '75' -> 75
					*/
					function convertSleepTime(time){
						if(typeof time == 'number'){
							let _timeStr = time;
							if(time >= 60){
								_timeStr = ( (time/60) << 0) + "h" + (time%60 || '');
							}
							return _timeStr;
						}

						if(typeof time == 'string'){
							if(!time.match(_pattern)) return null;

							//standard the hour delimiter
							time = time.replace(/[HGg\.\-\:]/g, 'h');

							let _times = time.split("h").map(_t => Number(_t) );
							let _timeMinutes = _times.pop();

							if(_times.length > 0){
								_timeMinutes += _times.pop() * 60;
							}
							return _timeMinutes;
						}
					}
					
					/** initial the global variable to keep the sleep timer state where
					 * @timer store the amount of seconds the audio will be paused
					 * @endTime store the point of time the audio is paused
					 * @stObj store the setInterval variable  */
					ssData.sleep = {
						timer: 0, 
						endTime: null, 
						siObj: null,
						enum: {"0": "Bỏ hẹn giờ",
							"-1": "Khi nghe hết chương hiện tại"
						}
					};

					/* initiate the datalist */
					let _defSleepTimes = [15, 30, 45, 60, 75, 90, 120, 180];
					//get array of sleep timer if xState saved that array
					if(xState.sleepTimers && Array.isArray(xState.sleepTimers)) _defSleepTimes = xState.sleepTimers;
					//populate the datalist
					_sleepTimersDatalist.innerHTML = _defSleepTimes.map(_time => {
						//because _time might be string, so we need to convert it to number for convertSleepTime to work as designed
						const _formattedTime = convertSleepTime( parseInt(_time) );
						// note that when select an option, content entered into input element will always come from the value attribute.
						return `<option value="${_formattedTime}" label="${_time} phút"></option>`;
					}).join(" ");
					
					
					/* function to active a sleep timer by the text in the _ipSleepTimer, also standardize _ipSleepTimer text (convert into hour format, e.g, if user type in '1h5' or '65', _ipSleepTimer text would be 1h5) */
					const _setSleepTimer  = _ => {
						
						// do some clean-up if user type in wrong-format string
						if(!_ipSleepTimer.checkValidity()){
							_ipSleepTimer.value = ssData.sleep.timer > 0 ? convertSleepTime(ssData.sleep.timer) : "";
							toast.showToast("Thời gian hẹn giờ nhập không đúng định dạng", toast.ToastType.Error);
							_popupDiv.classList.remove("shortPoupShow");
							return;
						}

						/** function to stop Sleep-Timer 
						 * @param interuptOldTimer {boolean}
						 * 	@value false or missing: meaning the current Sleep timer reach to the end, so we need to stop it
						 * 	@value true: user decide to disable current sleep timer
						*/
						const stopSleepTimer = interuptOldTimer => {
							const _sleepObj = ssData.sleep;
							clearInterval(_sleepObj.siObj);

							//const to know if there is an sleep timer is counting down
							const _AN_TIMER_ACTIVE = _sleepObj.siObj !== null;

							//reset sleep variables
							_sleepObj.timer = 0;
							_sleepObj.count = 0;
							_sleepObj.siObj = null;
							_sleepObj.endTime = null;

							//reset appearance of show popup button
							_btnShowPopup.classList.remove("sleepTimerActive");

							//hide the count down span
							_stCountdownCtn.classList.add("elm-hidden");
							//clear the blinking class (added when the timer when there is 30 seconds left)
							_stCountdownSpan.classList.remove("almostReachingEnd");

							//clear timer input
							_ipSleepTimer.value = "";
							
							//stop audio only for the case when the Sleep timer reached to the end
							if(!interuptOldTimer){
								xAudio.pause();

								toast.showToast("Dừng phát audio do đã tới thời gian hẹn giờ tắt", toast.ToastType.Warning, {duration: 1e4});
							}
							else if(_AN_TIMER_ACTIVE){
								toast.showToast("Tắt đồng hồ hẹn giờ trước hạn.", toast.ToastType.Warning, {duration: 1e4});
							}
						}

						//remove all spaces
						let newSleepTimeTxt = _ipSleepTimer.value.replace(/\s/g, "");
						
						//Check if timer string is empty or 0 (disable timer)
						if (!newSleepTimeTxt || newSleepTimeTxt === '0'){
							// if there is an active timer, stop it
							if(ssData.sleep.timer > 0) 
								stopSleepTimer(true); //interupt to end current timer without stopping audio
							_popupDiv.classList.remove("shortPoupShow");
							return;
						}

						//convert newSleepTimeTxt to number of minutes to compare with label's option
						let newSleepTime = convertSleepTime(newSleepTimeTxt);

						//Check if new timer was already there in the timer datalist, if not, push it in the datalist and saved new list to xState
						if(!_sleepTimersDatalist.querySelector('[label^="' + newSleepTime + ' "]')){
							// search right location to add newSpeed
							let i = 0;
							while (i < _sleepTimersDatalist.options.length && parseInt(_sleepTimersDatalist.options[i].label) < newSleepTime) {
								i++;
							}
							
							let _newOption = new Option("", convertSleepTime(newSleepTime) ); //text, value
							_newOption.label = newSleepTime + " phút";

							//add new speed before location just found
							_sleepTimersDatalist.insertBefore(_newOption, _sleepTimersDatalist.options[i]);
							
							//save the new list of Sleep Timers into xState
							xState.sleepTimers = [..._sleepTimersDatalist.options].map(_opt => parseInt(_opt.label));
						}

						/* NOW, SETTING a NEW Sleep TIMER */
						stopSleepTimer(true); // interupt and stop timer, do some clean up of old (but still active) timer (if any)

						//convert the number of minutes into hour format in the input box
						_ipSleepTimer.value = convertSleepTime(newSleepTime);

						//update ssData.sleep
						const _sleepObj = ssData.sleep;
						_sleepObj.count = _sleepObj.timer = newSleepTime * 60; //in seconds
						// set the time that the Sleep timer ends, specified by the number of seconds elapsed since the epoch
						_sleepObj.endTime = (Date.now() / 1000  << 0) + _sleepObj.timer;

						//change appearance of show popup button
						_btnShowPopup.classList.add("sleepTimerActive");

						// show the count down sleep timer text (below workart)
						_stCountdownCtn.classList.remove("elm-hidden");

						//start an interval to update the count-down sleep timer string and to pause audio (and do some resetting) when sleep time is reached
						_stCountdownSpan.textContent = toHhMmSs(_sleepObj.count);
						_sleepObj.siObj = setInterval(_ => {
							_sleepObj.count --;
							_stCountdownSpan.textContent = toHhMmSs(_sleepObj.count);
							//console.log(_sleepObj.count);

							// note that when a tab is inactive, the setInterval may work incorrectly (See 'Timeouts in inactive tabs' in setTimeout function from Mdn). Also, setInterval always being delayed (see mdn), so we need to update _sleepObj.count regularly based on system time to make sleep timer work more correctly. See this link https://stackoverflow.com/a/16033979/36866 for limits the minimum interval on inactive tab for different browsers
							//document.hidden && 
							if(_sleepObj.count % 10 == 0 || _sleepObj.count < 30) {
								// we re-update the counter based on system time every 10 times setInterval invoked or when timer reaching to the end
								_sleepObj.count = _sleepObj.endTime - (Date.now() / 1000  << 0);
							}

							//blinking the timer when there is 30 seconds left 
							if(_sleepObj.count == 30) {
								_stCountdownSpan.classList.add("almostReachingEnd");
							}

							// when timer reach to the very end
							if(_sleepObj.count <= 0) {
								stopSleepTimer();
								/* console.log("Reached end at: " + toHhMmSs(xAudio.currentTime) + ". Paused = " + xAudio.paused);
								xAudio.pause(); //just for sure, can be removed since it already been done on stopSleepTimer()
								console.log(xAudio.paused); */
							}
						}, 1000);						

						_popupDiv.classList.remove("shortPoupShow");
					}

					/* function to handle when user click 0utside the popup or press Escape. It just keep the old timer (or there was no sleep timers set, it keep it that way) */
					const _inputBlured = _ev => {
						const _sleepObj = ssData.sleep;
						_ipSleepTimer.value = _sleepObj.timer == 0 ? "" : convertSleepTime(_sleepObj.timer / 60);
						_popupDiv.classList.remove("shortPoupShow"); //close the popup
					}					
					
					//keyup event to handle some specfic key like Enter or Escape
					_ipSleepTimer.onkeyup  = _ev => {
						//Shift+backspace, Escape to clear the textbox
						if(_ev.shiftKey && _ev.code=="Backspace")	_ipSleepTimer.value = "";

						//Enter to set the Sleep Timer
						if( ["Enter", "NumpadEnter"].includes(_ev.code) ) {
							//_ipSleepTimer.blur();
							_setSleepTimer();
						}

						if (_ev.code === "Escape") {
							_inputBlured();
						}					

						_ev.stopPropagation();
					}

					//user click outside the small popup would work as click Escape in above onkeyup
					_ipSleepTimer.addEventListener("focusout", _inputBlured);

					//This function has only one job to avoid event propagate upward in the DOM, so that key press on this textbox not bubbling up, so keydown event handlers of main page would not does what it is intended to do such as pause/stop audio, key -/+ can decrase/increase audio playbackRate, open book sdd or chapter sdd
					_ipSleepTimer.addEventListener("keydown", evt => {evt.stopPropagation()});
				}
			}

			/* Handle small popup for button functions Seek to a duration time for audio to play */
			static showSeekAudioDurationPopup() {
				let _popupDiv = document.getElementById("seekDurationDivPopup");
				let _ipDuration2Seek = document.getElementById("ipAudioDuration");
				// the second part of regex (after |) is for ±.ss format
				const _pattern = /^([\+\-]?(([1-5][.,:])?([0-5]?\d)[.,:])?([0-5]?\d))|([\+\-]?[.,:][0-5]?\d)$/; //accept . or , or : as duration seperator
				let _maxDuration = xAudio.duration;
				if (!_maxDuration) _maxDuration = 0;

				_ipDuration2Seek.setAttribute("pattern", _pattern.source); //pattern to check valid
				_popupDiv.querySelector("label[for]").innerHTML = "Nhập thời gian muốn tua nhanh đến theo định dạng (dấu <b>+</b> hoặc <b>–</b> là độ lệch thời gian tua đến tính từ thời gian hiện tại): <b>[±]H.mm.ss</b>, <b>[±]mm.ss</b>, <b>[±]mm</b> hoặc <b>[±].ss</b><br/>(Thời lượng không quá <b>" + toHhMmSs(_maxDuration) + "</b>)";
				_ipDuration2Seek.value = ""; //elmPlaylist.getAttribute("attr-value");
				_popupDiv.classList.add("shortPoupShow"); //show the popup
				_ipDuration2Seek.focus({ focusVisible: true, preventScroll: false });

				if (!_ipDuration2Seek.onkeyup) { //check this, so these event defined only one time
					let seekAudioTo = () => {
						let _toTime = _ipDuration2Seek.value.trim(); //time in  H.mm.ss format 
						if (_pattern.test(_toTime)) {
							let _toDur = 0; //duration to jump to

							let plusMinus = _toTime[0];
							if ("+-".indexOf(plusMinus) > -1) {
								_toTime = _toTime.slice(1); //remove the +/- sign to get the time in h:mm:ss only
							}
							else plusMinus = ""; //there is no sign at all

							_toTime = _toTime.replaceAll(/[\.\,]/g, ":"); //change to H:mm:ss format
							let _seekDistanceMsg = plusMinus == "" ? "" : (plusMinus == "+" ? "Tiến thêm " : "Lùi lại ") + _toTime;

							//convert string to number of seconds
							if (_toTime.indexOf(":") == -1) //format mm
								_toTime = parseInt(_toTime) * 60
							else //the other two format, including ":ss" format
								_toTime = toSeconds(_toTime);

							//handle +/- sign
							if (plusMinus === "+") _toTime += xAudio.currentTime;
							if (plusMinus === "-") _toTime = xAudio.currentTime - _toTime;

							if (_toTime >= 0 && _toTime < xAudio.duration) { //if within the audio duration
								if (_seekDistanceMsg != "") toast.showToast(_seekDistanceMsg)
								xAudio.currentTime = _toTime; //this will raise audio onseeked event
								//xAudio.onseeked();
							}
							else
								toast.showToast(_toTime < 0 ? "Thời gian không được nhỏ hơn 0" : "Thời gian bạn nhập lớn hơn tổng thời lượng của chương truyện", toast.ToastType.Warning);
						}
						else {
							if (_toTime) //only show message when user type something
								toast.showToast("Thời gian bạn nhập không đúng format", toast.ToastType.Error);
						}

						_popupDiv.classList.remove("shortPoupShow");
					}

					/* Capture when user click Enter/Escape */
					_ipDuration2Seek.onkeyup = (_ev) => {
						//console.log(_ev.code);
						if (_ev.code === "Enter" || _ev.code === "NumpadEnter") {
							_ev.preventDefault();
							//if we call seekAudioTo() here, it would be invoked twice with one more time at focusout event. So, I call blur() to make textbox lost focus
							_ipDuration2Seek.blur();
						}

						if (_ev.code === "Escape") {
							_popupDiv.classList.remove("shortPoupShow"); //do nothing
						}
						_ev.stopPropagation();
					}

					//user click outside the small popup would work as click Escape in above onkeyup
					_ipDuration2Seek.addEventListener("focusout", seekAudioTo);

					//This function has only one job to avoid event propagate upward in the DOM, so that key press on this textbox not bubbling up, so keydown event handlers of main page would not does what it is intended to do such as pause/stop audio, key -/+ can decrase/increase audio playbackRate, open book sdd or chapter sdd
					_ipDuration2Seek.addEventListener("keydown", evt => {evt.stopPropagation()});
				}
			}

			/* Scroll to chapter in playlist that is playing. This would be invoked when new chapter is playing or when user click on scroll to playing chapter button */
			static gotoPlayingChapter() {
				let _liNewChap = elmPlaylist.querySelector("li.beingPlay");
				if (!_liNewChap) return; //this should never happen

				let _liParent = _liNewChap.parentElement;
				// if new playing chapter is inside a chapter group, then open that group if it currently close
				let _isSectionExpanded = true;
				let _chapGrpCheckbox = null; //checkbox that control the expand/collapse state of a section
				if (_liParent.nodeName == "SECTION") { //can use tagName or localName
					_chapGrpCheckbox = _liParent.previousElementSibling.previousElementSibling;
					_isSectionExpanded = _chapGrpCheckbox.checked;
					_chapGrpCheckbox.checked = true;

					//this has been done in _scrollToView, so we skip it here
					//if (_chapGrpCheckbox.checked != _isSectionExpanded) this.chapGrpChkboxClick(_chapGrpCheckbox); //save state of this checkbox only when its state changed
					//this.updateAllChapGrpChkboxUI(); //update UI of allChapGrpChkbox
				}
				let _scrollToView = _ => {
					//scroll to make _liNewChap in the middle of elmPlaylist with 'smooth' effect
					SddDropdown.prototype.scrollToElement(elmPlaylist, _liNewChap, 'smooth', true); 

					//wait for sometime until animation ends; if _liNewChap still out of view, scroll it again to make it in the middle of elmPlaylist (its container)
					setTimeout(_ => {
						//distance from _liNewChap top to top of container
						const _topDistance = _liNewChap.getBoundingClientRect().top - elmPlaylist.getBoundingClientRect().top;
						//if _liNewChap still out of view, scroll it again
						if( _topDistance < 0 || _topDistance > elmPlaylist.offsetHeight )
							SddDropdown.prototype.scrollToElement(elmPlaylist, _liNewChap, 'smooth', true);
						
						//if some sections label overlap, make it stick to the top of playlist
						_chapGrpCheckbox && setTimeout(_ => { utilityHandles.chapGrpChkboxClick(_chapGrpCheckbox, false)}, 200);
					}, 0);

					/* _liNewChap.scrollIntoView({
						behavior: 'smooth', //smooth sometime does not scroll to the location of playing chapter. Change to 'auto' might lack of scroll animation, but when the page first start, it can scroll into playing chapter
						block: 'center', //vertically centered
						inline: 'end'
					}) */
				}

				if (_isSectionExpanded) _scrollToView()
				else
					setTimeout(_ => {_scrollToView(); }, 800); //wait for closed section to be expanded before scrolling
			}

			/** This change UI (checked, indeterminate, not checked) of allChapGrpChkbox based on state of all chapGrpChkbox which decide a chapter group is collapse or expand */
			static updateAllChapGrpChkboxUI() {
				let _allChapChkbox = elmPlaylist.querySelectorAll("input[id^='chapGrpChkbox']");

				//count the number of expanded chapter group
				let _chkCount = 0, _chkTotal = _allChapChkbox.length;
				_allChapChkbox.forEach(_chkBox => {
					if (_chkBox.checked) _chkCount++;
				});

				let _chkExpandChapterGrp = document.getElementById("allChapGrpChkbox");
				let _chkLabel = _chkExpandChapterGrp.nextElementSibling;
				//watch for the tooltip change, so position it properly
				ssData.ttMutationObserver.observe(_chkLabel, { attributes: true, attributeFilter: ["data-tooltip"] });

				//update the tooltip
				_chkLabel.setAttribute("data-tooltip", `Đóng/mở tất cả các chapter group\n` + ((_chkCount == 0 || _chkCount == _chkTotal) ? `Tất cả các ${_chkTotal} nhóm chương đang ${_chkCount == 0 ? "đóng" : "mở"}` : `Hiện có ${_chkCount} trong ${_chkTotal} nhóm chương đang mở`));

				//update the checkbox state and UI
				setChkboxState(_chkExpandChapterGrp,
					_chkCount == 0 ? 0 : (_chkCount == _chkTotal ? 1 : 2));
			}

			/** handler for chapter group changing state from expand to collapse and vice versa 
				* @param _chapGrpChkbox {checkbox}: the checkbox of chapter-group which is changing state
				* @param _notCheckPosition: if [false] (default is false or missing), the page check all chapter-group-label to see if there is any one overlap (other label) or missed-recognized as pinned item. The reason see below. If [true], the checking is ignored
			Because scroll too fast, so IntersectionObserver object might not catch some lables being pinned at top of elmPlaylist, thanks to scrollTo, they are now moved down but still keep .stickyPinned class. So, we might need to go through all label and remove .stickyPinned from all label that below elmPlaylist top			
			*/
			static chapGrpChkboxClick(_chapGrpChkbox, _notCheckPosition) {
				//let _chapGrpChkbox = evt.target;
				let _grpNo = parseInt(_chapGrpChkbox.getAttribute("attr-grpNo"));

				let _bookxState = xState.history.books[xAudio.getAttribute("attr-book")];
				if(!_bookxState.chapGrpCollapse) return;

				let _idx = _bookxState.chapGrpCollapse.indexOf(_grpNo);
				let isChecked = _chapGrpChkbox.checked;

				if (_idx > -1 && isChecked)
					_bookxState.chapGrpCollapse.splice(_idx, 1); //remove it
				if (_idx === -1 && !isChecked)
					_bookxState.chapGrpCollapse.push(_grpNo); //add it
				utilityHandles.updateAllChapGrpChkboxUI(); //update allChapGrpChkbox UI when a group chapter change collapse/expand state

				//Check all label position to see if any one overlap or miss-recognized as pinned
				if (!_notCheckPosition) setTimeout(_ => { // && !isChecked
					let _parentTop = elmPlaylist.getBoundingClientRect().top;
					let _allChapGrpLabel = elmPlaylist.querySelectorAll("input[type='checkbox'] + label.is-sticky");

					let _stopCheck = false;
					for (let i = 0; i < _allChapGrpLabel.length; i++) {
						let _label = _allChapGrpLabel[i];
						let _lblRect = _label.getBoundingClientRect();
						let _lblTop = _lblRect.top;

						if (_lblTop >= _parentTop) {
							_label.classList.toggle("stickyPinned", _lblTop <= _parentTop + 1); //1 is just number got on experiment
							//console.log(_label.getAttribute("for") + ": " +  _lblTop + ". " + _parentTop);
						}

						if (!_stopCheck) {
							let _prevLblBottom = i > 0 ? _allChapGrpLabel[i - 1].getBoundingClientRect().bottom : -10;
							if (_lblTop < _prevLblBottom && _lblRect.bottom > _prevLblBottom) {
								{ //here
									elmPlaylist.scrollBy({ left: 0, top: (_lblTop - _prevLblBottom - 4), behavior: "smooth" }); //6 is label's margin-top/bottom (4px) + border-width (1.5px)
								}
								_stopCheck = true; //no need to check anymore, because in one moment, there is maximum 1 label overlap
							}
						}
					}
				}, 800); //800msec is safe interval for all transitions finished
			}

			/* update new artwork to notification center */
			static updateNCWorkart() {
				if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
					//it seems after assigned, navigator.mediaSession.metadata being read-only
					let _meta = navigator.mediaSession.metadata; //old one
					//assign the new MediaMetadata with same old data, except the new artwork
					navigator.mediaSession.metadata = new MediaMetadata({
						title: _meta.title,
						artist: _meta.artist,
						album: _meta.album,
						artwork: [
							{ src: elmArtwork.src, sizes: '512x512', type: 'image/png' }
						]
					});
				}
			}

			/** show/hide the workart image and hide/show the NoInternet svg image
			 * @param _show {boolean}. Default is navigator.onLine value
			 * 	true: show the workart and hide the NoInternet icon
			 * 	false: vice versa
			 */
			static showNoInternet(_show = navigator.onLine ){
				document.getElementById("elmArtwork").parentElement.classList.toggle("elm-hidden", !_show);
				document.querySelector(".noInternetImg").classList.toggle("elm-hidden", _show);
			}

			/* fetch the media url to get its size (in MB) and return it to callback function
				path {string}: url to media
				callback: callback function to pass result to 
					if successed: the result pass to would be like: {success: 1, msg: the-message-content}
					if failed: the result pass to would be like: {success: 0, msg: ""}
			*/
			static getFileSize(_urlPath, _callback) {
				_callback = _callback ?? (_msg => { console.log(_msg.msg) });
				//currently, only these two sites accept Cors
				if (!_urlPath.match(/www\.google|medialib\.qlgd/)) return _callback({ success: 0, msg: "" }); //archive\.org|

				/** format number of bytes into highest unit possible 
				 * @return {str: string of formatted size with unit, idx: the index of unit in UNITS array}: idx is added for purpose of formating
				 * @refer at: https://www.30secondsofcode.org/js/s/pretty-print-number-of-bytes/
				*/
				const prettyBytes = (num, precision = 2, addSpace = false) => {
					const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
					if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0];

					const exponent = Math.min(
						Math.floor(Math.log2(num < 0 ? -num : num) / 10),
						UNITS.length - 1
					);

					const n = Number(
						((num < 0 ? -num : num) / 1024 ** exponent).toFixed(precision)
					); //Math.pow(2,10) = 1024

					return {str: (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent], unit: UNITS[exponent], indx: exponent};
				};

				//create ChainToasts object
				const chainToast = new toast.ChainToasts("Đang lấy dữ liệu dung lượng file");
				//get only small HEAD
				fetch(_urlPath, { method: 'HEAD', cache: "force-cache" })
					.then(function (response) {
						/* let _contentType = response.headers.get("content-type");
						let _lastModified = response.headers.get("Last-Modified");
						console.log(`Content type: ${_contentType}. Last modified: ${_lastModified}`); */

						let _contentSize = response.headers.get("content-length");
						if (!_contentSize) {
							chainToast.checkoutToast(`Không lấy được dữ liệu dung lượng file.`, toast.ToastType.Error);
							return _callback({ success: 0, msg: "" });
						}

						_contentSize = parseInt(_contentSize, 10);

						//two array for unit and corresponding color
						//const _UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
						const _UNITS_COLOR = ['Black', 'Blue', 'Green', 'Red', 'DarkBlue', 'DarkGreen', 'DarkRed', 'DarkRed', 'DarkRed'];
						//pretty print the file size
						const {str: _fileSize, unit: _unit, indx: _idx} = prettyBytes(_contentSize);

						const _sizeStr = `<code style='color:${_UNITS_COLOR[_idx]}'>${_fileSize}</code>`;
						chainToast.checkoutToast(`Dung lượng file media vừa được cập nhật ${_fileSize}`, toast.ToastType.Success);
						_callback({ success: 1, msg: _sizeStr, size: _fileSize, unit: _unit, inbyte: _contentSize });

					}).catch(
						error => {
							chainToast.checkoutToast(`[${error.message}] Không lấy được dữ liệu dung lượng file.`, toast.ToastType.Error);
							_callback({ success: 0, msg: "" });
							console.warn('[fetchHead] Error on fetching header:', error.message); //error
						});
			}
		}

		/* Class to handle history buttons and functions */
		class historyCls {
			/* Change the button enable/disable state and their tooltips, titles.
			Because this function is sort of PRIVATE func, so you can access it by calling historyCls.prototype.buttonAppeance()
			*/
			buttonAppeance() {
				let _hist = xState.history;
				let _elmF = document.getElementById("elmHistoryGoForward");
				let _elmB = document.getElementById("elmHistoryGoBackward");
				//let _elmC = document.getElementById("elmHistoryClear");

				//if history data is empty
				if (_hist.hisList.length <= 1) {
					_elmF.classList.add("elm-disabled");
					_elmB.classList.add("elm-disabled");
					//_elmC.classList.add("elm-disabled");
					return;
				}
				//else _elmC.classList.remove("elm-disabled");

				if (_hist.currHis == _hist.hisList.length - 1) { //if current book is the last one in history
					_elmF.classList.add("elm-disabled")
				}
				else {
					const _adjHist = historyCls.prototype.getAdjHist(1); //get next book in history list

					if(_adjHist){
						//observer the tooltip changes to fix its position
						ssData.ttMutationObserver.observe(_elmF, { attributes: true, attributeFilter: ["data-tooltip"] });
						_elmF.classList.remove("elm-disabled");
						
						_elmF.setAttribute("data-tooltip", makeBrk(_adjHist.mc) + " " + _adjHist.title);
					}
				}

				//current book is the first one, just disable #elmHistoryGoBackward button
				if (_hist.currHis == 0) _elmB.classList.add("elm-disabled")
				else {
					const _adjHist = historyCls.prototype.getAdjHist(-1); //get previous book in history list

					if(_adjHist){
						//observer the tooltip changes to fix its position
						ssData.ttMutationObserver.observe(_elmB, { attributes: true, attributeFilter: ["data-tooltip"] });
						_elmB.classList.remove("elm-disabled");
						
						_elmB.setAttribute("data-tooltip", makeBrk(_adjHist.mc) + " " + _adjHist.title);
					}
				}
			}

			// flag to avoid adding the book shown by historyCls.historyGo() into on top of History List
			static histCallFlag = false;

			/** function for Clear history button. This function clear all history information, just keep the information of current Book, current Chapter */
			static historyClear() {
				let _hist = xState.history;
				//get current playing book store in xAudio element
				const _currBook = xAudio.getAttribute("attr-book"), _currChap = xAudio.getAttribute("attr-chap");
				_hist.currHis = 0;
				_hist.hisList.length = 0; //empty history list
				_hist.hisList.push(_currBook); //keep only current playing book
				xState.lb = _currBook; //make last book to be _currBook (just in case)

				//delete the history details of each book, except information of current chapter of current book
				for(let _book in xState.history.books) {
					if(_currBook !== _book)
						//delete information about all books except current book
						delete xState.history.books[_book];
					else{
						// keep information of current chapter of current book
						let _histBook = xState.history.books[_currBook];
						
						//delete information about all other chapter except current chapter
						Object.keys(_histBook)
							//filter all attributes that is a number, those are the chapter AND make sure it is NOT _currChap
							.filter( _attr => _attr.match(/^\d+$/) && _attr != _currChap )
							//delete information about the chapters
							.forEach(_chap => delete _histBook[_chap]);
						//make last book to be _currChap (just in case)
						_histBook.lc = _currChap;
					}
				}
				toast.showToast("Đã xóa toàn bộ lịch sử nghe sách", toast.ToastType.Success, {persistance: true});

				historyCls.prototype.buttonAppeance();
			}

			/** Add a new play book to history. This is called from changeBook() function. The book will be added to the end of history.hisList
			 * @param _bookId {8-chars string} the book Id
			*/
			static addToHistory(_bookId) {				
				let _hist = xState.history;
				if (this.histCallFlag) { //If changeBook() is called from History go backward or forward (see historyGo below), not add this book into history-database
					this.histCallFlag = false; //reset flag
				}
				else {
					//check to see of the new loading book is already in hisList
					const _bookIdx = _hist.hisList.indexOf(_bookId);
					//if the book is already in the hisList, remove it out of old position, then push it in the top of hisList
					if(_bookIdx > -1 ) _hist.hisList.splice(_bookIdx, 1);

					//push the new loaded book into the top of hisList and update the pointer accordingly
					_hist.hisList.push(_bookId);
					_hist.currHis = _hist.hisList.length - 1;
				}

				historyCls.prototype.buttonAppeance(); //history buttons enable/disable
			}
			
			/** function to get adjacent book in history list. If it not exist, clear all not-exist-anymore book from history list AND xState and get again
			 * @param dir {1 or -1}: 1: get next book in history list. -1: get previous
			 * 		Or in some rare case (such as calling from bookDataInitial() ), dir=0 just to clean the history and get the last book in history list
			 * @return: - if after being purged, the list is empty, it return {null}.
			 * 			- if the adjacent book is out of range of history List (-1 or hisList.length), return {undefined}.
			 * 			- else the book data of the adjacent book in history list.
			*/
			getAdjHist(dir){
				let _hist = xState.history;
				if(_hist.hisList.length == 0){
					_hist.currHis = 0;
					historyCls.prototype.buttonAppeance(); //change appearance
					return null;
				}

				let _new_currHist = _hist.currHis + dir; //new currHis if item before it being purged
				if(_new_currHist < 0 || _new_currHist >= _hist.hisList.length) return undefined;
				const _adjBook = ssData.bookData.findBookFromId(_hist.hisList[_new_currHist]);
				if( _adjBook ) return _adjBook; //book still exists, return it

				/* Books not exist, need to clean history list from not-existed books.
				This should never be happening, because in bookDataInitial(), the xState.history has been clean to remove all unexisted-books. */
				historyCls.cleanHist(); //clean the history
				return historyCls.prototype.getAdjHist(dir); //get again, but on all-existed-books history list
			}

			/** function to clean history in the case that some books stored in xState.history that not existed anymore (because of the change in DBs setting (DB which contains that book is not being set to load in this page session) or the change in DB itself)
			 * @note after being purged, the xState.history.currHis also being updated so that it still point to the same-old book it has pointed to before being purged.
			 * @note after being purge, if the hisList is empty, we will get some random-existed book to be the initial book, this book will be loaded when the page loaded
			 * @important this is only being invoked from BookData.bookDataInitial() to clean the history before working on the page
			 
			 * @return: the newly-updated xState.history.currHist
			*/
			static cleanHist(){
				
				let _hist = xState.history;
				/* This choose a random book to be the first book to load to the page when history is empty (when the page loaded very first time or after being historyCls.wipeAll(0) ). Filling in xState.history will be taken care by bookDataInitial() function */
				const _setFirstBook = _ => {
					//hisList after being purge is empty, we need to get an ramdom-existed book to be set as initial book
					const _bookdefault = Math.floor(Math.random() * ssData.bIds.length); //0 //the book that would be load when page is load in very first time in user's device
					let _lastBook = ssData.xData[_bookdefault].bookId; //default to load the first book
					//TODO: set this _lastBook and do historyCls.wipeAll() on the console, there is an error
					//_lastBook = '1bbc350f';
					
					// after setting xState["lb"], the rest task of loading book/chapter, and by the same time adding information to xState.history will be taken by selBookGroup.onchange() call in bookDataInitial() function.
					xState["lb"] = _lastBook; 

					_hist.currHis = 0;
				}

				if(_hist.hisList.length == 0){
					_setFirstBook();

					//_hist.currHis = 0;					
					return null;
				}

				let _currHist = _hist.currHis; //now, use _currHist as alias for _hist.currHis
				
				let  purgeIdxArr = []; //array of purged indexes
				//go backward, so purgeIdxArr is in decreasing order
				for(let i= _hist.hisList.length - 1; i >=0; i--  ){ //ssData.bIds contains bookId of all existing books
					if(!ssData.bIds.includes(_hist.hisList[i])){
						purgeIdxArr.push(i);

						if(i <= _currHist) _currHist--;
					}
				};

				//remove information about not-existed-anymore books
				if(purgeIdxArr.length > 0){
					toast.showToast(`Có ${purgeIdxArr.length} cuốn sách không còn tồn tại bị xóa khỏi lịch sử nghe sách`, toast.ToastType.Warning, {persistance:true});

					//remove books whose index stored in 
					purgeIdxArr.forEach(_idx => {
						const _book_id = _hist.hisList[_idx];
						//remove information about the book from xState
						if( _hist.books.hasOwnProperty(_book_id) ) delete _hist.books[_book_id];

						//remove purged item out of history list
						_hist.hisList.splice(_idx, 1);
					} );

					// after remove old books, there may be two consecutive books duplicate. Remove one of them
					let i= _hist.hisList.length - 1;
					while( i > 0  ){
						if(_hist.hisList[i] == _hist.hisList[i-1]) {
							_hist.hisList.splice(i, 1);
							if(i <= _currHist) _currHist--;
						}
						i--;
					};
				}

				if(_hist.hisList.length == 0) {
					//initialize the history when it is empty
					_setFirstBook();
					_currHist = 0;					
				}
				else {
					if(_currHist < 0) 
						_currHist= 0
					else if(_currHist >= _hist.hisList.length) 
						_currHist = _hist.hisList.length - 1;
					
					_hist.currHis = _currHist; //update position for current item in history list
					xState["lb"] = _hist.hisList[_currHist];
				}				

				return _currHist;
			}
			
			/** Go back and forward in history list 
				@param _dir: =-1 go backward, 1 go forward
					if @_dir is 8-char string, it is book Id
			*/
			static historyGo(_dir) {
				let _hist = xState.history;
				this.histCallFlag = true; //turn this flag on so addToHistory() above function know that changeBook() is called from historyGo, so addToHistory() will not add the book into history

				// if _dir is direction, go next or previous in history list
				if('number' === typeof _dir){
					_dir = _dir == 1? 1: -1;					

					const _adjHist = historyCls.prototype.getAdjHist(_dir);
					if(_adjHist){
						_hist.currHis += _dir; //update position of current history item
						//load the book. This will invoke changeBook(), but because histCallFlag is set to true above, so the loaded book will not be added into history list again.
						ssData.bookData.goGetBook(_adjHist.bookId); //note that goGetBook reload the elmSelBookTitles book list
					}
				}
				//if _dir is book id
				else if('string' === typeof _dir){
					//now, _dir is bookId
					const _bookId = _dir;
					let _bookIndex = _hist.hisList.indexOf(_bookId);
					//if the bookId not in history list, do nothing
					if(_bookIndex == -1) return;
					//update position of current history item
					_hist.currHis = _bookIndex;
					//call getAdjHist() in case that the book is removed because the change in the DBs
					const _adjHist = historyCls.prototype.getAdjHist(0);
					if(_adjHist){						
						//load the book. This will invoke changeBook(), but because histCallFlag is set to true above, so the loaded book will not be added into history list again.
						ssData.bookData.goGetBook(_adjHist.bookId); //note that goGetBook reload the elmSelBookTitles book list
					}
				}
				
				historyCls.prototype.buttonAppeance();
			}

			/** Clear all information saved in xState, not just books reading history, but also other information such as last playing time, grpLine, urlLine 
			 * @param mode 
			  		@value 0 or missing: completely wipe out xState (which store environment variable across page session) and xDBFilesCfg (which store setting for DBs file)
					@value 1: just clean xState, keep xDBFilesCfg so next session, the page would load only DBs that user set
			*/
			static wipeAll(mode) {
				mode = mode ?? 0;
				if (!confirm("Bạn muốn xóa toàn bộ lịch sử trang Web đã lưu?\n\n Sẽ cần phải nạp lại trang Web.")) return;
				xState = {}; //clear the xState
				localStorage.clear(); //clear local storage
				
				// if mode =1, save back the changes in xDBFilesCfg
				if(mode == 1) localStorage.setItem('xDBFilesCfg', JSON.stringify(xDBFilesCfg)); else xDBFilesCfg=null;
				
				//Force a hard reload to clear the cache if supported by the browser
				window.location.reload(true);
			}
		}

		/* Class to allow items of a list to be DRAG AND DROP */

		/* constructor
				_dragItemsQuery: json contain the parent container and css query string to get list of children which is dragitems. Format: {"parent": wrapper element, "queryString" : "li"}
				_exchangeFnc: callback function to do something after each drop
			*/
		let dragDropList = function (_dragItemsQuery, _exchangeFnc) {
			let dragItemsQuery = _dragItemsQuery;
			let dragItems = _dragItemsQuery["parent"].querySelectorAll(_dragItemsQuery["queryString"]);

			let exchangeFnc = null;
			if (_exchangeFnc) exchangeFnc = _exchangeFnc;

			//Setter to set callback function to change the list after drag and drop. This will take two parameter fromIdx, toIdx which are the index of drag&drop item 
			function setExchangeFnc(_exchangeFnc) {
				exchangeFnc = _exchangeFnc;
			}

			/* all action to deal with drag & drop */
			function handleDragDrop() {
				// (PART B) FLAG FOR "CURRENT ITEM BEING DRAGGED"
				let dragged;
				let cancelDefault = (event) => {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}

				// (PART C) DRAG-AND-DROP MECHANISM
				dragItems.forEach((_item, _idx) => {
					// (C1) LIST ITEM IS DRAGGABLE
					_item.draggable = true;
					_item.setAttribute("attr-dragIdx", _idx);

					// (C2) ON DRAG START - SET FLAG & DATA TRANSFER
					_item.ondragstart = event => {
						dragged = _item;
						const _dt = event.dataTransfer;
						_item.classList.add("activeDragItem");
						_dt.dropEffect = "move";
						_dt.effectAllowed = "move";
						//_dt.setData("text/html", _item.innerHTML);
						_dt.setData("text/plain", _item.getAttribute("attr-dragIdx"));

						const offsetX = 0, offsetY = 0;
						const createDragImage = function($node, x, y) {
							const _ghostNode = document.createElement("div"); // $node.cloneNode(true);
							const _node$pos = $node.getBoundingClientRect();
							_ghostNode.innerHTML = "Dragging: " +  $node.innerHTML;
							_ghostNode.style.top =  _node$pos.top  + "px"; //$node.offsetTop // Math.max(0, y - offsetY) + "px";
							_ghostNode.style.left = _node$pos.left + "px"; // $node.offsetLeft // Math.max(0, x - offsetX) + "px";
							_ghostNode.style.width = $node.offsetWidth + "px";
							_ghostNode.style.height = $node.offsetHeight + "px";
							_ghostNode.classList.add("draggingGhostElem");
							
							document.body.appendChild(_ghostNode);

							setTimeout(_ => document.body.removeChild(_ghostNode));

							return _ghostNode;
						};
						var ghostNode = createDragImage(dragged, event.pageX, event.pageY);
      					_dt.setDragImage(ghostNode, offsetX, offsetY);
						//event.dataTransfer.setDragImage(_item, 664, 44);
						//dragItems.forEach(_item => _item.querySelector("div:has(> span.dbFileBookList)")?.classList.add("elm-hidden"));
					};

					// (C3) ON DRAG OVER - NECESSARY PREVENT DEFAULT FOR DROP TO WORK
					_item.ondragover = event => {
						//event.preventDefault();
						cancelDefault(event);
					}

					// (C4) ON DROP - "SWAP POSITION"
					_item.ondrop = event => {
						//event.preventDefault();
						cancelDefault(event);
						if (dragged != _item) {
							//dragged.innerHTML = _item.innerHTML;
							//_item.innerHTML = event.dataTransfer.getData("text/html");

							let _fromIdx = event.dataTransfer.getData("text/plain"),
								_toIdx = _item.getAttribute("attr-dragIdx");
							_fromIdx = parseInt(_fromIdx), _toIdx = parseInt(_toIdx);
							if (exchangeFnc) exchangeFnc(_fromIdx, _toIdx); //invoke callback function to do the real exchange on the list outside

							//paint item just being dragged differently
							dragItemsQuery["parent"].querySelector(`[attr-dragIdx = "${_fromIdx}"]`).classList.add("beingPlay");

							//update attr-dragIdx for all item effected by the drag&drop action
							if (_fromIdx > _toIdx) {
								dragItems[_fromIdx].setAttribute("attr-dragIdx", _toIdx);
								for (let i = _toIdx; i < _fromIdx; i++) {
									dragItems[i].setAttribute("attr-dragIdx", i + 1);
								}
							}
							else {
								dragItems[_fromIdx].setAttribute("attr-dragIdx", _toIdx);
								for (let i = _fromIdx + 1; i <= _toIdx; i++) {
									dragItems[i].setAttribute("attr-dragIdx", i - 1);
								}
							}

							//we need to re-assign dragItems to update the items' order changes
							dragItems = dragItemsQuery["parent"].querySelectorAll(dragItemsQuery["queryString"]);

							//dragItems.forEach(_item => _item.querySelector("div:has(> span.dbFileBookList)")?.classList.remove("elm-hidden"));
						}
					};

					// (C5) NOT REALLY IMPORTANT - COSMETICS
					_item.ondragenter = (event) => { _item.classList.add("activeDropItem"); cancelDefault(event); }
					_item.ondragleave = (event) => { _item.classList.remove("activeDropItem"); cancelDefault(event); }
					_item.ondragend = (event) => {
						dragItems.forEach((_itm) => {
							_itm.classList.remove("activeDragItem", "activeDropItem");
						});
					};
				});
			}

			/* public methods */
			return {
				exchangeFnc: setExchangeFnc, /* setter function for callback function exchangeFnc */
				handleDragDrop: handleDragDrop /* Function to handle drag & drop */
			}
		}

		/* Class deal with user-setting on book group, show/hide books for each group, and show/hide circle progress on Play/Pause buttons 
		To optimize user experience, every time a check box (which define the group visible or hidden) is clicked, everytime a group is drag and drop, this function is called automatically to save the change in setting right away, without any further action to click on some kind of "save setting" buttons
		*/
		function Setting() {
			let _dragObj = null; // instance object of dragDropList class to handle drag&drop
			const xBookGrp = ssData.xBookGrp;
			
			/**
			 * HELPER FUNCTIONS
			  */
			//setting for circle progress button
			function handleBufferBarChkbox() {
				let _chkHideBufferBar = document.getElementById("chkHideBufferBar");
				_chkHideBufferBar.checked = !xState.hideBufferBar;

				if (!_chkHideBufferBar.onclick) //if click event has not been handled
					_chkHideBufferBar.onclick = (_ev) => { //user make change to show/hide buffer bar.
						xState.hideBufferBar = !_ev.target.checked;

						document.querySelector(".ap-buffer-bar").classList[xState.hideBufferBar ? "add" : "remove"]("elm-hidden");

						if (!xState.hideBufferBar) {
							toast.depressToast(true);
							//toast.depressToastFlag = true; //turn on flag so the toast Message will not display
							xAudio.onseeked(); //to update UI of the buffer bar
						}
					}
			}

			/* move an item of array ${arr} from index ${fromIndex} to index ${fromIndex} */
			function arrayMove(arr, fromIndex, toIndex) {
				let element = arr[fromIndex];
				arr.splice(fromIndex, 1); //take fromIndex item out
				arr.splice(toIndex, 0, element); //insert to toIndex
			}

			/* Compare two json object. Return TRUE if equals 
			Adapt from https://www.30secondsofcode.org/js/s/object-comparison/
			*/
			function objsEqual(obj1, obj2) {
				if (obj1 === obj2) return true;

				if (obj1 instanceof Date && obj2 instanceof Date)
					return obj1.getTime() === obj2.getTime();

				if (!obj1 || !obj2 || (typeof obj1 !== 'object' && typeof obj2 !== 'object'))
					return obj1 === obj2;

				if (obj1.prototype !== obj2.prototype) return false;

				const keys = Object.keys(obj1);
				if (keys.length !== Object.keys(obj2).length) return false;

				return keys.every(k => objsEqual(obj1[k], obj2[k]));
			};

			//setting for circle progress button
			function handleCircleProgressChkbox() {
				let _chkDisableCircleProgress = document.getElementById("chkDisableCircleProgressButton");
				_chkDisableCircleProgress.checked = !xState.disableCircleProgressButton;

				if (!_chkDisableCircleProgress.onclick) //if click event has not been handled
					_chkDisableCircleProgress.onclick = (_ev) => { //user make change to circle progress button setting.
						xState.disableCircleProgressButton = !_ev.target.checked;

						//update the Play button interface. See AudioPlayer.switchPlayPauseButton() for more details. Svg icon here can be #icnSvgSpinWaiting, #icnSvgPlay, #icnSvgPause OR #icnSvgSpinWaiting, #icnSvgPlayProgress, #icnSvgPauseProgress
						document.querySelectorAll("[svg-icon-name='PlayPauseIcon']").forEach(_elm => {
							let _currSvg = _elm.getAttribute("href");
							if (_currSvg == "#icnSvgSpinWaiting") return //if it is loading spinner, keep it the same
							else {
								if (xState.disableCircleProgressButton) {
									_currSvg = _currSvg.replace("Progress", ""); // Remove sufix "Progress" from the end of icon to make icon simple icon
								}
								else
									_currSvg += "Progress"; // Add sufix "Progress" to the end of icon to make icon 'circle progress'
							}
							_elm.setAttribute("href", _currSvg); //change svg icon
						});
					};
			}

			/* Function to change the UI of Book Kit checkbox depending on checked state of all of its book set checkbox. This function is called only  in bookSet view mode (which having #chkbox-BK-* checkbox) 
			This function should be put inside bookSetList(), but because of event delegation handler _showhideBookChkboxClickDelegation(), we have to move it out
			*/
			let updateBKchkboxUI = _bkIndex => {
				let _chkBookKit = document.getElementById(`chkbox-BK-${_bkIndex}`);
				if (!_chkBookKit) return; //if this book kit has only one book set, so there is no book kit checkbox

				//now count the number of checked book sets
				let allChkboxCount = 0, checkedCount = 0;
				document.querySelectorAll(`.modalPopupContent input[type='checkbox'][attr-bookkit-father='${_bkIndex}']`).forEach(_liChkBox => {
					allChkboxCount++;
					if (_liChkBox.checked) checkedCount++;
				});
				setChkboxState(_chkBookKit, checkedCount === 0 ? 0 : (checkedCount === allChkboxCount ? 1 : 2));

			};

			/**
			 * TABS FUNCTIONS
			 */

			//ol that display all sub-group and books of a group way
			const lstBookTitlesSetting = document.getElementById("lstBookTitlesSetting");
			/* handle with the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item 
				_grpLine {integer}: the index of group line, which is also selected index of selPopupBookGroup
			*/
			function bookSetList(_grpLine) {
				let xbookGrp_grp = xBookGrp[_grpLine].grp;

				lstBookTitlesSetting.innerHTML = ""; //clear the last book dropdown list
				let gStt = 1;
				for (let j = 0; j < xbookGrp_grp.length; j++) {
					let bookGrpItem = xbookGrp_grp[j];
					let _numberOfBooks = bookGrpItem.books.reduce((_total, _currItem) => { return _total + _currItem.bList.length }, 0);

					let _liGrpTitle = document.createElement('li');
					_liGrpTitle.innerHTML = `<input type="checkbox" ${bookGrpItem.bHidden ? "" : "checked"} role="switch" attr-BookKit-Father="${bookGrpItem.bookKit}" /><code data-rAlignGroup="itemOrder">${makeBrk(gStt++)}</code> <span>${bookGrpItem.label}<sup>${bookGrpItem.bookKit}</sup> ${makeBrk(_numberOfBooks)}</span>`;
					_liGrpTitle.setAttribute("attr-grpID", bookGrpItem.gId);
					//_liGrpTitle.setAttribute("attr-BookKit-Father", bookGrpItem.bookKit);

					lstBookTitlesSetting.appendChild(_liGrpTitle);
				}

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						// console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _itemDrop = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + t + "']");
						if (f > t)
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop);
						else
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						arrayMove(xbookGrp_grp, f, t); //re-arrange for xBookGrp
						arrayMove(xState.grpCfg[_grpLine].grp, f, t); //re-arrange for xState.grpCfg

						//re-calculte book kit rank
						ssData.bookData.calculateBookKitRank(_grpLine);
					}
					_dragObj = dragDropList({ "parent": lstBookTitlesSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated

				/* Create checkbox for book Kit that has more than 1 book sets */
				const bookKitInfor = ssData.bookKitInfor;
				let bkCounts = bookKitInfor.map(_it => 0);
				xBookGrp[_grpLine].grp.forEach(_it => bkCounts[_it.bookKit]++);
				let bookKitHTML = "";
				let _stt = 0;
				for (let i = 0; i < bkCounts.length; i++) {
					if (bkCounts[i] <= 1) continue;
					let _bkIdx = bookKitInfor[i].bkIdx;
					bookKitHTML += `<div class="bookKitNo${_stt++}"><input id="chkbox-BK-${_bkIdx}" type="checkbox" role="switch" attr-BookKit="${_bkIdx}" class="!text-[25px]"/>
			<label for="chkbox-BK-${_bkIdx}">${bookKitInfor[i].label}</label></div>`;
				}
				let bookKitChkboxContainer = document.querySelector('[name="bookKitChkboxContainer"]');
				bookKitChkboxContainer.innerHTML = bookKitHTML;
				bookKitChkboxContainer.querySelectorAll("input[type='checkbox'][id*='chkbox-BK-']").forEach(chkBox => {
					let _bkIndex = chkBox.getAttribute("attr-bookKit");
					updateBKchkboxUI(_bkIndex); //update Book Kit UI corresponding with its Book Sets checked state

					let _bkIdx = chkBox.getAttribute("attr-bookKit");
					let _bookSetsChilds = document.querySelectorAll(`.modalPopupContent input[type='checkbox'][attr-bookkit-father='${_bkIdx}']`);

					// add class for all Book sets children of this Book Kit, so when hover the Book Kit, all of its book sets will highlight (using CSS)
					let _clsName = chkBox.parentElement.classList[0];
					_bookSetsChilds.forEach(_liChkBox => {
						_liChkBox.parentElement.classList.add(_clsName + "-Childs");
					})

					// Change checked state of all Book Sets with theirs Book Kit checked state
					chkBox.onclick = function (evt) {
						//let chkBox = evt.target;
						//let _bkIdx = chkBox.getAttribute("attr-bookKit");
						// make all Book Set that belong to the Book Kit be shown/hidden with the checked state of the Book Kit checkbox
						_bookSetsChilds.forEach(_liChkBox => {
							_liChkBox.checked = chkBox.checked; // change book set UI

							let _gid = _liChkBox.parentNode.getAttribute("attr-grpid"); //book set Id
							xState.grpCfg[_grpLine].grp.find((_it) => { return _it.gId === _gid }).bHidden = !_liChkBox.checked; //update to xState.grpCfg

							xBookGrp[_grpLine].grp.find((_it) => { return _it.gId === _gid }).bHidden = !_liChkBox.checked; //update to xState.grpCfg
						});
					}
				});
			}

			/* handle with the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item 
				_grpLine {integer} the index of group line, which is also selected index of selPopupBookGroup
			*/
			function bookKitList(_grpLine) {

				//rank of each book kit in this group line
				const bookKitInfor = ssData.bookKitInfor;
				let _tempRank = bookKitInfor.map(_it => { return { bkIdx: _it.bkIdx, rank: _it.grpRanks[_grpLine].rank } });

				//sort book kit list by the rank
				let _tempBookKitInf = bookKitInfor.toSorted((x, y) => _tempRank[x.bkIdx].rank - _tempRank[y.bkIdx].rank);

				/* Count number of hidden book set for each book kit */
				bookKitInfor.forEach(_it => _it.grpRanks[_grpLine].bsHidden = 0);//reset hidden book set Count to 0 for this group line
				let xbookGrp_grp = xBookGrp[_grpLine].grp;
				for (let j = 0; j < xbookGrp_grp.length; j++) {
					let bookGrpItem = xbookGrp_grp[j];
					let _bkIdx = bookGrpItem.bookKit;

					if (bookGrpItem.bHidden) bookKitInfor[_bkIdx].grpRanks[_grpLine].bsHidden++;
				}

				document.querySelector('[name="bookKitChkboxContainer"]').innerHTML = ""; //clear all book Kit Chkbox of Book set view
				lstBookTitlesSetting.innerHTML = ""; //clear the last book dropdown list
				let gStt = 1;
				for (let j = 0; j < _tempBookKitInf.length; j++) {
					let _bookKitItem = _tempBookKitInf[j];
					let _numberOfBooks = _bookKitItem.endIdx - _bookKitItem.startIdx + 1;
					let _numOfBookset = _bookKitItem.grpRanks[_grpLine].bsCount;
					let _bkIdx = _bookKitItem.bkIdx;

					let _liGrpTitle = document.createElement('li');
					_liGrpTitle.innerHTML = `<input attr-bookKit="${_bkIdx}" type="checkbox" role="switch" checked /><code data-rAlignGroup="itemOrder">${makeBrk(gStt++)}</code> <span>${_bookKitItem.label}<sup>${_bkIdx}</sup> ${makeBrk(_numOfBookset)}<sup>${_numberOfBooks}</sup></span>`;
					_liGrpTitle.setAttribute("attr-bookKitIdx", _bkIdx);
					//_liGrpTitle.setAttribute("attr-BookKit-Father", bookGrpItem.bookKit);

					let _chkBookKit = _liGrpTitle.querySelector("input[type='checkbox']");
					//update UI for Book Kit checkbox
					let _ranksInfor = bookKitInfor[_bkIdx].grpRanks[_grpLine];
					_chkBookKit.title = `${_ranksInfor.bsHidden} out of ${_ranksInfor.bsCount} hidden`;
					setChkboxState(_chkBookKit, _ranksInfor.bsHidden === _ranksInfor.bsCount ? 0 : (_ranksInfor.bsHidden === 0 ? 1 : 2));

					lstBookTitlesSetting.appendChild(_liGrpTitle);
				}

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						//console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _fBKidx = _itemDrag.getAttribute("attr-bookKitIdx"); //book kit id of From element
						let _itemDrop = lstBookTitlesSetting.querySelector("li[attr-dragidx='" + t + "']");
						let _tBKidx = _itemDrop.getAttribute("attr-bookKitIdx"); //book kit id of To element

						if (f > t)
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop);
						else
							lstBookTitlesSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						//a. update bookKitInfor rank 
						lstBookTitlesSetting.querySelectorAll("li").forEach((_it, _idx) => {
							let _bkIdx = _it.getAttribute("attr-bookKitIdx");
							bookKitInfor[_bkIdx].grpRanks[_grpLine].rank = _idx; // the new rank of this book kit is its order in lstBookTitlesSetting
						});

						//b. update xState and xBookGrp together. Note that array xState.grpCfg[_grpLine].grp is part of array xBookGrp[_grpLine].grp (which has been assigned to variable bookGrp_grp), and most importantly, these two arrays are always aligned
						let _bsLocation = []; //location (index) of all book sets belong to from book kit
						let _fxState = [], _fxBookGrp = []; //store all book sets of dragged book kit
						let xstate_grpCfg = xState.grpCfg[_grpLine].grp; //short name for xState grp
						for (let j = 0; j < xbookGrp_grp.length; j++) {
							if (xbookGrp_grp[j].bookKit == _fBKidx) _bsLocation.push(j);
						}

						// take all book sets out of xBookGrp and xState. Because going from end to beginning of array, the taken out array would be revesed in order
						for (let j = _bsLocation.length - 1; j >= 0; j--) {
							_fxBookGrp = _fxBookGrp.concat(xbookGrp_grp.splice(_bsLocation[j], 1));
							_fxState = _fxState.concat(xstate_grpCfg.splice(_bsLocation[j], 1));
						}
						_fxBookGrp = _fxBookGrp.reverse(); //the order need to be reversed back
						_fxState = _fxState.reverse();

						if (f < t) { //dragging down: move all book sets of From book kit right after the last book set of To book kit
							let _tLastIdx = -1; //find the last index of 
							for (let j = xbookGrp_grp.length - 1; j >= 0; j--) {
								if (xbookGrp_grp[j].bookKit == _tBKidx) {
									_tLastIdx = j;
									break;
								}
							}
							// put back all book sets has been taken out after _tLastIdx
							xbookGrp_grp.splice(_tLastIdx + 1, 0, ..._fxBookGrp); //using Spread syntax
							xstate_grpCfg.splice(_tLastIdx + 1, 0, ..._fxState);
						}
						else { //dragging up: move all book sets of From book kit right before the first book set of To book kit
							let _tFirstIdx = -1; //find the last index of 
							for (let j = 0; j < xbookGrp_grp.length; j++) {
								if (xbookGrp_grp[j].bookKit == _tBKidx) {
									_tFirstIdx = j;
									break;
								}
							}
							// put back all book sets has been taken out right before _tFirstIdx
							xbookGrp_grp.splice(_tFirstIdx, 0, ..._fxBookGrp); //using Spread syntax
							xstate_grpCfg.splice(_tFirstIdx, 0, ..._fxState);
						}
					}
					_dragObj = dragDropList({ "parent": lstBookTitlesSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated
			}

			/* function to handle the content of Book Setting tab */
			function addBookSettingTab(){
				
				//listbox show all kind of group in xBookGrp
				let selPopupBookGroup = document.getElementById("selPopupBookGroup");

				// checkbox to show book kit or book set in lstBookTitlesSetting
				let _chkShowBookKit = document.getElementById("chkShowBookKit");
				if (!_chkShowBookKit.onclick)
					_chkShowBookKit.onclick = _ => {
						selPopupBookGroup.onchange(); //show book set/kit lists

						let _chkboxLabel = _chkShowBookKit.nextElementSibling;
						_chkboxLabel.innerText = _chkShowBookKit.checked ? "Book Kit view" : "Book Set view";

						let _tooltipTxt = _chkShowBookKit.checked ?
							"Danh sách hiển thị phía dưới là Book Kit. Mỗi item có dạng '[2] Harry Potter^1 [1]^7', trong đó:\n[2]: stt của book Kit Harry Potter.\n^1: id của Book Kit.\n[1]: số Book Set của Book Kit này.\n^7: số books của Book Kit này.\n\nChú ý: Trong chế độ Book Kit, nếu thay đổi thứ tự một Book Kit, toàn bộ Book Set của Book Kit đó sẽ được chuyển cùng nhau, có thể làm mất thứ tự các Book Set bị xen kẽ trong Book Set của các Book Kit khác." :
							"Danh sách hiển thị phía dưới là Book Set. Mỗi item có dạng '[2] Harry Potter^1 [7]', trong đó:\n[2]: stt của Book Set Harry Potter.\n^1: id của Book Kit cha.\n[7]: số books của Book set này.";
						_chkboxLabel.setAttribute("data-tooltip", _tooltipTxt);

						//we might use MutationObserver to watch for this _chkboxLabel changes the tooptip-data, but it is not required in this case because the tooltip content is long enough so its width not change

						// wait 1.5s for settingModal and tooltip to be render before re-calculate its position
						//setTimeout(_ => reposTooltips(null, { selfElem: _chkboxLabel, container: document.querySelector(".modalPopupContentWrapper") }), 1000);
					};

				//populate book group way list
				(function () {
					let _defGrpLabels = xBookGrp.map(_ => { return _.grpWay }); //get list of group name

					selPopupBookGroup.innerHTML = "";

					for (let i = 0; i < _defGrpLabels.length; i++) {
						let opt = document.createElement('option');
						opt.value = i;
						opt.innerHTML = makeBrk(pad(i + 1, 2)) + " " + _defGrpLabels[i];
						selPopupBookGroup.appendChild(opt);
					}
				})();
				selPopupBookGroup.selectedIndex = xState.grpLine;
				// make the replaced spinner to have the same color with elmSelBookTitles
				//selPopupBookGroup.style.backgroundImage = document.getElementById("elmSelBookTitles").style.backgroundImage;

				if(!selPopupBookGroup.onchange) selPopupBookGroup.onchange = _ => {
					let newGrpIdx = selPopupBookGroup.selectedIndex;
					if (_chkShowBookKit.checked) bookKitList(newGrpIdx);
					else bookSetList(newGrpIdx);

					//right-align some elements (for now, just the bookKit/bookSet)
					SddDropdown.prototype.rightAlignElems(lstBookTitlesSetting, "li");
				}
				_chkShowBookKit.onclick(); // this also invokes selPopupBookGroup.onchange()

				/* HANDLING EVENTS */

				//Handling event for clicking on checkbox inside #lstBookTitlesSetting to show/hide book kit/set using event-delegation technique on bubbling event: click
				lstBookTitlesSetting.addEventListener("click", _showhideBookChkboxClickDelegation);
				function _showhideBookChkboxClickDelegation(evt) {
					let _target = evt.target;
					//console.log(_target);
					//if not checkbox, return
					if (_target.tagName !== "INPUT" || _target.type !== "checkbox") return;

					let _grpLine = document.getElementById("selPopupBookGroup").selectedIndex;
					let xbookGrp_grp = xBookGrp[_grpLine].grp;
					let xState_grp = xState.grpCfg[_grpLine].grp;

					//mode can also be identified by value of document.getElementById("chkShowBookKit").checked

					//book Set view mode
					if (_target.hasAttribute("attr-bookKit-father")) {
						let _bkIndex = _target.getAttribute("attr-BookKit-Father");
						updateBKchkboxUI(_bkIndex);

						let _gid = _target.parentNode.getAttribute("attr-grpID"); //book set Id
						xbookGrp_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update hidden state to xBookGrp
						xState_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update to xState.grpCfg
					}

					//book Kit view mode
					if (_target.hasAttribute("attr-bookKit")) {
						//get book Kit id
						let _bkIdx = parseInt(_target.getAttribute("attr-bookKit"));
						if (isNaN(_bkIdx)) return; //should not happen, just check for sure

						//go through all xBookGrp[_idx].grp to find all book sets belong to book kit with id = _bkIdx
						for (let j = 0; j < xbookGrp_grp.length; j++) {
							let bookGrpItem = xbookGrp_grp[j];
							// if this book set belong to current book kit with bkIdx == _bkIdx
							if (bookGrpItem.bookKit == _bkIdx) {
								bookGrpItem.bHidden = !_target.checked; //update to xBookGrp
								let _gid = bookGrpItem.gId;

								xState_grp.find((_it) => { return _it.gId === _gid }).bHidden = !_target.checked; //update to xState.grpCfg
							}
						}
					}
				}
			}

			/* Deploy radio options to config the Toast, and handle any option changes */
			function addToastSettingControl() {
				let toastSettingDiv = document.querySelector('div[name="Toast-Setting"]');
				//check if control has deployed, we don't have to do that again
				if (!toastSettingDiv.hasAttribute("controlDeployed")) toastSettingDiv.setAttribute("controlDeployed", "done")
				else return;

				//initial xState.toastCfg if it not existed yet
				if (!xState.toastCfg) xState.toastCfg = {};
				let xToastCfg = xState.toastCfg;

				/** create HTML for radio buttons of a Toast configuration
					@param _cfgName {string}: a toast configuration such as theme, mode, animation, animation direction (animDir)
					@param _choiceLabel {string}: a title for current config
					@param _checkedIdx {integer}: a number (start from -1) to specify which radio button would be checked. set @null to check no button
					@param _innerHTMLOnly {boolean, optional}: @true if return innerHTML. Default return outterHTML
				 */
				function makeToastRadios(_cfgName, _choiceLabel, _checkedIdx, _innerHTMLOnly) {
					let _resHtml = "";
					let _attrStr = "toastSetting_" + _cfgName;
					//if _checkedIdx is undefined, make it default value = -1. Note that if _checkedIdx param == null, it will keep that value and no radio button is selected
					_checkedIdx = (_checkedIdx === undefined) ?  -1 : _checkedIdx;

					if(!_innerHTMLOnly) _resHtml += `<div class="fancyRadioContainer" name="${_attrStr}_container">`;
					_resHtml += `<div style="font-weight:bold;color:darkblue" data-checkeditem='${_checkedIdx}'>${_choiceLabel}: </div>`;
					
					let i = -1;
					for (let _item of ["Random"].concat(toast.toastChoices[_cfgName + "s"])) {
						let _labelText = _item;

						if (_cfgName == "theme") _labelText = (_item.match(/\-(.+)\-/) || ["", _item])[1].toProperCase(); //get 'random' or 'light', 'dark' or 'mono'

						let _otherFancyLabelCls = "";
						if (i == -1) _otherFancyLabelCls = 'fancyRadioLabelPurple'
						else{
							//toast mode: mode 0 is manual mode
							if (_cfgName == "mode" && i == 0) _otherFancyLabelCls = 'fancyRadioLabelBlue';

							//toast animation
							if (_cfgName == "animation") {
								let _possDirs = toast.toastChoices.posssibleAnimDirs(_labelText, "TOP-RIGHT"); //using some fake location
								//mark the animation having no direction with blue color
								if(!_possDirs.dir) {
									_otherFancyLabelCls = 'fancyRadioLabelBlue';
								}
								//in-place twited  animation, use gold color
								else if(_labelText.indexOf("--i") > -1)
								_otherFancyLabelCls = 'fancyRadioLabelGold';

								//extract suffix --m or --i from animation name
								_labelText = _possDirs.anim.toProperCase();
							}
						}

						// data-aIndex attribute mark the index of items in choices array. data-aChoice store config name (theme, mode, animation,...)
						_resHtml += `<input type="radio" id="${_attrStr}_${_item}" name="${_attrStr}" data-aIndex="${i}" data-aChoice="${_cfgName}" class="fancyRadioHidden" value="${_item}" ${_checkedIdx == i ? 'checked' : ''}>
						<label for="${_attrStr}_${_item}" class="fancyRadioLabel ${_otherFancyLabelCls}">${_labelText}</label>`;

						i++;
					}
					if(!_innerHTMLOnly)  _resHtml += `</div>`;
					return _resHtml;
				}

				//deploy all toast-setting radio options
				let _divHtml = "";
				_divHtml += makeToastRadios("theme", "Tông màu Toast", xToastCfg.theme);
				_divHtml += makeToastRadios("mode", "Vị trí Toast", xToastCfg.mode);
				_divHtml += makeToastRadios("animation", "Kiểu animations", xToastCfg.animation);
				toast.toastChoices["animDirs"] = [];
				_divHtml += makeToastRadios("animDir", "Chiều animations", xToastCfg.animDir);
				
				toastSettingDiv.innerHTML = _divHtml;

				let [_modeChoiceDivWrap, _animChoiceDivWrap, _animDirChoiceDivWrap] = ["mode", "animation", "animDir"].map( _choice => document.querySelector(`[name="toastSetting_${_choice}_container"]`) );

				//Using event-delegation technique to handle any radio option changes
				toastSettingDiv.addEventListener('click', function toastSettingHandler(evt) {
					let _target = evt.target;
					if (_target.tagName !== 'INPUT' && _target.type != 'radio' && !_target.classList.contains('fancyRadioHidden')) return;
					//console.log(_target);

					radioHandle(_target);

					evt.stopPropagation(); //stop the event propagate up to minimize events for upper Element in DOM tree

				});

				//force clicked on 'mode', 'animation' checked radio to update UI the dependent radios ('animation' and 'animDir')
				[_modeChoiceDivWrap, _animChoiceDivWrap].forEach(_wrapper => {
					let _checkedRadio = _wrapper.querySelector('input[type="radio"]:checked');
					if(_checkedRadio) _checkedRadio.click();
				});
				
				/* Main function to handle radio button click */
				function radioHandle(radioElem) {
					let _cfgName = radioElem.dataset.achoice;
					let _idx = parseInt(radioElem.dataset.aindex);

					//update to xState
					if(_idx == -1) delete xToastCfg[_cfgName]
					else xToastCfg[_cfgName] = _idx;

					const _container = radioElem.parentElement;
					_container.setAttribute("data-checkedItem", _idx);

					//remove the old label mark of page random choice that user not choose or choose random
					if( parseInt(_container.dataset.checkeditem) !== -1 )
					radioElem.parentElement.querySelectorAll("label.fancyRadioLabel.fancyRadioLabelRandomChoose").forEach(_lbl => _lbl.classList.remove("fancyRadioLabelRandomChoose"));
					
					/* 1. handle for 'MODE' radio buttons */
					if (_cfgName == "mode") {

						if (_idx == -1 || _idx == 0) { //random or manual mode
							
							fancyRadioAnimWrapperUI(true, _idx == 0? null: -1);
							makeAnimDirChoices([], true, _idx == 0? null: -1);
						}
						else {//auto mode "Bottom-Right", "Top-Right", "Top-Left", "Bottom-Left"
							let _lastAnimIdx = _animChoiceDivWrap.dataset.checkeditem ?? _animChoiceDivWrap.querySelector('input[type="radio"]:checked')?.dataset.aindex ?? -1;
							fancyRadioAnimWrapperUI(false, _lastAnimIdx);
							let _checkedAnimRadio = _animChoiceDivWrap.querySelector('input[type="radio"]:checked');
							_checkedAnimRadio && _checkedAnimRadio.click();
						}
					}

					/* 2. handle for 'ANIMATION' radio buttons */
					if (_cfgName == "animation") {
						let _possDirs = toast.toastChoices.posssibleAnimDirs( radioElem.value, _modeChoiceDivWrap.querySelector('input[type="radio"]:checked').value);
												
						if (_possDirs.dir) { //having directions
							toast.toastChoices["animDirs"] = _possDirs.dir;
							makeAnimDirChoices(toast.toastChoices["animDirs"], false, xToastCfg["animDir"] ?? -1); //-1
						}
						else{
							makeAnimDirChoices([], true, _idx == -1? -1 : null);
						}
					}

					/* Helper functions */
					/** Function to update UI for animation radio buttons
						@param _disabled {boolean}: to disable (true) or enable (false) the whole div container of all animation choices
						@param _checkedIdx {integer start from -1}: to check the radio having attribute 'data-aindex' of {_checkedIdx}. Set _checkedIdx = @null to check none.
					 */
					function fancyRadioAnimWrapperUI(_disabled, _checkedIdx){
						/* if(_checkedIdx == -1 || _checkedIdx == null) delete xToastCfg.animation
						else xToastCfg.animation = _checkedIdx; */

						_animChoiceDivWrap.classList.toggle("setting-elm-disabled", _disabled);
						let _checkedRadio = _animChoiceDivWrap.querySelector('input[type="radio"]:checked');
						if(_checkedRadio) _checkedRadio.checked = false;
						if(_checkedIdx !== null){
							let _newCheckedRadio = _animChoiceDivWrap.querySelector(`input[data-aindex="${_checkedIdx}"]`);
							if(_newCheckedRadio) _newCheckedRadio.checked = true;
						}
					}
					
					/** Function to deploy and update UI for animation Direction radio buttons
						@param _animDirArray {array}: the array of animDir choices. This depend on Toast location and Animation type
						@param _disabled {boolean}: to disable (true) or enable (false) the whole div container of all animation choices
						@param _checkedIdx {integer start from -1}: to check the radio having attribute 'data-aindex' of {_checkedIdx}. Set _checkedIdx = @null to check none.
					 */
					function makeAnimDirChoices(_animDirArray, _disabled, _checkedIdx){
						if(_checkedIdx == -1 || _checkedIdx == null) delete xToastCfg.animDir
						else xToastCfg.animDir = _checkedIdx;

						toast.toastChoices["animDirs"] = _animDirArray;
						_animDirChoiceDivWrap.classList.toggle("setting-elm-disabled", _disabled);

						_animDirChoiceDivWrap.innerHTML = makeToastRadios("animDir", "Chiều animations", _checkedIdx, true);
					}
				}
			}
			
			/* Mark the label of choice that not set by the user, but randomly choose by the page */
			function markToastRandomChoose(){
				const _toastChoices = toast.getToastConfig(); //page toast setting
				const _toastCfg = xState?.toastCfg ?? {}; //user toast setting
				/** Function to mark a label that randomly chosen by the page
				 * @_container {HTMLElement}: the div container that contains all radio+label which present a choice for a toast config (such as mode, theme, animation)
				 * @_choiceIdx {integer from 0}: the index of a choice made by the page (where user does not choose any choice for this toast config)
				  */
				const _markLabel = (_container, _choiceIdx) => {
					//removed the mark of old marked label
					_container.querySelectorAll("label.fancyRadioLabel.fancyRadioLabelRandomChoose").forEach(_lbl => _lbl.classList.remove("fancyRadioLabelRandomChoose"));

					//mark the new one
					const _markedLabel = _container.querySelector(`input[type="radio"].fancyRadioHidden[data-aindex="${_choiceIdx}"] + label.fancyRadioLabel`);
					if(_markedLabel) _markedLabel.classList.add("fancyRadioLabelRandomChoose");
				}
				const _cfgChoices = ["theme", "mode", "animation"];
				const _toastChoicesPropName = ["theme", "mode", "animMode"];
				_cfgChoices.forEach((_choice, i) => {
					if(!_toastCfg.hasOwnProperty(_choice) || _toastCfg[_choice] === -1) _markLabel(document.querySelector('div.fancyRadioContainer[name="toastSetting_' + _choice + '_container"]'), _toastChoices[_toastChoicesPropName[i]]);
				});

			}

			/* Function to deal with adding Database files and display its content including db variables, Book Kits inside and books in each bookKit */
			function addJsDatabaseFileReport(){
				/** generate HTML for statistics of a books collection 
				 * @param _dbSummary {json}: which normally the returned value of BookData.prototype.booksStatistics()
				 * @param _verbose {boolean}: default false. If true, adding names in Vietnamese of each statistic value
				 * @return HTML code
				*/
				const statisticsHTML = (_dbSummary, _verbose = false) => {
					//📚📜🎧
					const _VERB = _verbose? [" bộ sách. ", " quyển sách. ", " nhóm chương. ", window.innerWidth < 500? " chương." : " chương sách."] : new Array(4).fill("");
					//for iPhone, using simple backslash to separate between totolDur and RealListeningTime so that the DbFile Header not break into more than 3 lines
					const _SEPARATOR = window.innerWidth < 300 ? "/ " : makeSvgFromSprite("icnSvgListenTime",{class:"svg-img-infor"});

					return `<dfn style="font-size:.85em;font-weight:600">
						${_dbSummary.bookSetsCount && _dbSummary.bookSetsCount !== _dbSummary.booksCount?makeSvgFromSprite("icnSvgBookSets",{class:"svg-img-infor"}) + _dbSummary.bookSetsCount + _VERB[0] : ""}
						${makeSvgFromSprite("icnSvgBooks",{class:"svg-img-infor"})}${_dbSummary.booksCount}${_VERB[1]}
						${_dbSummary.chapGroupsCount ? makeSvgFromSprite("icnSvgChapGroupIcon",{class:"svg-img-infor"}) + commaNum(_dbSummary.chapGroupsCount) + _VERB[2] : ""}
						${makeSvgFromSprite("icnSvgChapters",{class:"svg-img-infor"})}${commaNum(_dbSummary.chaptersCount)}${_VERB[3]}${_verbose?"<br/>":""}
						${makeSvgFromSprite("icnSvgDuration",{class:"svg-img-infor"})}${toHhMmSs(_dbSummary.totalDur, _verbose? 2: 0)}
						${_SEPARATOR}<var attr-duration="${_dbSummary.totalDur}">${toHhMmSs(_dbSummary.totalDur / xState.speed, _verbose? 1: 0)}</var></dfn>`;
				}
					
				/** Display information of all Book of a Book Kit - which is a database variable whose name is _jsDBName (see the code)
				 * @param _liElem {HTMLElement} the li element of ol#lstJsFileDataSetting element. We extract dbName from this _liElem, and use the global variable has that {dbName} to extract information and put on _liElem
				 * @param _failCount 
					@value == undefined (is missing)
					- show Book infor if _jsDBName has data
					- show notification if variable whose name is {_jsDBName} not exists
					@value _failCount == number (usually > 10): show error notification

				 * @return: - null if {_jsDBName} not exists
						- json in format {bookSetsCount: , booksCount: , chaptersCount: , totalDur: } store statistics for the whole database inside DB files
				*/
				function addJsDataFilesDetails(_liElem, _failCount){
					//name of db files also name of db variable
					const _jsDBName = _liElem.getAttribute("attr-Data-jsFile-Name");

					//create div element to show detail books of this database
					/* const _divBookDetailElem = document.createElement('div');
					_divBookDetailElem.classList.add("detailContent"); */

					const _divBookDetailElem = _liElem.querySelector('div.detailContent');

					let _jsDBFile = ssData.jsDBFiles.find(_dbFile => _dbFile.dbName == _jsDBName );
					
					//database not exists
					if(!_jsDBFile || (!window[_jsDBName])) {
						_divBookDetailElem.innerHTML = `<h2>File <b style='color:#9f5c28'>${_jsDBName}.js</b> hoặc Cơ sở dữ liệu <b style='color:darkblue'>${_jsDBName}</b> không tồn tại.</h2>` +
						(_failCount == undefined? `` : `<div style="column-span: all">Database ${_jsDBName} đã load không thành công ${_failCount} lần. Nếu vẫn muốn nạp lại file này, hãy chuyển nút checkbox thành 'Fresh Load'</div>`);
						_liElem.appendChild(_divBookDetailElem);
						return;
					}

					let _ulInnerHtml = [];
					const _totalSummary = _jsDBFile.dbs.reduce((_acc, _dbName) => {
						//book set data 
						const _bkRawData = window[_jsDBName][_dbName];

						//statistics for the book set
						const _bkSummary = BookData.prototype.booksStatistics(_bkRawData.books);
						
						//list all books inside this book set
						let _bookTitles = [], titleCounter = {}, _bookSetsCount = 0;
						_bkRawData.books.forEach(_book => {
							//find if this title already in the list
							let _idx = _bookTitles.indexOf(_book.title);
							if(_idx == -1){
								_bookTitles.push(_book.title);
								// this is not very exact way to count the number of book Sets since there are some books with different name but actually in the same book Set 
								_bookSetsCount++;
							}
							else{
								titleCounter[_idx] = titleCounter[_idx] ?? 1;
								titleCounter[_idx]++; //increase the title count
							}
						});
						//update some approximate bookSets Count
						_bkSummary.bookSetsCount = _bookSetsCount;

						//update the sum-up statistics
						_acc.booksCount += _bkSummary.booksCount;
						_acc.chapGroupsCount += _bkSummary.chapGroupsCount;
						_acc.chaptersCount += _bkSummary.chaptersCount;
						_acc.totalDur += _bkSummary.totalDur;
						_acc.bookSetsCount += _bookSetsCount;
						
						//create HTML string
						let _ulItemHtml = `<p class='dbFileBookList'>` +
							//add book kit name and statistics
							`<i>${_bkRawData.meta.name}</i> ` + statisticsHTML(_bkSummary) +
							//book kit details
							_bookTitles.map((_bookTit, _idx) => `<code>${_bookTit}</code>${titleCounter[_idx] ? " [" + titleCounter[_idx] + "]":""}`).join("") +
						"</p>";
						_ulInnerHtml.push(_ulItemHtml);

						return _acc;
					}, {bookSetsCount: 0, booksCount: 0, chapGroupsCount: 0, chaptersCount: 0, totalDur: 0});

					_divBookDetailElem.innerHTML = _ulInnerHtml.join("");
					_liElem.appendChild(_divBookDetailElem);

					return _totalSummary;
				}
				
				/** getting book data inside an Database. If it is already exist (because the DB has been loaded before, by loadPage() for example), use that data. If it is not, using loadJS to download the DB file and use book data inside downloaded file to show the book report for that DB.
				 * This function alse is taken care of create html overlay for li element (which contain the report for each database), downloading database from js DB file (when necessary) and making details reports and statistical to put
				 * @param _jsDBName {string}: the name of the DB file also name of single variable inside it, such as 'data_0', 'data_3'
				 */
				function showingDataReportFromDB(_jsDBName){
					// xDBFilesCfg item contain config data of current _jsDBName
					const _jsFileItem = xDBFilesCfg.toLoad.find(_item => _item.dbName === _jsDBName);

					//li element which contain all report, including report header. Note that when a DB having new edition, we need to update report for that new edition, _liDBreport was create before when the JsFileDataSetting tab is first active
					let _liDBreport = document.querySelector(`[attr-data-jsfile-name="${_jsDBName}"]`);
					// if it has not been creacted, create it
					if(!_liDBreport) {
						_liDBreport = document.createElement('li');
						_liDBreport.setAttribute("attr-Data-jsFile-Name", _jsDBName);

						//ol that display all data files and book kits, books inside it
						let lstJsFileDataSetting = document.getElementById("lstJsFileDataSetting");
						lstJsFileDataSetting.appendChild(_liDBreport);
					}

					//make version string (that next to DB name)
					let _version = _jsFileItem.dbUrl.match(/v\=(\d+)/)?.[0] ?? "";
					_version = _version == "" ? "" : " (" + _version + ", " + (_jsFileItem.hasOwnProperty("edt")?"Edt=" + _jsFileItem.edt + ", ":"") + _jsFileItem.failCount + ")";

					//create overlay HTML for the li
					_liDBreport.innerHTML = `
					<div>
						<details open=""><summary><span>${_jsDBName}${window.innerWidth>600? _version:""}</span><br/><samp name="dbSummary"></samp></summary></details>
						<span><input type="checkbox" role="switch" id="jsDataFileChkbox_${_jsDBName}" attr-chkbox-Data-jsFile="${_jsFileItem.fileNo}"/> <label for="jsDataFileChkbox_${_jsDBName}"></label></span>
					</div>
					<div class="detailContent"></div>`; //div.detailContent will contains the list of book inside the database named {_jsDBName}

					// set checkbox state with loadMode value
					setChkboxState(_liDBreport.querySelector("input[type='checkbox']"), _jsFileItem.loadMode);					

					// js database files loaded before in loadPage() or somewhere else
					// first condition (before OR operator): is a short way for [DBFiles.LMODE.freshLoad, DBFiles.LMODE.cacheLoad].includes(_jsFileItem.loadMode)
					// second condition: check if window[_jsDBName] is Json like object
					if(_jsFileItem.loadMode > 0 || (window[_jsDBName] && window[_jsDBName].constructor === ({}).constructor )) {
						//adding details and calculate statistics for whole DB file
						const _dbSummary = addJsDataFilesDetails(_liDBreport);
						//adding statistics for whole DB file to the title of li element
						if(_dbSummary) {
							_liDBreport.querySelector('[name="dbSummary"]').innerHTML = statisticsHTML(_dbSummary);
						}
					}
					else { // js database files HAS NOT loaded in loadPage(), temporarily load it to get general information
						// if a database file has been failed too many time, no point to reload it Except when user set loadMode to 1
						if(_jsFileItem.failCount >= 10){
							// show the notification for this file without loading it
							addJsDataFilesDetails(_liDBreport, _jsFileItem.failCount);
							return;
						}
						// if variable not yet existed, temporarily load it from data js file, showing its books list (and some statisticals) them remove the variable to save memory
						DBFiles.loadJS({
							allowReload: true, //using this in case the DB has new edition but loadMode=0(no-show), so its script has been loaded before in loadPage() function (and even its script element has already been removed) but its data has been remove. now we need to load again							
							freshLoad: false, //get DB from cache if feasible
							url: _jsFileItem.dbUrl,
							//see DBFiles.loadJS for explanation of some properties of extAttr
							extAttr: {
								//fileNo: _jsFileItem.fileNo, //this property is actually not use
								jsDBName: _jsDBName, 
								loadMode: _jsFileItem.loadMode
								//Old: DBFiles.LMODE.tempLoad, //to mark that this load js not for adding data to xData, it is for showing book and book kit for user to decide or not to show this database next session. This might not be neccessary since in .then(), .catch() below we don't update back loadMode into xDBFiles, so we can set this loadMode to DBFiles.LMODE.cacheLoad or DBFiles.LMODE.freshLoad
							}
						})
						.then((_prom) => {
							// Here we run loadJS for a single DB file, so _prom point to script elements created inside createLoadJS()
							const _jsDBName = _prom.extAttr.jsDBName;

							// add data to data collected variable ssData.jsDBFiles
							if(typeof window[_jsDBName] == "object")
							DBFiles.deployDB.call(window[_jsDBName], _jsDBName, _prom.extAttr.loadMode);
							
							//adding details and calculate statistics for whole DB file
							const _dbSummary = addJsDataFilesDetails(_liDBreport);
							//adding statistics for whole DB file to the title of li element
							if(_dbSummary) {
								_liDBreport.querySelector('[name="dbSummary"]').innerHTML = statisticsHTML(_dbSummary);
							}

							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							//reset failCount
							if(_dbFileCfgItm) _dbFileCfgItm.failCount = 0;

							//if(_prom.extAttr.loadMode == DBFiles.LMODE.tempLoad) //maydo some extra check before cleaning DB variable
							window[_jsDBName] = undefined; //clean the variable that stored inside DB script
						})
						.catch((err) => { //error when page cannot load the database js files
							addJsDataFilesDetails(_liDBreport);
							//console.log(err);
							//err.target point to script element itself
							const _jsDBName = err.target.extAttr.jsDBName;
							const _dbFileCfgItm = xDBFilesCfg.toLoad.find(_item => _item.dbName == _jsDBName);
							toast.showToast(`Không tải được database ${err.target.src}`, toast.ToastType.Error);
							//increase failCount
							if(_dbFileCfgItm) {if(typeof _dbFileCfgItm.failCount == 'number')_dbFileCfgItm.failCount++; else _dbFileCfgItm.failCount = 1;}
						})
					}
				}

				//ol that display all data files and book kits, books inside it
				let lstJsFileDataSetting = document.getElementById("lstJsFileDataSetting");
				//remove mark of dragged li of last time using setting
				lstJsFileDataSetting.querySelectorAll("li.beingPlay").forEach(_li => _li.classList.remove("beingPlay") );

				//make sure the following event handler run only once in one session
				if (!lstJsFileDataSetting.hasAttribute("controlDeployed")) lstJsFileDataSetting.setAttribute("controlDeployed", "done")
				else return;
			
				// add showingDataReportFromDB as a prototype function of addJsDatabaseFileReport, so that it can be used in handyCheckDBsEdition 
				addJsDatabaseFileReport.prototype.showingDataReportFromDB = showingDataReportFromDB;				

				/* Load detailed information for each DB files */
				lstJsFileDataSetting.innerHTML = ""; //clear the last book dropdown list
				
				//showing report for each of database file based on database name
				xDBFilesCfg.toLoad.forEach(_toLoadItem => {
					const _jsDBName = _toLoadItem.dbName;
					
					/* showingDataReportFromDB is taken care of create html overlay for li element (which contain the report for each database), downloading database from js DB file (when necessary) and making details reports and statistical to put */
					showingDataReportFromDB(_jsDBName);
				});

				/* Show whole DB statistics, only count ones that user's setting loadMode !=0 */
				const _wholeStatistics = BookData.prototype.booksStatistics(ssData.xData);
				//count number of Book Sets according to grpWay 0
				_wholeStatistics.bookSetsCount = ssData.xBookGrp[0].grp.reduce((_acc, _grp) => _acc += _grp.books.length, 0);				

				const _DBStatisticselem =document.querySelector('[name="DBStatistics"]');
				const _nextCheckText = window.innerWidth > 500? "Lần tự động kiểm tra phiên bản DB tiếp theo: " : "Next auto-check for new DBs edition: ";

				_DBStatisticselem.innerHTML = statisticsHTML(_wholeStatistics, true) + `<br/><dfn name='lastCheckDBUpdateStatus'>${_nextCheckText}<mark style='color:darkred' data-tooltip='Khoảng cách giữa hai lần tự động kiểm tra là ${toHhMmSs(_DEFAULT_CFG.cDBFilesEdt.checkEdtDelay, 2)}'></mark></dfn>`;

				/* Event handler for component of this tab */
				const _checkDBUpdateElem = _DBStatisticselem.querySelector('dfn[name="lastCheckDBUpdateStatus"] > mark');
				function updateLastDBsEditionCheck(event) {
					//event && console.log(event.detail.updateDBs);
					/* const _lastDBChecked = new Date(ssData.lastDBCheck);
					const _timeDateStr = _lastDBChecked.toLocaleTimeString('vi') + '—'  + _lastDBChecked.toLocaleDateString('vi'); */
					const _timeDateStr = (new Date(ssData.lastDBCheck + 1000 * _DEFAULT_CFG.cDBFilesEdt.checkEdtDelay)).toLocaleString("vi-VI"); //format to 'time Date' form
	
					_checkDBUpdateElem.textContent = _timeDateStr;
				}
				// Add event handler for custom event 'DbsFileGotNewEditionEvent' which if fired in Setting.handyCheckDBsEdition() function right below. This event is fired every time the page checking DBs edition, and handler is taking care of showing the new time for next check
				window.addEventListener("DbsFileGotNewEditionEvent", updateLastDBsEditionCheck);
				updateLastDBsEditionCheck(); //update for the first time
				
				/* delegation to handle checkbox click and save to change to global variable xDBFilesCfg (and later to localStorage) */
				lstJsFileDataSetting.addEventListener("click", (evt) => {
					let _target = evt.target;
					//console.log(_target);
					evt.stopPropagation(); //stop click events to be bubbled to upper layers

					// handle event for load/unload js file checkbox
					if (_target.tagName == "INPUT" && _target.type == "checkbox" && _target.hasAttribute("attr-chkbox-Data-jsFile")) {
						let _currVal = parseInt(_target.dataset.stateVal ?? 0);
						//order of loadMode: 0 - no load --> 2-load, using cache if applicable --> 1-load fresh, no cache.
						const _stateArr = [0, 2, 1];
						let _newVal = _stateArr[(_stateArr.findIndex(_st => _st==_currVal) + 1) % 3];

						setChkboxState(_target, _newVal);

						const _fileNo = _target.getAttribute("attr-chkbox-Data-jsFile");
						if(_fileNo == undefined) return;
						
						//if this DB is set to no-show, we need to make sure that there is at least one DB is set to Cache-Load or Fresh-Load
						if(_newVal == 0){
							// get all other DB-file checkbox, except the current _target
							const _allOtherCheckboxes = lstJsFileDataSetting.querySelectorAll(`input[type="checkbox"][attr-chkbox-Data-jsFile]:not([attr-chkbox-Data-jsFile="${_fileNo}"])`);
							//count if there is any of those other DBs being Cache-Load(2) or Fresh-Load(1)
							let _DBLoadCounter = 0;
							_allOtherCheckboxes.forEach(_chkBox => {if(parseInt(_chkBox.dataset.stateVal ?? 0) != 0) _DBLoadCounter++});

							if(_DBLoadCounter == 0){ //if all of them are no-show
								toast.showToast('Phải có ít nhất một CSDL đặt chế độ Load', toast.ToastType.Error);
								setChkboxState(_target, _currVal);
								return;
							}
						}						

						let toLoadArr = xDBFilesCfg.toLoad;
						toLoadArr.find(_lm => _lm.fileNo == _fileNo).loadMode = _newVal;
					}
				});

				/* handle with drag&drop Book set in #lstBookTitlesSetting of the case when #chkShowBookKit (Book Kit checkbox) is off, meaning #lstBookTitlesSetting display book set as its item.
				*/
				(function startDragNDrop() {
					let _exchangeFnc = function (f, t) {
						// console.log("From " + f + " to " + t);
						f = parseInt(f), t = parseInt(t);
						let _itemDrag = lstJsFileDataSetting.querySelector("li[attr-dragidx='" + f + "']");
						let _itemDrop = lstJsFileDataSetting.querySelector("li[attr-dragidx='" + t + "']");
						if (f > t)
						lstJsFileDataSetting.insertBefore(_itemDrag, _itemDrop);
						else
						lstJsFileDataSetting.insertBefore(_itemDrag, _itemDrop.nextSibling);

						//save all changes of last session before changing group way
						arrayMove(xDBFilesCfg.toLoad, f, t); //re-arrange for xBookGrp
						
						//re-calculte book kit rank
						//calculateBookKitRank(_grpLine);
					}
					_dragObj = dragDropList({ "parent": lstJsFileDataSetting, "queryString": "li" }, _exchangeFnc);
					_dragObj.handleDragDrop();

				})(); //allow drag&drop right when new list is populated
			}
			
			/** Function to reload 'config.js', chech edition number to see if there is any DBs having new edition. If there are, download the new edition (and version) of those DBs. If among them, there is DBs that currently not in hidden mode (loadMode = cacheLoad(2) or freshLoad(1)), ask user to restart the page to get data inside those DBs got updated
			If found some DB having new edition (does not matter that DB is in hidden or shown mode), this function also update the report for those DB in JsFileDataSetting Setting tab. However, for now it does not update the total statisticals (at the bottom of the tab) for all the shown books
			 * @param _showFailedCheck (boolean): 
			 	@value true show the toast that tell there is no new DBs or failed to load config.js.
				@value false (default), not show the message
			 * @return nothing
			*/
			function _handyCheckDBsEdition(_showFailedCheck = false){
				//success or not, we need to update this lastDBCheck, otherwise in case of continuos fails (lost internet, for example), page will keep checking updates
				ssData.lastDBCheck = Date.now(); //update last checked time

				//get checkbox that control the active state of JsFileDataSetting tab
				const _radioTabJsFileDataSetting = document.getElementById("radioTabJsFileDataSetting");

				// an flag to tell if the tab-content is appeared in user view
				const _isTabActive = Boolean(_radioTabJsFileDataSetting.nextElementSibling.nextElementSibling.offsetParent);

				//function to run after each script load is successfully downloaded
				function _promiseCallback(_scriptElm){
					const _extAttr = _scriptElm.extAttr;
					const _jsDBName = _extAttr.jsDBName;
					// if JsFileDataSetting tab is currently active, replace report for DB has new edition
					if(_isTabActive)
						addJsDatabaseFileReport.prototype.showingDataReportFromDB(_jsDBName);
					// for DB in hidden mode, remove variable to save memory
					if(_extAttr.loadMode === DBFiles.LMODE.noShow)
						window[_jsDBName] = undefined;
				}
				//function to run after all script load is settled down and its general information is shown up in Setting modal tab
				function _allSettleCallback(){
					const _radioTabJsFileDataSetting = document.getElementById("radioTabJsFileDataSetting");

					// if ssData.setting.handyCheckDBsEdition invoked automatically when the time to check for new DB edition is reached and page just got focus AND the JsFileDataSetting tab is currently NOT active, next time that tab got active, the big addJsDatabaseFileReport() function will be invoked to re-load reports for ALL databases
					if(_isTabActive)
					delete _radioTabJsFileDataSetting.dataset.beenActive;
					//else: tab is not active, then _promiseCallback above take care of updating report for DB having new edition alone, without having reload report for ALL databases
				}
				
				//"config.js" has no "?v={version_number}" so it will be added in loadJs. This make config.js always in Fresh-load mode. allowReload=true allow config.js is reloaded even it has loaded before by the same old loadJS
				DBFiles.loadJS( {url: "config.js", allowReload: true} )
				.then((_ret) => {
					// this array store list of DB files that has newer editions. If none has or fail to load 'config.js', it is null					
					//See return in DBFiles.checkDBFilesEdition for the format of returned value
					let _DBsHasNewEdition = DBFiles.importDBfromFiles(
						//mark that invoke from Setting.handyCheckDBsEdition()
						1,
						//callback function which will be invoked each time a DB script file is loaded succesfully
						_promiseCallback,
						//callback function which is invoked when all DBs has been loaded (each might be sucessful or failed)
						_allSettleCallback
					);

					//if there is no DBs has new edition
					if(_showFailedCheck && _DBsHasNewEdition.length==0) toast.showToast("Cơ sở dữ liệu hiện có đã là mới nhất.", toast.ToastType.Infor, {duration: 1e4});

					//fire event that notifying that DBs has just been checked for updates, so the Settinng modal will update accordingly in case user are opening it (see Setting.addJsDatabaseFileReport() function right above which catch this event to update the last time checking DBs edition)
					window.dispatchEvent(new CustomEvent("DbsFileGotNewEditionEvent", {
						detail: { updateDBs: _DBsHasNewEdition, caller: 'Setting.handyCheckDBsEdition' }
					}));
				})
				.catch(err => {
					console.error(err);
					if(_showFailedCheck) toast.showToast("Không nạp được file config.js.", toast.ToastType.Error, {duration: 1e4});
				});
			}

			/** to list listening history  */
			function addListeningHistory(){
				let _hist = xState.history;

				//get the current book, chap play by xAudio
				let _xAudioCurrBook = xAudio.getAttribute("attr-book"),
				_xAudioCurrChap = parseInt(xAudio.getAttribute("attr-chap"));
				//update current time of chapter of current book to xState history
				let _xAudioCurrTime = xAudio.currentTime;
				//in case the new chapter is still loading, xAudio Current time might be NaN
				if(isNaN(_xAudioCurrTime)) _xAudioCurrTime = 0;

				if(!_hist.books.hasOwnProperty(_xAudioCurrBook)) _hist.books[_xAudioCurrBook] = {_xAudioCurrChap: _xAudioCurrTime, lc: _xAudioCurrChap, urlLine: 0}
				else _hist.books[_xAudioCurrBook][_xAudioCurrChap] = _xAudioCurrTime;
				
				//the outer div that contains ul, which contains all the history books
				const _lhWrapperElm = document.querySelector("#ListeningHistoryWrapper");

				//nothing in history yet
				if(_hist.hisList.length == 0){
					_lhWrapperElm.textContent = "No history yet";
					return null;
				}

				//get the list of id of all books has been listend and recored by xState
				let _bookListenedIds = Object.keys(_hist.books);

				/* //get list of all orphaned books, the book that recorded in _hist.books but not in _hist.hisList (see historyCls.addToHistory() for the reason)
				let _orphanedBookIds = [];
				_bookListenedIds.forEach(_bId => {if(!_hist.hisList.includes(_bId)) _orphanedBookIds.push(_bId)}); */

				/** function to generate svg icon along with tooltip and css style for each type of information
				* @param _type: inforType, see the code for details
				*/
				let makeSvgStr = _type => {
					//let _iconTitle = ["Tên sách", "Số thứ tự chương", "Tác giả", "Người đọc", "Thời lượng đã nghe"];
					let _iconNames = ["icnSvgBooks", "icnSvgChapters", "icnSvgMaleAuthor", "icnSvgMicrophone", "icnSvgDuration"];
					let _inlineStyle = "", _class = "svg-img-infor";

					return `${makeSvgFromSprite(_iconNames[_type], { class: _class, style: _inlineStyle })}`; //
				}
				
				/* this var is used to count the ordinal for history books, starts from the most recently one */
				let _bookStt = 0;				

				/** function to create html code for a book in history
				 * @param _bookId {8-char string} the book id that got from history to show information (mostly about chapter that user was listenning but not finished)
				  */
				const _makeTreeLi = _bookId => {
					//the data from xData for the book
					const bData = ssData.bookData.findBookFromId(_bookId);
					if(!bData){
						// this should never be happening, because in bookDataInitial(), the xState.history has been clean to remove all unexisted-books
						return "";
					}
					// the history information of the book got from xState
					const _histBook = _hist.books[_bookId];

					const _SEP_CHAR = '&hairsp;/&hairsp;'; //'&#8198;/&#8198;';
					//id for for checkbox and label
					const _elmId = 'BLH_' + _bookId; 
					//label for li that show book information
					let _liLabel = `<b>${++_bookStt}</b> ${makeSvgStr(0)}<span class='histTitle' style='font-weight:600'>${bData.title}</span> [${_bookId}] ${makeSvgStr(1)}${bData.statistics.chaptersCount}${_SEP_CHAR}${toHhMmSs(bData.statistics.totalDur)} ${makeSvgStr(2)}${bData.author} ${makeSvgStr(3)}${bData.mc}`; //ஃ&thinsp;
					
					//filter all attributes that is a number, those are the chapter
					let _chapSttList = Object.keys(_histBook).filter(_attr => _attr.match(/^\d+$/) );
					
					//get information for all listened chapters of the current books, each put in an li element
					let _chapsLiHtml = _chapSttList.map(_chap => {
						_chap = parseInt(_chap);
					
						const _chapData = bData.parts[_chap-1];
						//get title of the chapter, in case it is missing we need to generate from wildcart
						let _chapTit = _chapData.tit;
						//if there is no chap title or chap title contains wildcart string, we need to run wildcart generation for chapter titles
						if(!_chapTit || _chapTit.includes(ssData.wildCartStr)) {
							BookData.prototype.generateWCLinks(_bookId);
							_chapTit = _chapData.tit;
						}

						//li html code for current chapter information
						let _chapLiHtml = `<li class='chapter_li ${_chap == _histBook.lc? 'last-playing-chapter' : ''}' data-bookId='${_bookId}' data-chapter='${_chap}'>
							<label>
								${makeSvgStr(1)}<code data-rAlignGroup='chapStt'>${_chap}</code> 
								${makeSvgStr(4)}<b data-rAlignGroup='listenedTime'>${toHhMmSs(_histBook[_chap])}</b>/<code data-rAlignGroup='chapTime'>${_chapData.dur}</code> 
								<span class='histTitle'>⏵&thinsp;${_chapTit}</span>
							</label></li>`;
						return _chapLiHtml;
					}).join(" ");

					//li code for information about the book, including uncompleted was-listening-book.
					let _html = 
						`<li class="parent_li ${_bookId == xState.lb? 'last-playing-book':''}" data-bookid='${_bookId}'> 
							<input type="checkbox" id="${_elmId}" checked />
							<label for="${_elmId}">${_liLabel}</label>
							<ul>${_chapsLiHtml}</ul></li>`;
					return _html;
				}

				//list the books in reversed order, so that the most recent listened book on top
				let _booksLiHtml = _hist.hisList.toReversed().map(_bookId => _makeTreeLi(_bookId)).join(" ");

				_lhWrapperElm.innerHTML = 
					`<ul>
						<li class="parent_li"> 
						<input type="checkbox" id="outer_listening_history" checked />
						<label for="outer_listening_history">Lịch sử nghe sách</label>
						<ul>${_booksLiHtml}</ul>
					</ul>`;
				
				//query all ul that directly contains li that is chapter_li
				_lhWrapperElm.querySelectorAll('li.parent_li > ul :has(> li.chapter_li)')
					//right-align chapter stt and chapter listening time for all chapters belong to a book
					.forEach(_ulChap => SddDropdown.prototype.rightAlignElems(_ulChap, 'li.chapter_li > label'));

				/* function to middle the horizontal tree line (with the small triangle and dot) for parent_li. We can remove this function, so that all _parent_li will used the '--horizon-lines-top' default value set in CSS of #ListeningHistoryWrapper element (for now is 25px) */
				const centerParentLiTreeLine = function() {
					let _ParLi_Padding_Top = 0;
					_lhWrapperElm.querySelectorAll('li.parent_li:not(.treeview > ul > li.parent_li)').forEach(_parentLi => {
						//get the padding-top of parent_li element. Since all parent_li (which is not outer-most li.parent_li) has the same padding-top, so we need to get this value only one time and used for all li.parent_li
						if(_ParLi_Padding_Top == 0)
						_ParLi_Padding_Top = parseFloat(_parentLi.css('padding-top'));

						//get the height of label that is direct child of _parentLi (one that display information about book)
						const _labelElem = _parentLi.querySelector('label[for]');
						const _label_height = _labelElem.getBoundingClientRect().height;

						//in case the lable has not been fully-rendered yet
						if(_label_height > 0) 
							//set a customized css variable '--horizon-lines-top' uniquely for this _parentLi, so the horizontal tree line will be at the middle of the label of current _parentLi
							_parentLi.style.setProperty('--horizon-lines-top', (_ParLi_Padding_Top + _label_height/2) + 'px');						
					});
				}
				//wait for sometime until the tree is completely-rendered
				setTimeout(centerParentLiTreeLine, 500) ;

				/* make a delegation event handler on the wrapper div to catch the click event on chapter li, so to play the clicked chapter */
				if(!_lhWrapperElm.dataset.loaded){
					// so that all code in this block (which are all elements' handler) is loaded only one time
					_lhWrapperElm.dataset.loaded = true;

					/* A. Handler for elmHistoryClear button */
					document.querySelector('#elmHistoryClear').onclick = evt => {
						//clear history
						historyCls.historyClear();
						//reload the tab content to update the cleared history
						addListeningHistory();
					}

					/* B. Handler for chkShowHideAllHistChapDetails checkbox, so when that checkbox changes, all book listening history is collapsed/expanded accordingly */
					const _chkShowHideAllBooksDetail = document.querySelector('#chkShowHideAllHistChapDetails');
					_chkShowHideAllBooksDetail.onclick = evt => {
						let _isChecked = _chkShowHideAllBooksDetail.checked;
						//query all checkbox that control the expand/collapse state of a book history information
						_lhWrapperElm.querySelectorAll('li[data-bookid] > input[type="checkbox"][id^="BLH_"]').forEach(_bookChkbx => _bookChkbx.checked = _isChecked);
					}

					/* X. Handler when click on chapter's label to play the corresponding chapter */
					_lhWrapperElm.addEventListener('click', evt => {
						const _target = evt.target;
						//console.log(_target);

						/* X.1. Handler when click on book's label to collapse/expand book's chapter listening history */
						if(_target.tagName == 'INPUT' && _target.type == 'checkbox' && (_target.getAttribute('id') ?? '').startsWith('BLH_') ){
							//query all checkbox that control the expand/collapse state of a book history information
							const _allBookHistCheckboxes = _lhWrapperElm.querySelectorAll('li[data-bookid] > input[type="checkbox"][id^="BLH_"]');
							//count the number of expanded book history information
							let _chkCount = 0, _chkTotal = _allBookHistCheckboxes.length;
							_allBookHistCheckboxes.forEach(_bookChkbx => {
								if (_bookChkbx.checked) _chkCount++;
							});

							//update the checkbox state and UI
							setChkboxState(document.getElementById("chkShowHideAllHistChapDetails"),
								_chkCount == 0 ? 0 : (_chkCount == _chkTotal ? 1 : 2));
						}

						/* X.2. Handler when click on chapter's label to play the corresponding chapter */

						// note that we can catch click on label, so we need to get the li element that parent of clicked label (and label's children)
						const _liElem = _target.parentElement; // since in CSS we set 'pointer-events: none;' for all label's children, so can simply use _target.parentElement, instead of expensive _target.closest('li.chapter_li');
						//if it is chapter li. Note that for outer-most li>label, _liChapElem = null
						if(_target.tagName == 'LABEL' && _liElem && _liElem.classList.contains('chapter_li') ){
							
							//get the li element that mother of clicked label
							const _bookLi = _target.closest('li.parent_li');

							//if clicked label not in li that is current playing chapter, switch the class that mark li>label is current playing chapter
							if(!_liElem.classList.contains('last-playing-chapter')){
								const _lastPlayingChap = _bookLi.querySelector('li.last-playing-chapter');
								_lastPlayingChap && _lastPlayingChap.classList.remove('last-playing-chapter');
								//set UI of clicked li to be playing-chapter
								_liElem.classList.add('last-playing-chapter');
							}
							
							//get the bookId and chapter number from curren history chapter li element
							const _loadingBookId = _liElem.dataset.bookid, 
								_loadingChapterNum = _liElem.dataset.chapter;
							//re-acquire the book Id
							_xAudioCurrBook = xAudio.getAttribute("attr-book");
							//_xAudioCurrChap = parseInt(xAudio.getAttribute
							// ("attr-chap"));

							//if current li belong the the same book that are playing by xAudio, just change the chapter (changeChap will take care of re-play current playing chapter)
							if(_xAudioCurrBook === _loadingBookId){
								changeChap(_loadingChapterNum);
							}
							else{
								//change the UI of books
								//get the li that is currently marked as current played book
								const _lastPlayedBookELm = _lhWrapperElm.querySelector("li.last-playing-book");
								_lastPlayedBookELm && _lastPlayedBookELm.classList.remove("last-playing-book");
								//mark the new clicked book to be the new playing book
								_bookLi.classList.add("last-playing-book");

								//change the lc (last chapter) property of current book in xState, so that when loading the book, this chapter will be loaded
								_hist.books[_loadingBookId].lc = parseInt(_loadingChapterNum);
								//then just load the book without adding it to the history list
								historyCls.historyGo(_loadingBookId);
								//ssData.bookData.goGetBook(_loadingBookId);
							}
						}

						/* X.3. Handle event when click on little triangle of book li */
						// if we don't check _target.tagName, this might run twice, one on the label, one on the checkbox that the label associated with.
						if(_target.tagName == 'LABEL' && _liElem && _liElem.classList.contains('parent_li') ){
							/* Check if click on little triangle which drawed by label::before pseudo element. More accurate, but expensive condition: we compare the x-position (in relative to the vewport) to the left side of li element (again, relative to the viewport) 'evt.clientX < _liElem.getBoundingClientRect()' */
							//number -3 here is the left-most position of the little dot (sized 6px (set in {--dot-size} attribute of {li.parent_li.last-playing-book > label::after}) drawed by label::after pseudo element) in relative to the _liElem. Note that offsetX is The X coordinate of the mouse pointer relative to the position of the padding edge of the target node.
							if (evt.offsetX < -3) {
								const _bookId = _liElem.dataset.bookid;
								//console.log("Click on little triangles: " + _bookId);
								/* The process to remove book and chapter items from xState.history is exacly the same as historyCls.historyClear() */
								if(_bookId == xState.lb){
									// keep information of current chapter of current book
									let _histBook = _hist.books[_bookId];
									const _currChap = _histBook.lc;
									
									//delete information about all other chapter except current chapter
									Object.keys(_histBook)
										//filter all attributes that is a number, those are the chapter AND make sure it is NOT _currChap
										.filter( _attr => _attr.match(/^\d+$/) && _attr != _currChap )
										//delete information about the chapters
										.forEach(_chap => delete _histBook[_chap]);
									//make last book to be _currChap (just in case)
									_histBook.lc = _currChap;

									//remove all li that contains purged xState.history chapter of current _bookId out of DOM
									_liElem.querySelectorAll("ul > li.chapter_li:not(.last-playing-chapter)").forEach(_subLi => _subLi.remove());									
								}
								else{
									//delete all  information about _bookId out of xState.history.books
									delete _hist.books[_bookId];
									//delete the _bookId from xState.history.hisList and update currHis
									const _histIdx = _hist.hisList.findIndex(_book => _book == _bookId);
									if(_histIdx > -1) {
										_hist.hisList.splice(_histIdx, 1);
										//update currHis so that it still point to the old last-book before removing this _bookId
										if(_hist.currHis > _histIdx) _hist.currHis--;
									}

									//update history button in case the removal might affect
									historyCls.prototype.buttonAppeance();

									//remove book li out of DOM
									_liElem.remove();
								}

								//notify the user of removing book from history
								toast.showToast(`Đã xóa khỏi lịch sử nghe sách các chương đang nghe${_bookId == xState.lb?' (ngoài chương đang được phát)':''} của cuốn sách '${_target.querySelector('.histTitle').textContent}'.`, toast.ToastType.Warning);

								// prevent the tree expand/collapse
								evt.preventDefault();
								//evt.stopPropagation();
							}	
						}
						evt.stopPropagation();
					});					
				}
			}

			/* function to show all hot keys that support by the page along with some introduction, copyright, hints */
			function showHotKeys(){
				const hkWrapper = document.querySelector('div[name="hotkeysSettingWrapper"]');
				//break string of hotkey separated by "," or "+" into list of separate keys
				const _mapKey2Img = (_key, _ignoreMap = false) => {
					_key = _key.trim().replace(/^Key/,"");
					if(_ignoreMap) return _key;

					const _keysMap = [{key: "NumpadAdd", img: "Numpad+"},{key: "NumpadSubtract", img: "Numpad-"}];
					/* [{key: "ArrowUp", img: "↑"},{key: "ArrowDown", img: "↓"},
					{key: "ArrowLeft", img: "←"},{key: "ArrowRight", img: "→"},
					{key: "Backspace", img: "⌫"},{key: "Escape", img: "ESC"},
					{key: "NumpadAdd", img: "Numpad+"},{key: "NumpadSubtract", img: "Numpad-"},
					{key: "Shift", img: "⇧"},{key: "Alt", img: "⌥"},{key: "Ctrl", img: "⌘/⌃"},
					{key: "ControlRight", img: "⌘/⌃Right"},{key: "ShiftRight", img: "⇧Right"}]; */

					const _findKey = _keysMap.findIndex(k => k.key == _key);
					if(_findKey > -1) return _keysMap[_findKey].img; else return _key;
				}
				const breakKeys = (keyString, keySeparator = "<br/>", _ignoreModifierKeys = false) => {
					if(!Array.isArray(keyString)) keyString = keyString.split(",");
					return keyString.map(keys => 
						keys.trim().split("+").map(key => `<kbd${_ignoreModifierKeys?' class="ignoreModifierKeys"':''}>${_mapKey2Img(key)}</kbd>`).join(" + ")
					).join(keySeparator);

				}
				//list all hotkeys of a hotkey collection such as ssData.sddBookTitlesList.hotKeys
				const listHotKeys = (hkCollection, keySeparator = "<br/>") => {
					let _html = hkCollection.map(hk => `<samp data-task="${hk.task}">${breakKeys(hk.kCode, keySeparator, hk.ignoreModifier)}</samp><label>${hk.desc}</label>`);
					return _html.join("");
				}
				//add following in to field-set to make it land-scape layout with the full-width: ' class="lanscape-content" style="grid-column: span 2;" '
				hkWrapper.innerHTML = `<div>
				<fieldset style="grid-row: span 3;align-self: stretch;">
					<legend>Phím tắt cho Search–Dropdown</legend>
					<span class="commonGuide">— Trong danh mục các <b>tựa sách / chương sách</b>, kết hợp phím <samp modifier-key="true">${breakKeys(ssData.sddBookTitlesList.settings.makeSelectKey)}</samp> / <samp modifier-key="true">${breakKeys(ssData.sddChaptersList.settings.makeSelectKey)}</samp> (theo thứ tự) với các phím thay đổi mục (option) để phát ngay <b>tựa sách / chương sách</b>.</span><span class="commonGuide">— Chuyển chế độ tìm kiếm '<b>không dấu</b>' hoặc '<b>nguyên dấu</b>' bằng cách bấm phím tắt hoặc bấm nút chức năng <object style='display: inline-block; width: 20px; height: 20px; border: 1px solid; border-radius:4px;padding: 2px;'>${ssData.sddBookTitlesList.rootElement.querySelector(".search-diacritics-option-button > svg").outerHTML}</object> ở bên phải ô tìm kiếm.<br/>— App luôn luôn tìm kiếm không phân biệt chữ hoa-thường (case-insensitive). Tuy nhiên, tùy thuộc các chữ trong xâu tìm kiếm, ta có các cách tìm khác nhau:<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là chữ hoa, chế độ tìm kiếm sẽ theo '<b>Chữ cái đầu tiên</b>' của các từ liên tiếp. Ví dụ: So sánh tìm <kbd>TĐ</kbd> trong chế độ tìm dấu nêu trên.<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là chữ thường, chế độ tìm kiếm sẽ là tìm '<b>Cụm từ</b>' (như indexOf). Ví dụ: So sánh tìm <kbd>đại kinh</kbd> theo một trong hai chế độ tìm dấu. Trong chế dộ 'không dấu', so sánh kết quả tìm <kbd>Tinh do</kbd> vs <kbd>tinh do</kbd>; <kbd>dai kinh</kbd> vs <kbd>kinh dai</kbd>.<br/>&emsp;⨁ Nếu tất cả các chữ trong xâu tìm kiếm đều là số (và dấu <kbd>.</kbd>), chế độ tìm kiếm là '<b>Số</b>'. Có thể bấm số kết thúc bằng dấu <kbd>.</kbd> để tìm nhanh đến mục có số thứ tự tương ứng. Ví dụ: <kbd>30.</kbd><br/>&emsp;⨁ Trường hợp còn lại là chế độ tìm kiếm '<b>Khớp từ</b>', chuỗi kết quả là chuỗi chứa từng từ trong chuỗi tìm kiếm theo thứ tự bất kỳ. Ví dụ, tìm <kbd>Dai kinh</kbd> trong chế độ 'không dấu' sẽ tìm được cả 'Đại Kinh' và 'Kinh Tạng Đại Thừa'</span>
					${listHotKeys(ssData.sddBookTitlesList.hotKeys)}
				</fieldset>
				<fieldset>
					<legend>Phím tắt cho Audio–Player</legend>
					<span class="commonGuide">— Bấm các phím chức năng <kbd>Ctrl</kbd>/<kbd>Shift</kbd>/<kbd>Alt</kbd> cùng các phím tua nhanh để tua 40/30/20 giây.<br/>— Bấm phím chức năng <kbd>Alt</kbd> cùng các phím tăng/giảm âm lượng để thay đổi âm lượng 10%.<br/>— Bấm các phím chức năng <kbd>Shift</kbd>/<kbd>Alt</kbd> cùng các phím tăng/giảm tốc độ phát để thay đổi 0.2/0.1.<br/>— Nháy đúp vào {bên trái/bên phải} của [khung đếm thời gian/ảnh bìa/lề của trang] để tương ứng tua {về trước/về sau} lần lượt [15/20/30] giây. Nút lệnh tua [nhỏ/to] tua [10/20] giây. Nút tua trong Notification Center tua 15 giây.</span>
					${listHotKeys(ssData.hotKeys.audioPlayer)}
				</fieldset>
				<fieldset>
					<legend>Phím tắt cho trang ngoài</legend>
					${listHotKeys(ssData.hotKeys.mainPage, ", ")}
				</fieldset>
				<fieldset style="align-self: stretch;">
					<legend>Phím tắt trong cửa số cấu hình</legend>
					${listHotKeys(ssData.hotKeys.settingModal, ", ")}
				</fieldset>
				 <fieldset style="align-self: stretch;">
					<legend>Hints</legend>
					<div style='grid-column: span 2;text-align: justify;'>Với các biểu tượng và một số thành phần không biết ý nghĩa, người dùng có thể di chuột lên (với máy tính) hoặc bấm vào/nhấn giữ (với thiết bị cầm tay thông minh) để hiện tooltip (chữ trắng, nền đen mờ) hướng dẫn về chức năng và thông tin bổ sung (nếu có) của thành phần đó.</div>
				</fieldset>
				<fieldset style='align-self:end'>
					<legend>Who made this web-app</legend>
					<div name="coryright">🄲<span style="font-size:1.05em">②⓪②④</span>&puncsp;<div name="authorName"></div></div>
					<div style='grid-column: span 2;text-align: justify;'>This web-app has been made in my leisure time from May 2024 with the purpose of learning and applying state-of-the-art web technologies, so it might be a-bit of resource-consuming. It would perform well with latest browsers such as Chrome, Safari and Edge.</div>
				</fieldset>
				
				</div>`;
				/* <fieldset>
					<legend>Điều khiển phím tắt</legend>
					<input id="keyboard-hotkeys-disabled" type="checkbox" role="switch" class="!text-[25px]">
					<label for="keyboard-hotkeys-disabled">Khóa tất cả các Hot Keys</label>
				</fieldset> */
			}
			
			/**
			 * SETTING MODAL FUNCTIONS
			 */

			//store one copy of xState.toastCfg when openning the setting then compare later when close setting to see if there is any change
			let _toastConfigSetting = {};
			//store one copy of xState.grpCfg when openning the setting then compare later when close setting to see if there is any change in current groupLine
			let _xGrpCfgSetting = [];
			//contains a copy of xDBFilesCfg.toLoad global variables to track-changes if user has change the setting (loadMode, order) in DB files
			let _xDBFilesCfg_filtered_toLoadSetting = {};
			
			/* Function to initialate setting event handlers, run only once when create setting instance */
			function initSettingModal() {
				//reset beenActive attribute to tell that in this openSetting sessions, this tab has not been clicked at all
				//document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]').forEach(_tab => _tab.dataset.beenActive = "");

				const modalPopupTabsGroup = document.querySelector(".modalPopup .tabs-group");

				/* _TAB_IDS contains information for each tab. If you re-order the tab, then change the idx attribute accordingly. The 'reloadRequired' attribute to tell the page if this tab need to reload each time Setting modal is openned and that tab got click. For now, only tabBookSetting need refresh to update that changes if user change grpWay (through #selBookGroup element) */
				const _TAB_IDS = [ 
					{idx: 0, name: "tabBookSetting", reloadRequired: true}, 
					{idx: 1, name: "tabListenHistory", reloadRequired: true}, 
					{idx: 2, name: "tabUISetting"}, 
					{idx: 3, name: "tabDBFilesSetting"}, 
					{idx: 4, name: "tabHotkeysSetting"} ];

				//assign id for each tabs
				const _allTabCheckboxs = [...document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]')];
				_allTabCheckboxs.forEach( (_tabChkbx,i) => {
					const _tab_id = _TAB_IDS.find(_item => _item.idx === i);
					_tabChkbx.setAttribute("tabName", _tab_id.name);
					
					if(_tab_id.reloadRequired) 
						//so that each time open Setting, data-beenActive will be reset
						_tabChkbx.setAttribute("reloadRequired", 1);
					_tabChkbx.dataset.tabIndex = _tab_id.idx;
				} );
				
				//this is for container property in reposTooltips() only. I've used modalPopupTabsGroup as container, but tooltip got cut-out 
				const modalPopupContentWrapper = document.querySelector(".modalPopupContentWrapper");

				//delegation click event to tab-group to capture click on tab checkboxes
				const _tabGroupsDelegatedClickHandlers = _evt => {
					const _inputTab = _evt.target;
					//check if this is tab checkbox, which control the visibility of tab-content
					if(_inputTab.tagName === "INPUT" && _inputTab.type === "radio" && _inputTab.getAttribute("name") === "tabs-component"){

						/* function for each tab that run only one time when the tab got clicked very first time in whole Page session. For now, this is responsible for fix tooltip position (because before tab clicked, its content is hidden, so all of its children do not have dimension, yet) */
						if(!_inputTab.runOnlyOnce){
							let  _inputTabContent = _inputTab.nextElementSibling.nextElementSibling; // the div contain tab content
							if(_inputTab.checked) setTimeout(_ => reposTooltips( _inputTabContent, {container: modalPopupContentWrapper} ), 1000) //wait 1sec for UI to be rendered
							_inputTab.runOnlyOnce = true; //so next time it not run again
						}

						const _tabIdx = parseInt(_inputTab.dataset.tabIndex);
						const _tab_id = _TAB_IDS.find(_item => _item.idx === _tabIdx);

						//only load content again if beenActive flag is off or missing
						const _requiedReload = !Boolean(_inputTab.dataset.beenActive);
						
						switch(_tabIdx){
						case 0:
							// TAB 1: the book kits/sets setting
							if(_requiedReload) addBookSettingTab();
							break;
						case 1:
							// TAB 2: the listening history
							if(_requiedReload) addListeningHistory();
							break;	
							
						case 2:
							//TAB 3: deploy radio option buttons for toast-setting and handle option changes
							
							if(_requiedReload){
								addToastSettingControl();
								
								//handle setting for circle progress button
								handleCircleProgressChkbox();
								//handle setting for buffered-bar in audio player
								handleBufferBarChkbox();
							}
							markToastRandomChoose();
							break;
						case 3:
							//TAB 4: add database files and books it contains
							if(_requiedReload) addJsDatabaseFileReport();
							break;
						case 4:
							//TAB 5: show Hotkeys
							if(_requiedReload) showHotKeys();
							break;									
						}
						//console.log("Tab visit: " + (_tabIdx+1) + " - requiedReload:" + _requiedReload);
						

						//mark that this tab is active
						_inputTab.dataset.beenActive = 1;
					}
				};
				modalPopupTabsGroup.addEventListener("click", _tabGroupsDelegatedClickHandlers);

				/* keydown event provide short-cut keys for some frequently used functions 
				NOTE: audio hotkeys function created in AudioPlayer class also handles the document's keydown event
				*/
				const pageKeyDown = (evt) => {
					/** function to active adjacent tab 
					 * @param _goNext {boolean} true - go next; false: go previous
					*/
					const _goAdjTab = _goNext => {
						const _len = _allTabCheckboxs.length;
						// curent tab
						let _currTabIdx = _allTabCheckboxs.findIndex(_radio => _radio.checked);
						// adjacent tab
						_currTabIdx = ( _currTabIdx + _len + (_goNext ? 1 : -1) ) % _len;
						const _currTab = _allTabCheckboxs[_currTabIdx];
						_currTab.click(); //active the tab
						//show the notification
						const _tabLabelElem = _currTab.nextElementSibling.querySelector('code');

						toast.showToast(`Chuyển đến tab ${_tabLabelElem.innerHTML} [${_tabLabelElem.dataset.tooltip.split('\n')[0].replace(/[,\.]([^,\.]+)\:/,".")}]`);
					}					

					//full list of hotkeys with callback functions
					const hotkeyOptions = [

						// Z, ControlRight: open Books List dropdown
						{task: "settingModal_closeModal", kCode: ["Escape"], desc: "Đóng cửa sổ cấu hình.", callback: () => {
							ssData.setting.closeSettingModal();
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}},
						
						// PageUp, Shift+Tab: activate previous tab
						{task: "settingModal_prevTab", kCode: ["Shift+Tab", "PageUp"], noNotify: true, desc: "Về tab ngay trước.", callback: () => {
							_goAdjTab(false);
							evt.preventDefault();
							evt.stopImmediatePropagation();
							}
						},

						// PageDown, Tab: activate next tab
						{task: "settingModal_nextTab", kCode: ["Tab", "PageDown"], noNotify: true, desc: "Sang tab tiếp theo.", callback: () => {
							_goAdjTab(true);
							evt.preventDefault();
							evt.stopImmediatePropagation();
						}
						}
					];

					// if this function run without {evt} parameter, it just save the hotkeys List into ssData.hotKeys.mainPage to notify to user
					if(!evt && !ssData?.hotKeys?.settingModal){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.settingModal){
							ssData.hotKeys.settingModal = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return;
					}

					/* //find if the key just press in the list of supported shortcuts
					const hotkeyOpts = hotkeyOptions.filter(keyItem => keyItem.kCode.indexOf(evt.code)>-1);
					//if found, do the corresponding job
					hotkeyOpts.forEach(hotkeyOpt => hotkeyOpt.callback()); */

					//search if a key just press matched any key specify above, then take the corresponding action (stopPropagation and preventDefault)
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions, 3);
					
				};
				pageKeyDown(); //to get the list of hotKey and saved in ssData.hotKeys.mainPage
				modalPopupContentWrapper.focus();
				modalPopupContentWrapper.addEventListener("keydown", pageKeyDown); 

				//re-position tooltip for svg icons in tab headers of Setting modal.				
				setTimeout(() => {
					_allTabCheckboxs.forEach(_tabChckbox => 
					reposTooltips( _tabChckbox.nextElementSibling, {container: modalPopupContentWrapper} ))
				}, 1000);				
			}			
			
			/** function to filter to keep only dbName and loadMode properties of toLoad array, so the page will not false-alarm that there is a change in DB setting (even change might be on dbUrl or edition), filter this way, we will know exactly when user change the loadMode of a DB
			 * @param _DBFileCfg kind of _DBFileCfg
			 * @return let say an item of @param _DBFileCfg.toLoad is '{"fileNo":3,"dbName":"data_3","dbUrl":"data_3.js?v=178","loadMode":0,"failCount":0,"edt":117}', the returned json of that item now is only {"dbName":"data_3", "loadMode":0}
			*/
			const _filterDBFileCfg = _DBFileCfg => xDBFilesCfg.toLoad.map(_itm => { return {dbName: _itm.dbName, loadMode: _itm.loadMode} });

			/* When setting modal shows up */
			function openSettingModal() {
				//make a deep copy of xState.toastCfg to track changes
				_toastConfigSetting = structuredClone(xState.toastCfg);
				
				//make a deep copy of xState.grpCfg to track changes
				_xGrpCfgSetting = structuredClone(xState.grpCfg);

				//make a deep copy of xDBFilesCfg to track changes
				_xDBFilesCfg_filtered_toLoadSetting = structuredClone( _filterDBFileCfg(xDBFilesCfg) );

				document.getElementById("modalSettingPopup").classList.add("activeModalPopup"); //show the modal

				//run initSettingModal() if this is the very first time settingModal got opened
				if(!this.inited) {
					initSettingModal();
					this.inited = true; // so that initSettingModal won't run again next time open Setting
				}

				//now, open a last tab and reload HTML if required
				const _allTabCheckboxes = document.querySelectorAll('.modalPopup .tabs-group > input[type="radio"][name="tabs-component"]');
				let _lastActiveChkbox;
				_allTabCheckboxes.forEach(_tabChkbx => {
					//so that this tab will be refresh in this open Setting session
					if(_tabChkbx.hasAttribute("reloadRequired")) delete _tabChkbx.dataset.beenActive;
					if(_tabChkbx.checked) _lastActiveChkbox = _tabChkbx;
				});
				//force to last active tab to be active. If not exist, force the first one
				(_lastActiveChkbox || _allTabCheckboxes[0]).click();				

				
			}

			/* Clean-up, make change when modal closed */
			function closeSettingModal() {
				
				(function () {
					//clear the group listbox and books ol, and the same time clear all event handler (such as onchange or drag&drop) for each element and its children
					document.getElementById("selPopupBookGroup").innerHTML = "";
					document.getElementById("lstBookTitlesSetting").innerHTML = "";
					document.querySelector('.modalPopupContent [name="bookKitChkboxContainer"]').innerHTML = "";

					//clear the listening history (but keep the event)
					document.querySelector("#ListeningHistoryWrapper").innerHTML = "";
				})();
				_dragObj = null;

				//Lưu xSate vào Local Storage
				localStorage.setItem('xState', JSON.stringify(xState));
				
				//update new toast mode only if there is any change. 
				if(!objsEqual(_toastConfigSetting, xState.toastCfg) ){
					toast.setToastMode();
					toast.showToast("Có thay đổi trong thiết đặt cấu hình thông báo Toast!");
				}

				//re-populate the ssData.sddBookTitlesList if current group line configuration has any changes
				if( !objsEqual(_xGrpCfgSetting[xState.grpLine].grp, xState.grpCfg[xState.grpLine].grp) ){
					//turn on this flag so the Toast message called inside next function will not display
					//toast.depressToast(true);
					toast.showToast(`Có thay đổi trong thiết đặt cấu hình sách, nhóm số ${xState.grpLine}: '${xBookGrp[xState.grpLine].grpWay}'`);
					//make all the book setting take effect on main page, in case there is some changes in user-setting related to order or hidden-state of books
					document.getElementById("selBookGroup").onchange();
				}

				//check if there is any changes in DB files settings
				//TODO: note that when addJsDatabaseFileReport() trying to load a DBfile that has loadMode = 0 (no show) and its failed, then xDBFilesCfg.toLoad[idx].failCount would increase by 1 (see the .catch in addJsDatabaseFileReport()), so the below objsEqual() will return @true even if there is no user-change in the DBfiles setting, thus it will false-alarm the user that there is a change.
				if( !objsEqual(_xDBFilesCfg_filtered_toLoadSetting, _filterDBFileCfg(xDBFilesCfg)) ){
					if (confirm("Có thay đổi trong Database Files Setting.\nBạn có muốn nạp lại trang Web?")) 
						//Force a hard reload to clear the cache if supported by the browser
						window.location.reload(true);
				}

				//close the modal
				document.getElementById("modalSettingPopup").classList.remove("activeModalPopup");
			}

			/* PUBLIC METHOD */
			return {
				openSettingModal: openSettingModal,
				closeSettingModal: closeSettingModal,
				handyCheckDBsEdition: _handyCheckDBsEdition
			};
		}

	</script>

	<!-- MAIN PLAYER CONTROLS -->
	<script>
		"use strict";
		/* CLASS deal with audio player
			settingParam: json object to specify some initial value. For example, it can be {speed: 1.4, volume: 1} to specify the initial speed for audio playback is 1.4, audio volume to 1 (100%)
		
			modified from https://github.com/likev/html5-audio-player
		*/
		let AudioPlayer = function (settingParam) {
			let isSeeking = false, isPlaying, rightClick = false;
			//let volumeLength; //vars for seeking by mouse and by touching
			let xPlayer = document.querySelector(".ap-container");
			let volumeBtn = xPlayer.querySelector('.ap-volume-btn');
			let remTime = xPlayer.querySelector('.ap-time--remains');
			let trackTitle = xPlayer.querySelector('.ap-title');
			let progressBar = xPlayer.querySelector('.ap-progress-bar');
			let preloadBar = xPlayer.querySelector('.ap-progress-preload-bar');
			let volumeBar = xPlayer.querySelector('.ap-volume-bar');
			let playBtn = xPlayer.querySelector('.ap-play-pause-btn');
			let prevBtn = xPlayer.querySelector('.ap-prev-btn');
			let nextBtn = xPlayer.querySelector('.ap-next-btn');
			let reloadBtn = document.querySelector('.ap-reload-btn');
			let elmPlayingTime = document.getElementById("elmPlayingTime"); //playing time big display
			let bufferBarCanvas = document.querySelector('.ap-buffer-bar');
			let _xDuration = 0; //hold the duration of the current playing audio

			xAudio.autoplay = true; //this actually not doing anything
			
			/* Check if internet connection is alive or dead
			If dead, swich some element showing that internet is dead
			*/
			function checkInternetAlive() {
				if (navigator.onLine) return true;

				//no internet
				switchBigPlayingTime(-1); //showing no internet error

				// search "Audio readyState mdn" for meaning of readyState and its value
				if (xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA) {
					xAudio.pause(); //pause audio
					switchPlayPauseButton(1, 0); // Play icon but 3 buttons got disabled
				}
				return false;
			}

			/* ==========  WINDOW + DOCUMENT EVENT BINDING ========== */
			{
				window.addEventListener("offline", (e) => {
					toast.showToast("Mất kết nối Internet", toast.ToastType.Error, {persistance: true});
				});

				// this event only fires when connection is lost and got back again
				window.addEventListener("online", (e) => {
					toast.showToast("Kết nối Internet", toast.ToastType.Success, {persistance: true});
					document.getElementById("elmPlayingTime").innerText = toHhMmSs(xAudio.currentTime) + " / " + toHhMmSs(xAudio.duration); // remove "no internet" text from big font playing time;

					let _elmArtwork = document.getElementById("elmArtwork");
					//if _elmArtwork is currently hidden
					if(!_elmArtwork.offsetParent){
						//show cover img and hide No-Internet sprite svg image
						utilityHandles.showNoInternet();
						//reload cover image. For youtube image, if using "?v=" + performance.now().toFixed() the image will not load, because youtube take param 'v=' for other meaning
						_elmArtwork.src = _elmArtwork.src + "?" + performance.now().toFixed();

						//update new artwork to notification center
						utilityHandles.updateNCWorkart();
					}					

					//the param should be true for most of the cases, but I use 'xAudio.paused' instead of 'true' for the case lost internet, audio having buffer still playing, now got internet back, we let audio continue playing
					if (xAudio.paused) {
						switchPlayPauseButton(1, 1); //enable buttons and show Play icon

						//compare the width of progressBar and its container (parent), if it is equal (or not-possible longer), meaning the audio is paused at the very end of its full duration, we just make it  jump to next chapter
						if(progressBar.parentElement.offsetWidth <= progressBar.offsetWidth){
							playNextPrev(1); //play next chapter
						}
						//we only reload audio src when there is no audio buffer left, using naive-stupid method to check that condition is to compare the width of progressBar (audio duration played so far) with that of preloadBar (the audio duration has been buffered by browser)
						if(preloadBar.offsetWidth <= progressBar.offsetWidth)
						reloadSrc(true); //reload src, force Pause
					}
					else
						switchPlayPauseButton(0, 1); //enable buttons and show Play icon
				});

				/* keydown event provide short-cut keys for some frequently used functions */
				
				const audioKeyDown = (evt) => {
					//evt && console.log(evt.code);

					//customize change rate based on modifier key pressed for volume, seeking and speed
					const _VOLUME_CHANGE = evt?.altKey? 0.1 : 0.05;
					const _TIME_CHANGE = evt?.ctrlKey ? 40: ( evt?.shiftKey ? 30: (evt?.altKey? 20 : 10) );
					const _SPEED_CHANGE = evt?.shiftKey ? .2: (evt?.altKey? .1 : .05) ;
					
					//const _NO_MODIFIER_KEY = !(evt?.ctrlKey || evt?.metaKey || evt?.shiftKey|| evt?.altKey);

					/* See the comments on function SddDropdown.prototype.runHotkey to see the format and meaning of each shortcut */
					//full list of hotkeys with callback functions
					const hotkeyOptions = [
						// ArrowLeft: rewind current audio
						{task: "audio_rewind", kCode: ["ArrowLeft"], desc: "Tua lùi về sau (rewind) 10 giây.", ignoreModifier: true, noNotify: true, callback: () => xAudio.currentTime -= _TIME_CHANGE},
						// ArrowRight: fastforward current audio
						{task: "audio_fastforward", kCode: ["ArrowRight"], desc: "Tua tiến về trước (fastforward) 10 giây.", ignoreModifier: true, noNotify: true, callback: () => xAudio.currentTime += _TIME_CHANGE},

						// ArrowUp: increase audio volume by 5%
						{task: "audio_volumeUp", kCode: ["ArrowUp"], desc: "Tăng âm lượng audio 5%.", ignoreModifier: true, noNotify: true, callback: () => changeAudioVolume(xAudio.volume + _VOLUME_CHANGE)},
						// ArrowDown: increase audio volume by 5%
						{task: "audio_volumeDown", kCode: ["ArrowDown"], desc: "Giảm âm lượng audio 5%.", ignoreModifier: true, noNotify: true, callback: () => changeAudioVolume(xAudio.volume - _VOLUME_CHANGE)},
						// keyM: increase audio volume by 5%
						{task: "audio_toggleVolume", kCode: ["Delete", "KeyM"], desc: "Bật/Tắt âm lượng.", callback: volumeToggle.bind(volumeBtn)},

						// Speed UP
						{task: "audio_speedUp", kCode: ["Equal", "NumpadAdd"], ignoreModifier: true, desc: "Tăng tốc độ phát 0.05.", noNotify: true, callback: () => insertSpeed('+'+_SPEED_CHANGE)},
						// Speed DOWN
						{task: "audio_speedDown", kCode: ["Minus", "NumpadSubtract"], ignoreModifier: true, desc: "Giảm tốc độ phát 0.05.", noNotify: true, callback: () => insertSpeed('-'+_SPEED_CHANGE)},
						// Speed Normal
						{task: "audio_normalSpeed", kCode: ["Digit0", "Numpad0"], desc: "Đưa tốc độ phát về 1.0.", callback: _ => {elmSltSpeed.value = 1; xAudio.playbackRate=1}},

						// PageDown: next audio track
						{task: "audio_nextTrack", kCode: ["PageDown"], desc: "Phát chương sách tiếp theo.", callback: () => {nextBtn.click()} }, //shift+PgDown for next book in history
						// PageUp: previous audio track
						{task: "audio_prevTrack", kCode: ["PageUp"], desc: "Phát từ đầu chương (<30s) hoặc chương sách trước.", callback: () => {prevBtn.click()} },  //shift+PgUp for previous book in history

						// ["Space", "Enter"]: previous audio track
						{task: "audio_playPauseAudio", kCode: ["Space", "Enter"], desc: "Phát / Dừng phát chương sách.", callback: () => playBtn.click()}
					];

					// if function is invoked without {evt} parameter,  it just save the hotkeys List into ssData.hotKeys.audioPlayer to notify to user
					if(!evt && !ssData?.hotKeys?.audioPlayer){
						if(!ssData.hotKeys) ssData.hotKeys = {};
						if(!ssData.hotKeys.audioPlayer){
							ssData.hotKeys.audioPlayer = hotkeyOptions.map(hotkey => {
								let _temp = Object.assign({}, hotkey); //create deep copy
								delete _temp.callback; //remove the {callback} attribute
								return _temp;
							});
						}

						return; //the case that we run audioKeyDown() below just get the hotKey list
					}

					//search if a key just press matched any key specify above, then take the corresponding action. Set parameter keyPreventation = 3 to avoid page scroll when using hotKey
					SddDropdown.prototype.runHotkey(evt, hotkeyOptions);
					//evt.preventDefault(); //to avoid page scroll when using hotKey
				}; 
				audioKeyDown();
				//assign handler to page keydown event 
				document.addEventListener("keydown", audioKeyDown);
			}
			
			/* ==========  AUDIO HTML ELEMENT EVENT BINDING ========== */
			{//set event handler for audio element
				/* When audio lack of data, and need to load, the event order would be: Waiting [> Progress] > Stalled [> Progress] > CanPlay > Playing > Progress 
				However, on stupid Apple Safary, after firing Stalled event, browser does not fire any other event except timeUpdate and sometime progress
				*/
				xAudio.onloadstart = (event) => { //start loading media, so we need to wait until oncanplay
					console.log("Load Start");

					remTime.innerHTML = "-:-- / -:--";
					//reset progress bar
					progressBar.style.width = '0%';
					preloadBar.style.width = '0%';

					if (!checkInternetAlive()) return;

					switchBigPlayingTime(0); //change playing time from spinning HourGlass to current numbered time
					switchPlayPauseButton(-1, 0); //show loading icon

					//reset circle progress bar to 0% (beginning)
					updateCircleProgressBar(0);

					clearBufferBar(); //clean the buffer bar
				};

				// The canplay event is fired when the user agent can temporarily play the media, canplaythrough fired when it can play the media up to its end without stopping for content buffering.
				xAudio.oncanplay = (event) => { //the audio can now play
					// console.log("Can Play");
					updateTime();
					switchBigPlayingTime(1);

					//because of html audio element's autoplay attribute, we have to check the playing state to show corresponding buttons
					switchPlayPauseButton(xAudio.paused ? 1 : 0, 1);

					//TODO: to debug while sometime audio play at rate 1 even though the speed dropdown set the speed 1.4 or something other than 1
					/* if(xAudio.playbackRate == 1) {
						toast.showToast('xAudio.oncanplay: xState.speed = ' + xState.speed + '. settingParam.speed = ' + settingParam.speed, toast.ToastType.Error, {duration:1e4});						
					} */

					//it seems that on lastest version of some browser, the audio speed always reset to 1.0 when play a new audio, so we just set audio speed every time playing new audio
					changeAudioSpeed();
				};

				/* 
				//The waiting event is fired when playback has stopped because of a temporary lack of data. this is fired before on-stalled
				xAudio.onwaiting = () => {console.log("Waiting")};
				//The progress event is fired periodically as the browser loads a resource.
				xAudio.onprogress = () => {console.log("Progress")};
				  */

				//when the user agent is trying to fetch media data, but data is unexpectedly not forthcoming.
				xAudio.onstalled = (event) => { //this is similar to onwaiting ?
					console.log("Stalled !!!");
					checkInternetAlive();
					toast.showToast("Trying to fetch data.");
					//switchPlayPauseButton(); //show loading icon. TODO: If run this, we have to deactive it on some other event, see above for this problem
				};

				// when a seek operation completed, the current playback position has changed
				xAudio.onseeked = (event) => {
					//console.log("Seeked");
					// note that if user click mouse (without moving) to seek, this event fired before Mouse-up event, so isSeeking still true, thus the following Toast will not show
					if (!isSeeking) toast.showToast("Audio is seeked to " + toHhMmSs(xAudio.currentTime));
					updateTime(true); //after being seeked, the audio data need to buffer, sometime this take times until the audio can continue playing. So we need to update UI of the page
					//updateBufferCanvas(); //this is already called in updateTime with parameter forceHeavyUIUpdate = true
				};

				xAudio.onpause = (event) => {
					//console.log("on-Paused");
					toast.showToast("Audio paused !!!", toast.ToastType.Warning);
					//When having problem (such as lost internet), onpaused is fired after onstalled, so draw button according to condition if have future data or not
					switchPlayPauseButton(1, xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA ? 0 : 1); //show play icon
				};
				xAudio.onplay = (event) => { //onplaying fired twice each time audio play
					//console.log("Playing");
					toast.showToast("Đang phát chương sách... ✕" + xAudio.playbackRate);

					switchPlayPauseButton(0, 1); //show pause icon
				};

				/* Some important events */
				xAudio.onended = (event) => { //note that playback has stop before fire this event
					//console.log("on-ended");
					if (checkInternetAlive()) playNextPrev(1);
				}; //when reach to end, play the next chapter: 
				
				/* //somehow, sometimes the speed change back to normal withour user's request, so we need to change it back.  
				xAudio.onratechange = (event) => { 
					changeAudioSpeed(); 					
				};  */

				xAudio.ondurationchange = (event) => { 
					_xDuration = xAudio.duration; //update duration to variable

					//console.log(toHhMmSs(xAudio.duration));

					/* // to get real duration to update to ssData.xData
					if(!window["durs"]) window["durs"]={};
					durs[xAudio.getAttribute("attr-chap")] = toHhMmSs(_xDuration);  */
				};
				xAudio.addEventListener('timeupdate', _ => updateTime(), false);
				xAudio.addEventListener('error', audioError, false);
				function audioError(evt) {
					console.log("audio error event");
					toast.showToast('Phát Audio bị lỗi', toast.ToastType.Error);
					checkInternetAlive(); //update buttons UI
				}
			}

			/** load new source for audio
				@param _src {string}		: mp3 link for playing audio
				@param _justReload {boolean} :
					TRUE: If failed, just trying audio.load() to reload audio sr, skip step 3 of tryingLoadAudio()
					FALSE: if failed again after audio.load(), try others url src
			 */
			function loadSrc(_src, _justReload) {

				//reset the value that is used to lighten the heavy-burden of updateTime() function, that is, just update UI after some specific interval of time, not in every audio 'timeupdate' event firing
				_lastAudioPosition = 0;

				//reset the updateBufferCanvas counter
				_ubcCounter = 0; 

				xAudio.src = _src;
				tryingLoadAudio(_justReload);
			}

			/* Function using promise chain to try playing audio 
			1. Try audio.play() with current source
			2. If failed, using audio.load() to reload (same) source. Sometime media from archieve.org need to load 2-3 times for it to play
			3. Still failed: playing other sources
			4. Still failed: notify user, change buttons UI.
			
			param _justReload {boolean}
				True: just try reload current source without trying other url src line (skip step 3 above)
				False: include step 3
			 */
			function tryingLoadAudio(_justReload) {
				if (!checkInternetAlive()) return; //check internet connection, if lost: change button UI and return

				let playPromise = xAudio.play();
				let chainToast = new toast.ChainToasts("Nạp dữ liệu media chương sách");
				if (playPromise !== undefined) {
					playPromise.then(_ => {
						//console.log("Lan 1");
						chainToast.checkoutToast("Bắt đầu phát");
					})
					.catch(_err => {
						// You can put a breakpoint here to see the detail of _err, all its properties and built-in error constant code
						console.log(`[tryingLoadAudio]: [${_err.code}]${_err.name}: ${_err.message}`);

						if ([0, _err.ABORT_ERR, _err.NETWORK_ERR, _err.NOT_FOUND_ERR, _err.NOT_SUPPORTED_ERR, _err.NO_DATA_ALLOWED_ERR, _err.TIMEOUT_ERR].indexOf(_err.code) > -1) {
							//pass toast notification to next .then()
							return _err;
						}
						/* else
							toast.showToast(`[tryingLoadAudio]: [${_err.code}]${_err.name}: ${_err.message}`, toast.ToastType.Warning); //other error, just show error details
							*/

						//console.log("[tryingLoadAudio]: trying audio.load()");
						chainToast.showNextToast(`[tryingLoadAudio]: trying reload audio`, toast.ToastType.Warning);
						xAudio.load(); //trying to reload source ONE time
						return xAudio.play(); //throw new promise for next catch() to catch if there is any more error
					})
					.then(_res2 => {
						//console.log("Lan 2");
						//Check to see if this .then got from xAudio.play() promise. Note that other return because of error last .catch() give back _err.code
						if (_res2 instanceof Promise)
							chainToast.checkoutToast("Chương truyện có thể phát.", toast.ToastType.Infor);
						else if (_res2 instanceof Error) { //if is error got from return _err;
							let _errMsg = "Không rõ lỗi", _toastType = toast.ToastType.Error;
							let _throwErr = false;
							switch (_res2.code) {
								case 0:
									//[0]NotAllowedError: play() failed because the user didn't interact with the document first.
									_errMsg = `Phải bấm nút Play để nghe truyện`;
									_toastType = toast.ToastType.Warning;
									break;
								case _res2.NETWORK_ERR:
									_errMsg = `Mất kết nối Internet`;
									break;
								// [20]AbortError: The play() request was interrupted by a new load request.
								case _res2.ABORT_ERR:
									_errMsg = `Lệnh phát chương truyện bị hủy`;
									break;
								case _res2.NOT_FOUND_ERR:
									_errMsg = 'Nguồn phát media không tồn tại';
									_throwErr = true;
									break;
								case _res2.TIMEOUT_ERR:
									_errMsg = 'Quá thời gian tải cho phép';
									_throwErr = true;
									break;
								//NotSupportedError: Failed to load because no supported source was found.
								case _res2.NOT_SUPPORTED_ERR:
								//source type not allow
								case _res2.NO_DATA_ALLOWED_ERR:
									_errMsg = 'Không hỗ trợ phát nguồn media';
									_throwErr = true;
									break;
								//other error, just show error details	
								default:
									_errMsg = `[tryingLoadAudio]: [${_res2.code}]${_res2.name}: ${_res2.message}`;
									_toastType = toast.ToastType.Warning;
							}
							
							//throw error so the next .catch would try on another url line (if any)
							if(_throwErr) {
								class CustomAudioPlayError extends Error {
									constructor(_code, _msg, ...params) {
										super(...params); // Pass remaining arguments (including vendor specific ones) to parent constructor
										this.code = _code;
										this.message = _msg;
										this.name = "CustomAudioPlayError";
									}
								};
								toast.showToast(_errMsg, _toastType); //chainToast.showNextToast
								throw new CustomAudioPlayError(_res2.code, _errMsg, {cause: _res2.message});
							}
							else chainToast.checkoutToast(_errMsg, _toastType);
						}
						else // other unknown reason
							chainToast.checkoutToast("Có thể phát truyện dù không rõ lí do.", toast.ToastType.Warning);
					})
					//this catch would catch error from xAudio.play() in previous .catch or throw error in previous .then
					.catch(_err => {
						toast.showToast(`[tryingLoadAudio]: audio reload() thất bại.[${_err.name}]`, toast.ToastType.Error); //chainToast.showNextToast
						console.log(`[tryingLoadAudio]: audio.load() Failed.\n[${_err.code}] ${_err.name}: ${_err.message}`);

						let _switchSrcBtn = document.querySelector(".switchChapterAudioSrc");
						// Change audio source if there are more than one
						if (!_justReload && _switchSrcBtn) {
							console.log("[tryingLoadAudio]: Try loading other source");
							chainToast.checkoutToast(`[tryingLoadAudio]: Nạp nguồn link khác theo của chương truyện.`, toast.ToastType.Warning);
							changeAudioSrc(true); //trying load audio src WITHOUT fail-safe to play other url line if current url line failed
						}
						else {
							chainToast.checkoutToast("Không phát được chương truyện. Chọn chương hoặc truyện khác", toast.ToastType.Error);
							switchPlayPauseButton(1, 0); //paint UI (Play icon, disabled) for some buttons telling that audio cannot play

							elmPlayingTime.textContent = remTime.textContent = "-:-- / -:--";
							//reset progress bar
							progressBar.style.width = '0%';
							preloadBar.style.width = '0%';

							//change playing time from spinning HourGlass to current numbered time
							switchBigPlayingTime(1);

							//reset circle progress bar to 0% (beginning)
							updateCircleProgressBar(0);

							clearBufferBar(); //clean the buffer bar
						}
					});
				}
			}

			/* ==========  AUDIO CONTROL BUTTONS HANDLER =========== */
			document.querySelectorAll("button:has(svg > use[svg-icon-name='PlayPauseIcon'])").forEach(_btn => _btn.addEventListener('click', playStop, false)); //handler for the two Play/Pause buttons

			prevBtn.addEventListener('click', () => playNextPrev(0), false);
			nextBtn.addEventListener('click', () => playNextPrev(1), false);
			//Handler for buttons on notification center
			if ('mediaSession' in navigator) {
				let _mediaSession = navigator.mediaSession;
				_mediaSession.setActionHandler("previoustrack", () => playNextPrev(0));
				_mediaSession.setActionHandler("nexttrack", () => playNextPrev(1));
				_mediaSession.setActionHandler("play", () => playStop());
				_mediaSession.setActionHandler("pause", () => playStop());

				_mediaSession.setActionHandler("seekbackward", () => { xAudio.currentTime -= 15 });
				_mediaSession.setActionHandler("seekforward", () => { xAudio.currentTime += 15 });
			}

			function playStop() {
				//readyState = 4: video is playing
				if (xAudio.paused) {
					xAudio.play();
				}
				else {
					xAudio.pause();
				}
			}

			//isNext = 1: playing next, 0 or missing: playing previous
			function playNextPrev(isNext) {
				let currentStt = parseInt(elmPlaylist.getAttribute("attr-Value"));
				if (isNaN(currentStt)) currentStt = 1;
				let chapLength = parseInt(elmPlaylist.getAttribute("attr-Length"));
				if (isNaN(chapLength)) chapLength = elmPlaylist.querySelectorAll("li").length;

				if (isNext) {
					if (currentStt < chapLength) {
						changeChap(currentStt + 1); //if not the very last chapter, play the next one

					} else toast.showToast("Đã là chương cuối rồi!", toast.ToastType.Warning);
				}
				else {
					// if audio current time before 30 sec, will play previous chapter
					if (currentStt > 1 && xAudio.currentTime < 30) {
						changeChap(currentStt - 1);
					}
					// if audio current time after 30 sec, seek to the beginning of current chapter
					else xAudio.currentTime = 0;
				}
			}

			reloadBtn.addEventListener('click', reloadSrc, false);
			function reloadSrc(_forcePause) {
				if (!navigator.onLine) {
					toast.showToast("Không có kết nối Internet", toast.ToastType.Error);
					return;
				}
				let _currTime = xAudio.currentTime;
				if (!_currTime) _currTime = 0;
				xAudio.load();
				xAudio.currentTime = _currTime;

				if (_forcePause) xAudio.pause();
			}

			/** Display Play/Pause/Loading icons and enable/disable for play-pause button depending on playing state of audio element. The fastforward, rewind button got enable/disable accordingly 
				@param _playIconType: 
					-1: show spinning loading icon, and the same time, disable all 3 buttons
					 0 - show Pause icon on play-pause button
					 1 - show Play icon on play-pause button
				@param _disableButton: enable/disable 3 buttons
					-1: do nothing
					 0: disable
					 1: enable
			
			*/
			let switchPlayPauseButton = (_playIconType, _disableButton) => {

				//change link to svg icon for PlayPause buttons
				document.querySelectorAll("[svg-icon-name='PlayPauseIcon']").forEach(_elm => {
					_elm.setAttribute("href", _playIconType === -1 ? "#icnSvgSpinWaiting" : ((_playIconType === 1 ? "#icnSvgPlay" : "#icnSvgPause") + (xState.disableCircleProgressButton ? "" : "Progress")));
				});

				if (_disableButton === undefined) _disableButton = -1;
				if (_playIconType === -1) _disableButton = 0;
				//change state for PlayPause buttons
				if (_disableButton !== -1) {
					document.querySelectorAll("button:has(svg > use[svg-icon-name='PlayPauseIcon'])").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});

					// blinking #elmPlayingTime when audio is paused
					elmPlayingTime.classList.toggle("paused", _playIconType === 1);

					//change state for Rewind buttons
					document.querySelectorAll("button.ap-rewind-btn").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});

					//change state for Fastforward buttons
					document.querySelectorAll("button.ap-fastforward-btn").forEach(_elm => {
						_elm.classList.toggle("elm-disabled", _disableButton === 0);
					});
				};
			}

			/** Switch appearance of Playing time 
			@param _state {integer}: how playing time would be show up
				-1: internet connection lost, showing "No internet" on playingTime Elem
				 0: show spinning clock to tell user that chapter is loading
				 1: show current time / duration telling that audio is playing
			*/
			function switchBigPlayingTime(_state) {
				//playing time
				elmPlayingTime.classList.toggle("elm-hidden", _state == 0);
				//spinning glass hour
				document.querySelector("div[name='HourglassSpining']").classList.toggle("elm-hidden", _state !== 0);
				if (_state === -1) elmPlayingTime.innerHTML = "No Internet";
				//audio progress-bar 
				document.querySelector(".ap-progress").classList.toggle("ap-progress-bar--loading", _state == 0)
			}
			/* ========== AUDIO SPEED LIST ========== */

			/* Create Speed combobox with default options */
			let elmSltSpeed = document.querySelector(".ap-speed-option-select");
			document.querySelector(".ap-speed-decrease-speed").addEventListener('click', () => insertSpeed('-.05'), false);
			document.querySelector(".ap-speed-increase-speed").addEventListener('click', () => insertSpeed('.05'), false);

			(function populateSpeedList() {
				let _defSpd = [0.5, 0.75, 1.0, 1.1, 1.2, 1.25, 1.3, 1.35, 1.4, 1.45, 1.5, 1.75, 2, 2.95]; //store old options of combobox
				elmSltSpeed.innerHTML = "";// .options.length = 0; //clear the combobox

				// if there is xState.speeds, using it as initial speed list
				if(xState.speeds && Array.isArray(xState.speeds)) _defSpd = xState.speeds;

				for (let i = 0; i < _defSpd.length; i++) {
					let opt = document.createElement('option');
					opt.value = _defSpd[i];
					//If integer, need to add .0
					opt.innerHTML = Number.isInteger(_defSpd[i]) ? _defSpd[i] + ".0x" : _defSpd[i] + "x";
					if (_defSpd[i] == 1) {
						//opt.innerHTML = "1.0x"; //"Normal";
						opt.style["background-color"] = "#e5e161";
					}
					elmSltSpeed.appendChild(opt);
				}

				//handling onChange event
				elmSltSpeed.onchange = _ => {
					toast.showToast("Speed: ✕" + elmSltSpeed.value, null, {persistance: true});
					//change audio playbackRate accordingly, save new speed to Storage
					xState.speed = xAudio.playbackRate = parseFloat(elmSltSpeed.value);
					//localStorage.setItem('speed', xAudio.playbackRate); 

					//resize elmSltSpeed width with the content of selected item
					let _sel = document.createElement('select');
					_sel.css({ "font-size": elmSltSpeed.css("font-size") }); //copy font-size from elmSltSpeed to _sel
					let _spd = elmSltSpeed.value;
					if (Number.isInteger(parseFloat(_spd))) _spd = _spd + ".0";
					_sel.innerHTML = "<option>" + _spd + "</option>";
					document.body.appendChild(_sel);
					elmSltSpeed.style.width = (_sel.offsetWidth - 12) + "px";
					_sel.remove();

					//update the actual current chapter listenning time and total book listenning time with the change of playback speed
					document.querySelectorAll("[attr-duration]").forEach(elm => {
						let _duraion = elm.getAttribute("attr-duration");
						if (!_duraion) return;
						//.querySelector("[role='listeningTime']")
						elm.innerText = toHhMmSs(_duraion / xAudio.playbackRate);
					});
				}
			})();

			/** Insert Speed option to combobox and set audio player playbackrate to the inserted speed
			@param speed: 
					@value is string: should be in the form of '±0.1', '±0.05'
					@value is number: the new speed					
			*/
			function insertSpeed(speed) {
				let newSpeed = 1;
				if (typeof (speed) == "number") newSpeed = speed;
				if (typeof (speed) == "string") {
					speed = Number(speed);
					if(isNaN(speed)) speed = 0.05;
					newSpeed = Math.round( (parseFloat(elmSltSpeed.value) + speed) * 100 ) / 100;
					//minimum speed is .05
					newSpeed = Math.max(newSpeed, .05);
				}

				//Check if new speed was already there in the speed listbox
				if (elmSltSpeed.querySelector('[value="' + newSpeed + '"]')) {
					xAudio.playbackRate = elmSltSpeed.value = newSpeed; //select the new speed
					elmSltSpeed.onchange(); //onchange event is not automatically raised, so we need to call manually
					return;
				}

				// search right location to add newSpeed
				let i = 0;
				while (i < elmSltSpeed.options.length && parseFloat(elmSltSpeed.options[i].value) < newSpeed) {
					i++;
				}
				//add new speed before location just found
				elmSltSpeed.add(new Option(Number.isInteger(parseFloat(newSpeed)) ? newSpeed + ".0x" : newSpeed + "x", newSpeed), i); //text, value

				//save all speeds into xState
				xState.speeds = [...elmSltSpeed.options].map(_opt => _opt.value);

				//update newSpeed to audio and current option of speed list
				xAudio.playbackRate = elmSltSpeed.value = newSpeed;

				elmSltSpeed.onchange(); //onchange event is not automatically raised, so we need to call manually
			}

			/* This function is invoked on onratechange event of audio element, and onchange event of speed dropdown element*/
			function changeAudioSpeed() {
				if (xAudio.playbackRate != xState.speed) {
					xAudio.playbackRate = xState.speed; //parseFloat(elmSltSpeed.value)
				}
			}

			// Restore speed from last time running page, and insert it if it is not in defaul playbackRate list
			insertSpeed(settingParam.speed); //this also make speed s in elmPlaybackSpeed to be selected and the same time change xAudio playbackRate to s. So, we need no further action for speed			

			/* ========== BUFFER BAR & TIME DISPLAY ========== */
			if (xState.hideBufferBar) bufferBarCanvas.classList.add("elm-hidden");
			clearBufferBar(); //initialize the UI of buffer bar
			function clearBufferBar() {
				//if(xState.hideBufferBar) return;

				//if it is hidden when listening last chapter, then it is already cleaned
				if (bufferBarCanvas.classList.contains("elm-hidden")) {
					return;
				}
				else bufferBarCanvas.classList.add("elm-hidden"); //hide it, will show it again when user seek the audio

				let context = bufferBarCanvas.getContext('2d');

				context.clearRect(0, 0, bufferBarCanvas.width, bufferBarCanvas.height);
				context.fillStyle = '#bdbdbd'; //'lightgray';
				context.fillRect(0, 0, bufferBarCanvas.width, bufferBarCanvas.height);
			}

			function updateBufferCanvas() {
				//if user don't want to show buffer bar, do nothing
				if (xState.hideBufferBar) return;

				//show buffer bar if it is hidden
				if (bufferBarCanvas.classList.contains("elm-hidden"))
					bufferBarCanvas.classList.remove("elm-hidden");

				let context = bufferBarCanvas.getContext('2d');
				let inc = bufferBarCanvas.width / _xDuration;

				// if fillStyle not the one that assigned in clearBufferBar, it means the buffer bar has not been clean for the new one, so we need to redraw blank buffer bar
				if (context.fillStyle !== '#bdbdbd') {
					context.clearRect(0, 0, bufferBarCanvas.width, bufferBarCanvas.height);
					context.fillStyle = '#bdbdbd'; //'lightgray';
					context.fillRect(0, 0, bufferBarCanvas.width, bufferBarCanvas.height);
				}

				context.fillStyle = '#0062ff'; //cadetblue	darkgoldenrod crimson #f50
				context.strokeStyle = '#bdbdbd'; //white

				//clearBufferBar();

				// display TimeRanges
				for (let i = 0; i < xAudio.buffered.length; i++) {
					let startX = xAudio.buffered.start(i) * inc;
					let endX = xAudio.buffered.end(i) * inc;

					context.fillRect(startX, 0, endX, bufferBarCanvas.height);
					context.rect(startX, 0, endX, bufferBarCanvas.height);
					context.stroke();
				}
			}

			/* ========== PROGRESS BAR & TIME DISPLAY ========== */
			let progressWrapper = progressBar.parentNode.parentNode;
			progressWrapper.addEventListener('mousedown', progressbarMD, false);
			progressWrapper.addEventListener('mousemove', progressbarMM, false);
			document.documentElement.addEventListener('mouseup', seekingDone, false); //it must be documentElement to handle MouseUp because when user move the mouse, the mouse might go outside of progressWrapper.
			//progressWrapper.addEventListener('mouseup', seekingDone, false);

			function moveBar(evt, el, dir) {
				let value;
				if (dir === 'horizontal') {
					value = Math.round(((evt.clientX - el.offset().left) + window.pageXOffset) * 100 / el.parentNode.offsetWidth);
					el.style.width = value + '%';
					return value;
				}
				else {
					let offset = (el.offset().top + el.offsetHeight) - window.pageYOffset;
					value = Math.round((offset - evt.clientY));
					if (value > 100) value = 100;
					if (value < 0) value = 0;
					volumeBar.style.height = value + '%';
					return value;
				}
			}

			function progressbarMD(evt) {
				//console.log("Mouse down");
				rightClick = (evt.button === 2) ? true : false; //evt.which === 3, evt.which was deprecated
				isPlaying = !xAudio.paused; //flag to know if audio is playing
				if (isPlaying) xAudio.pause(); //if audio is playing, pause it so lots of temporary audio buffering, seeking,... is NOT invoked while seeking, that make the seeking perfectly smooth

				isSeeking = true;
				evt.preventDefault();
				progressbarMM(evt);
			}

			function progressbarMM(evt) {
				// console.log("Mouse move");
				if (isSeeking && rightClick === false && xAudio.readyState !== 0) {
					let value = moveBar(evt, progressBar, 'horizontal');
					xAudio.currentTime = _xDuration * (value / 100);
				}
			}

			function seekingDone(evt) {
				//console.log("Mouse up");
				//if mouse up on progress-bar, not the volume bar
				if (evt.target.closest(".ap-progress-container")) {
					toast.showToast(`Audio is seeking to ${toHhMmSs(xAudio.currentTime)}`);

					if (isPlaying && isSeeking) xAudio.play(); //audio, which was on playing, was paused for smooth seeking, now have to turn it back to playing
				}
				isSeeking = false; //turf off flag to mark the (progress and volume) seeking has finished
			}

			/* TOUCH EVENT */
			progressWrapper.addEventListener('touchstart', progressbarTS, false);
			progressWrapper.addEventListener('touchmove', progressbarTM, false);
			//document.documentElement
			progressWrapper.addEventListener('touchend', seekingDone, false);
			progressWrapper.addEventListener('touchcancel', seekingDone, false);

			let _progressbarLeft; //progress bar left value relative to the browser's viewport

			function progressbarTS(e) {
				//there are bunch of way to calculate this, depend on if there is scrollbar or not. Simply the most, I use this formula, hope it works.
				_progressbarLeft = progressBar.getBoundingClientRect().left; //progressBar.offset().left
				isPlaying = !xAudio.paused; //flag to know if audio is playing
				if (isPlaying) xAudio.pause(); //if audio is playing, pause it so lots of temporary audio buffering, seeking,... is NOT invoked while seeking, that make the seeking perfectly smooth
				isSeeking = true; //turn on flag showing that starting touch & move
				progressbarTM(e);
			}

			function touchMoveBar(e, el, dir) {
				let value;
				if (dir === 'horizontal') {
					value = Math.round((e.changedTouches[0].clientX - _progressbarLeft) * 100 / el.parentNode.offsetWidth);

					// console.log(`${_progressbarLeft} - ${el.parentNode.offsetWidth}`);
					// console.log(`touch-move: clientX=${touch.clientX} ~ ${value}`);

					//in case move over the progress bar
					if (value > 100) value = 100;
					if (value < 0) value = 0;
					el.style.width = value + '%';
				}
				else {
					/* Currently, I don't want to implement for vertical volume bar
					const diffY = touch.clientY - startY;
					value = Math.round( (el.offsetTop + diffY) * 100 / el.parentNode.offsetHeight  );
					if(value > 100) value = 100;
					if(value < 0) value = 0;
					volumeBar.style.height = value + '%'; */
				}

				e.preventDefault();
				return value;
			}

			function progressbarTM(evt) {
				if (isSeeking && xAudio.readyState !== 0) {
					let value = touchMoveBar(evt, progressBar, 'horizontal');
					xAudio.currentTime = _xDuration * (value / 100);
				}
			}

			let elmRoot = document.querySelector('[name="divContainer"]'); // root element to update circle progress around Pause button, see updateTime() function
			//let svgCircleElems = document.querySelectorAll("#svgProgressCircle");
			/* Draw the Circle ProgressBar surround the play and pause buttons. There are two ways to archive this, old way (seems very costly) is usage of --audio-playing-current-progress-percent variable in root element. 
			2nd way, using js to change directly to svg "stroke-dashoffset" attribute. However, this way make play/pause button sometime irreresponsive
			  currPercent {float from 0 to 1}: the current percentage of playing
			 */
			function updateCircleProgressBar(currPercent) {
				let _prgress = 383; //default value, which make progress go to 0%
				if (isFinite(currPercent)) //currPercent is not infinity or NaN
					_prgress = parseInt((1 - currPercent) * 383); //383 is value of stroke-dasharray which is circumstance of a circle having radius of 61. See svg symbol having id="icnSvgPlayProgress"

				//svgCircleElems.forEach(_cir => _cir.setAttribute("stroke-dashoffset", _prgress + 'px'));
				elmRoot.style.setProperty('--audio-playing-current-progress-percent', _prgress + 'px');
			}
			
			//an intenal variable that is used to lighten the heavy-burden of updateTime() function below. It helps to just update UI after some specific interval of time, not in every audio 'timeupdate' event firing
			let _lastAudioPosition = 0;
			/* The interval that the page do the update for some source-consuming UI update such as circle-progress-bar, audio progress bar, percentage of listened duration. 0.01 mean 1% of total audio duration */
			const _HEAVY_UPDATE_INTERVAL = 0.01;
			// the updateBufferCanvas counter, which count the times heavy-load UI repaint in updateTime() such as paint progressBar, Circle Progress Bar, preload bar,... The updateBufferCanvas (which uses canvas to show the detailed picture of audio buffer) is called after _ubcCounter reach to a specific number (e.g 10), because updateBufferCanvas() is way more heavy than the other UI repaint
			let _ubcCounter = 0;
			/** This function is called on audio timeUpdate event which happens 4 times a seconds. This function is in charge of updating UI for the audio 
			 * @param forceHeavyUIUpdate {boolean}: value true will make heavy UI update right away without waiting after a specific of time (usually 1% of audio duration, depending on value of @_HEAVY_UPDATE_INTERVAL ). For now, the value true is only invoked from audio onseeked event. Note that when updateTime is invoked from event such as timeUpdate, forceHeavyUIUpdate is an event object (not a boolean value)
			*/
			function updateTime(forceHeavyUIUpdate = false) {
				// this is to prevent override "No Internet" message when connection lost
				if (xAudio.readyState < HTMLMediaElement.HAVE_FUTURE_DATA) return; //there is no data for next frame (google 'audio readyState mdn' for more)

				//saveLastPosition(); //this works very well but might put too much burden on computer
				if (document.hidden) return; //if page is currently not on user's view, stop all UI update

				let _currTime = xAudio.currentTime; //, _xDuration = xAudio.duration;
				
				//changing some time-text, it's quite light, so just update the text every audio 'timeupdate' event firing
				let _remTime = _xDuration - _currTime;
				remTime.innerHTML = toHhMmSs(_remTime) + " / " + toHhMmSs(_remTime / xAudio.playbackRate); //remaining time

				elmPlayingTime.innerText = toHhMmSs(_currTime) + " / " + toHhMmSs(_xDuration); //big font playing time

				//check the interval from last time update resource-consuming UI to see if it over some specific percentage of total audio duration OR almost reach the end of audio. Note that for some UI, especially when dealing with 'width' css attribute, even we update UI in finer interval, the appearance of UI can't display it. For example, user can only see the change in progressBar barlength when the 'width' of progressbar changes by 1% of the whole length. Note that below, condition '_duration > 0' also includes '!isNaN(_duration)'				
				if( (_xDuration > 0) && (forceHeavyUIUpdate === true || Math.abs(_currTime - _lastAudioPosition) > _xDuration * _HEAVY_UPDATE_INTERVAL || _currTime > _xDuration - 5 ) ){
					//console.log(_lastAudioPosition + "\t" + _currTime);
					
					_lastAudioPosition = _currTime; //update new current time
				
					// 1. Update the audio progress-bar
					let barlength = Math.round(_currTime * (100 / _xDuration));
					progressBar.style.width = barlength + '%';

					// 2. Update preload progress bar
					let buffered = xAudio.buffered;
					if (buffered.length) {
						/* let loaded = Math.round(100 * buffered.end(0) / _duration);
						preloadBar.style.width = loaded + '%'; //buffer bar */
						for (let i = 0; i < buffered.length; i++) {
							if (buffered.start(buffered.length - 1 - i) < _currTime) {
								preloadBar.style.width = `${(buffered.end(buffered.length - 1 - i) * 100) / _xDuration}%`;
								break;
							}
						}
					}

					//TODO: can move this to outside in the form of a callback
					// 3. Update circle progress bar attached on Play/Pause button
					if (!xState.disableCircleProgressButton) { //will not update circle progress for lighter burden on the page performance
						updateCircleProgressBar(_currTime / _xDuration);
					}

					// 4. Update the percentage of listened chapters (include elapsed time of current chapter), so far
					//const percentageListened = document.querySelector("#percentageListened");
					//use id (#percentageListened) to refer to element
					let lPP = parseFloat(percentageListened.dataset.listenedPercent), 
					lPD = parseInt(percentageListened.dataset.listenedDuration) + _currTime,
					_bookDur = parseInt(percentageListened.dataset.bookDur);
					//update the elapsed time in the tooltip
					percentageListened.dataset.tooltip = percentageListened.dataset.tooltip.replace(/\[([\d\:]+)\]/, `[${ toHhMmSs(lPD)}]`);
					//there is a change in percentage
					const _newLPP = (100 * lPD/_bookDur).toFixed(1); //note that this is a string, not a number
					if( _newLPP != lPP ){//note that _newLPP is a string, lPP is number
						//save the new listenedPercent
						percentageListened.dataset.listenedPercent = _newLPP;
						//change the listened Percent text and progress UI
						percentageListened.innerText = `${_newLPP}%`;
						percentageListened.style.backgroundSize = `${_newLPP}% 100%`;
					}

					// 5. Update buffer canvas every 10 times update the preload-bar. With _HEAVY_UPDATE_INTERVAL=0.01 (1%), this update only run every 10% of audio duration, meanning this update only 10 times for each chapter
					if(forceHeavyUIUpdate === true || ++_ubcCounter == 10){
						updateBufferCanvas();
						_ubcCounter = 0; //reset counter
					}
				}
			}

			/* ==========  VOLUME BUTTON & BAR  ========== */
			volumeBtn.addEventListener('click', volumeToggle, false);
			let volumeWrapper = volumeBar.parentNode.parentNode;
			volumeWrapper.addEventListener('mousedown', volumebarMD, false);
			volumeWrapper.addEventListener('mousemove', volumebarMM);
			document.documentElement.addEventListener('mouseup', seekingDone, false);
			//volumeWrapper.addEventListener('mouseup', seekingDone, false);

			function changeAudioVolume(_volume){
				_volume = parseFloat( _volume.toFixed(2) );
				let _vol = Math.max( Math.min(_volume, 1), 0); //volume should be from 0 to 1
				
				//volume already 0 or 1, cannot decrease/increase anymore
				if((xAudio.volume ===0 && _volume < 0) || (xAudio.volume ===1 && _volume > 1)) return;

				//update the new volume to xAudio and save to xState
				xState.volume = xAudio.volume = _vol;
				//change the height of volume-bar accordingly
				volumeBar.style.height = _vol * 100 + '%';

				toast.showToast('Volume ' + (_vol * 100).toFixed() + '%');

				//toggle volume if when reach 0 or just got out of 0
				if( (_vol === 0 && !xAudio.muted) || (_vol > 0 && xAudio.muted)) volumeToggle.call(volumeBtn);
			}

			/* Get back VOLUME and MUTED state of the last session */
			//volumeBar.style.height = xAudio.volume * 100 + '%';
			changeAudioVolume(settingParam?.volume ?? 1); //use volume of last sesson
			
			//note that changeAudioVolume() above might set muted=false if volume>0, so to make sure if that is the volume-setting of last session, we need to force muted state to last session value
			xAudio.muted = !settingParam.muted; //get the inversed muted state from last session, so the next volumeToggle() call will get it back and by the same time, update the volume button UI
			volumeToggle.call(volumeBtn); //update UI

			//volumeLength = volumeBar.css('height');
			function volumeToggle() {
				if (xAudio.muted) {
					// if last time volume=0, when turn on make it 1
					if (xAudio.volume === 0) { //parseInt(volumeLength, 10) === 0
						/* volumeBar.style.height = '100%';
						xAudio.volume = 1; */
						changeAudioVolume(1);
					}
					else {
						//otherwise, use old volume
						volumeBar.style.height = xAudio.volume * 100 + '%'; //volumeLength;
					}
					xAudio.muted = false;
					this.classList.remove('muted');
				}
				else {
					xAudio.muted = true;
					volumeBar.style.height = 0;
					this.classList.add('muted');
				}
				//save muted state into xState
				xState.muted = xAudio.muted;
			}

			function volumebarMD(evt) {
				rightClick = (evt.button === 2) ? true : false; //evt.which === 3, evt.which was deprecated
				isSeeking = true;
				volumebarMM(evt);
			}

			function volumebarMM(evt) {
				let volumeLength = volumeBar.css('height');
				if (isSeeking && rightClick === false) {
					let value = moveBar(evt, volumeBar.parentNode, 'vertical') / 100;
					if (value <= 0) {
						//xAudio.volume = 0;
						changeAudioVolume(0);
						volumeBtn.classList.add('muted');
					}
					else {
						if (xAudio.muted) xAudio.muted = false;
						//xAudio.volume = value;
						changeAudioVolume(value);
						volumeBtn.classList.remove('muted');
					}
				}
			}

			/*===== *  Helpers *=====*/
			function extend(defaults, options) {
				for (let name in options) {
					if (defaults.hasOwnProperty(name)) {
						defaults[name] = options[name];
					}
				}
				return defaults;
			}

			Element.prototype.offset = function () {
				let el = this.getBoundingClientRect(),
					scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
					scrollTop = window.pageYOffset || document.documentElement.scrollTop;

				return {
					top: el.top + scrollTop,
					left: el.left + scrollLeft
				};
			};

			/* ==========  PUBLIC METHODS  ========== */
			return {
				//playAudio: tryingLoadAudio,
				updateTime: updateTime, // for update UI when the page got focus again
				loadSrc: loadSrc
			};
		}
	</script>

	<!-- SEARCH DROPDOWN JS -->
	<script>
		"use strict";
		/** Class to create search-drop-down (SDD) element 
		 * @params
		 *    @sddContainerQry: string store query selector to container that contains the new created sdd
		 *    @_setting = { 
		 * 			@displayOneLine: true,  // the sdd display on one line, text maybe truncated
		 * 			@maxHeight: max Height of dropdown content, in px
		 *          @options: array of option data definition
		 *          @optgroups:  array of option group definition or Null if no group
		 *          @render: {
		 *             option: function to render the option html
		 *             optgroup_header: function to render the option group header html
		 *          },
		 *          @callbacks: {
		 *             onChange: callback function that is invoked when selected item changed
		 *          }
		 * 		See the loadDropdown function for more attributes of _setting
		 * 		Item of option attribute look like: 
		 * 			{
						@gId: "$11", //group id, must match the id of optgroups. If this is missing, the dropdown would not have group
						@value: "DBR.PDS1",	//value for the option
						@label: "[1998] Pháo đài số", //option label
						@disabled: if true, this group header and all its children options will be disbaled. User can see those options, can go through them but cannot select them
						@{someextra_attributes}: //some user-specified extra properties can be used to render the option or for searching/filtering
						@attr: { "attr-book-array": "[72]" } //collection of attribute names and value that will be added to the option for manupulating later
					}
				Item of optgroups attribute look like: 
					{
						@gId: "$6",	//id for the option to group into. Also used as value of optgroup
						@label: "The Lord of the Rings", //label of optgroup, which is used to render the optgroup header
						@disabled: if true, this option will be disbaled. User can see this option, can go through it but cannot select it
						@{someextra_attributes}: //some user-specified extra properties can be used to render the optgroup header
						@attr: { "attr-gid": "$6" } //collection of attribute names and value that will be added to the optgroup for manupulating later
					}
		 * @PUBLIC PROPERTIES
		 *    @value {string get/set}: the value of selected item. When set, it will not invoke callback function. User can call sdd.onchange() to invoke the callback.
		 *    @selectedIndex {number get/set}: the selectedIndex of selected item. When set, it will not invoke callback function. User can call sdd.onchange() to invoke the callback.
		 *    @items {arrray of HTMLElement get}: list of all items
		 *    @length {number get}: number of items
		 *    @settings {json get}: the setting to create this SDD but {options} and {optgroups} has been removed
		 *    @rootElement {HTMLElement get}: the root HTML Element that wrap all sdd
		 *	  @displayElement {HTMLElement get}: the div element that left off to display the selected item when sdd closed
		 *	  @hotKeys: list of hotkeys information that supported by SDD, in the form {task: task_id, kCode: evt.code of the pressed key, desc: task description}. Note that some keys in this list comprising with modifier-key set in setting.makeSelectKey can do another task
		 * 
		 * @PUBLIC FUNCTIONS
		 *    @loadDropdown(_settingParam, selectInit): load data for the Dropdown, where _settingParam is user-defined setting, which later be added with default setting. selectInit is the index(number)/value(string) of initialized seleted item.
		 *    @onchange(): function to invoke onChange(seletedItem) callback. This can be called after assign value/selectedIndex to make a new selectedItem to update the change
		 *    @selectItem: see selectItem for details
		 *    @sddUnregisterEvents: remove all event listener that added by this class
		 * 	  @toggle: function to toggle (open/close) the dropdown
		 * 
		 * @USAGE: 
		 *  Way 1, load sdd as create it: 
		 *     const sddDropdown = new SddDropdown(".sdd-container", _setting);
		 *  Way 2: create then load both setting and data at the same time. This way, _setting must contain attribute both for setting and data. See BookData.popuGrpBookTitles and BookData.popuBookTitles for example of this way
		 *     const sddDropdown = new SddDropdown(".sdd-container");
		 * 	Then
		 * 		sddDropdown.loadDropdown(_setting
		 * 	  Or
		 *		sddDropdown.loadDropdown(_setting, ssData.sddChaptersList.LOAD_MODE_ENUM.All, 5);
		 * Way 3: load the setting and then load the data, separatedly. See changBook() for the example using this
		 * 		const sddDropdown = new SddDropdown(".sdd-container");
		 * 		sddDropdown.loadDropdown(_setting, ssData.sddChaptersList.LOAD_MODE_ENUM.SettingLoadOnly); //this _setting does not have to has data options, optgroups
		 *  	sddDropdown.loadDropdown({options:..., optgroups: ...}, ssData.sddChaptersList.LOAD_MODE_ENUM.DataLoadOnly);
		*/
		function SddDropdown(sddContainerQry, _settingParam) {
  			let _uid = "id" + Math.random().toString(16).substr(2, 8); //class id for internally used
			if(!new.target) return console.error("SddDropdown class must be constructed with 'new' keyword");

			//private variables
			let _settings = null; //setting object for whole sdd class
			let _selectedItem, _activeOption, _items, _filteredItems;
			let _sddWrapper; //the root HTML element of whole sdd
			let _onChange  = null, _notifyFunction = console.warn; //store the onChange callback function which will be invoked when selected Item changes
			let sHighlite = null; //object that handle search and highlight function of the SDD
			let _hotKeysList; //array of shortcut keys supported by this SDD
			let _dropdownOpenFirstTime = true; //to identify first time open dropdown, so we can do something related to element dimension which only rendered when their wrapper appear
	
			//wrap create core HTML into a function for nice code, only
			function makeSddCoreHtml(){
				const _CLEAR_SEARCH_BOX_SVG = `<svg viewBox="0 2 16 12" xmlns="http://www.w3.org/2000/svg"><path d="M6 2 0 8l6 6h10V2zm2 2 2 2 2-2 2 2-2 2 2 2-2 2-2-2-2 2-2-2 2-2-2-2z"/></svg>`; //clear search icon
				const _CLOSE_GROUP_SVG = `<svg viewBox="1 1 13 14" xmlns="http://www.w3.org/2000/svg"><path d="M1.5 1h2v1H2v12h1.5v1h-2l-.5-.5v-13zm6 6h-2L5 6.5v-2l.5-.5h2l.5.5v2zM6 6h1V5H6zm7.5 1h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 6h2V4h-2zm-3.5 6h-2l-.5-.5v-2l.5-.5h2l.5.5v2zM6 11h1v-1H6zm7.5 2h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 12h2v-2h-2zm-1-2H8v1h2zm0-5H8v1h2z"/></svg>`;
				//`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 20h1v1H1v-2h1zm20 0h-1v1h2v-2h-1zM1 5h1V4h1V3H1zm1 2H1v2h1zm0 4H1v2h1zm20-2h1V7h-1zm0 4h1v-2h-1zM2 15H1v2h1zm20 2h1v-2h-1zM5 4h2V3H5zm6 0V3H9v1zm2 0h2V3h-2zm6-1h-2v1h2zM5 21h2v-1H5zm4 0h2v-1H9zm4 0h2v-1h-2zm4 0h2v-1h-2zm4-17h1v1h1V3h-2zm-1 4v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1m-.999 2H19V8H5v2h14m1 4v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1m-.999 2H19v-2H5v2h14"/><path fill="none" d="M0 0h24v24H0z"/></svg>`;
				const _JUMP_TO_SELECTED = `<svg viewBox="2 2 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="4"/><path d="M12 8v8m0 0 4-4m-4 4-4-4" stroke-linecap="round" stroke-linejoin="round"/></g></svg>`;
				const _DIACRATICS_OPTION = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.98 16"><path d="M4 0h2v2h4v2H8.868a8.5 8.5 0 0 1-2.202 4.351c.8.388 1.691.617 2.633.646L10.274 6h2.453l3.25 10h-2.104l-.65-2H9.776l-.65 2H7.024l1.638-5.04A8.45 8.45 0 0 1 5 9.711 8.46 8.46 0 0 1 .5 11H0V9h.5a6.5 6.5 0 0 0 2.834-.649A8.5 8.5 0 0 1 1.752 6h2.27c.278.435.607.834.978 1.19A6.5 6.5 0 0 0 6.826 4H0V2h4zm8.574 12L11.5 8.697 10.427 12z"/></svg>`; //fill-rule="evenodd" clip-rule="evenodd"
				const _EXTRA_TITLE_SHOWHIDE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.586 18 12 21.414 15.414 18H19c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2H5c-1.103 0-2 .897-2 2v12c0 1.103.897 2 2 2zM5 4h14v12h-4.414L12 18.586 9.414 16H5z"/><path d="m12.479 7.219-4.977 4.969v1.799h1.8l4.975-4.969zm2.219-2.22 1.8 1.8-1.37 1.37-1.8-1.799z"/></svg>`; 

				/* CREATE STRUCTURE FOR SDD */
				const _sddWrapper = document.createElement("div");
				_sddWrapper.classList.add("sdd-wrapper");
				_sddWrapper.innerHTML = `<div class="sdd-controls"></div>
				<div class="sdd-dropdown-wrapper elm-hidden" role="listbox">
					<div class="input-wrapper">
						<input placeholder="🔍 Search..." type="text" class="sdd-search-box" pattern=".*\\S.*" title="" required>
						<div class="sdd-control-buttons">
							<button class="clear-input-button" data-tooltip="Xóa ô tìm kiếm" data-tooltip-location="bottom" style="--data-translateX: -55%;">${_CLEAR_SEARCH_BOX_SVG}</button>
							<button class="search-diacritics-option-button" data-tooltip="Tìm kiếm bỏ dấu (chữ nét, nền vàng) hay tìm kiếm nguyên dấu (chữ nhòe)" data-tooltip-location="bottom" style="--data-translateX: -82%;">${_DIACRATICS_OPTION}</button>
							<button class="jump-to-selected-item-button" data-tooltip="Cuộn tới mục đang được chọn" data-tooltip-location="bottom" style="--data-translateX: -89%;">${_JUMP_TO_SELECTED}</button>
							<button class="close-open-extra-title-button" data-tooltip="Ẩn/Hiện tiêu đề phụ" data-tooltip-location="bottom" style="--data-translateX: -85%;">${_EXTRA_TITLE_SHOWHIDE}</button>
							<button class="close-open-groups-button" data-tooltip="Đóng/Mở nhóm mục" data-tooltip-location="bottom" style="--data-translateX: -91%;">${_CLOSE_GROUP_SVG}</button>
						</div>
					</div>
					<div class="sdd-dropdown-content circus-background"></div>
					<div class="sdd-dropdown-border-bottom sdd-dropdown-border-bottom-stripes"></div>
				</div>`;
		
				const sddContainer = document.querySelector(sddContainerQry); //the container
				/* Using insertBefore(), insertAdjacentElement() and Element.insertAdjacentHTML(), there can be multiple option for user to add SDD to DOM. But it is rarely used, so I don't implement it */
				sddContainer.appendChild(_sddWrapper); //add sdd to the DOM
				return _sddWrapper;
			}
			
			_sddWrapper = makeSddCoreHtml();
			// some element variables
			const representativeDiv = _sddWrapper.querySelector(".sdd-controls"); //part that display when sdd closed
			const sddDropdownWrapper = _sddWrapper.querySelector( ".sdd-dropdown-wrapper" ); //wrapper of all hidden part when sdd closed

			const sddInputWrapper = sddDropdownWrapper.querySelector(".input-wrapper"); //wrapper of search textbox and few buttons
			const sddSearchBox = _sddWrapper.querySelector(".sdd-search-box"); //the search box

			const sddDropdownContent = _sddWrapper.querySelector( ".sdd-dropdown-content" ); //the container of all sdd options
			let sddDropdownStatusBar;
			
			const isTouchDevice = (function () {
				return (
					"ontouchstart" in window ||
					navigator.maxTouchPoints > 0 ||
					navigator.msMaxTouchPoints > 0
				);
			})();
			
			/* PUBLIC PROPERTIES */
			Object.defineProperty(this, "value", {
				get() {
					return _selectedItem.value;
				},
				set(value) {
					if(_selectedItem?.value == value) return; //no new item to select
					selectItem(value.toString(), true); //no fire onChange event
				}
			});
	
			Object.defineProperty(this, "selectedIndex", {
				get() {
					return _items.indexOf(_selectedItem);
				},
				set(index) {
					index = parseInt(index);
					if (isNaN(index)) {
						return console.warn("SDD selectedIndex set: index is not a number");
					}
					if(_selectedItem == _items[index]) return; //no new item to select
					selectItem(index, true); //no fire onChange event
				}
			});

			Object.defineProperty(this, "selectedItem", {
				get() {
					return _selectedItem;
				},
				set(item) {
					if (_items.indexOf(item) > -1 && item != _selectedItem) {
						selectItem(item, true); //no fire onChange event
					}
					
				}
			});
	
			/* get all items of SDD, each item is an option which internally is asss div.sdd-dropdown-item */
			Object.defineProperty(this, "items", {
				get() {
					return _items;
				},
				set(val) {
					console.warn("sdd.items property is not changable");
					return null;
				}
			});
	
			Object.defineProperty(this, "length", {
				get() {
					return _items.length;
				},
				set(val) {
					console.warn("sdd.length property is not changable");
					return null;
				}
			});
	
			/* get the SDD setting config */
			Object.defineProperty(this, "settings", {
				get() {
					//return a deep copy of _setting, so that outside code cannot change the internal _settings
					return Object.assign({}, _settings);
				},
				set(val) {
					console.warn("sdd.setting property is not changable");
					return null;
				}
			});

			/* get/set the diacriticsFilter mode. true: filter diacritics before searching. false: no filter */
			Object.defineProperty(this, "diacriticsFilterMode", {
				get() {
					return _settings.diacriticsFilterMode;
				},
				set(val) {
					//this also changes sHighlite.diacriticsFilterMode and re-filter SDD items
					setDiacriticsFilterMode( Boolean(val) );
				}
			});
	
			/* get the wrapper element which wrap the whole SDD */
			Object.defineProperty(this, "rootElement", {
				get() {
					return _sddWrapper;
				},
				set(val) {
					console.warn("sdd.rootElement property is not changable");
					return null;
				}
			});
			
			/* get the element which is left when SDD closed */
			Object.defineProperty(this, "displayElement", {
				get() {
					return representativeDiv;
				}
			});
	
			/* get the SDD Load Mode enum */
			Object.defineProperty(this, "LOAD_MODE_ENUM", {
				get() {
					//return a deep copy of _setting, so that outside code cannot change the internal _settings
					return loadSDDMode;
				}
			});
			//list of hotkeys
			Object.defineProperty(this, "hotKeys", {
				get() {
					//sole purpose is to initialize _hotKeysList variable. This not the best way to implement the hot keys list. But to initialize _hotKeysList in one pieces (inside onKeyDown for the callback - which use internal variables - to work), but still provide global property (sdd.hotKeys) for class-outside scope
					if(!_hotKeysList) _hotKeysList = onKeyDown(); //run onKeyDown without {evt} parameter to get _hotKeysList if it is not existed, yet

					return _hotKeysList;
				}
			});
			
			/** Select adjacent item without firing onChange event
			 * @param _dir {1, -1}: 1 next item. -1: previous item
			 * @return null: if adjacent item is out of bound (index -1 or _items.length) or _selectedItem currently undefined
			 */
			const goAdjacent = _dir => {
				let _currIdx = _items.indexOf(_selectedItem);

				//_selectedItem currently undefined, return null
				if(_currIdx == -1) return null;
				_dir = _dir == 1? 1 : -1;
				_currIdx += _dir;

				//out of bound, return null
				if(_currIdx < 0 || _currIdx >= _items.length) return null;

				selectItem(_currIdx, true); //no fire onChange event
				return _items[_currIdx];
			}

			/** Escapes a string for use within HTML. **/
			const escape_html = (str) => {
				return (str + "")
					.replace(/&/g, "&amp;")
					.replace(/</g, "&lt;")
					.replace(/>/g, "&gt;")
					.replace(/"/g, "&quot;");
				};
			/** populate options and optGroup for Dropdown 
			 * @param initSelectedItem {string, number}: the default item to be the selected one when dropdown created. if string, it is value of selected item. If number, it is selected index
			*/
			function populateDropdown(initSelectedItem) {
				if(!_settings) return; // if there is no setting assign, do nothing

				sddDropdownContent.innerHTML = "";
	
				representativeDiv.classList.toggle( "single-line", !!_settings.displayOneLine );

				sddDropdownStatusBar = document.createElement("DIV");
				sddDropdownStatusBar.classList.add("sdd-dropdown-status-bar", "statusbar-hidden");
				sddDropdownStatusBar.innerText = "Statusbar";
				sddDropdownContent.appendChild(sddDropdownStatusBar);
	
				/** make item for dropdown 
				 * @param optionData {json}: the pure data to create option. The {_settings.render.option} function will make option HTML from pure data
				 * @param i {integer}: index of the option in {_settings.options}, mostly for the purpose of adding order number  (for now), which is in <em> element and being added to the first child of option
				 * @param grpDisabled {boolean}: if parent group is disabled, all its children option being disabled accordingly.
				*/
				const makeOptionItem = (optionData, i, grpDisabled = false) => {
					const item = document.createElement("div");
					item.classList.add("sdd-dropdown-item");
					if (grpDisabled || optionData.disabled) item.classList.add("disabled");
					item.setAttribute("role", "option");
		
					//properties
					item.value = optionData[_settings.valueField].toString(); //default _settings.valueField is "value"
					item.setAttribute("value", item.value);
					item.dataset.index = i;
		
					//add attributes
					if ("object" == typeof optionData.attr) {
						const keys = Object.keys(optionData.attr);
						for (const key of keys) {
							if (optionData.attr.hasOwnProperty(key))
							item.setAttribute(key, optionData.attr[key]);
						}
					}
		
					//render inner HTML
					item.innerHTML = //`<em>${pad(i + 1, 2)}.</em>&emsp13;` +
						_settings.render.option(optionData, escape_html);
					
					//create <em> element to store the order-number of current option
					let _em = document.createElement("em");
					_em.classList.add("item-order");
					//data-rAlignGroup attribute to mark that this item is right-align
					_em.setAttribute("data-rAlignGroup", "itemOrder");
					_em.innerHTML = pad(i + 1, 2) + ".";

					//if first child of option is an <DIV>, add order-number to be the first child of that DIV. Otherwise, add <em> is the first child of item itself
					const _firstChild = item.firstChild;
					if(_firstChild instanceof HTMLDivElement) _firstChild.prepend(_em)
					else item.prepend(_em);

					return item;
				};

				/* make no-result notification in the form of an option item */
				const makeNoFoundItem = () => {
					const item = document.createElement("div");
					item.classList.add("no_results", "elm-hidden"); //initially, it is hidden
					item.innerHTML = _settings.render["no_results"]();
					return item;
				};
	
				/** Create optGroup
				 * @param grp {json}: item of _settings.optgroups array, contain information about a group
				 * @param grpI {number}: the index of current group in _settings.optgroups
				 */
				const makeOptionGroup = (grp, grpI) => {
					let _optGroupDiv = document.createElement("DIV");
					_optGroupDiv.classList.add("optgroup");
					_optGroupDiv.dataset.group = grpI;
					if (grp.value) _optGroupDiv.setAttribute("value", grp.value);
		
					const _chkBxId = "grpChkbox_" + _uid + "_" + grpI;
					let _grpLabel = escape_html(grp.label);
					if ("function" == typeof _settings.render.optgroup_header)
						_grpLabel = _settings.render.optgroup_header(grp, escape_html);
					_grpLabel = _grpLabel; //'<em></em>&emsp13;' + _grpLabel;
		
					_optGroupDiv.innerHTML = `<input type="checkbox" id="${_chkBxId}" attr-grpno="${ grp.gId }" checked>
						<label for="${_chkBxId}" class="optgroup-header ${ !!grp.disabled ? "disabled" : "" }">${_grpLabel}</label>
						<section></section>`;
		
					//add attributes
					if ("object" == typeof grp.attr) {
						const keys = Object.keys(grp.attr);
						for (const key of keys) {
							if (grp.attr.hasOwnProperty(key))
							_optGroupDiv.setAttribute(key, grp.attr[key]);
						}
					}
		
					return _optGroupDiv;
				};

				//generate group + options elements
				if (Array.isArray(_settings.optgroups)) {
					_settings.optgroups.forEach((grp, grpI) => {
						let _optGroupDiv = makeOptionGroup(grp, grpI);
						sddDropdownContent.appendChild(_optGroupDiv);
		
						const sectionElem = _optGroupDiv.querySelector("section");
		
						//add options having the same gId
						const _gId = grp[_settings.optgroupField] ; // default of _settings.optgroupField is "gId"
						_settings.options.forEach((optionData, i) => {
							if (optionData[_settings.optgroupField] == _gId)
							sectionElem.appendChild(makeOptionItem(optionData, i, !!grp.disabled));
						});
					});
				} else {
					// Loop All Options and Create Custom Option for Each Option And Append it to Inner Wrapper Element
					_settings.options.forEach((optionData, i) => {
						sddDropdownContent.appendChild(makeOptionItem(optionData, i));
					});
				}

				//if no SDD option has extra title (which marked with class .item-2nd-main-div), then hide the .close-open-extra-title-button button. Otherwise, show the button
				const _extra_title_toggle_state =  Boolean(sddDropdownContent.querySelector('.sdd-dropdown-item > .item-2nd-main-div') );
				sddInputWrapper.querySelector(".close-open-extra-title-button").classList.toggle("elm-hidden", !_extra_title_toggle_state);

				//add no-result like an option
				sddDropdownContent.appendChild(makeNoFoundItem());

				// delete no-longer-needed data to save some memory
				_settings.options.length = 0;
				delete _settings.options;
				//optgroups not always exists
				_settings.optgroups && (_settings.optgroups.length = 0);
				delete _settings.optgroups;
				
				//store all items elements
				_items = Array.prototype.slice.call( sddDropdownContent.querySelectorAll("div.sdd-dropdown-item") ); //array of all option items
	
				const sddSearchBox = _sddWrapper.querySelector(".sdd-search-box");
				sddSearchBox.placeholder = "🔍 " + _settings.searchBoxPlaceholder.replace("{_items_length}", _items.length) ;//`🔍 Search in ${_items.length} items ...`;
	
				//if ([null, undefined].includes(initSelectedItem)) initSelectedItem= 0;
				if(![null, undefined].includes(initSelectedItem) && "function" == typeof selectItem) {
					selectItem(initSelectedItem, false); //force raising onchange() event and invoking SDD.callbacks.onChange() callback fn.
				}
			}
  
			/* The following provides all the internal functions for dropdown to work. */

			/* delegation events handler catched on sddDropdownContent to handle click event on its div children, each of them is a dropdown item */
			function dropdownItemClickDelegation(evt) {
				let target = evt.target.closest(".sdd-dropdown-item");
				if (target) setSelected(target);
				evt.stopPropagation(); //prevent bubbling up
			}
  
			/** Sets the selected item in the dropdown menu of available options. *
			 * @param option {HTMLElement}: the option to be set active
			 * @param scroll {boolean, true}: scroll to its position or not
			 * @param toMiddle {boolean, false}: if true, scroll so that the option is in the middle of its container. 
			*/
			function setActiveOption(option, scroll = true, toMiddle = false, behavior) {
				if (!option) return;
				//only apply smooth scroll behavior when scroll to middle
				behavior = behavior ?? (toMiddle ? "smooth" : "auto");

				//because _selectedItem is set active everywhere, so just remove it here for sure
				_selectedItem && _selectedItem.classList.remove("is-active");

				if(option === _activeOption) {
					option.classList.add("is-active"); //in-case its class was reset in clearSearch
					if (option && scroll) scrollToOption(option, behavior, toMiddle); //scroll to old active option in-case it is moved out of view
					return;
				}
	
				//clear old active
				//sddDropdownContent.querySelectorAll(".is-active").forEach(_itemElem => _itemElem.classList.remove("is-active"));
				_activeOption && _activeOption.classList.remove("is-active");				
	
				//update new active option
				option.classList.add("is-active");
				_activeOption = option;
	
				if (scroll) scrollToOption(option, behavior, toMiddle); //scroll to active option
			}
	
			/** Get adjacent option item
				@param option {HTMLElement}: the current option to get its adjacent (which may not be adjacent DOM elements due to optGroup and filter)
				@parma direction {integer, 1}: -1 Go next down; 1: go next Up
					= -100 go Top, =100: go Bottom
					= -50: previous page, =50: next page
					= -35, 35, -36, 36: 
						-35: if active option not the very first one, go to the very first visible of the same group with current active option.Otherwise, go to the first visible option of previous visible option group
						35: go to first visible option of next visible option group (does not matter where current active option is)
						-36: go to last visible option of previous visible option group (does not matter where current active option is)
						36: if active option not the very last one, go to the very last visible of the same group with current active option. Otherwise, go to the last visible option of next visible option group
					= 0: just scroll to the selected Item
				@param makeSelect {boolean, false}
					False: just make new option active
					True: make new option to be selected item, and fire onChange event
			*/
			function getAdjacent(option, direction = 1, makeSelect = false) {
				const allItems = _filteredItems ?? _items; //depend on being filtered or not

				// no matched items, then nothing todo
				if(allItems.length == 0) return;

				let _currIdx = -1;
	
				//home and End key
				if ([100, -100].includes(direction)) {
					_currIdx = direction == 100 ? allItems.length - 1 : 0;
				}
				else {
					_currIdx = allItems.indexOf(option);
					if (_currIdx == -1) {
						_currIdx = 0;
					}
					else{
						const len = allItems.length;
						
						if(direction == 0){
							//nothing to do
						}
						//upArrow and downArrow key
						if ([1, -1].includes(direction)){
						_currIdx = (_currIdx + direction + len) % len;
						}

						//leftArrow and rightArrow key, go to very last/first visible option of the prev/next group
						if ([35, -35, 36, -36].includes(direction)){
							const optGroupCtn = option.closest(".optgroup");
							//no optGroup at all, nothing todo
							if(!optGroupCtn) return;

							//get all visible options of current group
							const _allVisibleOptions = [...optGroupCtn.querySelectorAll(".sdd-dropdown-item:not(.elm-hidden)")];

							//find the very first at(0) or last at(-1) visible option of same option group. direction = -35, 35 is go to first option; = -36,36 is go to last option
							let _adjOption = _allVisibleOptions.at(Math.abs(direction) == 35? 0: -1);

							//if current active option is actually the first/last option of current optGroup OR when go to first option of next group OR go to last option of previous group. In one of these case, we just go to first
							if(_adjOption == option || [35, -36].includes(direction) ){
								//all visible optGroups of SDD
								const _allVisibleOptGroups = [...sddDropdownContent.querySelectorAll(".optgroup:not(.elm-hidden)")];
								//get the adjacent visible optGroup Index. direction = -35, -36 is go to previous option group; = 35,36 is go to next option group
								const _adjOptGroupIndex = _allVisibleOptGroups.indexOf(optGroupCtn) + (direction < 0 ? -1 : 1);
								//check if it is not the very first/last visible option group
								if(_adjOptGroupIndex > -1 && _adjOptGroupIndex < _allVisibleOptGroups.length){
									//get first/last visible option of _adjOptGroupIndex option group. direction = -35, 35 is go to first option; = -36,36 is go to last option
									_adjOption = [..._allVisibleOptGroups[_adjOptGroupIndex].querySelectorAll(".sdd-dropdown-item:not(.elm-hidden)")].at(Math.abs(direction) == 35? 0: -1);
								}
							}
							
							_currIdx = allItems.indexOf(_adjOption);
						}

						//PageUp and PageDown keys
						if ([50, -50].includes(direction)) {
							//container height
							const _ctnHeight = sddDropdownContent.offsetHeight; //getBoundingClientRect().height;
							
							if(direction == 50){ //PageDown
								const _currTop = allItems[_currIdx].getBoundingClientRect().top;
								let i = _currIdx + 1;
								while(i < len){ //go down, search for first item of next page
									if(allItems[i].getBoundingClientRect().bottom - _currTop > _ctnHeight) break;
									i++;
								}
								_currIdx = Math.min(i - 1 , len - 1);
							}
		
							if(direction == -50){ //PageUp
								const _currBottom = allItems[_currIdx].getBoundingClientRect().bottom;
								let i = _currIdx - 1;
								while(i >= 0){  //go up, search for first item of previous page
									if(_currBottom - allItems[i].getBoundingClientRect().top > _ctnHeight) break;
									i--;
								}
								_currIdx = Math.max(i + 1, 0);
							}
						}
					}
				}
	
				const _chosenOption = allItems[_currIdx];
				if(makeSelect)
					//set adjacent option to be selected item, fire onChange() event but not close the dropdown
					setSelected(_chosenOption, false, false);
				else {
					//set adjacent option to be active without closing the SDD, so we need to handle the collapsed group and animation effect properly

					//function to set active option and animation effect for each case
					const _setAndScroll2ActiveOption = _ =>{
						if(direction == 0) 
							//scroll to selected option: smooth animation, middle of screen
							setActiveOption(_chosenOption, true, true, 'smooth') 
						else if([100,-100].includes(direction))
							//jump to beginning and end of SDD list: smooth animation, not necessarily middle of screen
							setActiveOption(_chosenOption, true, false, 'smooth') 
						else
							//othercase, just set active option with 'not smooth, not middle'
							setActiveOption(_chosenOption);
					}					
				
					//open optGroup containing the chosen option if there is any and it is closed and reveal the group header if the active option if the first visible option of its group
					const _optGroupFather = _chosenOption.closest(".optgroup");

					//no group at all
					if(!_optGroupFather) _setAndScroll2ActiveOption()
					else {//having group, need to handle the case group collapsed and the active option is the very first visible one of its group
						
						//function to scroll into option, then if it is the fist visible of its group, scroll to the header
						const _scroll2headerOrOption = _ => {
							//first, set active option and scroll to it
							_setAndScroll2ActiveOption();

							// show the group header if _currIdx is the top visible option of its group.
							// The condition is: if _currIdx is very top one (=0) 
							// OR its previous visible option is in another group (_chosenOption.getAttribute("attr-gid") !== allItems[_currIdx - 1].getAttribute("attr-gid")). Also, the direction has to be scroll up (direction < 0), because scroll down and scroll to the header, the option might be hight at the bottom of SDD
							if( _currIdx==0 || (_optGroupFather !== allItems[_currIdx - 1].closest(".optgroup") && direction < 0) )
								scrollToOption(_optGroupFather.querySelector(".optgroup-header"), 'smooth', direction == 0);
						}

						//if optGroup already open, just scroll to the option
						if(_optGroupFather.firstChild.checked) _scroll2headerOrOption()
						else{
							//wait for transition finish, then scroll
							_optGroupFather.lastChild.addEventListener('transitionend', 
								function _tmpFnc(e) {
									// remove this event listener so it only gets triggered once
									e.target.removeEventListener('transitionend', _tmpFnc);
									//scroll to the option
									_scroll2headerOrOption();
								}
							);
							//open the group, which will trigger event above
							_optGroupFather.firstChild.checked = true;
						}
					}
				}
			}
	
			/* Handle keydown event on search input textbox to move to another option or select it
			NOTE: if user hold ctrl+shift keys together (this key would be changed in _settings.makeSelectKey) when active new option, that option would be selected immediately without closing the dropdown, still onChange() event fires
			*/
			function onKeyDown(evt) {
				//remove the class so that hover is diseffective on option
				if(sddDropdownContent.classList.contains("allow-hover-on-item"))
					sddDropdownContent.classList.remove("allow-hover-on-item");

				//console.log(evt.code + " - " + evt.which); //ctrlKey, shiftKey
				
				// if user hold ctrl+shift keys together (or any modifier-key set in setting.makeSelectKey) when active new option, that option would be selected immediately without closing the dropdown, still onChange() event fires
				let _makeSelect = false;
				if(evt instanceof KeyboardEvent && _settings.makeSelectKey.trim() !==""){
					const _keyName = _settings.makeSelectKey.trim().toUpperCase();
					_makeSelect = true;
					if(_keyName.includes("CTRL")) _makeSelect &= evt.ctrlKey || evt.metaKey; //metaKey is controlKey in MAC, Window key in Window
					if(_keyName.includes("SHIFT")) _makeSelect &= evt.shiftKey;
					if(_keyName.includes("ALT")) _makeSelect &= evt.altKey;
				}

				//const _NO_MODIFIER_KEY = evt? !(evt.altKey || evt.shiftKey || evt.ctrlKey || evt.metaKey) : true;

				/* The evt.key to get the character, while the evt.code to get the “physical key code”. For example, evt.key=Shift while evt.code=ShiftLeft OR when user click shift+z: evt.key=Z while evt.code=keyZ */

				//full list of hotkeys with callback functions. See the comments on function SddDropdown.prototype.runHotkey below to see the format and meaning of each shortcut
				const hotkeyOptions = [
					// up: go previous option
					{task: "sdd_prevOption", kCode: ["ArrowUp"], ignoreModifier: true, desc: "Mục ngay trước.", noNotify: true, callback: () => getAdjacent(_activeOption, -1, _makeSelect)},
					// down: go to next option
					{task: "sdd_nextOption", kCode: ["ArrowDown"], ignoreModifier: true, desc: "Mục ngay sau.", noNotify: true, callback: () => getAdjacent(_activeOption, 1, _makeSelect)},
					
					// PageUp: go to option one page above
					{task: "sdd_pageUpOption", kCode: ["PageUp"], ignoreModifier: true, desc: "Lên một trang.", noNotify: true, callback: () => {
						//if(evt.shiftKey) return; //with shiftKey is for another task

						evt.preventDefault(); //prevent default because some browser Ctrl + PageUp switch the previous tab
						getAdjacent(_activeOption, -50, _makeSelect);
					}},
					// PageDown: go to option one page below
					{task: "sdd_pageDownOption", kCode: ["PageDown"], ignoreModifier: true, desc: "Xuống một trang.", noNotify: true, callback: () => {
						//if(evt.shiftKey) return; //with shiftKey is for another task

						evt.preventDefault(); //prevent default because some browser Ctrl + PageDown switch the next tab
						getAdjacent(_activeOption, 50, _makeSelect);
					}},
					
					// arrowLeft: go to first option of previous filtered optGroup
					{task: "sdd_prevFilterOptGrpFirstOption", kCode: ["ArrowLeft"], ignoreModifier: true, desc: "Tới mục đầu tiên của nhóm hiện tại (hoặc nhóm ngay trước).", noNotify: true, callback: () => {if(!evt.altKey) getAdjacent(_activeOption, -35, _makeSelect)}},
					// arrowRight: go to first option of next filtered optGroup
					{task: "sdd_nextFilterOptGrpFirstOption", kCode: ["ArrowRight"], ignoreModifier: true, desc: "Tới mục đầu tiên của nhóm tiếp theo.", noNotify: true, callback: () => {if(!evt.altKey) getAdjacent(_activeOption, 35, _makeSelect)}},

					// Alt+arrowLeft: go to last option of previous filtered optGroup
					{task: "sdd_prevFilterOptGrpLastOption", kCode: ["Alt+ArrowLeft"], ignoreModifier: true, desc: "Tới mục cuối cùng của nhóm ngay trước.", noNotify: true, callback: () => {if(evt.altKey) getAdjacent(_activeOption, -36, _makeSelect)}},
					// Alt+arrowRight: go to last option of next filtered optGroup
					{task: "sdd_nextFilterOptGrpLastOption", kCode: ["Alt+ArrowRight"], ignoreModifier: true, desc: "Tới mục cuối cùng của nhóm hiện tại (hoặc nhóm tiếp theo).", noNotify: true, callback: () => {if(evt.altKey) getAdjacent(_activeOption, 36, _makeSelect)}},

					// Ctrl+Home: go to the very first option
					{task: "sdd_firstOption", kCode: ["Ctrl+Home"], desc: "Tới mục đầu tiên.", callback: () => {{getAdjacent(_activeOption, -100, _makeSelect); evt.preventDefault()} }},
					// Ctrl+End: go to the very last option
					{task: "sdd_lastOption", kCode: ["Ctrl+End"], desc: "Tới mục cuối cùng.", callback: () => {getAdjacent(_activeOption, 100, _makeSelect)}},

					// Home, End: go back to selected option
					{task: "sdd_gotoSelectedOption", kCode: ["Home", "End"], desc: "Quay về mục đang được chọn.", callback: () => {getAdjacent(_selectedItem, 0)}}, //setActiveOption(_selectedItem, true, true)

					//Shift+Backspace: clear the search box
					{task: "sdd_clearSearchbox", kCode: ["Shift+Backspace"], desc: "Xóa ô tìm kiếm.", callback:_ => {
						clearSearch();
					}},
					
					//Insert: change the diacritics search mode
					{task: "sdd_toggleDiacriticsMode", kCode: ["Insert"], desc: "Đổi chế độ giữ dấu/bỏ dấu trước khi tìm kiếm.", callback: () => {setDiacriticsFilterMode(evt);evt.preventDefault();}},

					//Escape: close the dropdown
					{task: "sdd_closeDropdown", kCode: ["Escape"], desc: "Đóng Dropdown.", callback: toggleDropdown},

					//Tab: toggle the optGroups
					{task: "sdd_closeOptGroups", kCode: ["Tab"], desc: "Đóng/mở tất cả các nhóm mục.", callback: function(){
						evt.preventDefault(); //prevent default so that searchBox not loose focus
						toggleOptGroups.call(this, evt, 0); //0 for Tab key
					}},
					{task: "sdd_closeOptGroupsExceptSelective", kCode: ["Shift + Tab"], desc: "Đóng tất cả các nhóm mục ngoại trừ nhóm đang chứa mục được chọn và mục đang có con trỏ.", callback: function(){
						evt.preventDefault(); //prevent default so that searchBox not loose focus
						toggleOptGroups.call(this, evt, 1); //1 for Shift+Tab
					}},

					//Enter: select the option, close the dropdown
					{task: "sdd_selectOption", kCode: ["Enter", "NumpadEnter"], ignoreModifier:true, desc: "Chọn mục hiện tại. Bấm cùng phím Shift để chọn mục mà không đóng Dropdown.", callback: () => {
						//if _activeOption is a disabled one, don't make it selected
						if(_activeOption.classList.contains("disabled")) {
							console.warn("SDD setSelected: disabled item cannot be selected.");
							return _notifyFunction(`Sách '${_activeOption.textContent}' bị disabled, không thể chọn.`);
						}
						setSelected(_activeOption, false, !evt.shiftKey);
					}}
				];

				//if onKeyDown() is invoked without {evt} parameter, it just return value for _hotKeysList variable, no key is catched
				if(!evt){
					//extract hot keys list without callback, which is useless for outside scope
					const _hotKeysListTmp = hotkeyOptions.map(hotkey => {
						let _temp = Object.assign({}, hotkey); //create deep copy
						delete _temp.callback; //remove the {callback} attribute
						return _temp;
					});

					return _hotKeysListTmp; //return the hotKey List
				}

				//search if a key just press matched any key specify above, then take the corresponding action. Note that don't apply preventDefault() on this, otherwise, we can't use arrow keys to move between character in searchbox
				SddDropdown.prototype.runHotkey(evt, hotkeyOptions, 1, _settings.callbacks.notify);
		
				//this is necessary to stop some letter and digit key to propagate above, and maybe preventDefault above in the DOM, so those key does not work correctly (such as key 0 (which change audio speed to 1.0) has been preventDefault in the Document)
				evt.stopPropagation();
			}

			/** function to invoke and notify an action when a specified hotkey associated with that fuction is pressed.
			 * @param evt {KeyboardEvent}: the event associated with key action((key down, key up or key press)
			 * @param hotkeyOptions {json}: list of all supported hotkey. See SddDropdown.onKeyDown function for an example of its format. Each item is a json has following attributes
			 * 		@propety task {string}: the task id
			 * 		@propety kCode {array of string}: the array of keycode, can include modifer key (such as Ctrl, Alt, Shift, MetaKey) seperated by '+' to comprises the shortcut hotkey e.g: ["PageUp", "Alt+Home"], ["Ctrl+A", "Shift+ArrowLeft"] or even ['Alt+ShiftLeft']. Note that for a composite shortcut, there are two part. For example, shortcut like 'Ctrl+Shift+KeyA', the first part is modifier keys (Ctrl+Shift), the second part is evt.code (KeyA). But for shortcut like 'Shift+ControlRight', the action is only trigger if any Shift key is pressed AND Right Control key is pressed (that is, evt.code=='ControlRight'; in this case ControlRight is second part)
			 * 		@propety ignoreModifier {boolean, optional}: If set to {true}, the modifier pressed along with hotkey will be ignored. In normal case when ignoreModifier=true or missing,  if kCode:["PageUp"], then only PageUp key alone will trigger the function, Ctrl+PageUp, Shift+PageUp will not. ignoreModifier:true is applied for some hotkey is actually modifier key (such as ShiftLeft or ControlRight) or some function that associate with different modifier key to make different action like audio seeking, audio volumn changing or SDD selecting while changing active option
			 *  	@propety desc {string}: the descrition of the job will be carried out
			 * 		@propety noNotify {boolean, optional}: if specified true, the description of the task will not be notified to user when it is invoked
			 * 		@propety callback {function}: the function will be invoked when the corresponding key (and modifier key) is pressed
			 * @param keyPreventation {number}: to stopPropagation or preventDefault. Convert {keyPreventation} decimal number to binary number. {evt} will stopPropagation when bit 0 = 1, {evt} will preventDefault when bit 1 = 1:
			 * 	= 0: no stopPropagation, no preventDefault
			 *  = 1: stopPropagation, no preventDefault
			 *  = 2: no stopPropagation, preventDefault
			 *  = 3: stopPropagation and preventDefault
			 * @param notifyFnc {function}: the function, if specified, which show the functionality of hotkey action to the user. The default is simple Infor toast
			 */
			SddDropdown.prototype.runHotkey = function(evt, hotkeyOptions, keyPreventation = 3, notifyFnc = _msg => toast.showToast(_msg, toast.ToastType.Infor) ){
				/** function to find if a keycode that is part of a shortcut
				 * @param _shortcut {string} the comprised key set in kCode attribute of hotkeyOptions item. E.g: "KeyZ", "Ctrl+keyA" or "Shift+ArrowLeft"
				 * @param _code {string} the keyCode that user pressed, usually got from evt.code. E.g "KeyA", "ArrowLeft"
				 * @note need to check if @_code is empty (of which all hotkey in @hotkeyOptions will be matched), because this happen sometime when typing a Vietnamese keyword such as 'TĐ' (this might be the problem of Vietnamese typer such as UniKey)
				 */
				const _matchKeycode = (_shortcut, _code) => _code && _shortcut.match(new RegExp(`\\b${_code}\\b`,"i")); //'\\b' to make sure to match whole word

				//console.log(evt.code);
				//find if the key just press in the list of supported shortcuts
				const hotkeyOpts = hotkeyOptions.filter(keyItem => 
					//find the key in kCode (array of keys)
					keyItem.kCode.some(_shortcut => _matchKeycode(_shortcut, evt.code))
				);

				const [_stopPropagation, _preventDefault] = [keyPreventation % 2, keyPreventation / 2 << 0];
				//if found, do the corresponding job
				hotkeyOpts.forEach(hotkeyOpt => {
					// this var is used to check if a modifier key (or composition of modifier keys) specified in ignoreModifier attribute is pressed
					let _modifierKeys = true;
					if(evt instanceof KeyboardEvent) {
						//if ignoreModifier is false or missing, then need to check corresponding modifier key pressed
						if(!hotkeyOpt.ignoreModifier){
							const _shortcut = hotkeyOpt.kCode.find(_shrtcut => _matchKeycode(_shrtcut, evt.code)).trim();

							//if the shortcut is a composition of key and modifier
							if(_shortcut.includes("+")){
								if(_matchKeycode(_shortcut, "Ctrl")) _modifierKeys &= evt.ctrlKey || evt.metaKey; //metaKey is controlKey in MAC, Window key in Window
								if(_matchKeycode(_shortcut, "Shift")) _modifierKeys &= evt.shiftKey;
								if(_matchKeycode(_shortcut, "Alt")) _modifierKeys &= evt.altKey;							
							}
							else {
								//check for special key code such as ControlRight(Left); ShiftRight(Left); AltRight(Left)
								const _modifierAsKey = _shortcut.match(/\b(Control|Shift|Alt)(Left|Right)\b/i);
								if(_modifierAsKey){
									//manually set _modifierKeys for evt.code is one of ControlRight, ControlLeft, ShiftRight(Left), AltRight(Left). For those key, such as ControlRight, ControlLeft, we need to set value of _modifierKeys = true if control key is pressed, but Shift, Alt key must not pressed
									const _modifierArray = ['alt', 'ctrl', 'shift', 'meta']; //list of all modifier key name
									//extract modifier key from shortcut
									let _modiKey = _modifierAsKey[1].toLowerCase();
									if(_modiKey == 'control') _modiKey = 'ctrl';

									_modifierArray.forEach(_mk => {
										if(_mk == _modiKey) 
											_modifierKeys &= evt[_mk + 'Key'];
										else 
											_modifierKeys &= !evt[_mk + 'Key'];
									})
								}
								else
								//no modifier key should be allowed
								_modifierKeys = !(evt.altKey || evt.shiftKey || evt.ctrlKey || evt.metaKey);
							}
						}
					}
					if(_modifierKeys){
						hotkeyOpt.callback();
						//notify if there is notifyFnc and the hotkey allow notify
						if('function' == typeof notifyFnc && !hotkeyOpt.noNotify) notifyFnc(hotkeyOpt.desc);

						//do some preventation depending on keyPreventation
						if(_stopPropagation) evt.stopPropagation();
						if(_preventDefault) evt.preventDefault();
					}
					/* if(hotkeyOpt.notify && hotkeyOpts.length==1)
					_settings.callbacks.notify(hotkeyOpt.desc); */
				});
			}
	
			/** Toggle for Display and Hide Dropdown.
			 * @evt {any}
			 * 	- click event: when user click on SDD to expand/collapse it
			 * 	- keyboard event: when user press a key to expand the SDD (from page) or ESC to collapse the SDD (from SDD search box)
			 * 	- -1: called from closeIfClickedOutside function
			*/
			function toggleDropdown(evt) {
				//idea to animation collapse/expand is borrowed from https://css-tricks.com/using-css-transitions-auto-dimensions/
				/* COLLAPSE */
				if (!sddDropdownWrapper.classList.contains("elm-hidden")) {
					//set max-height to collapse dropdown Content and trigger transition effect
					sddDropdownContent.style.maxHeight = '0px';

					//wait for transition to be finished, then hide sddDropdownWrapper and glowing the rest still visibled
					sddDropdownContent.addEventListener('transitionend', function _tmpFnc(e) {
						// remove this event listener so it only gets triggered once
						sddDropdownContent.removeEventListener('transitionend', _tmpFnc);
						
						//hide sddDropdownWrapper
						sddDropdownWrapper.classList.add("elm-hidden");
						
						//glowing the rest which still visible
						_glowingElem(representativeDiv);
					});

					// reset the active option to _selectedItem
					_activeOption = _selectedItem;
		
					//clear search box and search result variables
					if(evt !== -1) clearSearch(); //not invoked from closeIfClickedOutside()
				} else { /* EXPAND */
					//need to remove hidden class before calculate dimension, otherwise getBoundingClientRect() return all 0
					sddDropdownWrapper.classList.remove("elm-hidden");

					//calculate max-height for sdd so that its bottom is not hidden, but sdd is not too short
					const _maxHeight = Math.max(_settings.maxHeight[0], 
						Math.min( _settings.maxHeight[1],
						window.innerHeight - sddDropdownContent.getBoundingClientRect().top - 30 )
					);
					/* const _maxHeight = Math.max(_settings.maxHeight[0], 
						Math.min( _settings.maxHeight[1],
						window.innerHeight - representativeDiv.getBoundingClientRect().bottom - 60 )
					); */

					//TODO: maybe sometime transitionend not fired or fired very late, we can use setTimeout 600sec instead
					// when the next css transition finishes, glowing the sddDropdownWrapper
					sddDropdownContent.addEventListener('transitionend', 
					//setTimeout(
						function _tmpFnc(e) {
							// remove this event listener so it only gets triggered once
							sddDropdownContent.removeEventListener('transitionend', _tmpFnc);
							//toast.showToast('sddDropdownContent transitionend');
							
							//choose the option to be active when SDD open. If _selectedItem is visible (here I check if offsetParent exists, because _selectedItem sometime hidden because it has class .elm-hidden, some other time because its parent optGrp is hidden), then use _selectedItem. If it is not, use _activeOption, if _activeOption not exist, then get the first filtered item
							let _iniActiveOption = Boolean(_selectedItem.offsetParent)? _selectedItem : (Boolean(_activeOption.offsetParent) ? _activeOption : (_filteredItems ?? _items)[0])
							//scroll to last selected option
							if (_iniActiveOption) {
								setActiveOption(_iniActiveOption, true, true);
								//scrollToOption(_selectedItem, "auto", true);
							}

							_glowingElem(sddDropdownWrapper);
						}//, 550
					);

					///set max-height and trigger transition effect. This should be set after setting transitionend handler
					sddDropdownContent.style.maxHeight =  _maxHeight + "px";

					//set focus search box when on desktop
					if (!isTouchDevice) sddSearchBox.focus();
		
					/* UI: when sdd open for the first time, Right align all marked-to-align-right elements (ones having attribute [data-rAlignGroup]) inside an option for collection of options (which can be inside a section or all options for sdd have no sections) */
					if(_dropdownOpenFirstTime){
						_dropdownOpenFirstTime = false; //so next time toggle, this will not run again, until a new SDD is loaded in
						
						const _allSections = sddDropdownContent.querySelectorAll("div.optgroup > section");
						//if having group and user set (which actually default) _settings.rightAlignInEachOptGroup = true
						if(_allSections.length>0 && _settings.rightAlignInEachOptGroup)
							//if there is optGroups, only right-align across options inside group
							_allSections.forEach( sectionElem => _rightAlignElems(sectionElem) )
						else _rightAlignElems(sddDropdownContent); //no optGroup

						//repos tooltip for control buttons. I don't want to use this outside function to position tooltips, but I have no choices ):-
						reposTooltips(sddInputWrapper); //, {container: sddDropdownContent}
					}
				}

				//if stopPropagation, two sdd may open at the same time
				//evt && evt.stopPropagation(); //prevent bubbling up
			}
	
			/** Set Selected Option
				@param clickedOption: dropdown option to be set selected
				@param seizeOnChange {boolean, false}: if true, no fire the onChange() callback
				@param closeOnSelect {boolean, true}: after set selected Item, close the dropdown or not
			*/
			function setSelected(clickedOption, seizeOnChange = false, closeOnSelect = true) {
				//make select the alread-selected option, then nothing todo
				if (_selectedItem === clickedOption) {
					if('function' == typeof _settings.callbacks.notify) _settings.callbacks.notify("Bạn vừa chọn lại mục đang được chọn.");
					//return clickedOption;
				}
				else{
					//remove the last selected
					if (_selectedItem)
						_selectedItem.classList.remove("is-selected");
		
					//this is bound to dropdown item which is clicked
					_activeOption = _selectedItem = clickedOption;
					
					// Change the Text on Selected Element
					//representativeDiv.textContent = clickedOption.textContent;
					representativeDiv.innerHTML = _settings.render.select_option(clickedOption, escape_html);

					// Add Selected Class to Clicked Option
					clickedOption.classList.add("is-selected");	

					//invoke _onChange callback if it is set
					if ("function" == typeof _onChange && !seizeOnChange)
					_onChange(clickedOption);
				}
	
				// Reset Search Input Value, Remove Selected Class from Previously Selected Option;  And Show All Div if they Were Filtered
				clearSearch();
				
				// Close the Dropdown
				/* if (closeOnSelect) sddDropdownWrapper.classList.add("elm-hidden"); */
				if (closeOnSelect && !sddDropdownWrapper.classList.contains("elm-hidden")) {
					toggleDropdown();
				}
	
				return clickedOption;
			}
	
			/** reset SDD to the state of non-filter  */
			function resetFilter(){
				//hide statusBar
				sddDropdownStatusBar.classList.add("statusbar-hidden");

				//put no-result option into hidden
				sddDropdownContent.querySelector("DIV.no_results").classList.add("elm-hidden");

				_filteredItems = null; //clear _filteredItems data
				_items.forEach((option) => {
					// Remove active Class from Previously active Option
					if (option.classList.contains("is-active")) {
						option.classList.remove("is-active");
					}
					// And Show All Div if they Were Filtered
					if (option.classList.contains("elm-hidden"))
						option.classList.remove("elm-hidden");
		
					//remove last high-light if there any
					sHighlite.removeHighlight(option);
				});
		
				//show all the groups which are hidden by last search
				sddDropdownContent.querySelectorAll("div.optgroup")
					.forEach((_optGroup) => { _optGroup.classList.remove("elm-hidden"); });
			}
			
			/* clear the search */
			function clearSearch(evt) {
				
				// Reset Search Input Value
				sddSearchBox.value = "";
				//sddSearchBox.focus(); //this should not put here, it will cause keyboard to showup when close the dropdown on smart devices

				resetFilter(); //clear all the filter
				
				//make selectedItem to be active one and scroll to it. But sdd scroll to the middle if this clearSearch() function is invoked from .clear-input-button button (evt !== undefined), otherwise if clearSearch() is invoked without {evt} parameter, it scroll in usual way
				setActiveOption(_selectedItem, true, !!evt);

				(evt instanceof Event) && evt.stopPropagation(); //PointerEvent
			}
	
			// Filter the Items by searchStr
			function filterItems(evt) {
				
				// Get Value of Search Input
				let searchStr = sddSearchBox.value;
				/* searchStr = searchStr.replaceAll(/\s\s+/g, " "); //save and trim value of sddSearchBox, so there is no two consecutive space
		
				//reset the search to prepare for the new one. Side effect: set searchbox to empty
				clearSearch(); 
		
				sddSearchBox.value = searchStr; //get back the value of sddSearchBox
				searchStr = searchStr.trim(); //should not toLowerCase() here, because this will prevent "search by first char" mode, where all chars of searchStr is capital
		 		*/

				resetFilter();
				searchStr = searchStr.replaceAll(/\s\s+/g, " ").trim(); //should not toLowerCase() here, because this will prevent "search by first char" mode, where all chars of searchStr is capital
				if (searchStr == "") return;
		
				//set new query string for sHighlite to deal with
				sHighlite.queryString = searchStr;

				// Get Items that match the search
				const matchedItems = _items.filter((item) =>
					// using textContent for simplicity. TODO: can specify which field or which child-element of an item to test the match
					sHighlite.matchSearch(item.textContent)
				);
				// Get the Indexes of FilteredItems
				const indexesArr = matchedItems.map((item) =>
					_items.indexOf(item)
				);
		
				//filtered _items data
				_filteredItems = matchedItems;
		
				//show/hide statusbar to notify the seearch results
				if(matchedItems.length == 0)
					//hide statusBar if there is no found
					sddDropdownStatusBar.classList.add("statusbar-hidden")
				else{
					//if(sddDropdownStatusBar.classList.contains("elm-hidden"))
					sddDropdownStatusBar.classList.remove("statusbar-hidden"); //show statusBar
					//sddDropdownStatusBar.style.opacity = 1;
					sddDropdownStatusBar.innerHTML = `Tìm thấy <mark>${matchedItems.length}</mark> kết quả.${window.innerWidth < 500?'<br/>':' '}Mode <small><mark>${sHighlite.wordMode}</mark>＋<mark>${sHighlite.diacriticsFilterMode?'Bỏ dấu':'Nguyên dấu'}</mark></small>.`; //statusBar content
					
					//using sddDropdownStatusBar.lastTO to store the timeout ID of last setTimeout. If statusBar still visible when new filter taken, just clear last timeout so that the new search result would not be disapear before its own timeout
					if(!sddDropdownStatusBar.classList.contains("statusbar-hidden") && sddDropdownStatusBar.lastTO)
					clearTimeout(sddDropdownStatusBar.lastTO);

					//set the time out to disappear the statusBar
					sddDropdownStatusBar.lastTO = setTimeout(_ => {
						//sddDropdownStatusBar.style.opacity = 0;
						sddDropdownStatusBar.classList.add("statusbar-hidden");
					}, _settings.statusBarTimeout);
				}

				// hide the not-match items
				_items.forEach((item) => {
					const optionIdx = _items.indexOf(item);
					sHighlite.removeHighlight(item); //remove all old highlight if there are any
					item.classList.remove('is-active'); //remove is-active class
					if (!indexesArr.includes(optionIdx)) {
						// Check if Option is not Inside Filtered Indexes Array, then Hide it
						item.classList.add("elm-hidden");
					} else {
						// else if it is Inside Indexes Array and it is Hidden, then Show it
						//if ( item.offsetParent === null ) item.style.display = "block";
						if (item.classList.contains("elm-hidden"))
						item.classList.remove("elm-hidden");
		
						//high-light the matched text
						sHighlite.highlight(item);
					}
				});
		
				//Hide all optGroup that doest not have any matched options. Expand all optGroups having matched option(s).
				sddDropdownContent.querySelectorAll("DIV.optgroup")
					.forEach((_optGroup) => {
						if ( _optGroup.querySelectorAll( "section > .sdd-dropdown-item:not(.elm-hidden)" ).length == 0 )
							_optGroup.classList.add("elm-hidden");
						//else expand the optGroup
						else _optGroup.querySelector('[id^="grpChkbox"]').checked = true;
					});
		
				//toggle show/hidden of no-results option if there no match or not
				sddDropdownContent.querySelector("DIV.no_results").classList.toggle("elm-hidden", matchedItems.length > 0);

				//make the first matched option to be the currently active one
				if (matchedItems.length > 0) {
					if( matchedItems.includes(_selectedItem) )
						setActiveOption(_selectedItem, true, false) //if there is seletedItem, make it active. If scroll to middle, the UI freeze on iOS
					else
						setActiveOption(matchedItems[0]); //otherwise, make the first one active
				}

				evt && evt.stopPropagation();
			}
	
			// Close Dropdown if Clicked Outside Dropdown Element
			function closeIfClickedOutside(evt) {
				if ( !sddDropdownWrapper.classList.contains("elm-hidden") &&
					evt.target.closest(".sdd-wrapper") !== _sddWrapper 
					//evt.target !== _sddWrapper &&
				)  {
					//this close the dropdown but don't clear the search. Note that if click on representativeDiv, it also close the dropdown but clear the search also
					/* sddDropdownWrapper.style.opacity = 0; */
					//setTimeout(() => sddDropdownWrapper.classList.add("elm-hidden"), 600);
					toggleDropdown(-1); //with param -1, the dropdown would be collapsed without clearing search box
				}
			}
	
			/** toggle all option groups. There two place invoked this function:
			 * 1. When user click the .close-open-groups-button 
			 * 2. On onkeydown function which handle event when user press Tab or Shift + Tab
			 * @param evt: the event, not really necessary here
			 * @param type {number}: 
				* 	0 or missing, close or opens all optgroups (depending on the last state the button open or close or partially close)
				* 	1: close all optGroups except the one containing selected option and the one containing active option
			*/
			function toggleOptGroups(evt, type){
				const _toggleButton = sddInputWrapper.querySelector(".close-open-groups-button");
				
				const allChkboxElem = sddDropdownContent.querySelectorAll("div.optgroup > input[type='checkbox']");
				if(allChkboxElem.length === 0) return; //no optgroup at all
				
				/* order: open -> close all but selected+active -> close all. So _state has 3 states:
				*	0: open all optgroups
			 	* 	1: close all optGroups except the one containing selected option and the one containing active option
			 	* 	2: close all optgroups */
				let _state;
				//user click from button
				if(type == undefined){ //user click '.close-open-groups-button' button
					_state = _toggleButton.dataset.toggleState ?? 0; //if attribute "data-toggleState" not exists yet, make it to be 0, so when click, all optGroups closed except one containing active or selected options

					//get next state and update to the button
					_toggleButton.dataset.toggleState = _state = (parseInt(_state) + 1) % 3;
					
				}
				else {//called from onKeyDown()
					//Shift+Tab
					if(type == 1) _state = 1; //so when click button, all close except selected + active

					//Tab only
					if(type == 0){ //open or close
						_state = _toggleButton.dataset.toggleState ?? 0;
						_state = (parseInt(_state) + 1) % 3;
					}
					
					//update new state to the button
					_toggleButton.dataset.toggleState = _state;
				}

			
				/* //toggle all optGroups: open all if currenly less than half are opened and vice versa
				const checkedCount = [...allChkboxElem].reduce( (count, _chkBox) => count+(_chkBox.checked), 0 ); //count number of expanded group
				
				//expand all groups if less than half of group currently expand
				const toChecked = checkedCount < allChkboxElem.length /2; 
				*/
				
				const toChecked = (_state == 0);
				//open (_state==0) or close (_state = 1 or 2) all group
				allChkboxElem.forEach(chkBox => chkBox.checked = toChecked);

				if(_state == 1){ // all optGroups are closed, now just open one containing selected and active
					//open group that contains selected and active option
					sddDropdownContent.querySelectorAll("div.optgroup > input[type='checkbox']:has( +label+section>.sdd-dropdown-item:is(.is-selected,.is-active) )").forEach(chkBox => chkBox.checked = true);
				}

				//if all or some optGroups opens, scroll to selected option
				if(_state == 0 || _state == 1) setTimeout( scrollToOption.bind(null,_selectedItem, 'smooth', true), 800); //wait for animation to finish, then scroll. On CSS, set the animation time is 500ms
				
				evt && evt.stopPropagation();
			}

			/* .clear-input-button event handler */
			function clearSearchButtonClick(evt){
				//https://stackoverflow.com/questions/75686162/javascript-unable-to-set-focus-to-a-dynamically-created-textbox suggest that put it setTimeout might work
				setTimeout(_ => sddSearchBox.focus(), 0);
				clearSearch(evt);				
			}
			
			/* Function hook to mousemove event to restore :hover effect for sdd option after it is disabled by keydown event on search box */
			function restoreHoverOnOption(){
				//add the class so that hover is re-effective on option
				if(!sddDropdownContent.classList.contains("allow-hover-on-item"))
					sddDropdownContent.classList.add("allow-hover-on-item");
			}
			
			/** Function to switch search mode from Exact search and diacritics Search
			 * @param _evt_forcedState {missing or boolean}:
			 * 	- if missing: this function just do the swap state 
			 * 	- if is an event: this function is invoked from '.search-diacritics-option-button' button event handler (see sddRegisterEvents, sddUnregisterEvents below) or by hotkey in onKeyDown() event handler , so it just do the swap state and change button appearance
			 * 	- if a boolean specified, this function force _settings.diacriticsFilterMode to be its value and change the button appearance, accordingly.
			 */
			function setDiacriticsFilterMode(_evt_forcedState){
				const _sddDiacriticsOptionBtn = sddInputWrapper.querySelector(".search-diacritics-option-button");
				
				if(_evt_forcedState !== undefined){ //missing param, nothing to set
					if(_evt_forcedState == event){
						//called from button event handler
						_settings.diacriticsFilterMode =  !_settings.diacriticsFilterMode;

						//invoke the callback function to tell outside the changes of search mode
						if("function" == typeof _settings.callbacks.diacriticsFilterModeOnChanged) _settings.callbacks.diacriticsFilterModeOnChanged(_settings.diacriticsFilterMode);
					}
					else if(typeof _evt_forcedState == "boolean"){
						//forced state
						_settings.diacriticsFilterMode = _evt_forcedState;

						//invoke the callback function to tell outside the changes of search mode
						if("function" == typeof _settings.callbacks.diacriticsFilterModeOnChanged) _settings.callbacks.diacriticsFilterModeOnChanged(_settings.diacriticsFilterMode);
					}
					//change diacritics mode of SearchHighlite
					sHighlite.diacriticsFilterMode = _settings.diacriticsFilterMode;
					//re-filter items
					filterItems();
				}
				
				//changne appearance of the button
				_sddDiacriticsOptionBtn.classList.toggle("search-diacritics-exactSearch", !_settings.diacriticsFilterMode);

				_sddDiacriticsOptionBtn.dataset.tooltip = _settings.diacriticsFilterMode ? "Chữ nét, nền vàng: Tìm kiếm bỏ dấu cả từ tìm (keyword) và đích tìm.\nVí dụ: nếu cần tìm 'hoàn Kiếm' hoặc 'Hoàng Kiệm' gõ 'hoan kiem', 'Họa KiẾM' hoặc 'hÓan kIêm' đều tìm được" : "Chữ nhòe: tìm kiếm nguyên dấu.\nVí dụ muốn tìm 'Hoàn Kiếm' thì phải gõ 'Hoàn Kiếm', nếu chỉ gõ 'Hoan Kiếm' sẽ không tìm ra."
			}

			/** HELPER FUNCTIONS */
	
			/** align right all sub-elements having attribute [data-rAlignGroup] inside of element (such as an option) inside a collection (such as SDD content which contains multiple optGroups, each optGroup contains multiple options). This function will right-align for each type of [data-rAlignGroup] sub-element of element (such as options) for all options inside a _container (can be whole SDD or each optGroup) 
			This function is set public below for using outside of this class, such as for #elmPlaylist or #lstBookTitlesSetting
			* @param _container {HTMLElement}: the container element such as whole SDD or a optGroup. For outside, it can be the whole ol or a section which store chapters for a chapGroup
			* @param _subContainerElemQueryStr {string}: the query string that _container can get the sub-container elements (which each in turn contains sub-sub-elements having [data-rAlignGroup] - those who need to be right-align). For example, for SDD _subContainerElemQueryStr can be "div.sdd-dropdown-item" which points to options. For playlist, _subContainerElemQueryStr can be "li" which point to list-items, each contains infor for a chapter
			*/
			const _rightAlignElems = (_container, _subContainerElemQueryStr = "div.sdd-dropdown-item") => {
				// get all sub-container (e.g, each of them is one SDD option div.sdd-dropdown-item or #elmPlaylist.li)
				const _allSubContainers = _container.querySelectorAll(_subContainerElemQueryStr);
				// if there is no more than 1 item, there is nothing to match right-align with
				if(_allSubContainers.length <= 1) return;

				// take one option and looking for elements inside that option having attribute [data-rAlignGroup], these elements should be the one that need align right. Get all that element into an array in form of query selector, looks like:  ["EM[data-rAlignGroup = 'itemOrder']", "CODE[data-rAlignGroup = 'chapterDuration']"], each item of _alignElemTags will looks like: { "tagName": "EM", "attrId": "itemOrder", "elemsArray": [], "maxWidth": 0 }
				const _alignElemTags = 
				Array.from(_allSubContainers[0].querySelectorAll("[data-rAlignGroup]")) //Array.from is the fastest way to create an Array from a NodeList
					.map(elem => {return {tagName: elem.tagName, attrId: elem.dataset.raligngroup, elemsArray:[], maxWidth:0 } });

				//go through all options, in each option find all elements having [data-rAlignGroup], collect them into some array (each type on one array) and by the same time, measure the max-Width of each array
				_allSubContainers.forEach(_option => {
					//in each option, find elements having[data-rAlignGroup] attribute, collect them into an array (elemsArray) and find the max-Width maxWidth
					_alignElemTags.forEach(_tag => {
						const queryStr = _tag.tagName + "[data-rAlignGroup = '" + _tag.attrId + "']";
						//the right-align element inside current option
						const _elem = _option.querySelector(queryStr);
						_tag.elemsArray.push(_elem); //collect elements
						_tag.maxWidth = Math.max(_tag.maxWidth, _elem.offsetWidth); //get the maxWidth
					});
				});
				
				//align-right for each type of element
				_alignElemTags.forEach(_tag => 
					//align-right for each type of element, with different value of [data-rAlignGroup] attribute
					_tag.elemsArray.forEach(_elem => _elem.style.width = _tag.maxWidth + "px" )
				);
				//clean the temp Array
				_alignElemTags.length = 0;
			}

			/** Sets the dropdown_content scrollTop to display the option 
			 * @param option {element}: the option need to scroll to if it is hidden
			 * @param behavior {string, 'auto'}: the scroll behavior
			 * @param toMiddle {boolean, false}: 
			 * 	if true, scroll so that the {option} locates at middle of dropdown. 
			 *  if false: 	- option is in the view, do nothing
			 * 				- option is hidden above the dropdown, it will be scroll to top of dropdown
			 *  			- option is hidden below the dropdown, it will be scroll to bottom of dropdown
			*/
			function scrollToOption(option, behavior = "auto", toMiddle = false) {
				_scrollToElement(sddDropdownContent, option, behavior, toMiddle);
			}

			/** Sets the dropdown_content scrollTop to display the option
			 * @param container {HTMLElement}: the container where the scroll take place, the one that contains the @option 
			 * @param option {HTMLElement}: the option need to scroll to if it is hidden
			 * @param behavior {string, 'auto'}: the scroll behavior, 'auto' ỏ 'smooth'
			 * @param toMiddle {boolean, false}: 
			 * 	if true, scroll so that the {option} locates at middle of dropdown. 
			 *  if false: 	- option is in the view, do nothing
			 * 				- option is hidden above the dropdown, it will be scroll to top of dropdown
			 *  			- option is hidden below the dropdown, it will be scroll to bottom of dropdown
			*/
			function _scrollToElement(container, option, behavior = "auto", toMiddle = false) {
				if (!option) return;
	
				/** * Scroll the dropdown to the given position * */
				function scroll(scrollTop, behavior) {
					if (behavior) {
						container.style.scrollBehavior = behavior;
					}
					container.scrollTop = scrollTop;
					container.style.scrollBehavior = "";
				}
	
				const _containerHeight = container.clientHeight;
				const scrollTop = container.scrollTop || 0;
				const _itemHeight = option.offsetHeight;
				// y-coord: the distance of option top to container top
				const y =
					option.getBoundingClientRect().top -
					container.getBoundingClientRect().top +
					scrollTop;
	
				//scroll to middle
				if (toMiddle)
					return scroll(y - _containerHeight / 2 + _itemHeight, behavior);
	
				//otherwise, scroll so that option is inside the view
				if (y + _itemHeight > _containerHeight + scrollTop) {
					scroll(y - _containerHeight + _itemHeight, behavior); //option at bottom
				} else if (y < scrollTop) {
					scroll(y, behavior); //option at top
				}
				//otherwise: option is inside the view, keep it that way
			}

			/** Glowing element for 1 second  */
			const _glowingElem = _elem => {
				//glowing the element
				_elem.classList.add("glowing-border");
				/* setTimeout(_ => {
					_elem.classList.remove("glowing-border");
				}, 900); //hide the glowing after 1 sec */

				//hide the glowing after animation end (note that animation-iteration-count of .glowing-border is set to 1)
				_elem.addEventListener("animationend", function _tmp_glowing_end(evt){
					//console.log(`animation ended: \t ${evt.animationName}\t ${evt.elapsedTime}\t ${evt.pseudoElement}`);
					_elem.removeEventListener("animationend", _tmp_glowing_end);
					_elem.classList.remove("glowing-border");
				});
			}			
	
			/** Class to search and highlight matched strings
				@param queryStr {string} string to search, can contains multiple words separated by space (\s+), each word will be matched separatedly.
				@param diacriticsFilterMode {boolean}: false - search exactly queryStr (with breaking into words, of course)
					true: - removed diacritics from both searchStr and textContent (searched String) before matching
			*/
			function SearchHighlite(diacriticsFilterMode) {

				let _diacriticsFilterMode = diacriticsFilterMode ?? false;
				/* get/set the diacriticsFilter mode. true: filter diacritics before searching. false: no filter */
				Object.defineProperty(this, "diacriticsFilterMode", {
					get() {
						return _diacriticsFilterMode;
					},
					set(val) {
						_diacriticsFilterMode = Boolean(val);
					}
				});

				/* TODO: add case-sensitive and case-insensitive mode if needed. This require modify asciifold */

				/** Search mode: the algorithm to break string into word when searching. This mode and _diacriticsFilterMode would define how to match searched result. For now, all the search is case-insensitive.
				 * Default is Break mode*/
				const _WORD_MODE = Object.freeze({
					/* The mode that seach string is all number and \. (can add more separate letter when needed)(regex = /^[\d.]+$/). This mode is mostly used for searching the order number of an SDD option. Beside that, this mode is only used for decoration. E.g, keyword '123' or '123.' would automatically turn this mode on */
					'Number': 'Số',
					/* This is default mode, in which the keyword is broken into words (using space as seperator char), then match the content to each word. So, any content that match all those words (in any order) would be considered as matched content. E.g, keyword 'hoàn kiếm' would match 'Hoàn Kiếm' or 'Hoang phí vs Tiết Kiệm' when _diacriticsFilterMode = true */
					'Break': 'Khớp từ',
					/* if keyword is all capital-letter, this mode is turned on. In this mode, the keyword is broken into letters, then any content that having substring that having first letter of adjacent word match each letters of keyword (in the same order) would be considers as matched content. E.g: keyword 'HP'would find 'Harry potter' but not 'Phuong Hoang'  */
					'FirstLetter': 'Chữ cái đầu',
					/* if keyword is all lower-case-letter, this mode is turned on. In this mode, if content has substring (which starts as whole word) that matches the keyword, it is considered as matched. E.g, when _diacriticsFilterMode = true: keyword 'chi dien' would match 'Tam Quốc Chí Diễn Nghĩa' but keyword 'hi dien' (not start as whole word) or 'diễn chí' (not match the order of words) would not match that content */
					'Phrase': 'Cụm từ'
				});

				/* The word mode when searching to define how to match keyword with words in the content, could take one of modes in _WORD_MODE enum */
				let _wordSearchMode = _WORD_MODE.Break;
				/* get the word search mode. This mode depends on the keyword (number, all lower case, all upper case, mixed-case) and is set in makeSearchRegex() function */
				Object.defineProperty(this, "wordMode", {
					get() {
						return _wordSearchMode;
					},
					/* set(val) {
						_wordSearchMode = val;
					} */
				});

				//break queryStr into keys
				let _searchKeys = [];
				/** get/set the queryString.
				 * @get : return the searchKeys that being broken-up from queryStr
				 * @set : set searchKeys from queryStr that usable for other function such as matchSearch or highlight. This set is usually called from filterItems() when there is new queryString, this call by the same time will break queryString into _searchKeys
				 */
				Object.defineProperty(this, "queryString", {
					get() {
						return _searchKeys;
					},
					set(queryStr) {
						_searchKeys = queryStr2RegexWords(queryStr);
					}
				});

				/* const removeVnAccents = (vnStr) => {
					const _repArr = [
						[/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a"],
						[/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e"],
						[/ì|í|ị|ỉ|ĩ/g, "i"],
						[/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o"],
						[/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u"],
						[/ỳ|ý|ỵ|ỷ|ỹ/g, "y"],
						[/đ/g, "d"],
						[/À|Á|Ạ|Ả|Ã|Â|Ầ|Ấ|Ậ|Ẩ|Ẫ|Ă|Ằ|Ắ|Ặ|Ẳ|Ẵ/g, "A"],
						[/È|É|Ẹ|Ẻ|Ẽ|Ê|Ề|Ế|Ệ|Ể|Ễ/g, "E"],
						[/Ì|Í|Ị|Ỉ|Ĩ/g, "I"],
						[/Ò|Ó|Ọ|Ỏ|Õ|Ô|Ồ|Ố|Ộ|Ổ|Ỗ|Ơ|Ờ|Ớ|Ợ|Ở|Ỡ/g, "O"],
						[/Ù|Ú|Ụ|Ủ|Ũ|Ư|Ừ|Ứ|Ự|Ử|Ữ/g, "U"],
						[/Ỳ|Ý|Ỵ|Ỷ|Ỹ/g, "Y"],
						[/Đ/g, "D"],
						[/[\u0300-\u036f]/g, ""],
					]; // Remove combining diacritical marks
					_repArr.forEach(
						(_rep) => (vnStr = vnStr.replace(_rep[0], _rep[1]))
					);
					return vnStr;
				}; */
	
				/* Adapt from https://github.com/brianreavis/sifter.js/blob/master/lib/sifter.js#L36 and https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.base.js */
				const asciifold = (function () {
					const DIACRITICS = {
						0: "߀",
						a: "àáạảãâầấậẩẫăằắặẳẵÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄⱥɐɑ",
						b: "␢βΒB฿𐌁ᛒƀɓƃ",
						c: "ĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃꜿƈȼↄ",
						d: "đĐĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄðđɗɖᴅƌꮷԁɦ",
						e: "èéẹẻẽêềếệểễÈÉẸẺẼÊỀẾỆỂỄÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐεɛǝᴇɇ",
						f: "ƑƒḞḟꝼƒ",
						g: "ɢ₲ǤǥĜĝĞğĢģƓɠĠġǥɠꞡᵹꝿɢ",
						h: "ĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕħⱨⱶɥ",
						i: "ìíịỉĩÌÍỊỈĨÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉɨı",
						j: "ȷĴĵɈɉʝɟʲɉȷ",
						k: "ƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭ƙⱪꝁꝃꝅꞣ",
						l: "ŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌłƚɫⱡꝉꝇꞁɭ",
						n: "ŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋꞥƞɲꞑᴎлԉ",
						o: "òóọỏõôồốộổỗơờớợởỡÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօøǿɔɵꝋꝍᴑ",
						p: "ṔṕṖṗⱣᵽƤƥᵱƥᵽꝑꝓꝕρ",
						q: "ꝖꝗʠɊɋꝘꝙq̃ꝗꝙɋ",
						r: "ŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽɍɽꝛꞧꞃ",
						s: "ŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈ßȿꞩꞅʂ",
						t: "ŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭŧƭʈⱦꞇ",
						u: "ùúụủũưừứựửữÙÚỤỦŨƯỪỨỰỬỮŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪ʉ",
						v: "ṼṽṾṿƲʋꝞꝟⱱʋʋꝟʌ",
						w: "ẂẃẀẁŴŵẄẅẆẇẈẉⱳ",
						x: "ẌẍẊẋχ",
						y: "ỳýỵỷỹỲÝỴỶỸÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴƴɏỿ",
						z: "ŹźẐẑŽžŻżẒẓẔẕƵƶƶȥɀⱬꝣ",
						"/": "⁄∕",
						aa: "ꜳ",
						ae: "æǽǣ",
						ao: "ꜵ",
						au: "ꜷ",
						av: "ꜹꜻ",
						ay: "ꜽ",
						m: "ɱɯϻ",
						oe: "œ",
						oi: "ƣ",
						oo: "ꝏ",
						ou: "ȣ",
						th: "þ",
						tz: "ꜩ",
						vy: "ꝡ",
						hv: "ƕ",
					};
	
					let foreignletters = "";
					let lookup = {}; //map each foreign letter to latin letter
					for (const k in DIACRITICS) {
						if (DIACRITICS.hasOwnProperty(k)) {
						const chunk = DIACRITICS[k]; //.substring(2, DIACRITICS[k].length - 1);
						foreignletters += chunk;
						for (let i = 0, n = chunk.length; i < n; i++) {
						lookup[chunk.charAt(i)] = k;
						}
						}
					}
					let regexp = new RegExp("[" + foreignletters + "]", "g");
					return function (str) {
						return str
						.replace(regexp, function (foreignletter) {
							return lookup[foreignletter];
						})
						.toLowerCase();
					};
				})();
	
				/** Function to keep diacratics or normalize string and convert (almost) all dicratic unicode chars (which can see in Vietnamese, Polish,.., language) into 26-letter latin characters 
				 * @param txtContent {string}: the string need to removed diacratics (or not, depending on _diacriticsFilterMode mode, and value of forceRemoveDiacratics)
				 * @param forceRemoveDiacratics {boolean}: if true (default false), it force to remove diacritics no matter what the value of _diacriticsFilterMode
				*/
				const uni2Latin = (txtContent, forceRemoveDiacratics = false) => {
					txtContent =  txtContent.replaceAll(/\s\s+/g, " ").trim();

					//if diacriticsFilterMode, just return lower case string
					if(!_diacriticsFilterMode && !forceRemoveDiacratics) return txtContent.toLowerCase();

					// NFC — Normalization Form Canonical Composition. — Dựng Sẵn (mặc định)
					// NFD — Normalization Form Canonical Decomposition. — Tổ Hợp
					txtContent = txtContent.normalize("NFC").toLowerCase();

					return asciifold(txtContent); //removeVnAccents(txtContent); //
				};
	
				/** Prepare list of string-regex keywords that ready for regex matching. Depending on @queryStr , this also decide the word-search mode
				 * @param queryStr {string}: the search string that used as keyword to search through the SDD
				 * @return an {array of string}: depending on the queryStr, a corresponding mode would turn on (see the comments in _WORD_MODE enum and the code below)
					* @mode FirstLetter: array of regex so that each item correspond with one upper-case letter in Query string
					* @mode Phrase: array of one string that match (in the way of indexOf matching) query string
					* @mode Number and Break: break queryStr into list of keywords, sort by decending order of keyword length. Function returns array of all keyword which are separated by space in queryStr, with converting special escape character like ^$\...
				*/
				function queryStr2RegexWords(queryStr) {
					if (!queryStr) return null;
					queryStr = queryStr.trim();
					// all the chars including diacritics, got from https://stackoverflow.com/questions/30225552/regex-for-diacritics
					const _allLeters = '[A-zÀ-ÖØ-öø-įĴ-őŔ-žǍ-ǰǴ-ǵǸ-țȞ-ȟȤ-ȳɃɆ-ɏḀ-ẞƀ-ƓƗ-ƚƝ-ơƤ-ƥƫ-ưƲ-ƶẠ-ỿ]';
					const _matchLeterRegex = new RegExp(_allLeters, 'iu');

					//Decide which wword-search mode should be
					//if queryStr is all numbers and '.', it is in number mode
					if(queryStr.match(/^[\d.]+$/))
						_wordSearchMode = _WORD_MODE.Number;
					//if queryStr is all capital chars, then we are in search by first char mode
					else if( queryStr.length > 1 && _matchLeterRegex.test(queryStr) && queryStr == queryStr.toUpperCase() )
						_wordSearchMode = _WORD_MODE.FirstLetter
					else if( queryStr.length > 1 && _matchLeterRegex.test(queryStr) && queryStr == queryStr.toLowerCase() )
						_wordSearchMode = _WORD_MODE.Phrase
					//Otherwise, it is in match word-by-word mode
					else _wordSearchMode = _WORD_MODE.Break;
					//console.log('_wordSearchMode = ' + _wordSearchMode);
	
					//force asciifold if _searchByFirstChar mode is true
					queryStr = uni2Latin(queryStr);
	
					const escape_regex = (str) => {
						return (str + "").replace(
						/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu,
						"\\$1"
						);
					};
	
					//break search string into keyword, and sort by decending order of the length of keyword
					let searchKeys;
					if(_wordSearchMode == _WORD_MODE.FirstLetter){
						const _word = _diacriticsFilterMode? '[A-z]*' : _allLeters + '*';//'[\\w]*'; //'[^\\s]*'
						searchKeys = queryStr.replace(/\s/g,"").split('').map((key) => escape_regex(key) + _word);
					}
					else if(_wordSearchMode == _WORD_MODE.Phrase){
						searchKeys = [queryStr.replace(/\s{2,}/g, " ").trim()];

					}
					//number and break mode
					else searchKeys = queryStr
						.trim()
						.split(/\s+/)
						.map((key) => escape_regex(key))
						.sort((a, b) => b.length - a.length);
	
					return searchKeys;
				}

				//list all chars can be identified as word seperator. In future, can add more char to this list
				const _char_separator = '[\\s\\$\\(\\)\\*\\-–—\\+,;\\.!&*\\?\\[\\]\\^\\{\\|\\}\\\\]';
				/** Function to create regex for first-char mode, which require every char in queryStr is capital, each has to be the first char of adjacent word in order to be matched */
				const makeFirstCharModeRegEx = (searchKeysArray) => {
					
					//TODO: can extend word-separator to include more 
					const _word_seperator = '\\s+'; //`${_char_separator}+`;//
					//because of diacritics, we have to use naive '(?<=^|\\s)' or a bit more complex as code below instead of simple but powerful '\\b' to match the begin of word, so make sure it not middle of a word (such as if we find a word start with 'H', it match 'Hưng', but not match 'Nhưng')
					const _markBegin = _diacriticsFilterMode? "\\b" : `(?<=^|${_char_separator})`;
					const _markEnd = _diacriticsFilterMode? "\\b" : `(?=${_char_separator}|$)`;
					return new RegExp(_markBegin + searchKeysArray.join(_word_seperator) + _markEnd, "iu");
				}

				/** Function to create regex for first-char mode, which require every char in queryStr is capital, each has to be the first char of adjacent word in order to be matched */
				const makePhraseModeRegEx = (searchKeysArray) => {
					
					//TODO: can extend word-separator to include more 
					const _word_seperator = '\\s+'; //`${_char_separator}+`;//
					//because of diacritics, we have to use naive '(?<=^|\\s)' or a bit more complex as code below instead of simple but powerful '\\b' to match the begin of word, so make sure it not middle of a word (such as if we find a word start with 'H', it match 'Hưng', but not match 'Nhưng')
					const _markBegin = _diacriticsFilterMode? "\\b" : `(?<=^|${_char_separator})`;
					//const _markEnd = _diacriticsFilterMode? "\\b" : `(?=${_char_separator}|$)`;
					return new RegExp(_markBegin + searchKeysArray.join(_word_seperator), "iu");
				}

				/** Match function to match search string to text content. Depending on word-search mode, the algorithm are different. For example, in Break mode, the algorithm using AND operator to match all keywords (each is seperated by space in searchStr)
				@return:  false if not match
						true: if searchStr empty or matched
				*/
				function matchSearch(searchKeys, txtContent) {
					if (!searchKeys) return true;
	
					txtContent = uni2Latin(txtContent);	
					
					let isMatched;
					if(_wordSearchMode == _WORD_MODE.FirstLetter){
						const regEx = makeFirstCharModeRegEx(searchKeys);
						isMatched = regEx.test(txtContent);
					}
					else if(_wordSearchMode == _WORD_MODE.Phrase){
						const regEx = makePhraseModeRegEx(searchKeys);
						isMatched = regEx.test(txtContent);
					}
					//number and Break mode
					else
						//txtContent has to match all keywords (logically AND)
						isMatched = searchKeys.reduce((ismatch, key) => {
							//if it not match in previous key testing, just return false without needing check any other key
							if(!ismatch) return false;

							const regEx = new RegExp(`(${key})`, "i");
							return (ismatch &= regEx.test(txtContent));
						}, true);
	
					return !!isMatched;
				}
	
				/* Highligt matched text */
				const highlightOneKey = (elem, regex) => {
					if (regex === null) return;
	
					/** * Replace a node */
					const replaceNode = (existing, replacement) => {
						if (existing.parentNode)
						existing.parentNode.replaceChild(replacement, existing);
					};
	
					// convet string to regex
					if (typeof regex === "string") {
						if (!regex.length) return;
						regex = new RegExp(regex, "i");
					}
	
					// Wrap matching part of text node with highlighting <span>, e.g.
					// Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i
					const highlightText = (node) => {
						var match = uni2Latin(node.data).match(regex);
						if (match && node.data.length > 0) {
						var spannode = document.createElement("span");
						spannode.className = "highlight";
						var middlebit = node.splitText(match.index);
						middlebit.splitText(match[0].length);
						var middleclone = middlebit.cloneNode(true);
						spannode.appendChild(middleclone);
						replaceNode(middlebit, spannode);
						return 1;
						}
						return 0;
					};
	
					// Recurse element node, looking for child text nodes to highlight, unless element is childless, <script>, <style>, or already highlighted: <span class="hightlight">
					const highlightChildren = (node) => {
						if (
						node.nodeType === Node.ELEMENT_NODE &&
						node.childNodes &&
						!/(script|style)/i.test(node.tagName) &&
						(node.className !== "highlight" || node.tagName !== "SPAN")
						) {
						//Node.ELEMENT_NODE = 1
						Array.from(node.childNodes).forEach((element) => {
						highlightRecursive(element);
						});
						}
					};
					const highlightRecursive = (node) => {
						if (node.nodeType === Node.TEXT_NODE) {
						//Node.TEXT_NODE=3
						return highlightText(node);
						}
						highlightChildren(node);
						return 0;
					};
					highlightRecursive(elem);
				};
	
				/**
				 * removeHighlight fn copied from highlight v5 and
				 * edited to remove with(), pass js strict mode, and use without jquery
				 */
				const removeHighlight = (elem) => {
					var elements = elem.querySelectorAll("span.highlight");
					Array.prototype.forEach.call(elements, function (el) {
						var parent = el.parentNode;
						parent.replaceChild(el.firstChild, el);
						parent.normalize();
					});
				};
	
				//SearchHighlite.prototype.removeHighlight = removeHighlight;

				/* public functions that bind to current {queryStr} */
				//word-search mode enum
				this.WORD_MODE = _WORD_MODE;
				//remove old hightlight from element
				this.removeHighlight = removeHighlight;
				//check to see if an element match the search or not
				this.matchSearch = (txtContent) => {
					return matchSearch(_searchKeys, txtContent);
				};
				//hightlight part of matched search for an element
				this.highlight = (elem) => {
					if(_wordSearchMode == _WORD_MODE.FirstLetter){
						const regEx = makeFirstCharModeRegEx(_searchKeys);
						highlightOneKey(elem, regEx);
					}
					else if(_wordSearchMode == _WORD_MODE.Phrase){
						const regEx = makePhraseModeRegEx(_searchKeys);
						highlightOneKey(elem, regEx);
					}
					else 
					_searchKeys.forEach((regexKey) => highlightOneKey(elem, regexKey));
				}
	
				/* return {					
					//makeSearchRegex: makeSearchRegex,
					removeHighlight: removeHighlight,
					matchSearch: (txtContent) => {
						return matchSearch(_searchKeys, txtContent);
					},
					highlight: (elem) =>
						_searchKeys.forEach((regexKey) => highlightOneKey(elem, regexKey))
				}; */
			}
			
			/* PUBLIC FUNCTIONS */
			/* Add event handlers for all inner controls of search-dropdown element */
			let sddRegisterEvents = () => {
				//event delegation for dropdown _items
				sddDropdownContent.addEventListener( "click", dropdownItemClickDelegation );

				//for now, main job of mousemove on sddDropdownContent is to restore hover effect on options
				sddDropdownContent.addEventListener( "mousemove", restoreHoverOnOption );

				representativeDiv.addEventListener("click", toggleDropdown);
		
				// Add Input Event to Search Input Element to Filter Items
				sddSearchBox.addEventListener("input", filterItems);
		
				// add keydown event to handle up/down, enter, esc,.. keys
				sddSearchBox.addEventListener("keydown", onKeyDown);
		
				// Add Click Event to Element to Close Custom Dropdown if Clicked Outside
				document.addEventListener("click", closeIfClickedOutside);

				/* Buttons */
				//handler for toggle all optGroups button
				sddInputWrapper.querySelector(".close-open-groups-button").addEventListener("click", toggleOptGroups);

				//handler for jump to selected option
				sddInputWrapper.querySelector(".jump-to-selected-item-button").addEventListener("click", _ => getAdjacent(_selectedItem, 0)); //setActiveOption(_selectedItem, true, true)

				//handler for show/hide 2nd extra title for each option
				const _toggel_extra_title_button = sddInputWrapper.querySelector(".close-open-extra-title-button");
				_toggel_extra_title_button.addEventListener("click", _ => {
					if(!_toggel_extra_title_button.hasAttribute("extra-title-toggle"))
						_toggel_extra_title_button.setAttribute("extra-title-toggle", 'shown')
					else
						_toggel_extra_title_button.removeAttribute("extra-title-toggle");

					_sddWrapper.classList.toggle("hideOptionExtraTitle");
				});

				//handler for clear Search box button
				sddInputWrapper.querySelector(".clear-input-button").addEventListener("click", clearSearchButtonClick);

				//handler search-diacritics-option button
				sddInputWrapper.querySelector(".search-diacritics-option-button").addEventListener("click", setDiacriticsFilterMode);
			};
	
			/* sddUnregisterEvents function of main class used to remove all event listeners when search-drop-down elements is removed or replaced */
			let sddUnregisterEvents = () => {
				//Remove event delegation for dropdown _items
				sddDropdownContent.removeEventListener( "click", dropdownItemClickDelegation );
				sddDropdownContent.removeEventListener( "mousemove", restoreHoverOnOption );
		
				representativeDiv.removeEventListener("click", toggleDropdown);
		
				// Remove Input Event to Search Input Element to Filter Items
				sddSearchBox.removeEventListener("input", filterItems);
		
				// Remove keydown event to handle up/down, enter, esc,.. keys
				sddSearchBox.removeEventListener("keydown", onKeyDown);
		
				// Remove Click Event to Element to Close Custom Dropdown if Clicked Outside
				document.removeEventListener("click", closeIfClickedOutside);

				//handler for toggle all optGroups button
				sddInputWrapper.querySelector(".close-open-groups-button").removeEventListener("click", toggleOptGroups);

				//handler for clear Search box button
				sddInputWrapper.querySelector(".clear-input-button").removeEventListener("click", clearSearchButtonClick);

				//handler search-diacritics-option button
				sddInputWrapper.querySelector(".search-diacritics-option-button").removeEventListener("click", setDiacriticsFilterMode);

				//because of my lazy, for now I miss unregitered event handler for .jump-to-selected-item-button button and .close-open-extra-title-button button
			};
	
			/* Set selected item for the dropdown
				@param option:
				number: select by index of item. Same as set sdd.selectedIndex
				string:: select by value of item. Same as set sdd. value
				HTML element: select by the element itself
			*/
			let selectItem = (option, seizeOnChange = false) => {
				/* number: select by index of item */
				if (typeof option === "number") {
					const _index = option;
					if (_index < 0 || _index >= _items.length) {
						console.warn("SDD selectedIndex set: index out of bound");
						return null;
					} else return setSelected(_items[_index], seizeOnChange);
				}
	
				/* string:: select by value of item. */
				if (typeof option === "string") {
					let value = option.toString().toLowerCase().trim();
					if (!value) {
						console.warn("SDD value set: no value to set");
						return null;
					}
					let foundItem = _items.filter(
						(item) => item.value.toLowerCase() == value
					);
					if (foundItem.length == 0) {
						console.warn("SDD value set: no such value");
						return null;
					}
					return setSelected(foundItem[0], seizeOnChange);
				}
	
				/* element: select by the element itself */
				if (typeof option === "object" && option instanceof HTMLElement) {
					if (_items.indexOf(option) == -1) option = _items[0];
					return setSelected(option, seizeOnChange);
				}
			};
			
			/* Load Mode enum to define some mode for loadDropdown() */
			const loadSDDMode = Object.freeze({
				SettingLoadOnly: "justSomeSettings", //load the setting, usually used for SDD that has fix setting but different data loads multiple time, such as sddChaptersList
				DataLoadOnly: "loadDataOnly", //use to load data multiple time after setting is initially loaded
				All: "SettingsAndData" //load both setting and data at the same time. This is mostly used for SDD that share by different kind of data, such as ssData.sddBookTitlesList (grpLine = 0 has different data format, callbacks, render function than grpLine = 1;2)
			});

			/** populate the data and functionalities for dropdown 
			 * @param _settingParam {json, required}: can be just the setting, can be just the data {option, optgroups} or all the setting, depending the @param loadMode
			 * @param loadMode {SddDropdown.LOAD_MODE_ENUM, optional - default loadSDDMode.All} to specify which mode to load. See enum loadSDDMode above for details
			 * @param initSelectedItem {integer, string, HTMLElement - optional}: the index, value or Div.sdd-dropdown-item option for the item to be set selected when SDD just got populated. See selectItem() function for the requirement of this param
			*/
			function loadDropdown(_settingParam, loadMode = loadSDDMode.All, initSelectedItem){
				if ("object" !== typeof _settingParam) 
					return console.error("Search-Dropdown need to be initialized with a setting parameter");
				
				/* make SETTING */
				if(loadMode !== loadSDDMode.DataLoadOnly){
					//Default outer properties of setting
					const _DEFAULT_PROPS = {
						displayOneLine: false, //sdd display on only one line when close
						makeSelectKey: "Ctrl + Shift", //the key that would make active option immediately becoming selected option. See keydown event for more
						maxHeight: [400, 900], // the range for max-height of dropdown menu (div.sdd-dropdown-content - part that contains all options) when it is open. the height of SDD is set so that its bottom, when expanded, almost reaches to bottom of viewport. If the set-height out of this range, the height will be set to either end of the range.
						//backgroundCSSClass: null, //specify class that would decorate background for SDDDropdownContent. If not specified, the default class for background is .circus-background
						customizedCssClass: null, //this specify the customized css class for components of SDD, this should be a string that specify the name of customized class applied for whole .sdd-wrapper container. If we need to change the css for any component inside .sdd-wrapper, in CSS code we specify the query-selector path for that component and put css for that component inside that path. See changeBook() function for this customized setting for ssData.sddChaptersList
						searchBoxPlaceholder: "Search in {_items_length} items ...", //🔍 the text that will display as placeholder in search textbox, where {_items_length} would be replaced by the number of items of this dropdown
						statusBarTimeout: 5000, //the duration in ms that starusBar appear when user filter the items
						rightAlignInEachOptGroup: true, //for elements that having attribute [data-rAlignGroup] (see more in _DEFAULT_RENDER const below), they will be right align in each optGroup (true) or all SDD
						diacriticsFilterMode: true, //option (=false) to search matching with whatever user type in or (=true) removed diacritics from both searchStr and textContent (searched String) before doing the matching
						
						valueField: "value",	//The name of the property to use as the value when an item is selected.
						optgroupField: "gId", //The name of the property to group items by.
						searchField: [], //An array of property names to analyze when filtering options.
					};
					//default render functions
					const _DEFAULT_RENDER = {
						//function to render the option. escape is a buil-in function to escape all  HTML tag special character such as &<>'".... Any element in the rendering HTML which include attribute [data-rAlignGroup] class will be rendered vertically right-align from option to option. The value of [data-rAlignGroup] attribute is used to identify that element across option item, so if an option has multiple element need to right-aligned (that is, having [data-rAlignGroup] attribute), the value of [data-rAlignGroup] attribute of them HAS to be different. Avoid using "itemOrder" as value of [data-rAlignGroup] attribute since it has to be used for <em> element which contains the order of option. See render function in popuGrpBookTitles() for an example
						'option': (data, escape) => {
							return '<span>' + escape(data["label"]) + '</span>';
						},
						//function to extract element from current option to show on representatve DIV {div.sdd-controls}, the one left off sdd when sdd closed
						'select_option': (option, escape) => {
							return '<span>' + escape(option.textContent) + '</span>';
						},
						//function to render the header of option group. 
						'optgroup_header': (data, escape) => {
							return '<span>' + escape(data["label"]) + '</span>';
						},
						//function to render the notification text that notify no-result when search haven't found nothing
						'no_results': () => {
							return '<span>No results found</span>';
						}
					};
					//default render functions
					const _DEFAULT_CALLBACKS = {
						//callback function would be invoked when a new item selected. Note that when assign property {value} and {selectedIndex}, this callback will not be invoked to avoid loop code
						onChange: null,
						//function to notify user if SDD have something that end-user should know (such as select 'disabled item' is not allowed)
						'notify': (message) => {
							toast.showToast(message, toast.ToastType.Warning);
						},
						//callback function which will be invoked every time _setting.diacriticsFilterMode is changed (e.g: when user click on '.search-diacritics-option-button' button). This callback function will has one param, which is new value of _setting.diacriticsFilterMode
						diacriticsFilterModeOnChanged: null
					}

					if(_settingParam.maxHeight){ //if maxHeight properties not array of range, just remove it
						if(!Array.isArray(_settingParam.maxHeight)) delete _settingParam.maxHeight;
					}

					// merge the user-setting with default one
					_settings = {};
					_settings = Object.assign({}, _DEFAULT_PROPS, _settingParam); //outer properties
					_settings.render = Object.assign({}, _DEFAULT_RENDER, _settingParam.render); //render properties
					_settings.callbacks = Object.assign({}, _DEFAULT_CALLBACKS, _settingParam.callbacks); //callbacks properties

					//set customized css class (mostly background) for some SDD component, such as background for SDD Dropdown Content, decoration for SDD-dropdown-bottom-border. See _DEFAULT_PROPS for the detailed explanation, See changeBook() function for this customized setting for ssData.sddChaptersList
					const _customizedCss = _settings.customizedCssClass;
					if(_customizedCss) _sddWrapper.classList.add(_customizedCss);
					
					// class event callbacks
					_onChange = _settings.callbacks.onChange;
					if("function" == typeof _settings.callbacks.notify) _notifyFunction = _settings.callbacks.notify;

					//create sHighlite object that bind to current {searchStr}
					sHighlite = new SearchHighlite(_settings.diacriticsFilterMode);
					//sHighlite.diacriticsFilterMode = _settings.diacriticsFilterMode;

					//set the button appearance according to setting option
					setDiacriticsFilterMode();					
				}
				/* DONE with SETTING */

				/* Load DATA */
				if(loadMode !== loadSDDMode.SettingLoadOnly){
					if(loadMode === loadSDDMode.DataLoadOnly){
						//assign new Data for SDD before populating
						_settings = Object.assign(_settings, _settingParam);
					}

					populateDropdown(initSelectedItem); //generate dropdown options and groups
					
					//new sdd, when open dropdown again, we need to re-caluculate dimension for right-aligned items and re-assign their width property
					_dropdownOpenFirstTime = true;
					//reset state of collapse/expand groups button
					sddInputWrapper.querySelector(".close-open-groups-button").dataset.toggleState = 0;

					//default: select first item, no onChange() event fire
					//if(initSelectedIndex == undefined) selectItem(0, true); 
				}				
			}
	
			/* PUBLIC FUNCTIONS ASSIGNMENT */

			//this.onChange = _onChange;
			//alias of onChange function without parameter
			this.onchange = () => {
				if('function' == typeof _onChange) _onChange(_selectedItem);
			};
	
			//fnc to load new data to existing SDD
			this.loadDropdown = loadDropdown;
			//fnc to select an item by index, value or element itself
			this.selectItem = selectItem;
			this.sddUnregisterEvents = sddUnregisterEvents;
			//public for toggle SDD by keypress
			this.toggle = toggleDropdown;
			
			//function to right-align sub-elements having attribute [data-rAlignGroup]. This is set public below for using outside this class, such as for #elmPlaylist or #lstBookTitlesSetting. This function is quite independent to whole class, so I put it in prototype
			SddDropdown.prototype.rightAlignElems = _rightAlignElems;
			SddDropdown.prototype.scrollToElement = _scrollToElement;

			//function to glowing an element
			//SddDropdown.prototype.glowingElem = _glowingElem;
			//function to glowing the SDD (when it is collapsed)
			this.glowing = _ => _glowingElem(representativeDiv);
			
			//note that following 2 functions will NOT fire onChange() event
			this.nextItem = _ => goAdjacent(1);
			this.prevItem = _ => goAdjacent(-1);
	
			//if _settingParam is specified in SddDropdown, populate dropdown
			if ("object" == typeof _settingParam) loadDropdown(_settingParam);
			
			//register event handlers for sdd to response to user (mouse, keyboard, etc) actions
			sddRegisterEvents();
		}
  
		/* //Usage: const sddDropdown = new SddDropdown(".sdd-container", _setting);
  
		const sddDropdown = new SddDropdown(".sdd-container");
		sddDropdown.loadDropdown(_setting, 5); 
		*/
	</script>

	<!-- SVG ICONS LIBRARY -->
	<svg width="0" height="0" class="elm-hidden" id="core-svg-icon" xmlns="http://www.w3.org/2000/svg">
		<!-- Audio controls icons -->
		<symbol id="icnSvgReload" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 118.66">
			<path
				d="M 16.68,22.2 C 14.9,24.41 13.25,26.75 11.62,29.66 5.63,40.31 3.1,52.39 4.13,64.2 5.14,75.74 9.56,87.03 17.5,96.47 c 2.85,3.39 5.91,6.38 9.13,8.97 11.11,8.93 24.28,13.34 37.41,13.22 13.13,-0.12 26.21,-4.78 37.14,-13.98 3.19,-2.68 6.18,-5.73 8.91,-9.13 6.4,-7.96 10.51,-17.29 12.07,-27.14 1.53,-9.67 0.59,-19.83 -3.07,-29.66 C 115.6,29.4 110.27,21.07 103.31,14.54 96.7,8.33 88.59,3.76 79.2,1.48 76.26,0.77 73.26,0.3 70.21,0.11 c -3.06,-0.2 -6.19,-0.13 -9.4,0.22 -2.01,0.22 -3.46,2.03 -3.24,4.04 0.22,2.01 2.03,3.46 4.04,3.24 2.78,-0.31 5.49,-0.37 8.14,-0.19 2.65,0.17 5.23,0.57 7.73,1.17 8.11,1.96 15.1,5.91 20.84,11.29 6.14,5.75 10.85,13.12 13.94,21.43 3.21,8.61 4.04,17.51 2.7,25.96 -1.37,8.58 -4.96,16.73 -10.56,23.69 -2.47,3.07 -5.12,5.78 -7.91,8.13 -9.59,8.07 -21.03,12.15 -32.5,12.26 -11.47,0.11 -23,-3.76 -32.76,-11.61 C 28.33,97.41 25.61,94.76 23.1,91.77 16.18,83.55 12.33,73.68 11.45,63.57 10.54,53.19 12.77,42.58 18.02,33.24 19.61,30.42 21.23,28.17 23.03,26 l 0.53,14.7 c 0.07,2.02 1.76,3.6 3.78,3.53 2.02,-0.07 3.6,-1.76 3.53,-3.78 L 30.02,17.03 c -0.07,-2.02 -1.76,-3.59 -3.78,-3.52 -0.13,0.01 -0.25,0.02 -0.37,0.03 v 0 l -22.7,3.19 c -2,0.28 -3.4,2.12 -3.12,4.13 0.28,2 2.12,3.4 4.13,3.12 z M 98.2393,58.71 42.72725,89.104525 42.282275,31.187 Z" />
		</symbol>
		<symbol id="icnSvgPlay" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
			<path
				d="m10 16.5 6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" />
		</symbol>
		<symbol id="icnSvgPause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
			<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z" />
		</symbol>
		<symbol id="icnSvgFastForward" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M256 0c70.69 0 134.7 28.66 181.02 74.98C483.34 121.31 512 185.32 512 256.01c0 70.68-28.66 134.69-74.98 181.01C390.7 483.34 326.68 512 256 512s-134.69-28.66-181.02-74.98C28.66 390.7 0 326.69 0 256.01c0-70.68 28.66-134.7 74.98-181.03C121.31 28.66 185.32 0 256 0zm110.47 269.8c10.3-9.17 10.02-17.33 0-26.62l-86.09-76.78c-11.21-7.03-22.9-2.9-22.59 11.73l.12 43.14-61.54-54.87c-11.2-7.03-22.89-2.9-22.59 11.73l.45 154.47c.96 15.86 10.01 20.21 23.37 12.87l60.51-53.95.12 41.08c.96 15.86 10.01 20.21 23.36 12.87l84.88-75.67zm46.28-170.55C372.64 59.15 317.22 34.33 256 34.33S139.36 59.15 99.26 99.25c-40.11 40.11-64.93 95.55-64.93 156.76 0 61.21 24.82 116.63 64.93 156.74 40.1 40.1 95.52 64.92 156.74 64.92 61.21 0 116.64-24.82 156.75-64.92 40.1-40.11 64.92-95.53 64.92-156.74 0-61.23-24.82-116.65-64.92-156.76z" />
		</symbol>
		<symbol id="icnSvgSkipNext" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M255.99 0c70.68 0 134.7 28.66 181.02 74.98C483.33 121.3 512 185.31 512 256c0 70.68-28.67 134.69-74.99 181.01C390.69 483.33 326.67 512 255.99 512S121.3 483.33 74.98 437.01C28.66 390.69 0 326.68 0 256c0-70.67 28.66-134.7 74.98-181.02C121.3 28.66 185.31 0 255.99 0zm53.25 163.2h29.85c5.65 0 10.27 4.66 10.27 10.28v165.04c0 5.62-4.65 10.28-10.27 10.28h-29.85c-5.63 0-10.28-4.63-10.28-10.28V173.48c0-5.65 4.63-10.28 10.28-10.28zm-41.69 106.6c10.29-9.17 10.01-17.33 0-26.62l-82.3-76.78c-11.21-7.03-22.9-2.9-22.59 11.73l.44 154.47c.97 15.86 10.01 20.21 23.37 12.87l81.08-75.67zM412.74 99.25c-40.1-40.1-95.54-64.92-156.75-64.92-61.21 0-116.63 24.82-156.74 64.92-40.1 40.11-64.92 95.54-64.92 156.75 0 61.22 24.82 116.64 64.92 156.74 40.11 40.11 95.53 64.93 156.74 64.93 61.21 0 116.65-24.82 156.75-64.93 40.11-40.1 64.93-95.52 64.93-156.74 0-61.22-24.82-116.64-64.93-156.75z" />
		</symbol>
		<symbol id="icnSvgPlayProgress" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 142 142">
			<g transform="rotate(-90 71 71)">
				<circle r="61" cx="71" cy="71" fill="transparent"
					stroke="var(--audio-playing-current-progress-remained-color)" stroke-width="16px"
					stroke-dasharray="383.08000000000004px" stroke-dashoffset="0" />
				<circle id="svgProgressCirclePlaying" r="61" cx="71" cy="71"
					stroke="var(--audio-playing-current-progress-played-color)" stroke-width="16px"
					stroke-linecap="round" stroke-dashoffset="var(--audio-playing-current-progress-percent)"
					fill="transparent" stroke-dasharray="383.08000000000004px" />
			</g>
			<polygon transform="translate(53 32), scale(0.6)" style="fill-rule:evenodd;clip-rule:evenodd;"
				points="92.2,60.97 0,122.88 0,0 92.2,60.97" />
		</symbol>
		<symbol id="icnSvgPauseProgress" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 142 142">
			<path transform="translate(14.95 14.9), scale(0.915)" style="fill-rule:evenodd;clip-rule:evenodd;"
				d="M61.44,0c33.93,0,61.44,27.51,61.44,61.44c0,33.93-27.51,61.44-61.44,61.44S0,95.37,0,61.44 C0,27.51,27.51,0,61.44,0L61.44,0z M68.16,33.88H84.1V89l-15.94,0V33.88L68.16,33.88L68.16,33.88z M38.78,33.88h15.94V89l-15.94,0 V33.88L38.78,33.88L38.78,33.88z" />
			<g transform="rotate(-90 71 71)">
				<circle r="61" cx="71" cy="71" fill="transparent"
					stroke="var(--audio-playing-current-progress-remained-color)" stroke-width="10"
					stroke-dasharray="383.08000000000004px" stroke-dashoffset="0" />
				<circle id="svgProgressCirclePaused" r="61" cx="71" cy="71"
					stroke="var(--audio-playing-current-progress-played-color)" stroke-width="10" stroke-linecap="round"
					stroke-dashoffset="var(--audio-playing-current-progress-percent)" fill="transparent"
					stroke-dasharray="383.08000000000004px" />
			</g>

		</symbol>
		<symbol id="icnSvgVolumeOn" xmlns="http://www.w3.org/2000/svg" viewBox="0 1.01 16 13.99">
			<path
				d="M7 1.008a.99.99 0 0 0-.77.351L3 5H2C.906 5 0 5.844 0 7v2c0 1.09.91 2 2 2h1l3.23 3.64A.97.97 0 0 0 7 15zm6.46.96a1 1 0 0 0-.558.169 1.005 1.005 0 0 0-.27 1.39 7.995 7.995 0 0 1 0 8.946 1.005 1.005 0 0 0 .27 1.39 1.005 1.005 0 0 0 1.391-.27 10.015 10.015 0 0 0 0-11.187 1 1 0 0 0-.832-.437m-3.42 2.02A1.004 1.004 0 0 0 9 4.996v.059a.95.95 0 0 0 .2.535 4 4 0 0 1 0 4.816.97.97 0 0 0-.2.535v.063c0 .305.133.605.395.805a1 1 0 0 0 1.398-.2A5.98 5.98 0 0 0 12 8a6 6 0 0 0-1.207-3.613 1 1 0 0 0-.754-.399m0 0" />
		</symbol>
		<symbol id="icnSvgVolumeOff" xmlns="http://www.w3.org/2000/svg" viewBox="0 1.01 15.01 13.99">
			<path
				d="M7 1.008a.99.99 0 0 0-.77.351L3 5H2C.906 5 0 5.844 0 7v2c0 1.09.91 2 2 2h1l3.23 3.64A.97.97 0 0 0 7 15zM10 5a1 1 0 0 0-.707 1.707L10.586 8 9.293 9.293a1 1 0 1 0 1.414 1.414L12 9.414l1.293 1.293a1 1 0 1 0 1.414-1.414L13.414 8l1.293-1.293a1 1 0 1 0-1.414-1.414L12 6.586l-1.293-1.293A1 1 0 0 0 10 5m0 0" />
		</symbol>
		<symbol id="icnSvgMinusSign" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
			<g transform="matrix(0.22 0 0 0.22 12 12)">
				<path transform=" translate(-50, -50)"
					d="M 94.75 50 C 94.75 56.213 89.514 61.25 83.054 61.25 L 16.946 61.25 C 10.486 61.25 5.25 56.213 5.25 50 L 5.25 50 C 5.25 43.787 10.486 38.75 16.945999999999998 38.75 L 83.053 38.75 C 89.514 38.75 94.75 43.787 94.75 50 L 94.75 50 z" />
			</g>
		</symbol>
		<symbol id="icnSvgPlusSign" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
			<g transform="matrix(0.22 0 0 0.22 12 12)">
				<path transform="translate(-50, -50)"
					d="M 40.747 13.955 L 59.254000000000005 13.955 C 60.353 13.955 61.242000000000004 14.845 61.242000000000004 15.941 L 61.242000000000004 38.787 L 84.08600000000001 38.787 C 85.18400000000001 38.787 86.07000000000001 39.675 86.07000000000001 40.772999999999996 L 86.07000000000001 59.226 C 86.07000000000001 60.324999999999996 85.183 61.211999999999996 84.08600000000001 61.211999999999996 L 61.242 61.211999999999996 L 61.242 84.05799999999999 C 61.242 85.157 60.352 86.044 59.254 86.044 L 40.747 86.044 C 39.652 86.044 38.762 85.15599999999999 38.762 84.05799999999999 L 38.762 61.213 L 15.915 61.213 C 14.819999999999999 61.213 13.93 60.325 13.93 59.227000000000004 L 13.93 40.773 C 13.93 39.67400000000001 14.82 38.787000000000006 15.915 38.787000000000006 L 38.762 38.787000000000006 L 38.762 15.941 C 38.762 14.845 39.651 13.955 40.747 13.955 z" />
			</g>
		</symbol>

		<!-- functional buttons right below audio player -->
		<symbol id="icnSvgJump2PlayingChap" xmlns="http://www.w3.org/2000/svg" viewBox="3.74 4.53 16.35 14.79">
			<path d="M8.694 7.625V6.003h9.782v11.854H8.859v-1.292H7.238v2.761h12.859V4.534H7.073v3.09z" />
			<path d="m16.45 11.932-2.865 2.64-2.851 2.64v-3.24H3.742V9.71h6.992V6.65l2.851 2.642z" />
		</symbol>
		<symbol id="icnSvgRunJumping" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105.74 122.88">
			<path
				d="M3.07 79.92c4.32 1.19 29.57 17.12 32.69 10.85.32-.64 2.87-6.24 2.87-6.27l13.62 3.47c.44 1.39-5.97 12.95-7.23 14.27-1.6 1.68-3.21 2.68-4.93 3.57C34.31 108.79 6.82 94.12 0 93.16zm72.78 39.9c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zm10.94-7.69c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zm.33-11.66c.63.24.89 1.1.58 1.93s-1.07 1.31-1.7 1.07l-18.78-7.03c-.63-.24-.89-1.1-.58-1.93s1.07-1.31 1.7-1.07zM22.26 22.99c-.66-.15-1.03-.97-.83-1.83.19-.86.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm-2.47-10.86c-.66-.15-1.03-.97-.83-1.83.19-.86.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm5.9-8.98c-.66-.15-1.03-.97-.84-1.83s.88-1.44 1.54-1.29l19.56 4.41c.66.15 1.03.97.83 1.83-.19.86-.88 1.44-1.54 1.29zm13.28 44.06-2.86 17.67c-.58 6.69-.63 11.89 5.95 15 3.44 1.62 4.32 1.42 8.12 2.06l19.27-.42c1.04-.02 26.34 11.02 28.43 12.43l7.83-9.36c1.1-1.31-25.7-14.04-29.63-15.46-18.65-6.72-20.64 10.5-16.9-15.51 3.75 2.9 6.93 3.62 13.62 5.39 8.01 1.1 11.41-.86 17.65-3.7l9.22-4.57-7.14-10.84-7.05 4.2c-.26.12-.92.45-2.08 1.01-2.92 1.07-5.25 1.95-7.25 1.26-6.64-2.32-12.06-12.07-29.81-11.45-24.69.86-22.32-2.09-38.63 17.42l9.79 7.55c7.7-9.21 8.39-11.43 20.79-12.61.23-.04.45-.05.68-.07M59.12 9.04c6.83-3.12 14.89-.11 18 6.72 3.12 6.83.11 14.89-6.72 18-6.83 3.12-14.89.11-18-6.72-3.12-6.83-.11-14.89 6.72-18" />
		</symbol>			
		<symbol id="icnSvgSleepTimer" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 493 511.92">
			<path d="M277.16 41.75c49.87 6.77 94.55 29.89 128.47 63.79 40.67 40.67 65.83 96.87 65.83 158.93 0 62.08-25.15 118.28-65.83 158.96a227 227 0 0 1-25.34 21.83l27.24 38.33c5.68 8.18 3.65 19.42-4.54 25.11-8.19 5.68-19.44 3.65-25.12-4.54l-28.28-39.78c-30.84 15.91-65.83 24.89-102.92 24.89-37.7 0-73.23-9.28-104.43-25.69l-26.59 39.71c-5.54 8.28-16.76 10.5-25.04 4.95-8.29-5.55-10.5-16.75-4.95-25.03l26.07-38.95a226 226 0 0 1-24-20.83c-40.68-40.68-65.84-96.89-65.84-158.96 0-62.06 25.17-118.26 65.84-158.93 36.44-36.44 85.34-60.4 139.74-65.03 16.45-1.4 33.38-.97 49.69 1.24m5.6 195.95 65.46-.03v31.57H234.68V239l63.71-63.71h-62.95v-31.57h110.69v30.24zM177.59 355.19l44.18-.03v21.31h-76.64v-20.41l43.01-43h-42.49v-21.31h74.71v20.41zm304.1-210.46c17.29-41.28 15.24-84.52-9.52-113.49-29.69-34.76-83.39-38.75-133.25-14.3 53.01 36.36 101.11 78.78 142.77 127.79m-470.15 1.35C-6.1 104.02-4.01 59.97 21.21 30.45 51.47-4.97 106.18-9.03 156.99 15.88c-54 37.06-103.03 80.26-145.45 130.2m368.56-15.02c-34.14-34.15-81.31-55.27-133.42-55.27-52.1 0-99.28 21.12-133.43 55.27-34.14 34.14-55.26 81.31-55.26 133.42s21.12 99.28 55.26 133.43c34.15 34.14 81.32 55.26 133.42 55.26 52.12 0 99.29-21.12 133.43-55.26 34.14-34.15 55.27-81.32 55.27-133.44 0-52.1-21.12-99.27-55.27-133.41"/>
		</symbol>

		<!-- Other icons -->
		<symbol id="icnSvgHourGlass" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 24">
			<path
				d="M13.974 19.455c0-.342-.01-.748-.077-1.169a4.11 4.11 0 00-.649-1.653c-.174-.263-1.05-1.176-3.127-3.258a69.969 69.969 0 01-.372-.374l-.156-.159a5.561 5.561 0 01-.2-.217 2.823 2.823 0 01-.056-.07 1.504 1.504 0 01-.157-.226.652.652 0 01-.078-.2 1.729 1.729 0 01-.008-.263v-.031c.002-.106.005-.2.023-.27a.592.592 0 01.098-.186 3.43 3.43 0 01.225-.288c.076-.085.158-.168.244-.256l.065-.067.37-.372c2.078-2.083 2.955-2.997 3.13-3.26a4.106 4.106 0 00.649-1.653 7.57 7.57 0 00.076-1.169V2.261A.741.741 0 0014 2.075C14 .727 10.393 0 7 0S0 .727 0 2.075c0 .062.01.122.025.182v2.057c0 .322.01.745.077 1.17A4.116 4.116 0 00.75 7.135c.174.263 1.051 1.177 3.129 3.26.187.188.32.321.37.373l.062.063a3.43 3.43 0 01.471.547.59.59 0 01.099.186c.018.07.021.16.023.27v.03c.002.096.003.188-.008.263a.647.647 0 01-.078.2 1.515 1.515 0 01-.157.228 2.849 2.849 0 01-.153.177 6.914 6.914 0 01-.103.108l-.104.104c-3.288 3.29-3.486 3.59-3.551 3.688a4.114 4.114 0 00-.649 1.653 7.692 7.692 0 00-.077 1.17v2.239C.025 23.279 3.641 24 7 24c3.36 0 6.975-.721 6.975-2.305v-.306l-.001-1.934zm-.949 2.24v.016c-.051.422-2.1 1.367-6.025 1.367-3.976 0-6.026-.97-6.026-1.384-.001-.615-.002-1.621 0-2.237 0-.307.008-.67.065-1.031a3.208 3.208 0 01.509-1.293c.055-.081.466-.576 3.434-3.545l.113-.113a6.845 6.845 0 00.24-.262 2.436 2.436 0 00.325-.46c.066-.123.145-.29.175-.494.022-.146.02-.285.018-.408v-.029a1.954 1.954 0 00-.053-.485 1.475 1.475 0 00-.239-.485 4.256 4.256 0 00-.287-.367 8.51 8.51 0 00-.276-.29l-.06-.061c-.05-.052-.187-.189-.378-.38-1.865-1.87-2.878-2.918-3.012-3.117a3.209 3.209 0 01-.509-1.294 6.732 6.732 0 01-.066-1.031V3.168c1.3.643 3.713.981 6.027.981 2.313 0 4.725-.338 6.026-.98v1.143c-.001.308-.01.671-.066 1.031a3.203 3.203 0 01-.51 1.294c-.133.199-1.146 1.247-3.011 3.117-.191.191-.328.328-.378.38l-.064.064c-.09.092-.182.186-.273.287-.109.123-.202.249-.287.367a1.474 1.474 0 00-.239.485 1.95 1.95 0 00-.052.486v.03c-.002.121-.004.26.017.406.03.203.11.37.175.494a2.464 2.464 0 00.325.46 4.399 4.399 0 00.24.261l.157.161.38.382c1.864 1.869 2.877 2.917 3.01 3.115a3.209 3.209 0 01.51 1.294c.057.36.065.723.065 1.031.002.616.001 1.622 0 2.237z" />
			<path
				d="M12.715 19.253a5.274 5.274 0 00-.133-.127 5.793 5.793 0 00-.656-.542 5.292 5.292 0 00-.75-.425 11.85 11.85 0 00-1.715-.636c-.145-.042-.29-.084-.435-.128-.154-.048-.31-.09-.457-.155a1.752 1.752 0 01-.325-.185 1.982 1.982 0 01-.447-.45c-.131-.182-.256-.391-.297-.605-.04.214-.166.423-.297.605-.122.17-.27.323-.447.45-.1.073-.21.135-.326.185-.146.064-.303.107-.456.155-.145.044-.29.086-.436.128a11.875 11.875 0 00-1.715.636 5.294 5.294 0 00-.75.425 5.79 5.79 0 00-.655.542 5.297 5.297 0 00-.278.28.858.858 0 00-.14.193C2 20.373 4.461 21 7.497 21c3.035 0 5.496-.627 5.496-1.401H13a.852.852 0 00-.14-.194 5.181 5.181 0 00-.145-.152zM6.417 10.512c.063.06.123.135.177.221.096.153.178.337.244.54.072.219.14.47.162.727.022-.257.09-.508.162-.727.066-.203.148-.387.244-.54.054-.086.114-.16.177-.221.08-.077.166-.129.25-.186.078-.053.158-.103.237-.154.162-.103.321-.214.478-.343.155-.129.309-.266.458-.42.143-.149.28-.316.408-.51.13-.196.245-.42.358-.65a6.916 6.916 0 00.152-.336A1.39 1.39 0 0010 7.681C10 6.753 8.658 6 7.002 6c-1.656 0-2.998.753-2.998 1.681H4c.019.085.046.16.076.232a5.72 5.72 0 00.152.335c.112.231.228.455.357.651.128.194.266.361.41.51a5.4 5.4 0 00.457.42c.156.129.316.24.478.343.08.05.158.1.237.154.084.057.17.109.25.186z" />
		</symbol>
		<symbol id="icnSvgSpinWaiting" viewBox="22 22 56 56">
			<g transform="rotate(0 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.9166666666666666s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(30 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.8333333333333334s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(60 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.75s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(90 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.6666666666666666s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(120 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.5833333333333334s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(150 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.5s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(180 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.4166666666666667s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(210 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.3333333333333333s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(240 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.25s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(270 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.16666666666666666s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(300 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="-0.08333333333333333s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
			<g transform="rotate(330 50 50)">
				<rect x="47" y="24" rx="3" ry="6" width="6" height="12">
					<animate attributeName="opacity" values="1;0" keyTimes="0;1" dur="1s" begin="0s"
						repeatCount="indefinite"></animate>
				</rect>
			</g>
		</symbol>

		<!-- SETTING icons -->
		<symbol id="icnSvgSetting" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.878">
			<path fill-rule="evenodd" clip-rule="evenodd"
				d="M101.589,14.7l8.818,8.819c2.321,2.321,2.321,6.118,0,8.439l-7.101,7.101 c1.959,3.658,3.454,7.601,4.405,11.752h9.199c3.283,0,5.969,2.686,5.969,5.968V69.25c0,3.283-2.686,5.969-5.969,5.969h-10.039 c-1.231,4.063-2.992,7.896-5.204,11.418l6.512,6.51c2.321,2.323,2.321,6.12,0,8.44l-8.818,8.819c-2.321,2.32-6.119,2.32-8.439,0 l-7.102-7.102c-3.657,1.96-7.601,3.456-11.753,4.406v9.199c0,3.282-2.685,5.968-5.968,5.968H53.629 c-3.283,0-5.969-2.686-5.969-5.968v-10.039c-4.063-1.232-7.896-2.993-11.417-5.205l-6.511,6.512c-2.323,2.321-6.12,2.321-8.441,0 l-8.818-8.818c-2.321-2.321-2.321-6.118,0-8.439l7.102-7.102c-1.96-3.657-3.456-7.6-4.405-11.751H5.968 C2.686,72.067,0,69.382,0,66.099V53.628c0-3.283,2.686-5.968,5.968-5.968h10.039c1.232-4.063,2.993-7.896,5.204-11.418l-6.511-6.51 c-2.321-2.322-2.321-6.12,0-8.44l8.819-8.819c2.321-2.321,6.118-2.321,8.439,0l7.101,7.101c3.658-1.96,7.601-3.456,11.753-4.406 V5.969C50.812,2.686,53.498,0,56.78,0h12.471c3.282,0,5.968,2.686,5.968,5.969v10.036c4.064,1.231,7.898,2.992,11.422,5.204 l6.507-6.509C95.471,12.379,99.268,12.379,101.589,14.7L101.589,14.7z M61.44,36.92c13.54,0,24.519,10.98,24.519,24.519 c0,13.538-10.979,24.519-24.519,24.519c-13.539,0-24.519-10.98-24.519-24.519C36.921,47.9,47.901,36.92,61.44,36.92L61.44,36.92z" />
		</symbol>
		<symbol id="icnSvgFullTrashBin" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
			<path
				d="M322.62 254.95h-20.71v195.41h20.71V254.95zM111.53 2.02l105.89 36.64 3.26-9.41c.11-.32.23-.64.38-.94 3.69-9.25 13.28-14.76 23.08-13.35 2.56.37 4.75 1.19 7.16 2.03l60.97 21.1c.82.28 1.62.53 2.4.91 5.11 2.08 9.07 5.94 11.32 10.59 2.21 4.56 2.8 9.93 1.36 15.13-.17.61-.35 1.25-.55 1.83l-3.07 8.89 106.95 37.01c1.43.49 2.47.88 3.84 1.61 6.86 3.69 10.35 11.45 8.43 19.03-.21.82-.44 1.59-.72 2.38l-12.01 34.71c-1.67 4.85-6.97 7.41-11.81 5.74l-19.61-6.79a81.15 81.15 0 0 1 6.56 28.24c1.22.78 2.35 1.68 3.36 2.68 3.52 3.47 5.81 8.14 5.93 13.34.02 1.1-.11 2.21-.21 3.3L388.9 490.72c-.33 3.6-.93 6.8-2.75 10.18-3.52 6.55-10.03 11.1-18.14 11.1H117.06c-5.32 0-9.19-.47-13.67-3.53-5.28-3.61-8.74-9.7-9.35-16.46L68.66 215.9c-.08-.87-.16-1.82-.13-2.68.18-5.15 2.44-9.76 5.94-13.19 2.78-2.73 6.45-4.74 10.43-5.61-.19-.97-.3-1.96-.3-2.99v-66.36c0-8.26 6.76-15.02 15.02-15.02h78.92c8.25 0 15.01 6.76 15.01 15.02v22.45c12.39-10.17 28.24-16.28 45.52-16.28a71.52 71.52 0 0 1 32.54 7.79c4.18-3.5 8.71-6.6 13.54-9.22L79.45 58.63c-4.85-1.68-7.42-6.97-5.75-11.82l.07-.2 11.29-32.63C89.79.32 98.32-2.56 111.53 2.02zm143.75 252.93h-20.72v195.41h20.72V254.95zm-67.34 0h-20.71v195.41h20.71V254.95zm205.55-42.48H89.89c-1.99 0-2.94.34-2.75 2.45l25.11 273.2c.16 1.69.13 5.33 2.53 5.29h253.25c2.08 0 2.32-2.93 2.46-4.44l25.57-274.23c.16-1.77-.89-2.27-2.57-2.27zm-224.75-23.88h9.8v-52.32c0-5.98-4.9-10.87-10.88-10.87h-57.17c-5.98 0-10.87 4.89-10.87 10.87v52.32h69.12zm100.12 2.44H379.1c-2.52-15.25-11.22-28.4-23.44-36.82l-.15-.11-.23-.15-.38-.26-.38-.25-.02-.01-.37-.25-.39-.24-.26-.17-.13-.08-.4-.24-.39-.24-.11-.06-.29-.17-.4-.23-.36-.21-.04-.02-.4-.23-.41-.22-.41-.22-.41-.21-.41-.22-.06-.03-.35-.17-.42-.21-.32-.16-.09-.04-.42-.2-.43-.2-.16-.07-.26-.12-.43-.19-.42-.18-.01-.01-.42-.17-.71-.29-.16-.06-.84-.33-.02-.01-.12-.05-.32-.12-.44-.16-.4-.14-.04-.01-.45-.16-.44-.15-.24-.07-.21-.07-.45-.15-.45-.13-.06-.02-.39-.12-.45-.13-.35-.1-.11-.03-.45-.12-.46-.12-.18-.05-.28-.07-.46-.11-.46-.11h-.01l-.46-.1-.76-.17-.17-.03-.46-.09-.48-.09-.12-.03-.34-.06-.48-.08-.42-.07-.05-.01-.48-.07-.47-.07-.24-.04-.24-.03-.48-.06-.48-.05-.06-.01-.42-.05-.48-.05-.37-.03-.11-.01-.49-.04-.48-.04-.19-.01-.3-.02c-1.18-.08-2.37-.12-3.57-.12-27.51 0-50.44 19.73-55.12 46.67z" />
		</symbol>
		<symbol id="icnSvgTrashBin" xmlns="http://www.w3.org/2000/svg" viewBox="128 64 768 896">
			<path d="M384 384h64v384h-64zm192 0h64v384h-64z"/>
			<path d="M128 192v64h64v640a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V256h64v-64zm128 704V256h512v640zM384 64h256v64H384z"/>
		</symbol>
		<symbol id="icnSvgCheckDBsUpdate" xmlns="http://www.w3.org/2000/svg" viewBox="1.1 0 56 58.2">
			<path d="M44.1 32.201c-3.764 0-7.317 1.581-9.75 4.338a1.001 1.001 0 0 0 1.5 1.324c2.053-2.327 5.061-3.662 8.25-3.662 6.065 0 11 4.935 11 11s-4.935 11-11 11c-4.992 0-9.407-3.367-10.741-8H38.1v-2h-8v8h2v-3.664c2.093 4.531 6.781 7.664 12 7.664 7.168 0 13-5.832 13-13s-5.832-13-13-13M26.243 43.109a16.95 16.95 0 0 1 5.092-10.15q-1.28.073-2.628.111a84 84 0 0 1-5.22-.001c-7.341-.201-13.191-1.238-17.403-2.717C4.104 29.685 2.409 28.899 1.1 28v9.4c2.846 2.971 12.394 5.711 25 5.711zm-2.507-13.144q.487.014.982.023a79 79 0 0 0 2.765.001q.494-.01.982-.023l.349-.008c11.253-.359 19.648-2.915 22.286-5.668v-9.401C46.233 18.232 35.944 20 26.1 20s-20.133-1.768-25-5.111v9.4c2.638 2.754 11.033 5.31 22.286 5.668z"/><path d="M51.1 11.306V9a.9.9 0 0 0-.135-.458C49.843 4.241 41.215 0 26.1 0 11.023 0 2.404 4.22 1.247 8.51A.97.97 0 0 0 1.1 9v2.306C3.937 14.267 13.417 17 26.1 17s22.164-2.733 25-5.694M26.151 46.2H26.1c-12.346 0-20.866-2.29-25-5.201V49.2a.94.94 0 0 0 .117.451C2.398 54.546 12.964 58.2 26.1 58.2c2 0 3.93-.094 5.787-.255A16.95 16.95 0 0 1 26.151 46.2"/>
		</symbol>

		<symbol id="icnSvgHistory" xmlns="http://www.w3.org/2000/svg" viewBox="3 2 18 20">
			<path d="M19 10H5c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2M5 6h14v2H5zm2-4h10v2H7z"/>
		</symbol>
		<symbol id="icnSvgGUI" xmlns="http://www.w3.org/2000/svg" viewBox="2 4 28 24">
			<circle cx="20" cy="8" r="1"/>
			<circle cx="23" cy="8" r="1"/>
			<circle cx="26" cy="8" r="1"/>
			<path d="M28 4H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2m0 2v4H4V6ZM4 12h6v14H4Zm8 14V12h16v14Z"/><path style="fill:none" d="M0 0h32v32H0z"/>
		</symbol>
		<symbol id="icnSvgDatabaseConfig" xmlns="http://www.w3.org/2000/svg" viewBox="3 2 29.1 28.82"><ellipse cx="14" cy="8" rx="10" ry="5"/>
		<ellipse cx="14" cy="8" rx="11" ry="6"/>
		<path d="M14 24c-4.8 0-8.8-1.4-11-3.6V24c0 3.4 4.8 6 11 6 .9 0 1.8-.1 2.7-.2-1.5-1.5-2.4-3.6-2.7-5.8M3 12.4V16c0 3.4 4.8 6 11 6h.1c.2-2.4 1.4-4.6 3-6.2-1 .1-2 .2-3.1.2-4.8 0-8.8-1.4-11-3.6m28.7 8.5c-.1-.5-.7-.8-1.2-.7-.7.2-1.2 0-1.3-.2s0-.7.5-1.3c.4-.4.4-1 0-1.4q-1.5-1.5-3.6-2.1c-.5-.1-1.1.2-1.2.7-.2.7-.6 1-.9 1s-.6-.4-.9-1c-.2-.5-.7-.8-1.2-.7q-2.1.6-3.6 2.1c-.4.4-.4 1 0 1.4.5.5.6 1 .5 1.3-.1.2-.6.4-1.3.2-.5-.1-1.1.2-1.2.7Q16 21.95 16 23c0 1.05.1 1.4.3 2.1.1.5.7.8 1.2.7.7-.2 1.2 0 1.3.2s0 .7-.5 1.3c-.4.4-.4 1 0 1.4q1.5 1.5 3.6 2.1c.5.1 1.1-.2 1.2-.7.2-.7.6-1 .9-1s.6.4.9 1c.1.4.5.7 1 .7h.3q2.1-.6 3.6-2.1c.4-.4.4-1 0-1.4-.5-.5-.6-1-.5-1.3.1-.2.6-.4 1.3-.2.5.1 1.1-.2 1.2-.7q.3-1.05.3-2.1c0-1.05-.2-1.4-.4-2.1M24 26c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3"/>
		</symbol>
		<symbol id="icnSvgKeyboard" viewBox="3 3.7 26 25.31">
			<path d="M27 29.016H5a2 2 0 0 1-2-2v-13a2 2 0 0 1 2-2l1.058.006c0-1.634.497-2.694 1.492-3.807q1.492-1.668 3.702-1.668 1.049 0 2.323.354s1.847.614 3.129.614q2.936 0 4.001-2.574.5-1.238 1.017-1.238.742 0 .742.691 0 1.223-1.322 2.703-1.773 2.012-4.367 2.012c-1.343 0-3.644-.63-3.644-.63q-1.402-.339-1.998-.339-1.435 0-2.458 1.226c-1.023 1.226-1.023 1.54-1.023 2.669L27 12.016a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2m1-15a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v13a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1zm-7.997 7.011h6.018v1.981h-6.018zm1.985-3h4.021v1.981h-4.021zm2.019-3.011h2.003v2.044h-2.003zm-2.97 0h1.961v2.044h-1.961zm-2.029 3.011h1.981v1.981h-1.981zm-.983-3.011h2.002v2.044h-2.002zm-2.071 3.011h2.044v1.981h-2.044zm-.982-3.011h2.044v2.044h-2.044zm-2.97 0h2.023v2.044h-2.023zm-3.074 0h2.065v2.044H8.928zm-2.928 0h2.044v2.044H6zm6.018 4.993H6v-1.981h6.018zm-3.974 6.044H6v-2.044h2.044zm-2.033-5.026h4.021v1.981H6.011zm5.024 5.026H8.99v-2.044h2.045zm4.969-3.044h-2.045v-1.981h2.045zm-2.991 0h-2.044v-1.981h2.044zm1.995-3h-2.045v-1.981h2.045zm3.986 1.018v1.981h-1.981v-1.981zm1.013 5.026h-7.963v-2.044h7.963zm2.991 0h-2.045v-2.044h2.045zm2.99 0h-1.981v-2.044h1.981z"/>
		</symbol>
		<symbol id="icnSvgBookSets" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 99.45">
			<path d="M64.48.38H82.9c1.85 0 3.36 1.51 3.36 3.36v14.84H61.12V3.74c0-1.85 1.51-3.36 3.36-3.36m21.79 27.27v45.19H61.12V27.65zm0 54.27v13.8c0 1.85-1.51 3.36-3.36 3.36H64.48c-1.85 0-3.36-1.51-3.36-3.36v-13.8zM101.09.38h18.42c1.85 0 3.36 1.51 3.36 3.36v14.84H97.73V3.74c0-1.85 1.52-3.36 3.36-3.36m21.79 27.27v45.19H97.73V27.65zm0 54.27v13.8c0 1.85-1.51 3.36-3.36 3.36H101.1c-1.85 0-3.36-1.51-3.36-3.36v-13.8zM35.95.2l17.31 6.3c1.74.63 2.64 2.57 2.01 4.31L50.2 24.75l-23.63-8.6 5.07-13.94C32.28.47 34.22-.43 35.95.2M47.1 33.28 31.65 75.75l-23.63-8.6 15.45-42.46zm-18.55 51-4.72 12.96c-.63 1.74-2.57 2.64-4.31 2.01l-17.31-6.3C.47 92.32-.43 90.38.2 88.64l4.72-12.96z"/>
		</symbol>
		<symbol id="icnSvgBooks" xmlns="http://www.w3.org/2000/svg" viewBox="102.4 153.6 870.4 819.2">
			<path d="M512 819.2c-23.3 31.1-60.5 51.2-102.4 51.2H179.2a76.8 76.8 0 0 1-76.8-76.8V230.4a76.8 76.8 0 0 1 76.8-76.8h230.4c41.9 0 79.1 20.1 102.4 51.2 23.3-31.1 60.5-51.2 102.4-51.2h230.4a76.8 76.8 0 0 1 76.8 76.8v358.4c0-41.9-20.1-79.1-51.2-102.4v-256a25.6 25.6 0 0 0-25.6-25.6H614.4a76.8 76.8 0 0 0-76.8 76.8v460.8c0 26.8 13.8 50.5 34.7 64.2 6.6 22.7 16.5 43.9 29.2 63.2a127.8 127.8 0 0 1-89.5-50.6M153.6 230.4v563.2a25.6 25.6 0 0 0 25.6 25.6h230.4a76.8 76.8 0 0 0 76.8-76.8V281.6a76.8 76.8 0 0 0-76.8-76.8H179.2a25.6 25.6 0 0 0-25.6 25.6M892.2 824a127.5 127.5 0 0 0 29.4-81.6 25.6 25.6 0 0 1 51.2 0 179.3 179.3 0 0 1-153.6 177.4v27.4a25.6 25.6 0 0 1-51.2 0v-27.4a179.8 179.8 0 0 1-136.3-100.6 178.5 178.5 0 0 1-17.3-76.8 25.6 25.6 0 0 1 51.2 0A127.5 127.5 0 0 0 695 824c23.4 28.3 58.9 46.4 98.5 46.4h.2c39.7 0 75.1-18.1 98.5-46.4M716.8 588.8a76.8 76.8 0 0 1 153.6 0v153.6a76.8 76.8 0 0 1-153.6 0z"/>
		</symbol>

		<!-- History icons -->
		<symbol id="icnSvgClearHistory" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 469 503.83">
			<path
				d="m 381.11617,403.59756 c 0.62578,-0.65795 1.2824,-1.26347 1.98274,-1.81082 0.5261,-0.83393 1.12396,-1.62039 1.78642,-2.37814 7.21069,-8.05937 13.76554,-16.6275 19.58337,-25.74825 3.18815,-5.00492 8.68614,-8.12229 14.63376,-8.19884 13.99176,-0.27228 22.67458,15.34326 15.18358,27.10929 -6.86879,10.7419 -14.5975,20.90895 -23.11016,30.40119 -0.80181,0.89691 -1.67825,1.6832 -2.59409,2.36683 -0.49157,0.7564 -1.06068,1.4783 -1.67927,2.15493 l -0.17532,0.18512 0.0295,0.0208 C 362.43204,474.85634 303.18715,499.57992 243.22206,501.44327 183.25338,503.29726 122.58315,482.28383 75.430095,437.96857 28.273455,393.64397 3.5498604,334.3991 1.6865324,274.43401 -0.1767985,214.46891 20.845975,153.7951 65.157653,106.6327 80.651923,90.15565 97.97448,76.404451 116.52512,65.405988 132.16185,56.136617 148.6682,48.825679 165.66865,43.499506 L 152.97927,38.29103 C 142.92837,34.179883 138.11551,22.702323 142.23024,12.660779 146.34138,2.609903 157.81896,-2.2029589 167.8605,1.911773 l 50.72806,20.813083 c 1.97027,0.807554 3.72498,1.890665 5.26129,3.186151 8.0534,5.381343 11.07261,16.037105 6.67646,24.954859 l -24.21807,49.196584 c -4.78796,9.71086 -16.53638,13.70649 -26.25656,8.9221 -9.71084,-4.78797 -13.7065,-16.53638 -8.91857,-26.247207 l 2.31493,-4.712601 c -13.5005,4.454005 -26.60925,10.375036 -39.06061,17.757548 -15.71719,9.31097 -30.41067,20.98181 -43.56923,34.97697 -37.66808,40.08123 -55.528739,91.63616 -53.949554,142.57345 1.573429,50.95023 22.603219,101.2979 62.688004,138.97532 40.08122,37.66808 91.63616,55.52873 142.57347,53.94953 28.18114,-0.86679 56.18383,-7.69562 81.96039,-20.40742 0.56283,-0.37666 1.14411,-0.72492 1.74174,-1.04349 2.94605,-1.50578 5.83758,-3.09776 8.71122,-4.73641 0.73187,-0.40947 1.49098,-0.77586 2.25293,-1.07905 16.00441,-9.39981 30.94497,-21.20832 44.29969,-35.41804 z" />
			<path
				d="m 201.26897,182.98215 c 0,-10.03 8.13,-18.16 18.16,-18.16 10.03,0 18.16,8.13 18.16,18.16 v 110.52001 l 75.64,33.25 c 9.17,4.04 13.33,14.74 9.3,23.9 -4.04,9.17 -14.74,13.33 -23.91,9.29 l -85.58,-37.61 c -6.87,-2.59 -11.77,-9.22 -11.77,-17.01 z" />
			<g transform="matrix(1.8093715,0,0,1.9111334,269.98843,23.875916)">
				<path
					d="m 4.873,9.058 h 33.35 V 6.2 6.187 c 0,-0.095 0.002,-0.186 0.014,-0.279 0.075,-1.592 0.762,-3.037 1.816,-4.086 L 40.046,1.815 c 1.104,-1.104 2.637,-1.79 4.325,-1.806 l 0.023,0.002 V 0 h 0.031 19.884 0.016 c 0.106,0 0.207,0.009 0.309,0.022 1.583,0.084 3.019,0.76 4.064,1.81 1.102,1.104 1.786,2.635 1.803,4.315 l -0.003,0.021 h 0.014 V 6.2 9.057 h 32.909 0.017 c 0.138,0 0.268,0.014 0.401,0.034 1.182,0.106 2.254,0.625 3.034,1.41 l 0.004,0.007 0.005,-0.007 c 0.851,0.857 1.386,2.048 1.401,3.368 l -0.002,0.032 h 0.014 v 0.032 10.829 c 0,1.472 -1.195,2.665 -2.667,2.665 H 105.558 2.667 C 1.195,27.426 0,26.233 0,24.762 V 24.699 13.933 13.919 C 0,13.813 0.004,13.708 0.018,13.604 V 13.583 C 0.107,12.376 0.642,11.279 1.44,10.485 L 1.433,10.483 C 2.295,9.622 3.49,9.087 4.81,9.069 L 4.842,9.071 V 9.058 Z M 77.79,49.097 h -5.945 v 56.093 h 5.945 z m -19.33,0 h -5.948 v 56.093 h 5.948 z m -19.33,0 H 33.184 V 105.19 H 39.13 Z M 10.837,31.569 h 87.385 l 0.279,0.018 0.127,0.007 0.134,0.011 h 0.009 l 0.163,0.023 c 1.363,0.163 2.638,0.789 3.572,1.708 1.04,1.025 1.705,2.415 1.705,3.964 0,0.098 -0.009,0.193 -0.019,0.286 l -0.002,0.068 -0.014,0.154 -7.393,79.335 -0.007,0.043 h 0.007 l -0.016,0.139 -0.051,0.283 -0.002,0.005 -0.002,0.018 c -0.055,0.331 -0.12,0.646 -0.209,0.928 l -0.007,0.022 -0.002,0.005 -0.009,0.018 -0.023,0.062 -0.004,0.021 c -0.118,0.354 -0.264,0.698 -0.432,1.009 -1.009,1.88 -2.879,3.187 -5.204,3.187 H 18.13 l -0.247,-0.014 v 0.003 l -0.011,-0.003 -0.032,-0.004 c -0.46,-0.023 -0.889,-0.091 -1.288,-0.202 -0.415,-0.116 -0.818,-0.286 -1.197,-0.495 l -0.009,-0.002 -0.002,0.002 c -1.785,-0.977 -2.975,-2.882 -3.17,-5.022 L 4.88,37.79 4.869,37.665 4.858,37.418 4.854,37.302 H 4.849 c 0,-1.553 0.664,-2.946 1.707,-3.971 0.976,-0.955 2.32,-1.599 3.756,-1.726 l 0.122,-0.004 v -0.007 l 0.3,-0.013 0.104,0.002 v -0.014 z m 87.386,5.334 H 10.837 V 36.896 L 10.721,36.9 c -0.163,0.022 -0.322,0.106 -0.438,0.222 -0.063,0.063 -0.104,0.132 -0.104,0.179 h -0.007 l 0.007,0.118 7.282,79.244 h -0.002 l 0.002,0.012 c 0.032,0.376 0.202,0.691 0.447,0.825 l -0.002,0.004 0.084,0.032 0.063,0.012 h 0.077 72.695 c 0.207,0 0.399,-0.157 0.518,-0.377 l 0.084,-0.197 0.054,-0.216 0.014,-0.138 H 91.5 L 98.884,37.41 98.881,37.3 c 0,-0.045 -0.041,-0.111 -0.103,-0.172 -0.12,-0.118 -0.286,-0.202 -0.451,-0.227 z m 0.111,-0.002 h -0.016 z m 0.549,0.512 v -0.004 z m 5.297,0.377 -0.002,0.018 z M 40.887,14.389 H 5.332 v 7.706 h 97.63 V 14.389 H 67.907 67.844 c -1.472,0 -2.664,-1.192 -2.664,-2.664 V 6.2 6.168 h 0.007 C 65.18,5.948 65.081,5.735 64.928,5.583 64.791,5.442 64.604,5.354 64.407,5.331 H 64.325 64.309 44.425 44.394 V 5.325 C 44.181,5.332 43.972,5.429 43.818,5.584 L 43.814,5.58 43.807,5.584 c -0.131,0.134 -0.231,0.313 -0.259,0.501 l 0.007,0.102 V 6.2 11.724 c -10e-4,1.472 -1.196,2.665 -2.668,2.665 z" />
			</g>
		</symbol>
		<symbol id="icnSvgHistoryForward" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.883 122.882">
			<path
				d="M61.441,0C44.475,0,29.115,6.877,17.996,17.996C6.877,29.115,0,44.475,0,61.441c0,16.966,6.877,32.326,17.996,43.445 c11.119,11.118,26.479,17.995,43.445,17.995c16.967,0,32.327-6.877,43.446-17.995c11.119-11.119,17.996-26.479,17.996-43.445 c0-16.967-6.877-32.327-17.996-43.445C93.768,6.877,78.408,0,61.441,0L61.441,0z M51.505,42.166 c-1.735-1.784-1.696-4.637,0.088-6.372c1.784-1.735,4.637-1.696,6.373,0.088l21.839,22.521l-3.23,3.142l3.244-3.146 c1.738,1.792,1.693,4.652-0.098,6.39c-0.053,0.05-0.105,0.099-0.158,0.146L57.966,87.017c-1.735,1.784-4.588,1.823-6.373,0.088 c-1.784-1.734-1.823-4.588-0.088-6.372l18.78-19.201L51.505,42.166L51.505,42.166z M24.386,24.386 C33.869,14.903,46.97,9.038,61.441,9.038c14.471,0,27.573,5.865,37.055,15.348c9.484,9.483,15.35,22.584,15.35,37.056 c0,14.471-5.865,27.572-15.35,37.055c-9.482,9.483-22.584,15.349-37.055,15.349c-14.471,0-27.572-5.865-37.055-15.349 C14.903,89.014,9.038,75.912,9.038,61.441C9.038,46.97,14.903,33.869,24.386,24.386L24.386,24.386z" />
		</symbol>
		<symbol id="icnSvgSquareLinkArrow" xmlns="http://www.w3.org/2000/svg" viewBox="300 150 424 724">
			<path
				d="M725.4 853.3H256C208.9 853.3 170.7 815.1 170.7 768V298.7C170.7 251.5 208.9 213.3 256 213.3H426.7V298.7H256V768H725.4V597.3H810.7V768C810.7 815.1 772.5 853.3 725.4 853.3ZM499.2 584.8L439.1 524.5 707.6 256H554.7V170.7H853.4V469.3H768V316.4L499.2 584.8Z">
			</path>
		</symbol>

		<!-- Icons for using in general chapter information item -->
		<symbol id="icnSvgMicrophone" xmlns="http://www.w3.org/2000/svg" viewBox="192 0 640 1024">
			<path
				d="M224 416a32 32 0 0 1 32 32v64a256 256 0 0 0 512 0v-64a32 32 0 0 1 64 0v64a320 320 0 0 1-288 318.4V960h192a32 32 0 0 1 0 64H288a32 32 0 0 1 0-64h192V830.4A320 320 0 0 1 192 512v-64a32 32 0 0 1 32-32" />
			<path
				d="M640 512a128 128 0 1 1-256 0V192a128 128 0 1 1 256 0zM512 0a192 192 0 0 0-192 192v320a192 192 0 0 0 384 0V192A192 192 0 0 0 512 0" />
		</symbol>
		<symbol id="icnSvgDuration" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512">
			<path d="M320 0c8 0 14.8 5.9 15.9 13.9l49.3 369.5 47-305.8c1.2-7.9 8-13.6 16-13.6s14.6 6 15.7 13.8l34.6 254L528.3 173c1.4-7.3 7.6-12.7 15-13s14.1 4.5 16.1 11.6L588.1 272H624c8.8 0 16 7.2 16 16s-7.2 16-16 16h-48c-7.1 0-13.4-4.7-15.4-11.6l-13.4-46.8-35.5 189.3c-1.4 7.7-8.3 13.2-16.1 13s-14.4-6.1-15.5-13.8L447 191.4l-47.2 307c-1.2 7.9-8 13.6-16 13.6s-14.6-6-15.7-13.9l-48.1-361-48.1 361c-1.1 7.9-7.7 13.8-15.7 13.9s-14.8-5.7-16-13.6l-47.2-307-33.1 242.8c-1.1 7.8-7.6 13.6-15.5 13.8s-14.7-5.3-16.1-13L92.8 245.6l-13.4 46.8c-2 6.9-8.2 11.6-15.4 11.6H16c-8.8 0-16-7.2-16-16s7.2-16 16-16h35.9l28.7-100.4c2-7.1 8.7-11.9 16.1-11.6s13.6 5.7 15 13l29.8 158.8 34.6-254c1.1-7.9 7.8-13.8 15.7-13.8s14.7 5.7 16 13.6l47.1 305.9 49.2-369.6C305.2 5.9 312 0 320 0"/>
		</symbol>
		<symbol id="icnSvgListenTime" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 115.34 122.88">
			<path
				d="M97.74 119.52a2 2 0 0 1-.68-.12V65.93a2 2 0 0 1 .68-.12c3.34 0 6.43 5 8.48 7l-.46-12.12c0-12.8-3.72-23.11-9.68-30.93a7.37 7.37 0 0 1-5.86-2.23l-.68-.7C80.91 18.29 69 14.44 57.24 14.66s-23.48 4.53-31.55 12.25l-.66.64a7.3 7.3 0 0 1-6.49 2.05c-6 7.84-9.75 18.21-9.75 31.14l-.46 13.89c2.25-2.71 6.34-8.66 10-8.82v53.71C10.52 119.36 4.91 107.05 3 101H0V60.74a57.33 57.33 0 0 1 12.83-36.17 7.35 7.35 0 0 1 1.8-7.36l1-.95C26.36 6 41.62.3 57 0s31.25 4.9 42.87 16.46l.91.93a7.33 7.33 0 0 1 1.74 7.2 57.34 57.34 0 0 1 12.81 36.13V101h-2.21c-1.89 6.14-7.54 18.57-15.39 18.57Zm-5.55 3.36h-9a3.48 3.48 0 0 1-3.48-3.47V65.65a3.49 3.49 0 0 1 3.48-3.48h9zm-69-60.71H33a3.5 3.5 0 0 1 3.48 3.48v53.76a3.49 3.49 0 0 1-3.48 3.47h-9.86V62.17Z" />
		</symbol>
		<symbol id="icnSvgCalendar" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 119.92 122.88">
			<path
				d="M108.68,122.88H11.24A11.28,11.28,0,0,1,0,111.64V22.55A11.28,11.28,0,0,1,11.24,11.31H21.61V25.14a12.35,12.35,0,0,0,4.67,9.61,14.55,14.55,0,0,0,18.31,0,12.35,12.35,0,0,0,4.67-9.61V11.31H70.2V25.14a12.35,12.35,0,0,0,4.67,9.61,14.55,14.55,0,0,0,18.31,0,12.35,12.35,0,0,0,4.67-9.61V11.31h10.83a11.3,11.3,0,0,1,11.24,11.24v89.09a11.27,11.27,0,0,1-11.24,11.24ZM83.58,56.77h16.1a2.07,2.07,0,0,1,2.06,2v13.4a2.07,2.07,0,0,1-2.06,2H83.58a2.06,2.06,0,0,1-2-2V58.82a2.05,2.05,0,0,1,2-2Zm-31.51,0H68.18a2.06,2.06,0,0,1,2,2v13.4a2.07,2.07,0,0,1-2,2H52.07a2.06,2.06,0,0,1-2-2V58.82a2.06,2.06,0,0,1,2-2Zm-31.84,0H36.34a2.06,2.06,0,0,1,2,2v13.4a2.07,2.07,0,0,1-2,2H20.23a2.06,2.06,0,0,1-2.05-2V58.82a2.05,2.05,0,0,1,2.05-2ZM83.58,85.26h16.1a2.07,2.07,0,0,1,2.06,2v13.4a2.06,2.06,0,0,1-2.06,2.05H83.58a2.06,2.06,0,0,1-2-2.05V87.31a2.06,2.06,0,0,1,2-2Zm-31.51,0H68.18a2.06,2.06,0,0,1,2,2v13.4a2.06,2.06,0,0,1-2,2.05H52.07a2.06,2.06,0,0,1-2-2.05V87.31a2.07,2.07,0,0,1,2-2Zm-31.84,0H36.34a2.06,2.06,0,0,1,2,2v13.4a2.06,2.06,0,0,1-2,2.05H20.23a2.06,2.06,0,0,1-2.05-2.05V87.31a2.06,2.06,0,0,1,2.05-2ZM78.6,4.45C78.6,2,81,0,84,0s5.43,2,5.43,4.45V25.14c0,2.46-2.42,4.45-5.43,4.45s-5.42-2-5.42-4.45V4.45ZM30,4.45C30,2,32.44,0,35.44,0s5.42,2,5.42,4.45V25.14c0,2.46-2.42,4.45-5.42,4.45S30,27.6,30,25.14V4.45ZM3.6,43.86v66.58a8.87,8.87,0,0,0,8.84,8.84h95a8.87,8.87,0,0,0,8.85-8.84V43.86Z" />
		</symbol>
		<symbol id="icnSvgChapterInfor" xmlns="http://www.w3.org/2000/svg" viewBox="204.8 102.4 614.4 819.2">
			<path
				d="M204.8 204.8v614.4a102.4 102.4 0 0 0 102.4 102.4h486.4a25.6 25.6 0 0 0 0-51.2H307.2a51.2 51.2 0 0 1-51.2-51.2h512a51.2 51.2 0 0 0 51.2-51.2V204.8a102.4 102.4 0 0 0-102.4-102.4H307.2a102.4 102.4 0 0 0-102.4 102.4m512-51.2a51.2 51.2 0 0 1 51.2 51.2V768H256V204.8a51.2 51.2 0 0 1 51.2-51.2zM550.4 294.4a38.4 38.4 0 1 0-76.8 0 38.4 38.4 0 0 0 76.8 0M537.6 640a25.6 25.6 0 0 1-51.2 0V435.2a25.6 25.6 0 0 1 51.2 0z" />
		</symbol>
		<symbol id="icnSvgChapGroupIcon" viewBox="1 1 13 14" xmlns="http://www.w3.org/2000/svg">
			<path d="M1.5 1h2v1H2v12h1.5v1h-2l-.5-.5v-13zm6 6h-2L5 6.5v-2l.5-.5h2l.5.5v2zM6 6h1V5H6zm7.5 1h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 6h2V4h-2zm-3.5 6h-2l-.5-.5v-2l.5-.5h2l.5.5v2zM6 11h1v-1H6zm7.5 2h-3l-.5-.5v-3l.5-.5h3l.5.5v3zM11 12h2v-2h-2zm-1-2H8v1h2zm0-5H8v1h2z"/>
		</symbol>
		<symbol id="icnSvgMediaLinks" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 95.19">
			<path
				d="M11.7 0h6.19v2.07c15.49 3.54 17.26 11 8.28 22.7.95-11.63-.22-14.12-8.28-14.66v29.4a4 4 0 0 1 0 .47c0 3.82-4 7.61-8.95 8.47S0 46.9 0 43.07c0-5.21 7.16-9.74 11.7-8.14zM103 0h6.19v2.07c15.48 3.54 17.25 11 8.27 22.7 1-11.63-.22-14.12-8.27-14.66v29.87c0 3.82-4 7.61-9 8.47s-9-1.55-9-5.38c0-5.21 7.16-9.74 11.7-8.14V0ZM70.51 68.64a11.3 11.3 0 0 1 4.5.08V37.13l-33.43 9.59v37.3c0 5.82-6.42 10.06-11.57 11-6.39 1.1-11.58-2-11.58-7S23.65 78.18 30 77.08a13 13 0 0 1 6.49.42V32.34l43.54-9.91v50.88c.48 5.4-5 9.49-9.56 10.28-5.34.92-9.66-1.68-9.66-5.81s4.32-8.22 9.66-9.14Z" />
		</symbol>
		<symbol id="icnSvgSwitchChapterLinks" xmlns="http://www.w3.org/2000/svg" viewBox="64 64 896 896">
			<path
				d="M768 768v64h78.7A190.1 190.1 0 0 1 704 896a192.2 192.2 0 0 1-192-192h-64a255.5 255.5 0 0 0 448 168.5V960h64V768zm-64-320a257.3 257.3 0 0 0-192 87.5V448h-64v192h192v-64h-78.7A190.1 190.1 0 0 1 704 512a192.2 192.2 0 0 1 192 192h64a256.3 256.3 0 0 0-256-256" />
			<path
				d="M384 896H192V768h64v-64h-64V544h64v-64h-64V320h64v-64h-64V128h576v256h64V128a64 64 0 0 0-64-64H192a64 64 0 0 0-64 64v128H64v64h64v160H64v64h64v160H64v64h64v128a64 64 0 0 0 64 64h192Z" />
		</symbol>		

		<!-- Icons for using in general book information item -->
		<symbol id="icnSvgFeather" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 121.24 122.88">
			<path class="st0"
				d="M10.05,96.6C6.38,105.51,1.42,113.97,0,122.88l5.13-0.44c8.1-23.56,15.4-39.4,31.23-59.21 C48.24,48.39,61.13,36.58,77.66,27.2c8.8-5,20.07-10.47,30.21-11.85c2.77-0.38,5.58-0.49,8.46-0.24 c-31.4,7.19-56.26,23.84-76.12,48.8C32.1,74.09,25.05,85.4,18.57,97.32l11.94,2.18l-4.97-2.47l17.78-2.83 c-6.6-2.33-13.12-1.55-15.21-4.06c18.3-0.83,33.34-4.78,43.9-12.45c-3.93-0.55-8.46-1.04-10.82-2.17 c17.69-5.98,27.92-16.73,40.9-26.27c-16.87,3.54-32.48,2.96-37-0.25c29.77,2.21,49-6.02,55.59-26.77c0.57-2.24,0.73-4.5,0.37-6.78 C118.74,0.62,92.49-4.39,83.95,7.77c-1.71,2.43-4.12,4.66-6.11,7.48L85.97,0c-21.88,7.39-23.68,15.54-35,40.09 c0.9-7.47,2.97-14.24,5.66-20.63c-27.34,10.55-36.45,37.11-37.91,59.7c-0.79-7.88,0.67-17.78,3.49-28.9 c-7.98,8-13.41,17.39-11.47,30.79l-3.65-1.63l1.92,7.19l-5.46-2.59L10.05,96.6L10.05,96.6z" />
		</symbol>
		<symbol id="icnSvgChapters" viewBox="0 0 122.88 111.96">
			<path d="M61.15 0 0 26.52l61.41 24.96 61.47-24.88zm61.73 57.12L95.46 45.31 62.73 58.56c-.88.36-1.83.33-2.65 0L27.27 45.22 0 57.05 61.41 82zM96.14 75.56 62.73 89.08c-.88.36-1.83.33-2.65 0L26.59 75.47 0 87.01l61.41 24.96 61.47-24.88z"/>
		</symbol>
		<symbol id="icnSvgRemainTime" xmlns="http://www.w3.org/2000/svg" viewBox="-0.42 0 1024.32 1024.2">
			<path
				d="M545 65.2a448 448 0 0 0-33-1.2V0a512 512 0 0 1 37.7 1.4zM673.2 94a448 448 0 0 0-63-19.1l14-62.5c24.5 5.5 48.6 12.8 72.1 21.9zm87.7 45.5a449 449 0 0 0-28.1-17.3l31.6-55.7a513.6 513.6 0 0 1 62.6 41.9l-39.4 50.4a448 448 0 0 0-26.7-19.3M878.3 254a447.4 447.4 0 0 0-41.8-50.9l46.3-44.2c17.3 18.2 33.3 37.8 47.8 58.3zm47.6 86.5a453 453 0 0 0-13.7-29.9l57.1-28.8a510.5 510.5 0 0 1 28.8 69.6l-60.8 20.1a450 450 0 0 0-11.4-31M959.8 501a447.4 447.4 0 0 0-6.4-65.6l63-10.9c4.3 24.7 6.8 49.8 7.5 74.9l-64 1.6zm-8.4 98.4c2.1-10.9 3.8-21.7 5.2-32.6l63.6 7.9a509 509 0 0 1-14.8 73.9l-61.7-17.1c2.9-10.6 5.5-21.2 7.7-32.1m-60.9 152.3c11.8-18.6 22.1-38 31.1-58.1l58.5 25.9c-10.2 23-22.1 45.2-35.5 66.4zm-61.7 77.1c7.8-7.8 15.3-15.9 22.4-24.2l48.5 41.8A517 517 0 0 1 874 874z" />
			<path d="M512 64a448 448 0 1 0 316.8 764.8L874 874A512.1 512.1 0 1 1 512 0z" />
			<path
				d="M480 192a32 32 0 0 1 32 32v333.4l207.9 118.8a32 32 0 0 1-31.8 55.6l-224-128A32 32 0 0 1 448 576V224a32 32 0 0 1 32-32" />
		</symbol>
		<symbol id="icnSvgMaleAuthor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 117.37 122.88">
			<path
				d="M78.08 115.36H6.11c-5.24-.4-6.5-4.17-6.02-8.52C2.96 81.2 31.72 88.62 43.28 78.21c5.76 16.96 29.85 17.59 35.26 0 3.18 2.87 9.48 4.58 15.85 6.08.32.08.65.15 1 .23-7.77 4.75-13.88 12.08-16.32 20.65-1 3.52-1.31 6.95-.99 10.19m31.43-26.51 7.04 5.43c.93.72 1.1 2.06.39 2.99l-1.83 2.29-10.42-8.04 1.83-2.29c.71-.92 2.06-1.09 2.99-.38m-7.59 28.62c-2.4 1.1-4.79 2.19-7.19 3.28-5.63 2.57-5.45 3.78-4.58-2.08l1.37-9.22-.01-.01 11.54-15.87 10.42 8.04-11.55 15.87zm-8.62-6.65 6.84 5.28c-1.58.72-3.15 1.44-4.72 2.15-3.7 1.68-3.58 2.48-3.01-1.37zM43.13 61.2c2.19 3.47 4.48 7.02 7.32 9.63 2.74 2.5 6.06 4.2 10.45 4.21 4.76.01 8.23-1.75 11.06-4.39 2.94-2.75 5.25-6.52 7.54-10.28l6.14-10.12c1.14-2.62 1.56-4.36 1.3-5.39-.16-.61-.83-.91-1.98-.96-.24-.01-.49-.01-.74-.01-.27.01-.56.03-.86.05-.17.01-.32 0-.47-.03-.54.03-1.11-.01-1.68-.09l2.1-9.31c-15.61 2.46-27.28-9.13-43.77-2.32l1.19 10.97c-.65.04-1.29.01-1.87-.07-9.47.31 2.4 15.14 4.27 18.11m43.95-20.09c1.51.46 2.48 1.42 2.88 2.97.44 1.72-.04 4.14-1.5 7.45-.03.06-.05.12-.09.18l-6.21 10.23c-2.4 3.94-4.82 7.9-8.07 10.93-3.36 3.15-7.5 5.24-13.16 5.22-5.28-.01-9.27-2.03-12.53-5.02-3.94-3.62-22.12-26.37-14-31.85.4-.26.84-.49 1.32-.67-.36-4.7-.48-10.63-.26-15.59.12-1.17.35-2.35.67-3.53 1.39-4.98 4.89-8.99 9.21-11.74 2.39-1.52 5-2.67 7.72-3.43 1.73-.49-1.47-6.03.31-6.2 8.65-.89 22.66 7.01 28.7 13.55 3.02 3.27 4.93 7.62 5.34 13.36z" />
		</symbol>
		<symbol id="icnSvgBookType" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 353 512.32">
			<path
				d="M74.05 244.67h38.71c1.5-4.16 2.96-8.33 4.3-12.54l-17.01-27.12 12.78 4.82-5.65-15.84 8.53 3c-6.84-29.82 3.66-51.96 20.14-71.46-4.28 25.57-5.73 48.13-2.5 65.73-.89-51.13 14.71-112.63 74.32-141.43-4.89 14.88-8.31 30.5-8.94 47.49 20.95-57.37 23.5-76.06 71.4-96.75l-15.49 35.85c3.97-6.72 8.98-12.18 12.38-17.97C284-10.53 344.03-4.1 352 28.85c1.22 5.07 1.28 10.19.41 15.33-10.99 47.95-52.78 70.02-120.22 70.57 10.78 6.38 46.02 4.81 83.36-6.29-27.47 23.87-48.51 49.98-87.25 66.72 5.53 2.11 15.82 2.38 24.78 2.89-22.36 19.23-55.49 30.9-96.54 36.16 5.18 5.27 19.71 2.3 35 6.33l-39.51 9.67 11.64 4.65-27.29-2.7c12.39-28.04 26.16-54.82 42.52-79.24 40.11-59.89 93.01-101.98 162.38-123.98-6.51-.02-12.83.76-19 2.12-22.58 4.98-46.94 19.39-65.83 32.27-35.47 24.19-62.32 53.17-86.3 88.8-22.05 32.77-35.33 60.54-45.99 92.52h46.04c4.57 0 8.74 1.88 11.77 4.9l.05.05c3.01 3.03 4.88 7.19 4.88 11.75v36.45c0 4.56-1.88 8.74-4.91 11.78l.01.01a16.74 16.74 0 0 1-8.92 4.66v21.82c3.4 1.18 7.36 2.46 11.56 3.8 21.21 6.79 47.87 15.34 56.04 31.64 3.32 6.64 4.16 13.61 3.23 21.24-.83 6.86-3.1 14.21-6.21 22.4l-24.58 67.59-.35.79c-3.72 7.58-8.2 13.82-13.48 18.57-5.46 4.92-11.75 8.28-18.91 9.92-.68.18-1.4.28-2.13.28H66a9 9 0 0 1-1.71-.19c-7.33-1.6-13.76-4.99-19.34-10.01-5.17-4.66-9.57-10.75-13.25-18.13q-.33-.585-.57-1.23L6.55 415.17c-3.02-7.96-5.25-15.14-6.13-21.91-.98-7.54-.31-14.4 2.71-20.89 7.87-16.9 35.04-25.61 56.58-32.51 4.16-1.33 8.09-2.59 11.46-3.77v-21.83a16.66 16.66 0 0 1-8.89-4.64h-.04a16.7 16.7 0 0 1-4.89-11.8v-36.45c0-4.6 1.87-8.78 4.89-11.8s7.2-4.9 11.81-4.9m19.27 126.18h57.6v16.23h-57.6zm-55.93 81.77h169.47l15.69-43.15c2.68-7.05 4.61-13.22 5.27-18.6.56-4.62.16-8.62-1.59-12.12-5.1-10.19-28.18-17.58-46.54-23.46-6.63-2.12-12.71-4.07-17.76-6.14-3.14-1.27-5.03-4.29-5.04-7.48h-.03v-27.16H87.39v27.16c0 3.7-2.47 6.81-5.84 7.79-4.88 1.95-10.64 3.79-16.9 5.8-18.53 5.94-41.92 13.44-46.82 23.96-1.63 3.5-1.96 7.45-1.38 11.95.69 5.26 2.61 11.35 5.25 18.3zm163.57 16.23H43.29l2.93 8.06c2.73 5.45 5.91 9.87 9.57 13.17 3.26 2.94 6.96 4.97 11.12 6.02h110.43c4.16-1.05 7.85-3.08 11.12-6.02 3.66-3.3 6.84-7.72 9.57-13.17zM170.2 260.89H74.05c-.13 0-.25.06-.33.15-.09.09-.15.21-.15.33v36.45c0 .12.06.23.15.32.07.1.19.15.33.15h96.15c.12 0 .24-.06.33-.15h.03c.07-.07.12-.19.12-.32v-36.45c0-.14-.05-.26-.12-.33l-.03-.03a.47.47 0 0 0-.33-.12" />
		</symbol>
		
		<!-- Toast icons -->
		<symbol id="svgIconToastInfor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<path fill-rule="evenodd"
				d="M61.44 0c33.926 0 61.44 27.514 61.44 61.44s-27.514 61.439-61.44 61.439C27.513 122.88 0 95.366 0 61.44S27.513 0 61.44 0m17.98 98.215H43.46v-6.053h6.757v-36.96H43.46v-4.816h16.808c4.245 0 8.422-.51 12.549-1.551v43.328h6.604v6.052zM63.859 21.078c2.785 0 4.975.805 6.571 2.396 1.579 1.59 2.377 3.771 2.377 6.581 0 2.848-1.358 5.381-4.093 7.601-2.751 2.22-5.941 3.338-9.577 3.338-2.733 0-4.905-.765-6.569-2.297-1.665-1.551-2.497-3.556-2.497-6.05 0-3.143 1.358-5.853 4.059-8.152q4.05-3.416 9.729-3.417" />
		</symbol>
		<symbol id="svgIconToastSuccess" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.881 122.88">
			<path fill-rule="evenodd"
				d="M61.44 0c33.933 0 61.441 27.507 61.441 61.439s-27.508 61.44-61.441 61.44C27.508 122.88 0 95.372 0 61.439S27.508 0 61.44 0M34.106 67.678l-.015-.014a3.87 3.87 0 0 1-1.256-2.669 3.86 3.86 0 0 1 .984-2.777l.029-.031a3.87 3.87 0 0 1 2.668-1.256 3.87 3.87 0 0 1 2.792.998l12.956 11.748 31.089-32.559a3.87 3.87 0 0 1 2.719-1.204 3.87 3.87 0 0 1 2.771 1.067v.001a3.87 3.87 0 0 1 1.205 2.718 3.87 3.87 0 0 1-1.068 2.773L55.279 81.769a1 1 0 0 1-.073.067 3.87 3.87 0 0 1-2.598 1.13 3.86 3.86 0 0 1-2.744-1L34.118 67.688z" />
		</symbol>
		<symbol id="svgIconToastWarning" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 463.43">
			<path fill-rule="evenodd"
				d="M189.46 44.02c34.26-58.66 99.16-58.77 133.24.12l.97 1.81 175.27 304.4c33.71 56.4-1.2 113.76-66.17 112.96v.12H73.53c-.9 0-1.78-.04-2.66-.11-58.34-.79-86.64-54.22-61.9-106.84.39-.85.82-1.67 1.28-2.46l-.04-.03 179.3-309.94zm50.32 302.4c4.26-4.13 9.35-6.19 14.45-6.56 3.4-.24 6.8.29 9.94 1.48 3.13 1.19 6.01 3.03 8.39 5.41 6.92 6.91 8.72 17.38 4.64 26.16-2.69 5.8-7.08 9.7-12.11 11.78-3.03 1.27-6.3 1.84-9.56 1.76-3.27-.08-6.49-.82-9.41-2.18-5.02-2.33-9.3-6.43-11.7-12.2-2.65-6.36-2.27-12.96.63-19.15 1.15-2.46 2.75-4.81 4.73-6.5m33.86-47.07c-.8 19.91-34.51 19.93-35.28-.01-3.41-34.1-12.13-110.53-11.85-142.58.28-9.87 8.47-15.72 18.94-17.95 3.23-.69 6.78-1.03 10.35-1.02 3.6.01 7.16.36 10.39 1.05 10.82 2.3 19.31 8.39 19.31 18.45l-.05 1z" />
		</symbol>
		<symbol id="svgIconToastError" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<path style="fill-rule:evenodd"
				d="M61.44 0A61.44 61.44 0 1 1 0 61.44 61.44 61.44 0 0 1 61.44 0m13.14 36.8c1.74-1.77 2.83-3.18 5-1l7 7.13c2.29 2.26 2.17 3.58 0 5.69L73.33 61.83l12.75 12.75c1.77 1.74 3.18 2.83 1 5l-7.13 7c-2.26 2.29-3.58 2.17-5.68 0L61.44 73.72 48.63 86.53c-2.1 2.15-3.42 2.27-5.68 0l-7.13-7c-2.2-2.15-.79-3.24 1-5l12.73-12.7-13.2-13.19c-2.15-2.11-2.27-3.43 0-5.69l7-7.13c2.15-2.2 3.24-.79 5 1l13.09 13.12z" />
		</symbol>
		<symbol id="svgIconToastPromise" xmlns="http://www.w3.org/2000/svg" viewBox="0.05 0.05 127.9 127.9">
			<path d="M38.52 33.37 21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z"></path>
			<path
				d="M67.642 24.324 67.649.05a63.6 63.6 0 0 1 38.31 15.627L88.778 32.86a39.5 39.5 0 0 0-21.142-8.528zM94.63 38.52l17.17-17.16a63.6 63.6 0 0 1 16.04 38.14h-24.3a39.5 39.5 0 0 0-8.92-20.98zm9.046 29.122 24.275.007a63.6 63.6 0 0 1-15.627 38.31L95.14 88.778a39.5 39.5 0 0 0 8.528-21.142zM89.48 94.63l17.16 17.17a63.6 63.6 0 0 1-38.14 16.04v-24.3a39.5 39.5 0 0 0 20.98-8.92zm-29.122 9.046-.007 24.275a63.6 63.6 0 0 1-38.31-15.627L39.222 95.14a39.5 39.5 0 0 0 21.142 8.528zM33.37 89.48 16.2 106.64A63.6 63.6 0 0 1 .16 68.5h24.3a39.5 39.5 0 0 0 8.92 20.98zm-9.046-29.122L.05 60.351a63.6 63.6 0 0 1 15.627-38.31L32.86 39.222a39.5 39.5 0 0 0-8.528 21.142z"
				style="opacity:0.6">
		</symbol>

		<symbol id="svgIconNoInternetConnection" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 122.88 122.88">
			<path
				d="m101.68 32.93-68.76 68.75a49.29 49.29 0 0 0 77.83-40.24A49.3 49.3 0 0 0 108 45.15a48.9 48.9 0 0 0-6.32-12.22M24 93.5 93.49 24A49.31 49.31 0 0 0 24 93.5"
				style="fill:#fff" />
			<path
				d="M30.29 52a3 3 0 0 1-4.29-.37 3 3 0 0 1 .34-4.24A59.3 59.3 0 0 1 43.27 37a48 48 0 0 1 36.4.31A61 61 0 0 1 96.46 47.9a1.3 1.3 0 0 1 .17.16 3 3 0 0 1 .27 4.07 1.5 1.5 0 0 1-.17.19 3 3 0 0 1-4.16.19A55.2 55.2 0 0 0 77.47 43a41.86 41.86 0 0 0-32.08-.27A53.4 53.4 0 0 0 30.29 52m31.15 24.09A6.59 6.59 0 1 1 56.77 78a6.62 6.62 0 0 1 4.67-1.93ZM50.05 72.5a3 3 0 0 1-4.16-.35 1.4 1.4 0 0 1-.16-.18 3 3 0 0 1 .43-4.07l.17-.14a27.6 27.6 0 0 1 7.33-4.33 21.7 21.7 0 0 1 7.84-1.52 21.4 21.4 0 0 1 7.8 1.47 27.1 27.1 0 0 1 7.34 4.36 3 3 0 0 1 .44 4.26 3 3 0 0 1-2 1.1 3.06 3.06 0 0 1-2.21-.66 21.3 21.3 0 0 0-5.62-3.37 15.12 15.12 0 0 0-11.47 0 22 22 0 0 0-5.7 3.41Zm-9.56-9.71-.15.13a3.06 3.06 0 0 1-2.08.67 3 3 0 0 1-2-1 1 1 0 0 1-.14-.15 3 3 0 0 1 .34-4.16 45.8 45.8 0 0 1 12.36-8 30.76 30.76 0 0 1 25.6.42 45.7 45.7 0 0 1 12.11 8.41l.08.07a3.1 3.1 0 0 1 .87 2 3 3 0 0 1-.82 2.15l-.07.08a3 3 0 0 1-2 .87 3 3 0 0 1-2.15-.81A40.1 40.1 0 0 0 72 56.28a24.75 24.75 0 0 0-21-.35 39.7 39.7 0 0 0-10.5 6.86Z" />
			<path
				d="M61.44 0A61.31 61.31 0 1 1 38 4.66 61.3 61.3 0 0 1 61.44 0m40.24 32.93-68.75 68.75A49.44 49.44 0 0 0 80.31 107 49.53 49.53 0 0 0 107 80.3a49 49 0 0 0 3.73-18.86 48.93 48.93 0 0 0-9.08-28.51ZM24 93.5 93.5 24A49.32 49.32 0 0 0 24 93.5"
				style="fill:#d92d27" />
		</symbol>

	</svg>
</body>

</html>